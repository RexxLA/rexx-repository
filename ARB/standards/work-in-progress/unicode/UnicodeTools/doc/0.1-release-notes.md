# Release notes for version 0.1, 20230716

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚ This file is part of The Unicode Tools Of Rexx (TUTOR).                                                       â”‚
â”‚ See https://github.com/RexxLA/rexx-repository/tree/master/ARB/standards/work-in-progress/unicode/UnicodeTools â”‚
â”‚ Copyright Â© 2023, 2024 Josep Maria Blasco <josep.maria.blasco@epbcn.com>.                                     â”‚
â”‚ License: Apache License 2.0 (https://www.apache.org/licenses/LICENSE-2.0).                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

I've just uploaded the current version of the Unicode Toys to https://github.com/RexxLA/rexx-repository/tree/master/ARB/standards/work-in-progress/unicode/UnicodeToys

Please have a look at https://github.com/RexxLA/rexx-repository/blob/master/ARB/standards/work-in-progress/unicode/UnicodeToys/UnicodeToys.md to understand the spirit of this set of programs.

Things you can do (after you add ::Requires Unicode.cls to your program and maybe some wrappers to implement new functionality for old BIFs).

* Continue to use normal "strings". You can explicitly say that a string is a Bytes string by using the new BYTES(string) BIF.
* Create Runes strings with the new RUNES(string) BIF. Runes strings are composed of codepoints (i.e., they are functionally equivalent to UTF-32 strings). 
  A few BIFs have been implemented, namely LENGTH, SUBSTR, POS, CENTER/CENTRE and the ooRexx-specific [] notation.
* Convert Runes strings to Bytes strings using BYTES(string).
* Create Text strings with the new TEXT(string) BIF. Text strings are composed of extended grapheme clusters. A few BIFs have been implemented,  namely LENGTH, SUBSTR, POS, CENTER/CENTRE and the ooRexx-specific [] notation.
* Convert Text strings to Runes using RUNES, and to Bytes using BYTES.
* ALLRUNES(string) converts a Runes or Text string into a set of blank-delimited hexadecimal codepoints. For example, ALLRUNES('ğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§') = '1F469 200D 1F468 200D 1F469 200D 1F467'.
* Given a hexadecimal codepoint, R2N(code) returns the corresponding Name (na) property: R2N('1F385') = "FATHER CHRISTMAS".
* Given a name, N2R returns its codepoint, if there is a match: N2R("Hangul syllabe GEOL") = "AC78".

You will find numerous documentation details in the links included above and in the source files. You may also want to play with the three included demo programs.

This is a 0.1 release. Comments, feedback and criticism are very welcome.

  Josep Maria

P.S. I am copying below the output of Unicode.demo.basic.rex:

Testing basic operations and conversions
----------------------------------------
```
Test number 1: a UTF8 Bytes string (.String)

string = 'noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…'
Length(string) = 34
StringType(string) = 'BYTES'
Elements of 'noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…':
 1: n ('6E'X) 18: ï¿½ ('80'X)
 2: o ('6F'X) 19: ï¿½ ('8D'X)
 3: ï¿½ ('C3'X) 20: ï¿½ ('F0'X)
 4: ï¿½ ('AB'X) 21: ï¿½ ('9F'X)
 5: l ('6C'X) 22: ï¿½ ('91'X)
 6: ï¿½ ('F0'X) 23: ï¿½ ('A9'X)
 7: ï¿½ ('9F'X) 24: ï¿½ ('E2'X)
 8: ï¿½ ('91'X) 25: ï¿½ ('80'X)
 9: ï¿½ ('A9'X) 26: ï¿½ ('8D'X)
10: ï¿½ ('E2'X) 27: ï¿½ ('F0'X)
11: ï¿½ ('80'X) 28: ï¿½ ('9F'X)
12: ï¿½ ('8D'X) 29: ï¿½ ('91'X)
13: ï¿½ ('F0'X) 30: ï¿½ ('A7'X)
14: ï¿½ ('9F'X) 31: ï¿½ ('F0'X)
15: ï¿½ ('91'X) 32: ï¿½ ('9F'X)
16: ï¿½ ('A8'X) 33: ï¿½ ('8E'X)
17: ï¿½ ('E2'X) 34: ï¿½ ('85'X)

Press ENTER to continue
Test number 2: a Runes string (composed of codepoints)

string = Runes('noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…')
Length(string) = 12
StringType(string) = 'RUNES'
Elements of 'noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…':
 1: n ('6E'X)
 2: o ('6F'X)
 3: Ã« ('C3AB'X)
 4: l ('6C'X)
 5: ğŸ‘© ('F09F91A9'X)
 6: â€ ('E2808D'X)
 7: ğŸ‘¨ ('F09F91A8'X)
 8: â€ ('E2808D'X)
 9: ğŸ‘© ('F09F91A9'X)
10: â€ ('E2808D'X)
11: ğŸ‘§ ('F09F91A7'X)
12: ğŸ… ('F09F8E85'X)
AllRunes(string) = '006E 006F 00EB 006C 1F469 200D 1F468 200D 1F469 200D 1F467 1F385'

Press ENTER to continue
Test number 3: a Text string (composed of extended grapheme clusters)

string = Text('noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…')
Length(string) = 6
StringType(string) = 'TEXT'
Elements of 'noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…':
 1: n ('6E'X)
 2: o ('6F'X)
 3: Ã« ('C3AB'X)
 4: l ('6C'X)
 5: ğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ('F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7'X)
 6: ğŸ… ('F09F8E85'X)
AllRunes(string) = '006E 006F 00EB 006C 1F469 200D 1F468 200D 1F469 200D 1F467 1F385'

Press ENTER to continue
Test number 4: converting a Text to Runes

string = Runes('noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…')  -- Text to Runes
Length(string) = 12

Press ENTER to continue
Test number 5: converting a Runes to Bytes

string = Bytes('noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…')  -- Runes to Bytes (String)
Length(string) = 34

Press ENTER to continue
Test number 6: converting Text to Bytes

string = Bytes(Text('noÃ«lğŸ‘©â€ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ğŸ…')  -- Text to Bytes (String)
Length(string) = 34
```
