/**
 * <h4><code>lines.rxu</code></h4>
 *
 * <p>This program tests the extended features of the LINES BIF.
 *
 * First released with the 0.3 version of the Tools, 20230811.
 */
tmpfile = SysTempFileName("????.file")

If tmpFile == "" Then Do
  Say "Cannot create temporary file."
  Exit 1
End

Say "Testing the LINES BIF"
Say "---------------------"
Say
Say "When the program appears to stop, please press ENTER to continue"
Say
Parse pull
Say "Testing the functionality of the BIF when no ENCODING has been specified"

Call LineOut tmpFile,"One line"
Call LineOut tmpFile,"Two lines"
Call LineOut tmpFile,"Three lines"
Call LineOut tmpFile               -- Close the file

lines = lines(tmpFile)
If lines \== 1 Then Do
  Say "LINES returned" lines", expected 1."
  Call Exit 1
End
lines = lines(tmpFile,"Count")
If lines \== 3 Then Do
  Say "LINES returned" lines", expected 3."
  Call Exit 1
End
Say "PASSED!"
Say
Parse pull
Say "Now testing the functionality of the BIF with a fixed-length ENCODING with a standard end-of-file character"

Call Stream tmpFile,"Command", "Close"
Call Stream tmpFile,"Command", "Open Read Encoding CP-850"
lines = lines(tmpFile)
If lines \== 1 Then Do
  Say "LINES returned" lines", expected 1."
  Call Exit 1
End
lines = lines(tmpFile,"Count")
If lines \== 3 Then Do
  Say "LINES returned" lines", expected 3."
  Call Exit 1
End
Say "PASSED!"
Say
Parse pull
Say "Now testing the functionality of the BIF with a fixed-length ENCODING with a non-standard end-of-file character"

Call Stream tmpFile,"Command", "Close"
Call Stream tmpFile,"Command", "Open Read Encoding IBM-1047"
lines = lines(tmpFile)
If lines \== 1 Then Do
  Say "LINES returned" lines", expected 1."
  Call Exit 1
End
Signal On Syntax Name IBM1047
lines = lines(tmpFile,"Count")
Say "FAILED! Syntax error expected."
Call Exit 1
IBM1047:
Say "PASSED!"
Say
Parse pull
Say "Now testing the functionality of the BIF with a variable-length ENCODING"

Call Stream tmpFile,"Command", "Close"
Call Stream tmpFile,"Command", "Open Read Encoding UTF-8"
lines = lines(tmpFile)
If lines \== 1 Then Do
  Say "LINES returned" lines", expected 1."
  Call Exit 1
End
Signal On Syntax Name UTF8
lines = lines(tmpFile,"Count")
Say "FAILED! Syntax error expected."
Call Exit 1
UTF8:
Say "PASSED!"
Say


Call Exit 0  
   
Call Stream tmpFile,"C","Open Read"   

-- Sequential read, first line
Call Test LineIn(tmpFile), 1, "Sequential read, line 1"

-- Sequential read
Call Test LineIn(tmpFile), 2, "Sequential read, line 2"

-- Sequential read, embedded "0D"x
Call Test LineIn(tmpFile), 3, "Sequential read, line 3"

-- Sequential read, last line (no EOL)
Call Test LineIn(tmpFile), 4, "Sequential read, line 4"

-- Now testing line positioning

Call LineIn tmpFile, 3, 0
If result \== "" Then Do
  Say "Test failed: result should be the null string when 'count' is zero, got '"result"'."
  Call Exit 1
End
Call Test LineIn(tmpFile), 3, "Line-positioning, then LINEIN, line 3"

Call Test LineIn(tmpFile,2,1), 2, "Line-positioning-and-read, line 2"

Call Stream tmpFile,"c","Close"
Call SysFileDelete tmpfile

Say ""
Say "All tests PASSED!"
parse pull

Say "Now testing new functionality."
Say "=============================="
Say
Say "Testing bad encoding"
Say "---------------------"
Say 
Say "We will create an invalid UTF-16 file, consisting of a single surrogate, 'DB00'X."
Call CreateFile .Array~of("D800"X),"000A"X -- A single line containing a surrogate
Say "We then open the newly created file with an ENCODING of UTF-16:"
Say
Say '  Call Stream tmpfile, "C", "Open Read Encoding UTF-16 SYNTAX"'
Say
Call Stream tmpfile, "C", "Open Read Encoding UTF-16 SYNTAX"
Say "Reading from this file should raise a Syntax condition. Let's prepare for it:"
Say
Say "  Signal On Syntax Name BadEncoding"
Say 
Signal On Syntax Name BadEncoding
Say "Now let's call LINEIN:"
Say 
Say "  Call LineIn(tmpfile) -- This raises a syntax error"
Say 
Parse pull
Call LineIn(tmpfile) -- This raises a syntax error
Say "Test failed! Should have raised a syntax error for bad encoding."
Call Exit 1

Say "BadEncoding:"
BadEncoding:
Say "A condition was raised, and we have intercepted it."
Say
Say "Let's see what was the offending line:"
Say 
Say "  Say ""'""Stream(tmpFile, 'C', 'Query ENCODING LASTERROR')~c2x""'X"""
Say
Say "  '"Stream(tmpFile, 'C', 'Query ENCODING LASTERROR')~c2x"'X"
If Stream(tmpFile, "C", "Query ENCODING LASTERROR") \== "D800"X Then Do
  Say "Test failed! Stream 'C', 'QUERY ENCODING LASTERROR' failed."
  Call Exit 1
End
Say 
Say "Test PASSED!"
Say 
Parse pull
Say 
Say "Testing a non-existent ENCODING (should fail)"
Say "---------------------------------------------"
Say
Signal On Syntax Name Tralfamadore

Call Stream tmpfile, "C", "Open Read Encoding Tralfamadore"

Say "Test failed! TRALFAMADORE encoding should raise a Syntax condition."
Call Exit 1

Tralfamadore:

Say 
Say "  Raised Syntax condition ("rc"."Condition("E")"): "Condition("A")
Say
Parse pull

Say
Say "Testing a ENCODING for BINARY streams (should fail)"
Say "---------------------------------------------------"
Say
Signal On Syntax Name Binary

Call Stream tmpfile, "C", "Open Read Bi Encoding UTF-32"

Say "Test failed! BINARY and ENCODING should raise a Syntax condition."
Call Exit 1

Binary:

Say 
Say "  Raised Syntax condition ("rc"."Condition("E")"): "Condition("A")
Say
Parse pull

Say
Say "Testing ENCODING UTF-32 and unaligned line-ends."
Say "------------------------------------------------"
Say ""
line.1 = 4("a")4("b")4("c")
-- Test a "0A" in the wrong place, i.e., the string will contain "0000000A"X,
-- but nor aligned to a 4-byte boundary.
line.2 = 4("z")4("")4("0A81"X) -- 0A81 is GUJARATI SIGN CANDRABINDU 
-- now out of alignment "0000000D 0000000A"X
line.3 = 4("z")4("")4("0D0A"X)4("")4("0A81"X) -- 0D0A is MALAYALAM LETTER UU

Call CreateFile (line.1, line.2, line.3), "0000000A"X

Call Stream tmpfile, "C", "Open Read Encoding UTF-32"

line.1 = "abc"
line.2 = "7A00E0AA81"X
line.3 = "7A00E0B48A00E0AA81"X

Call Test LineIn(tmpfile),1,"Simple UTF-32 decoding, line 1"
Call Test LineIn(tmpfile),2,"Unaligned LF, line 2"
Call Test LineIn(tmpfile),3,"Unaligned CRLF, line 3"
Say ""
Say "Testing LINE positioning in a file with ENCODING UTF-32 (should fail)"

Signal On Syntax Name UTF32

Call LineIn tmpFile,2

Say "Test failed! LINE positioning should raise a Syntax condition for encoding UTF32."
Call Exit 1

UTF32:

Say 
Say "  Raised Syntax condition ("rc"."Condition("E")"): "Condition("A")
Say


Say "All tests PASSED!"
parse pull

Say "Now testing a variant of EBCDIC, IBM1047"
Say "----------------------------------------"
Say
Say "We first build a small IBM1047 file, ..."

line.1 = "Line 1, á"
line.2 = "Line 2, ñ"
line.3 = "Line 3, José Mª"
ebcdic = .Encoding["ibm1047"]

Call CreateFile (ebcdic~encode(line.1), ebcdic~encode(line.2), ebcdic~encode(line.3)), "15"X

Say "...and then we open it with ENC IBM-1047."

Call Stream tmpfile, "C", "Open Read encoding ibm-1047"

Call Test LineIn(tmpfile),1,"Simple IBM1047 decoding, line 1"
Call Test LineIn(tmpfile),2,"Simple IBM1047 decoding, line 1"
Call Test LineIn(tmpfile),3,"Simple IBM1047 decoding, line 1"
Say ""
Say "Testing LINE positioning (should fail)"

Signal On Syntax Name IBM1047

Call LineIn tmpFile,2

Say "Test failed! LINE positioning should raise a Syntax condition for encoding IBM1047."
Call Exit 1

IBM1047:

Say 
Say "  Raised Syntax condition ("rc"."Condition("E")"): "Condition("A")
Say

Say "All tests PASSED!"
parse pull

Call Exit 0

Exit:
  Call Stream tmpfile,"C","CLOSE"
  Call SysFileDelete tmpfile
  Exit Arg(1)

4: Return Right(Arg(1),4,"00"x)

Test: Procedure Expose line. tmpfile
  Use Strict Arg read, n, label
  If read \== line.n Then Do
    Say "Test failed: line no." n,,
      "should be '"ChangeStr("0D"X,line.n,"_")"' ('"c2x(line.n)"'X),",,
      "found     '"ChangeStr("0D"X,read  ,"_")"' ('"c2x(read)"'X)."
    Call Exit 1
  End
  Say label": PASSED."
Return


CreateFile: Procedure Expose tmpFile
  Call Stream tmpFile,"C","Open Write Replace"
  Use Strict Arg lines, eol
  Do counter c line Over lines
    Call CharOut tmpFile, line
    -- No line-end after last line    
    If c < lines~items Then Call CharOut tmpFile, eol
  End
  Call Stream tmpFile,"C","CLOSE"
Return  
  
  