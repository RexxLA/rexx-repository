/******************************************************************************/
/* 6.1.5 BNF syntax definition. The BNF syntax, described in BNF, is:         */
/******************************************************************************/

production              := identifier ':=' bnf_expression
bnf_expression          := abuttal | bnf_expression '|' abuttal
abuttal                 := [abuttal] bnf_primary
bnf_primary             := '[' bnf_expression ']' | 
                           '(' bnf_expression ')' | literal 
                           | identifier | message_identifier 
                           | bnf_primary '+'


/******************************************************************************/
/* 6.3.2 Syntax level                                                         */
/******************************************************************************/

starter                 := x3j18
x3j18                   := program Eos | Msg35.1
program                 := [label_list] [ncl] 
                           [requires+] 
                           [prolog_instruction+]
                           (class_definition [requires+])+
  requires              := 'REQUIRES' ( taken_constant | Msg19.8 ) ';'+
  prolog_instruction    := (package | import | options) ncl
    package             := 'PACKAGE'( NAME | Msgnn )
    import              := 'IMPORT' ( NAME | Msgnn ) ['.']
    options             := 'OPTIONS' ( symbol+ | Msgnn )
    ncl                 := null_clause+ | Msg21.1
      null_clause       := ';' [label_list]
         label_list     := (LABEL ';')+
class_definition        := class [property_info] [method_definition+]
  class                 := 'CLASS' ( taken_constant | Msg19.12 ) 
                           [class_option+]
                           ['INHERIT' ( taken_constant | Msg19.13 )+] 
                           ncl
  class_option          := visibility | modifier | 'BINARY' | 'DEPRECATED'
                           | 'EXTENDS' ( NAME | Msgnn )
                           | 'USES' ( NAMElist | Msgnn )
                           | 'IMPLEMENTS' ( NAMElist | Msgnn )
                           | external | metaclass | submix /* | 'PUBLIC' */
    external            := 'EXTERNAL' (STRING | Msg19.14)
    metaclass           := 'METACLASS' ( taken_constant | Msg19.15 )
    submix              := 'MIXINCLASS' ( taken_constant | Msg19.16 )
                           | 'SUBCLASS' ( taken_constant | Msg19.17 )
    visibility          := 'PUBLIC' | 'PRIVATE'
    modifier            := 'ABSTRACT' | 'FINAL' | 'INTERFACE' | 'ADAPTER'
    NAMElist            := NAME [(',' ( NAME | Msgnn ) )+]
  property_info         := numeric | property_assignment | properties | trace
    numeric             := 'NUMERIC' (numeric_digits | numeric_form | Msg25.15)
      numeric_digits    := 'DIGITS' [expression]
      numeric_form      := 'FORM' ['ENGINEERING' | 'SCIENTIFIC']
  property_assignment   := NAME | assignment
  properties            := 'PROPERTIES' ( properties_option+ | Msgnn)
    properties_option   := properties_visibility | properties_modifier
      properties_visibility := 'INHERITABLE' | 'PRIVATE' 
                           | 'PUBLIC' | 'INDIRECT'
      properties_modifier   := 'CONSTANT' | 'STATIC' | 'VOLATILE' 
                           | 'TRANSIENT'
  trace                 := 'TRACE' ['ALL' | 'METHODS' | 'OFF' | 'RESULTS']
method_definition       := (method [expose ncl]| routine)
                           balanced
  expose                := 'EXPOSE' variable_list
  method                := 'METHOD' (taken_constant | Msg19.9)
                           [ '(' assigncommalist | Msgnn ( ')' | Msgnn )]
                           [method_option+] ncl
    assigncommalist     := assignment [(',' ( assignment | Msgnn ) )+]
    method_option       := method_visibility | method_modifier | 'PROTECT'
                           | 'RETURNS' ( term | Msgnn )
                           | 'SIGNAL' ( termcommalist | Msgnn )
                           | 'DEPRECATED'
                           | 'CLASS' | 'ATTRIBUTE' | /*'PRIVATE' | */ guarded
        guarded         := 'GUARDED' | 'UNGUARDED'
      method_visibility := 'INHERITABLE' | 'PRIVATE' | 'PUBLIC' | 'SHARED'
      method_modifier   := 'ABSTRACT' | 'CONSTANT' | 'FINAL' 
                           | 'NATIVE' | 'STATIC'
      termcommalist     := term [(',' ( term | Msgnn ) )+]
  routine               := 'ROUTINE' ( taken_constant | Msg19.11 )
                           ['PUBLIC'] ncl
  balanced              := instruction_list ['END' Msg10.1]
    instruction_list    := instruction+


/******************************************************************************/
/* The second part is about groups                                            */
/******************************************************************************/

instruction             := group | single_instruction ncl
group                   := do ncl | if | loop ncl | select ncl
  do                    := do_specification ncl 
                           [instruction+] 
                           [group_handler]
                           ('END' [NAME] | Eos Msg14.1 | Msg35.1)
    group_option       := 'LABEL' ( NAME | Msgnn ) 
                          | 'PROTECT' ( term | Msgnn )
    group_handler       := catch | finally | catch finally
      catch             := 'CATCH' [ NAME '=' ] ( NAME | Msgnn) ncl 
                           [instruction+]
/* FINALLY implies a semicolon. */
      finally           := 'FINALLY' ncl ( instruction+ | Msgnn )
  if                    := 'IF' expression [ncl] (then | Msg18.1)
                           [else]
    then                := 'THEN' ncl
                           (instruction | EOS Msg14.3 | 'END' Msg10.5)
    else                := 'ELSE' ncl
                           (instruction | EOS Msg14.4 | 'END' Msg10.6)
  loop                  := 'LOOP' [group_option+] [repetitor] [conditional] ncl
                           instruction+ 
                           [group_handler]
                           loop_ending
    loop_ending         := 'END' [VAR_SYMBOL] | EOS Msg14.n | Msg35.1
  conditional           := 'WHILE' whileexpr | 'UNTIL' untilexpr
    untilexpr           := expression
    whileexpr           := expression
  repetitor             := assignment [count_option+] | expression | over |
                           'FOREVER'
    count_option        := loopt | loopb | loopf
      loopt             := 'TO' expression
      loopb             := 'BY' expression
      loopf             := 'FOR' expression
    over                := VAR_SYMBOL 'OVER' expression
                           | NUMBER 'OVER' Msg31.1
                           | CONST_SYMBOL 'OVER' (Msg31.2 | Msg31.3)
  select                := 'SELECT' [group_option+] ncl select_body [group_handler]
                           ('END' [NAME Msg10.4] | EOS Msg14.2 | Msg7.2)
    select_body         := (when | Msg7.1) [when+] [otherwise]
      when              := 'WHEN' expression [ncl] (then | Msg18.2)
      otherwise         := 'OTHERWISE' ncl [instruction+]


/******************************************************************************/
/* Third part is for single instructions.                                     */
/******************************************************************************/

single_instruction      := assignment 
                           | message_instruction 
                           | keyword_instruction
                           | command
  assignment            := VAR_SYMBOL '#' expression
                           | NUMBER '#' Msg31.1
                           | CONST_SYMBOL '#' (Msg31.2 | Msg31.3)
  message_instruction   := message_term | message_term '#' expression
  keyword_instruction   := address | arg | call | drop | exit
                           | interpret | iterate | leave
                           | nop | numeric | options
                           | parse | procedure | pull | push 
                           | queue | raise | reply | return 
                           | say | signal | trace | use
                           | 'THEN' Msg8.1 | 'ELSE' Msg8.2
                           | 'WHEN' Msg9.1 | 'OTHERWISE' Msg9.2
  command               := expression
address                 := 'ADDRESS' [(taken_constant [expression]
                           | Msg19.1 | valueexp) [ 'WITH' connection]]
  taken_constant        := symbol | STRING
  valueexp              := 'VALUE' expression
  connection            := ad_option+
    ad_option           := error | input | output | Msg25.5
      error             := 'ERROR' (resourceo | Msg25.14)
      input             := 'INPUT' (resourcei | Msg25.6)
        resourcei       := resources | 'NORMAL'
      output            := 'OUTPUT' (resourceo | Msg25.7)
        resourceo       := 'APPEND' (resources | Msg25.8)
                           | 'REPLACE' (resources | Msg25.9)
                           | resources | 'NORMAL'
resources               := 'STREAM' (VAR_SYMBOL | Msg53.1)
                           | 'STEM' (VAR_SYMBOL | Msg53.2)
  vref                  := '(' var_symbol (')' | Msg46.1)
    var_symbol          := VAR_SYMBOL | Msg20.1
arg                     := 'ARG' [template list]
call                    := 'CALL' (callon_spec|
                           (taken_constant | vref | Msg19.2)[expression_list])
  callon_spec           := 'ON' (callable_condition | Msg25.1)
                           ['NAME' (symbol_constant_term | Msg19.3)]
                           | 'OFF' (callable_condition | Msg25.2)
    symbol_constant_term := term
    callable_condition  := 'ANY' | 'ERROR' | 'FAILURE' | 'HALT' | 'NOTREADY'
                           | 'USER' ( symbol_constant_term | Msg19.18 )
    condition           := callable_condition | 'LOSTDIGITS'
                           | 'NOMETHOD' | 'NOSTRING' | 'NOVALUE' | 'SYNTAX'
  expression_list       := expr | [expr] ',' [expression_list]
do_specification        := do_simple | do_repetitive
  do_simple             := 'DO' [group_option+]
  do_repetitive         := do_simple (dorep | conditional | dorep conditional)
    dorep               := 'FOREVER' | repetitor
drop                    := 'DROP' variable_list
  variable_list         := (vref | var_symbol)+
exit                    := 'EXIT' [expression]
forward                 := 'FORWARD' [forward_option+ | Msg25.18]
  forward_option        := 'CONTINUE' | ArrayArgOption |
                           MessageOption | ClassOption | ToOption
    ArrayArgOption      :='ARRAY' arguments | 'ARGUMENTS' term
    MessageOption       := 'MESSAGE' term
    ClassOption         := 'CLASS' term
    ToOption            := 'TO' term
guard                   := 'GUARD' 
                           ('ON' | Msg25.22) [('WHEN' | Msg25.21) expression] 
                           | ('OFF' | Msg25.19) [('WHEN' | Msg25.21) expression]
interpret               := 'INTERPRET' expression
iterate                 := 'ITERATE' [VAR_SYMBOL | Msg20.2]
leave                   := 'LEAVE' [VAR_SYMBOL | Msg20.2]
nop                     := 'NOP'
numeric                 := 'NUMERIC' (numeric_digits | numeric_form
                           | numeric_fuzz | Msg25.15)
  numeric_digits        := 'DIGITS' [expression]
  numeric_form          := 'FORM' [numeric_form_suffix]
    numeric_form_suffix := ('ENGINEERING'|'SCIENTIFIC'|valueexp | Msg25.11)
  numeric_fuzz          := 'FUZZ' [expression]
options                 := 'OPTIONS' expression
parse                   := 'PARSE' [translations] 
                           (parse_type | Msg25.12)
                           [template_list]
  translations          := 'CASELESS' ['UPPER' | 'LOWER']
                           | ('UPPER' | 'LOWER') ['CASELESS']
  parse_type            := parse_key | parse_value | parse_var | term
    parse_key           := 'ARG' | 'PULL' | 'SOURCE' | 'LINEIN'
                           | 'VERSION'
    parse_value         := 'VALUE' [expression] ('WITH' | Msg38.3)
    parse_var           := 'VAR' var_symbol
  template              := NAME [( [pattern] NAME)+]
    pattern             := STRING 
                           | [indicator] NUMBER 
                           | [indicator] '(' symbol ')'
      indicator         := '+' | '-' | '='
procedure               := 'PROCEDURE' [expose | Msg25.17]
pull                    := 'PULL' [template_list]
push                    := 'PUSH' [expression]
queue                   := 'QUEUE' [expression]
raise                   := 'RAISE' conditions (raise_option | Msg25.24)
  conditions            := 'ANY' | 'ERROR' term | 'FAILURE' term
                           | 'HALT'| 'LOSTDIGITS' | 'NOMETHOD' | 'NOSTRING' 
                           | 'NOTREADY' | 'NOVALUE' | 'PROPAGATE' 
                           | 'SYNTAX' term
                           | 'USER' ( symbol_constant_term | Msg19.18) 
                           | Msg25.23
  raise_option          := ExitRetOption | Description | ArrayOption
....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8
