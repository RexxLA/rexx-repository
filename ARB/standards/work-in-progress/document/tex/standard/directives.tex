%preprocessed texin
\chapter{Directives}\label{directives}

The syntax constructs which are introduced by the optional `::' token
are known as directives.

\section{Notation}\label{notation}

Notation functions are functions which are not directly accessible as
functions in a program but are used in this standard as a notation for
defining semantics.

Some notation functions allow reference to syntax constructs defined in
nnn. Which instance of the syntax construct in the program is being
referred to is implied; it is the one for which the semantics are being
specified.

The \texttt{BNF\_primary} referenced may be directly in the production
or in some component referenced in the \emph{production}, recursively.
The components are considered in left to right order.

\lstinputlisting[language=rexx,label=directivescontainsidentifier.rexx,caption=directivescontainsidentifier.rexx]{directivescontainsidentifier.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Identifier} is an \emph{identifier} in a \emph{production}
  (see nnn) defined in nnn.
\item
  \texttt{BNF\_primary} is a \emph{bnf\_primary} (see nnn) in a
  \emph{production} defined in nnn.
\end{itemize}

Return \texttt{\textquotesingle{}1\textquotesingle{}} if the
\emph{production} identitied by \emph{Identifier} contained a
\emph{bnf\_primary} identified by \texttt{BNF\_primary}, otherwise
return \texttt{\textquotesingle{}0\textquotesingle{}}.

\lstinputlisting[language=rexx,label=directivesinstance.rexx,caption=directivesinstance.rexx]{directivesinstance.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Identifier} is an \emph{identifier} in a \emph{production}
  defined in nnn.
\item
  \texttt{BNF\_primary} is a \emph{bnf\_primary} in a \emph{production}
  defined in nnn.
\end{itemize}

Returns the content of the particular instance of the
\texttt{BNF\_primary}. If the \texttt{BNF\_primary} is a
\texttt{VAR\_SYMBOL} this is referred to as the symbol ``taken as a
constant.''

\lstinputlisting[language=rexx,label=directivesevaluate.rexx,caption=directivesevaluate.rexx]{directivesevaluate.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Identifier} is an \emph{identifier} in a \emph{production}
  defined in nnn.
\item
  \texttt{BNF\_primary} is a \emph{bnf\_primary} in a \emph{production}
  defined in nnn.
\end{itemize}

Return the value of the \texttt{BNF\_primary} in the \emph{production}
identified by \texttt{Identifier}.

\lstinputlisting[language=rexx,label=directivesexecute.rexx,caption=directivesexecute.rexx]{directivesexecute.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Identifier} is an \emph{identifier} in a \emph{production}
  defined in nnn.
\item
  \texttt{BNF\_primary} is a \emph{bnf\_primary} in a \emph{production}
  defined in nnn.
\end{itemize}

Perform the instructions identified by the \texttt{BNF\_primary} in the
\emph{production} identified by \texttt{Identifier}.

\lstinputlisting[language=rexx,label=directivesparses.rexx,caption=directivesparses.rexx]{directivesparses.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Value} is a string
\item
  \texttt{BNF\_primary} is a \emph{bnf\_primary} in a \emph{production}
  defined in nnn.
\end{itemize}

Return \texttt{\textquotesingle{}1\textquotesingle{}} if Value matches
the definition of the \texttt{BNF\_primary}, by the rules of clause 6,
\texttt{\textquotesingle{}0\textquotesingle{}} otherwise.

\lstinputlisting[language=rexx,label=directivesclause.rexx,caption=directivesclause.rexx]{directivesclause.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Label} is a label in code used by this standard to describe
  processing.
\end{itemize}

Return an identification of that label. The value of this identification
is used only by the \texttt{\#Goto} notation function.

\lstinputlisting[language=rexx,label=directivesgoto.rexx,caption=directivesgoto.rexx]{directivesgoto.rexx}

where:

\begin{itemize}
\tightlist
\item
  \texttt{Value} identifies a label in code used by this standard to
  describe processing.
\end{itemize}

The description of processing continues at the identified label.

\lstinputlisting[language=rexx,label=directivesrexxtry.rexx,caption=directivesrexxtry.rexx]{directivesrexxtry.rexx}

This notation is used in the description of interactive tracing to
specify re-execution of the clause just previously executed. It has the
effect of transferring execution to the beginning of that clause, with
state variable \texttt{\#Loop} set to the value it had when that clause
was previously executed.

\section{Initializing}\label{initializing}

\emph{Some of the initializing, now grouped in classic section 8.2.1
will have to come here so that we have picked up anything from the
\texttt{START\_API} that needs to be passed on to the execution of
REQUIRES subject. We will be using some operations that are forward
reference to what was section nnn.}

\subsection{Program initialization and message
texts}\label{program-initialization-and-message-texts}

Processing of a program begins when \texttt{API\_Start} is executed. A
pool becomes current for the reserved variables.

\lstinputlisting[language=rexx,label=initialization.rexx,caption=initialization.rexx]{initialization.rexx}

\emph{Is it correct to make the reserved variables and the builtin
objects in the same pool?}

Some of the values which affect processing of the program are parameters
of \texttt{API\_Start}: \texttt{\#Howlnvoked} is set to
\texttt{\textquotesingle{}COMMAND\textquotesingle{}},
\texttt{\textquotesingle{}FUNCTION\textquotesingle{}} or
\texttt{\textquotesingle{}SUBROUTINE\textquotesingle{}} according to the
first parameter of \texttt{API\_Start}.

\texttt{\#Source} is set to the value of the second parameter of
\texttt{API\_Start}.

The third parameter of \texttt{API\_Start} is used to determine the
initial active environment.

The fourth parameter of \texttt{API\_Start} is used to determine the
arguments. For each argument position \texttt{\#ArgExists.1.ArgNumber}
is set \texttt{\textquotesingle{}1\textquotesingle{}} if there is an
argument present, \texttt{\textquotesingle{}0\textquotesingle{}} if not.
\texttt{ArgNumber} is the number of the argument position, counting from
\texttt{1}. If \texttt{\#ArgExists.1.ArgNumber} is
\texttt{\textquotesingle{}1\textquotesingle{}} then
\texttt{\#Arg.1.ArgNumber} is set to the value of the corresponding
argument. If \texttt{\#ArgExists.1.ArgNumber} is
\texttt{\textquotesingle{}0\textquotesingle{}} then \texttt{\#Arg.1.Arg}
is set to the null string. \texttt{\#ArgExists.1.0} is set to the
largest \texttt{n} for which \texttt{\#ArgExists.1.n} is
\texttt{\textquotesingle{}1\textquotesingle{}}, or to zero if there is
no such value of \texttt{n}.

Some of the values which affect processing of the program are provided
by the configuration:

\lstinputlisting[language=rexx,label=configotherblankcharacters.rexx,caption=configotherblankcharacters.rexx]{configotherblankcharacters.rexx}
our model are only distinquished by the values within their pool so we
can construct the builtin classes incomplete and then complete them with
directives.}

\emph{Can we initialize the methods of .nil by directives?}

\lstinputlisting[language=rexx,label=configobjectnew.rexx,caption=configobjectnew.rexx]{configobjectnew.rexx}

Some of the state variables set by this call are limits, and appear in
the text of error messages. The relation between message numbers and
message text is defined by the following list, where the message number
appears immediately before an
\texttt{\textquotesingle{}=\textquotesingle{}} and the message text
follows in quotes.

\lstinputlisting[language=rexx,label=configerrortexts1.rexx,caption=configerrortexts1.rexx]{configerrortexts1.rexx}

\emph{Unsound now we are using `term'?}

\lstinputlisting[language=rexx,label=errortexts2.rexx,caption=errortexts2.rexx]{errortexts2.rexx}

If the activity defined by clause 6 does not produce any error message,
execution of the program continues.

\lstinputlisting[language=rexx,label=confignosource.rexx,caption=confignosource.rexx]{confignosource.rexx}

If \texttt{Config\_NoSource} has set \texttt{\#NoSource} to
\texttt{\textquotesingle{}0\textquotesingle{}} the lines of source
processed by clause 6 are copied to \texttt{\#SourceLine.} , with
\texttt{\#SourceLine.O} being a count of the lines and
\texttt{\#SourceLine.n} for \texttt{n}=1 to \texttt{\#SourceLine.0}
being the source lines in order.

If \texttt{Config\_NoSource} has set \texttt{\#NoSource} to
\texttt{\textquotesingle{}1\textquotesingle{}} then
\texttt{\#SourceLine.0} is set to \texttt{0}.

The following state variables affect tracing:

\lstinputlisting[language=rexx,label=configtracesettings.rexx,caption=configtracesettings.rexx]{configtracesettings.rexx}

An initial variable pool is established:

\lstinputlisting[language=rexx,label=configinitialvarpool.rexx,caption=configinitialvarpool.rexx]{configinitialvarpool.rexx}

For this first level, there is no previous level from which values are
inherited. The relevant fields are initialized.

\lstinputlisting[language=rexx,label=configdigits.rexx,caption=configdigits.rexx]{configdigits.rexx}

An environment is provided by the \texttt{API\_Start} to become the
initial active environment to which commands will be addressed. The
alternate environment is made the same:

\lstinputlisting[language=rexx,label=configenvironments.rexx,caption=configenvironments.rexx]{configenvironments.rexx}

Conditions are initially disabled:

\lstinputlisting[language=rexx,label=configdisablesconditions.rexx,caption=configdisablesconditions.rexx]{configdisablesconditions.rexx}

The opportunity is provided for a trap to initialize the pool.

\lstinputlisting[language=rexx,label=configinitializepooltrap.rexx,caption=configinitializepooltrap.rexx]{configinitializepooltrap.rexx}

\section{REQUIRES}\label{requires}

For each requires in order of appearence:

\emph{A use of Start\_API with \#instance(requires, taken\_constant).
Msg40.1 or a new if completion `E'. Add Provides to an ordered
collection. Not cyclic because .LIST can be defined without defining
REQUIRES but a fairly profound forward reference.}

\section{CLASS}\label{class}

For each class in order of appearence:

\lstinputlisting[language=rexx,label=classnamesorderofappearance.rexx,caption=classnamesorderofappearance.rexx]{classnamesorderofappearance.rexx}

\emph{New instance of CLASS class added to list. Msg ``Duplicate ::CLASS
directive instruction''(?)} \#\# METHOD

For each method in order of appearence:

\lstinputlisting[language=rexx,label=methodsorderofappearance.rexx,caption=methodsorderofappearance.rexx]{methodsorderofappearance.rexx}

\emph{GUARDED \& public is default. if \#contains(method, `PRIVATE')
then m\textasciitilde setprivate; if \#contains(method, 'UNGUARDED))
then m\textasciitilde setunguarded\\
Why is there a keyword for GUARDED but not for PUBLIC here?\\
Does CLASS option mean ENHANCE with Class class methods?\\
\#CurrentClass\textasciitilde class(\#instance(method, taken\_constant),
m)\\
For ATTRIBUTE, should we actually construct source for two methods?
ATTRIBUTE case needs test of null body. OOI doesn't have source (because
it actually traps UNKNOWN?).\\
For EXTERNAL test for null body. Simon Nash doc says ``Accessibility to
external methods \ldots{} is implementation-defined''. Left like that it
doesn't even tell us about search order. We will need a
Config\_ExternalClass to import the public names of the class.}

\section{ROUTINE}\label{routine}

For each routine in order of appearence:

\emph{Add name (with duplicate check) to list for this file.\\
Extra step needed in the invocation search order. Although this is
nominally EXTERNAL we presumably wont use the external call mechanism.
(Except perhaps when the routine was made available by a REQUIRES; in
that case the PARSE SOURCE answer has to change.)\\
I have the builtins-defined-by-directives elsewhere; it would make sense
if they wound up about here.}
