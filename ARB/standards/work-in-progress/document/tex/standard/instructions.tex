%preprocessed texin
\chapter{Instructions}\label{instructions}

This clause describes the execution of instructions, and how the
sequence of execution can vary from the normal execution in order of
appearance in the program.

Execution of the program begins with its first clause.

\emph{If we left Routine initialization to here we can leave method
initialization.}

\section{Method initialization}\label{method-initialization}

There is a pool for local variables.

\lstinputlisting[language=rexx,label=localvariablepoolinit.rexx,caption=localvariablepoolinit.rexx]{localvariablepoolinit.rexx}

\emph{Set self and super}

\section{Routine initialization}\label{routine-initialization}

If the routine is invoked as a function,
\texttt{\#IsFunction.\#NewLevel} shall be set to
\texttt{\textquotesingle{}1\textquotesingle{}}, otherwise to
\texttt{\textquotesingle{}0\textquotesingle{}}; this affects the
processing of a subsequent RETURN instruction.

\lstinputlisting[language=rexx,label=routineinit.rexx,caption=routineinit.rexx]{routineinit.rexx}

Many of the initial values for a new invocation are inherited from the
caller's values.

\lstinputlisting[language=rexx,label=callersvalues.rexx,caption=callersvalues.rexx]{callersvalues.rexx}

If this invocation is not caused by a condition occurring, see nnn, the
state variables for the CONDITION built-in function are copied.

\lstinputlisting[language=rexx,label=conditionlevel.rexx,caption=conditionlevel.rexx]{conditionlevel.rexx}

Execution of the initialized routine continues at the new level of
invocation.

\lstinputlisting[language=rexx,label=newlevel.rexx,caption=newlevel.rexx]{newlevel.rexx}

\section{Clause initialization}\label{clause-initialization}

The clause is traced before execution:

\lstinputlisting[language=rexx,label=traceclauseinit.rexx,caption=traceclauseinit.rexx]{traceclauseinit.rexx}

The time of the first use of DATE or TIME will be retained throughout
the clause.

\lstinputlisting[language=rexx,label=clauseretaindatetime.rexx,caption=clauseretaindatetime.rexx]{clauseretaindatetime.rexx}

The state variable \texttt{\#LineNumber} is set to the line number of
the clause, see nnn.

A clause other than a null clause or label or procedure instruction
sets:

\lstinputlisting[language=rexx,label=allowprocedure.rexx,caption=allowprocedure.rexx]{allowprocedure.rexx}

\section{Clause termination}\label{clause-termination}

\lstinputlisting[language=rexx,label=inihibittrace.rexx,caption=inihibittrace.rexx]{inihibittrace.rexx}

Polling for a HALT condition occurs:

\lstinputlisting[language=rexx,label=haltquery.rexx,caption=haltquery.rexx]{haltquery.rexx}

At the end of each clause there is a check for conditions which occurred
and were delayed. It is acted on if this is the clause in which the
condition arose.

\lstinputlisting[language=rexx,label=endclauseconditions.rexx,caption=endclauseconditions.rexx]{endclauseconditions.rexx}
be turned on via the configuration. Only a change in the setting is
significant.

\lstinputlisting[language=rexx,label=configtracequery.rexx,caption=configtracequery.rexx]{configtracequery.rexx}

\emph{Tracing just not the same with NetRexx.}

When tracing interactively, pauses occur after the execution of each
clause except for CALL, DO the second or subsequent time through the
loop, END, ELSE, EXIT, ITERATE, LEAVE, OTHERWISE, RETURN, SIGNAL, THEN
and null clauses.

If the character `=' is entered in response to a pause, the prior clause
is re-executed.

Anything else entered will be treated as a string of one or more clauses
and executed by the language processor. The same rules apply to the
contents of the string executed by interactive trace as do for strings
executed by the INTERPRET instruction. If the execution of the string
generates a syntax error, the standard message is displayed but no
condition is raised. All condition traps are disabled during execution
of the string. During execution of the string, no tracing takes place
other than error or failure return codes from commands. The special
variable RC is not set by commands executed within the string, nor is
.RC.

If a TRACE instruction is executed within the string, the language
processor immediately alters the trace setting according to the TRACE
instruction encountered and leaves this pause point. If no TRACE
instruction is executed within the string, the language processor simply
pauses again at the same point in the program.

At a pause point:

\lstinputlisting[language=rexx,label=pausepoint.rexx,caption=pausepoint.rexx]{pausepoint.rexx}

\section{Instruction}\label{instruction}

\subsection{ADDRESS}\label{address}

For a definition of the syntax of this instruction, see nnn.

An external environment to which commands can be submitted is identified
by an environment name. Environment names are specified in the ADDRESS
instruction to identify the environment to which a command should be
sent.

I/O can be redirected when submitting commands to an external
environment. The submitted command's input stream can be taken from an
existing stream or from a set of compound variables with a common stem.
In the latter case (that is, when a stem is specified as the source for
the commands input stream) whole number tails are used to order input
for presentation to the submitted command. \texttt{Stem.0} must contain
a whole number indicating the number of compound variables to be
presented, and \texttt{stem.\ 1} through \texttt{stem.n} (where
\texttt{n=stem.0}) are the compound variables to be presented to the
submitted command.

Similarly, the submitted command's output stream can be directed to a
stream, or to a set of compound variables with a given stem. In the
latter case (i.e., when a stem is specified as the destination) compound
variables will be created to hold the standard output, using whole
number tails as described above. Output redirection can specify a
REPLACE or APPEND option, which controls positioning prior to the
command's execution. REPLACE is the default.

I/O redirection can be persistently associated with an environment name.
The term ``environment'' is used to refer to an environment name
together with the I/O redirections.

At any given time, there will be two environments, the active
environment and the alternate environment. When an ADDRESS instruction
specifies a command to the environment, any specified I/O redirection
applies to that command's execution only, providing a third environment
for the duration of the instruction. When an ADDRESS command does not
contain a command, that ADDRESS command creates a new active
environment, which includes the specified I/O redirection.

The redirections specified on the ADDRESS instruction may not be
possible. If the configuration is aware that the command processor named
does not perform I/O in a manner compatible with the request, the value
of \texttt{\#Env\_Type.} may be set to
\texttt{\textquotesingle{}UNUSED\textquotesingle{}} as an alternative to
\texttt{\textquotesingle{}STEM\textquotesingle{}} and
\texttt{\textquotesingle{}STREAM\textquotesingle{}} where those values
are assigned in the following code.

In the following code the particular use of
\texttt{\#Contains(address,\ expression)} refers to an expression
immediately contained in the \emph{address}.

\lstinputlisting[language=rexx,label=addressinstruct.rexx,caption=addressinstruct.rexx]{addressinstruct.rexx}

\subsection{ARG}\label{arg}

For a definition of the syntax of this instruction, see nnn.

The ARG instruction is a shorter form of the equivalent instruction:\\
\texttt{PARSE\ UPPER\ ARG}\emph{\texttt{template\ list}}

\subsection{Assignment}\label{assignment}

Assignment can occur as the result of executing a clause containing an
assignment (see nnn and nnn), or as a result of executing the VALUE
built-in function, or as part of the execution of a PARSE instruction.
Assignment involves an \emph{expression} and a \emph{VAR\_SYMBOL}. The
value of the \emph{expression} is determined; see nnn.

If the \emph{VAR\_SYMBOL} does not contain a period, or contains only
one period as its last character, the value is associated with the
\emph{VAR\_SYMBOL}:

\lstinputlisting[language=rexx,label=assignmentvarpoolzero.rexx,caption=assignmentvarpoolzero.rexx]{assignmentvarpoolzero.rexx}

Otherwise, a name is derived, see nnn. The value is associated with the
derived name:

\lstinputlisting[language=rexx,label=assignmentvarpoolone.rexx,caption=assignmentvarpoolone.rexx]{assignmentvarpoolone.rexx}

\subsection{CALL}\label{call}

For a definition of the syntax of this instruction, see nnn.

The CALL instruction is used to invoke a routine, or is used to control
trapping of conditions.

lf a \emph{vref} is specified that value is the name of the routine to
invoke:

\lstinputlisting[language=rexx,label=callcontains.rexx,caption=callcontains.rexx]{callcontains.rexx}

If a \emph{taken\_constant} is specified, that name is used.

\lstinputlisting[language=rexx,label=calltakenconstant.rexx,caption=calltakenconstant.rexx]{calltakenconstant.rexx}

The name is used to invoke a routine, see nnn. If that routine does not
return a result the RESULT and .RESULT variables become uninitialized:

\lstinputlisting[language=rexx,label=callvardrop.rexx,caption=callvardrop.rexx]{callvardrop.rexx}

If the routine does return a result that value is assigned to RESULT and
.RESULT. See nnn for an exception to assigning results.

If the routine returns a result and the trace setting is
\texttt{\textquotesingle{}R\textquotesingle{}} or
\texttt{\textquotesingle{}I\textquotesingle{}} then a trace with that
result and a tag
\texttt{\textquotesingle{}\textgreater{}\textgreater{}\textgreater{}\textquotesingle{}}
shall be produced, associated with the call instruction.

If a \emph{callon\_spec} is specified:

\lstinputlisting[language=rexx,label=callcallonspec.rexx,caption=callcallonspec.rexx]{callcallonspec.rexx}

\subsection{Command to the
configuration}\label{command-to-the-configuration}

For a definition of the syntax of a command, see nnn.

A command that is not part of an ADDRESS instruction is processed in the
ACTIVE environment.

\lstinputlisting[language=rexx,label=commandtoconfifuration.rexx,caption=commandtoconfifuration.rexx]{commandtoconfifuration.rexx}

\texttt{CommandIssue} is also used to describe the ADDRESS instruction:

\lstinputlisting[language=rexx,label=commandIssue.rexx,caption=commandIssue.rexx]{commandIssue.rexx}

The configuration may choose to perform the test for message 54.1 before
or after issuing the command.

\subsection{DO}\label{do}

For a definition of the syntax of this instruction, see nnn.

The DO instructions is used to group instructions together and
optionally to execute them repeatedly.

Executing a \emph{do\_simple} has the same effect as executing a
\emph{nop}, except in its trace output. Executing the \emph{do\_ending}
associated with a \emph{do\_simple} has the same effect as executing a
\emph{nop}, except in its trace output.

A \emph{do\_instruction} that does not contain a \emph{do\_simple} is
equivalent, except for trace output, to a sequence of instructions in
the following order.

\lstinputlisting[language=rexx,label=doinstruction.rexx,caption=doinstruction.rexx]{doinstruction.rexx}

The following three assignments are made in the order in which
\texttt{\textquotesingle{}TO\textquotesingle{}},
\texttt{\textquotesingle{}BY\textquotesingle{}} and
\texttt{\textquotesingle{}FOR\textquotesingle{}} appear in
\emph{docount}; see nnn.

\lstinputlisting[language=rexx,label=doassignments.rexx,caption=doassignments.rexx]{doassignments.rexx}

\subsection{DO loop tracing}\label{do-loop-tracing}

When clauses are being traced by \texttt{\#TraceSource}, due to
\texttt{pos(\#Tracing.\#Level,\ \textquotesingle{}AIR\textquotesingle{})\ \textgreater{}\ 0},
the DO instruction shall be traced when it is encountered and again each
time the \texttt{IterateLabel} (see nnn) is encountered. The END
instruction shall be traced when the \texttt{TraceOfEnd} label is
encountered.

When expressions or intermediates are being traced they shall be traced
in the order specified by nnn. Hence, in the absence of conditions
arising, those executed prior to the first execution of
\texttt{OnceLabel} shall be shown once per execution of the DO
instruction; others shall be shown depending on the outcome of the
tests.

The code in the DO description:

\lstinputlisting[language=rexx,label=dolooptracing.rexx,caption=dolooptracing.rexx]{dolooptracing.rexx}

represents updating the control variable of the loop. That assignment is
subject to tracing, and other expressions involving state variables are
not. When tracing intermediates, the BY value will have a tag of
\texttt{\textquotesingle{}\textgreater{}+\textgreater{}\textquotesingle{}}.

\subsection{DROP}\label{drop}

For a definition of the syntax of this instruction, see nnn.

The DROP instruction restores variables to an uninitialized state.

The words of the \emph{variable\_list} are processed from left to right.

A word which is a VAR\_SYMBOL, not contained in parentheses, specifies a
variable to be dropped. If VAR\_SYMBOL does not contain a period, or has
only a single period as its last character, the variable associated with
VAR\_SYMBOL by the variable pool is dropped:

\lstinputlisting[language=rexx,label=drop.rexx,caption=drop.rexx]{drop.rexx}

If VAR\_SYMBOL has a period other than as the last character, the
variable associated with VAR\_SYMBOL by the variable pool is dropped by:

\lstinputlisting[language=rexx,label=drop2.rexx,caption=drop2.rexx]{drop2.rexx}

If the word of the \emph{variable\_list} is a VAR\_SYMBOL enclosed in
parentheses then the value of the VAR\_SYMBOL is processed. The value is
considered in uppercase:

\lstinputlisting[language=rexx,label=dropconfigupper.rexx,caption=dropconfigupper.rexx]{dropconfigupper.rexx}

Each word in that value found by the WORD built-in function, from left
to right, is subjected to this process:

If the word does not have the syntax of VAR\_SYMBOL a condition is
raised:

\lstinputlisting[language=rexx,label=dropnotsymbolcondition.rexx,caption=dropnotsymbolcondition.rexx]{dropnotsymbolcondition.rexx}

Otherwise the VAR\_SYMBOL indicated by the word is dropped, as if that
VAR\_SYMBOL were a word of the \emph{variable\_list}.

\subsection{EXIT}\label{exit}

For a definition of the syntax of this instruction, see nnn.

The EXIT instruction is used to unconditionally complete execution of a
program.

Any \emph{expression} is evaluated:

\lstinputlisting[language=rexx,label=exitevaluate.rexx,caption=exitevaluate.rexx]{exitevaluate.rexx}

The opportunity is provided for a final trap.

\lstinputlisting[language=rexx,label=finaltrap.rexx,caption=finaltrap.rexx]{finaltrap.rexx}

The processing of the program is complete. See nnn for what
\texttt{API\_Start} returns as the result.

If the normal sequence of execution ``falls through'' the end of the
program; that is, would execute a further statement if one were appended
to the program, then the program is terminated in the same manner as an
EXIT instruction with no argument.

\subsection{EXPOSE}\label{expose}

The expose instruction identifies variables that are not local to the
method.

\emph{We need a check that this starts method; similarities with
PROCEDURE.}

For a definition of the syntax of this instruction, see nnn.

It is used at the start of a method, after method initialization, to
make variables in the receiver's pool accessible:

\lstinputlisting[language=rexx,label=allowexpose.rexx,caption=allowexpose.rexx]{allowexpose.rexx}

The words of the \emph{variable\_list} are processed from left to right.

A word which is a VAR\_SYMBOL, not contained in parentheses, specifies a
variable to be made accessible. If VAR\_SYMBOL does not contain a
period, or has only a single period as its last character, the variable
associated with VAR\_SYMBOL by the variable pool (as a non-tailed name)
is given the attribute `exposed'.

\lstinputlisting[language=rexx,label=exposenoperiod.rexx,caption=exposenoperiod.rexx]{exposenoperiod.rexx}

If VAR\_SYMBOL has a period other than as last character, the variable
associated with VAR\_SYMBOL in the variable pool ( by the name derived
from VAR\_SYMBOL, see nnn) is given the attribute `exposed'.

\lstinputlisting[language=rexx,label=exposederivedname.rexx,caption=exposederivedname.rexx]{exposederivedname.rexx}

If the word from the \emph{variable\_list} is a VAR\_SYMBOL enclosed in
parentheses then the VAR\_SYMBOL is exposed, as if that VAR\_SYMBOL was
a word in the variable\_list. The value of the VAR\_SYMBOL is processed.
The value is considered in uppercase:

\lstinputlisting[language=rexx,label=configupper.rexx,caption=configupper.rexx]{configupper.rexx}
the WORD built-in function, from left to right, is subjected to this
process:

If the word does not have the syntax of VAR\_SYMBOL a condition is
\lstinputlisting[language=rexx,label=raisesyntaxnotsymbol2.rexx,caption=raisesyntaxnotsymbol2.rexx]{raisesyntaxnotsymbol2.rexx}
VAR\_SYMBOL indicated by the word is exposed, as if that VAR\_SYMBOL
were a word of the \emph{variable\_list}.

\subsection{FORWARD}\label{forward}

For a definition of the syntax of this instruction, see nnn.

The FORWARD instruction is used to send a message based on the current
message.

\lstinputlisting[language=rexx,label=forward.rexx,caption=forward.rexx]{forward.rexx}

\subsection{GUARD}\label{guard}

For a definition of the syntax of this instruction, see nnn.

The GUARD instruction is used to conditionally delay the execution of a
method.

\lstinputlisting[language=rexx,label=guardinstruction.rexx,caption=guardinstruction.rexx]{guardinstruction.rexx}
\lstinputlisting[language=rexx,label=dropexclusive.rexx,caption=dropexclusive.rexx]{dropexclusive.rexx}

\subsection{IF}\label{if}

For a definition of the syntax of this instruction, see nnn.

The IF instruction is used to conditionally execute an instruction, or
to select between two alternatives. The \emph{expression} is evaluated.
If the value is neither \texttt{\textquotesingle{}0\textquotesingle{}}
nor \texttt{\textquotesingle{}1\textquotesingle{}} error 34.1 occurs. If
the value is `1', the \emph{instruction} in the \emph{then} is executed.
If the value is \texttt{\textquotesingle{}0\textquotesingle{}} and
\emph{else} is specified, the instruction in the \emph{else} is
executed.

In the former case, if tracing clauses, the clause consisting of the
THEN keyword shall be traced in addition to the instructions.

In the latter case, if tracing clauses, the clause consisting of the
ELSE keyword shall be traced in addition to the instructions.

\subsection{INTERPRET}\label{interpret}

For a definition of the syntax of this instruction, see nnn.

The INTERPRET instruction is used to execute instructions that have been
built dynamically by evaluating an expression.

The \emph{expression} is evaluated.

The HALT condition is tested for, and may be raised, in the same way it
is tested at clause termination, see nnn.

The process of syntactic recognition described in clause 6 is applied,
with \texttt{Config\_SourceChar} obtaining its results from the
characters of the value, in left-to-right order, without producing any
\texttt{EOL} or \texttt{EOS} events. When the characters are exhausted,
the event \texttt{EOL} occurs, followed by the event \texttt{EOS}. If
that recognition would produce any message then the \emph{interpret}
raises the corresponding `SYNTAX' condition.

If the program recognized contains any LABELs then the \emph{interpret}
raises a condition:

\lstinputlisting[language=rexx,label=raiselabel.rexx,caption=raiselabel.rexx]{raiselabel.rexx}
LABEL in the \emph{program}.

Otherwise the \emph{instruction\_list} in the \emph{program} is
executed.

\subsection{ITERATE}\label{iterate}

For a definition of the syntax of this instruction, see nnn.

The ITERATE instruction is used to alter the flow of control within a
repetitive DO.

For a definition of the nesting correction, see nnn.

\lstinputlisting[language=rexx,label=instructioniterate.rexx,caption=instructioniterate.rexx]{instructioniterate.rexx}

\subsection{Execution of labels}\label{execution-of-labels}

The execution of a label has no effect, other than clause termination
activity and any tracing.

\lstinputlisting[language=rexx,label=traceexecutelabel.rexx,caption=traceexecutelabel.rexx]{traceexecutelabel.rexx}

\subsection{LEAVE}\label{leave}

For a definition of the syntax of this instruction, see nnn.

The LEAVE instruction is used to immediately exit one or more repetitive
DOs.

For a definition of the nesting correction, see nnn.

\lstinputlisting[language=rexx,label=instructionleave.rexx,caption=instructionleave.rexx]{instructionleave.rexx}

\subsection{Message term}\label{message-term}

\emph{We can do this by reference to method invokation, just as we do
CALL by reference to invoking a function.}

\subsection{LOOP}\label{loop}

\emph{Shares most of it's definition with repetitive DO.}

\subsection{NOP}\label{nop}

For a definition of the syntax of this instruction, see nnn.

The NOP instruction has no effect other than the effects associated with
all instructions.

\subsection{NUMERIC}\label{numeric}

For a definition of the syntax of this instruction, see nnn.

The NUMERIC instruction is used to change the way in which arithmetic
operations are carried out.

\subsubsection{NUMERIC DIGITS}\label{numeric-digits}

For a definition of the syntax of this instruction, see nnn.

NUMERIC DIGITS controls the precision under which arithmetic operations
and arithmetic built-in functions will be evaluated.

\lstinputlisting[language=rexx,label=numericdigits.rexx,caption=numericdigits.rexx]{numericdigits.rexx}

\subsubsection{NUMERIC FORM}\label{numeric-form}

For a definition of the syntax of this instruction, see nnn.

NUMERIC FORM controls which form of exponential notation is to be used
for the results of operations and arithmetic built-in functions.

The value of form is either taken directly from the SCIENTIFIC or
ENGINEERING keywords, or by evaluating \emph{valueexp}.

\lstinputlisting[language=rexx,label=numericform.rexx,caption=numericform.rexx]{numericform.rexx}

\subsubsection{NUMERIC FUZZ}\label{numeric-fuzz}

For a definition of the syntax of this instruction, see nnn.

NUMERIC FUZZ controls how many digits, at full precision, will be
ignored during a numeric comparison.

\lstinputlisting[language=rexx,label=numericfuzz.rexx,caption=numericfuzz.rexx]{numericfuzz.rexx}

\subsubsection{OPTIONS}\label{options}

For a definition of the syntax of this instruction, see nnn.

The OPTIONS instruction is used to pass special requests to the language
processor.

The \emph{expression} is evaluated and the value is passed to the
language processor. The language processor treats the value as a series
of blank delimited words. Any words in the value that are not recognized
by the language processor are ignored without producing an error.

\lstinputlisting[language=rexx,label=configoptions.rexx,caption=configoptions.rexx]{configoptions.rexx}

\subsubsection{PARSE}\label{parse}

For a definition of the syntax of this instruction, see nnn.

The PARSE instruction is used to assign data from various sources to
variables.

The purpose of the PARSE instruction is to select substrings of the
\emph{parse\_fype} under control of the \emph{template\_list}. If the
\emph{template\_list} is omitted, or a \emph{template} in the list is
omitted, then a template which is the null string is implied.

Processing for the PARSE instruction begins by constructing a value, the
source to be parsed.

\lstinputlisting[language=rexx,label=instructionsparse.rexx,caption=instructionsparse.rexx]{instructionsparse.rexx}

The first template is associated with this source. If there are further
templates, they are matched against null strings unless `ARG' is
specified, when they are matched against further arguments.

The parsing process is defined by the following routine,
\texttt{ParseData}. The \emph{template\_list} is accessed by
\texttt{ParseDat}a as a stemmed variable. This variable
\texttt{Template.} has elements which are null strings except for any
elements with tails 1,2,3,\ldots{} corresponding to the tokens of the
\emph{template\_list} from left to right.

\lstinputlisting[language=rexx,label=parsedata.rexx,caption=parsedata.rexx]{parsedata.rexx}

For a definition of the syntax of this instruction, see nnn.

The PROCEDURE instruction is used within an internal routine to protect
all the existing variables by making them unknown to following
instructions. Selected variables may be exposed.

It is used at the start of a routine, after routine initialization:

\lstinputlisting[language=rexx,label=procedure.rexx,caption=procedure.rexx]{procedure.rexx}

If there is a \emph{variable\_list}, it provides access to a previous
variable pool.

The words of the \emph{variable\_list} are processed from left to right.

A word which is a VAR\_SYMBOL, not contained in parentheses, specifies a
variable to be made accessible. If VAR\_SYMBOL does not contain a
period, or has only a single period as its last character, the variable
associated with VAR\_SYMBOL by the variable pool (as a non-tailed name)
is given the attribute `exposed'.

\lstinputlisting[language=rexx,label=exposepool.rexx,caption=exposepool.rexx]{exposepool.rexx}

If VAR\_SYMBOL has a period other than as last character, the variable
associated with VAR\_SYMBOL in the variable pool (by the name derived
from VAR\_SYMBOL, see nnn) is given the attribute `exposed'.

\lstinputlisting[language=rexx,label=exposederived.rexx,caption=exposederived.rexx]{exposederived.rexx}

If the word from the \emph{variable\_list} is a VAR\_SYMBOL enclosed in
parentheses then the VAR\_SYMBOL is exposed, as if that VAR\_SYMBOL was
a word in the \emph{variable\_list}. Tne value of the VAR\_SYMBOL is
processed. The value is considered in uppercase:

\lstinputlisting[language=rexx,label=configuppervalue.rexx,caption=configuppervalue.rexx]{configuppervalue.rexx}

Each word in that value found by the WORD built-in function, from left
to right, is subjected to this process:

If the word does not have the syntax of VAR\_SYMBOL a condition is
raised:

\lstinputlisting[language=rexx,label=callraisesyntax.rexx,caption=callraisesyntax.rexx]{callraisesyntax.rexx}

Otherwise the VAR\_SYMBOL indicated by the word is exposed, as if that
VAR\_SYMBOL were a word of the \emph{variable\_list}.

\subsection{PULL}\label{pull}

For a definition of the syntax of this instruction, see nnn.

A PULL instruction is a shorter form of the equivalent instruction:

\lstinputlisting[language=rexx,label=upperpull.rexx,caption=upperpull.rexx]{upperpull.rexx}

\subsection{PUSH}\label{push}

For a definition of the syntax of this instruction, see nnn.

The PUSH instruction is used to place a value on top of the stack.

\lstinputlisting[language=rexx,label=push.rexx,caption=push.rexx]{push.rexx}

\subsection{QUEUE}\label{queue}

For a definition of the syntax of this instruction, see nnn.

The QUEUE instruction is used to place a value on the bottom of the
stack.

\lstinputlisting[language=rexx,label=queue.rexx,caption=queue.rexx]{queue.rexx}

\subsection{RAISE}\label{raise}

The RAISE instruction returns from the current method or routine and
raises a condition.

\subsection{REPLY}\label{reply}

The REPLY instruction is used to allow both the invoker of a method, and
the replying method, to continue executing.

\emph{Must set up for error of expression on subsequent RETURN.} \#\#\#
RETURN For a definition of the syntax of this instruction, see nnn.

The RETURN instruction is used to return control and possibly a result
from a program or internal routine to the point of its invocation.

The RETURN keyword may be followed by an optional expression, which will
be evaluated and returned as a result to the caller of the routine.

Any \emph{expression} is evaluated:

\lstinputlisting[language=rexx,label=return.rexx,caption=return.rexx]{return.rexx}

At this point the clause termination occurs and then the following:

If the routine started with a PROCEDURE instruction then the associated
pool is taken out of use:

\lstinputlisting[language=rexx,label=isprocedure.rexx,caption=isprocedure.rexx]{isprocedure.rexx}

A RETURN instruction which is interactively entered at a pause point
leaves the pause point.

\lstinputlisting[language=rexx,label=atpause.rexx,caption=atpause.rexx]{atpause.rexx}

The activity at this level is complete:

\lstinputlisting[language=rexx,label=newlevel.rexx,caption=newlevel.rexx]{newlevel.rexx}

If \texttt{\#Level} is not zero, the processing of the RETURN
instruction and the invocation is complete. Otherwise processing of the
program is completed:

The opportunity is provided for a final trap.

\lstinputlisting[language=rexx,label=apifinaltrap.rexx,caption=apifinaltrap.rexx]{apifinaltrap.rexx}

The processing of the program is complete. See nnn for what
\texttt{API\_Start} returns as the result.

\subsection{SAY}\label{say}

For a definition of the syntax of this instruction, see nnn.

The SAY instruction is used to write a line to the default output
stream.

\lstinputlisting[language=rexx,label=say.rexx,caption=say.rexx]{say.rexx}

For a definition of the syntax of this instruction, see nnn.

The SELECT instruction is used to conditionally execute one of several
alternative instructions. When tracing, the clause containing the
keyword SELECT is traced at this point.

The \texttt{\#Contains(}\emph{\texttt{select\_body,\ when}}\texttt{)}
test in the following description refers to the items of the optional
\emph{when} repetition in order:

\lstinputlisting[language=rexx,label=select.rexx,caption=select.rexx]{select.rexx}

When tracing, the clause containing the END keyword is traced at this
point.

\subsection{SIGNAL}\label{signal}

For a definition of the syntax of this instruction, see nnn.

The SIGNAL instruction is used to cause a change in the flow of control
or is used with the ON and OFF keywords to control the trapping of
conditions.

\lstinputlisting[language=rexx,label=signal.rexx,caption=signal.rexx]{signal.rexx}

If there was a \emph{signal\_spec} this complete the processing of the
signal instruction. Otherwise:

\lstinputlisting[language=rexx,label=signalspec.rexx,caption=signalspec.rexx]{signalspec.rexx}

The Name matches the first LABEL in the program which has that value.
The comparison is made with the
\texttt{\textquotesingle{}==\textquotesingle{}} operator.

If no label matches then a condition is raised:

\lstinputlisting[language=rexx,label=raisesyntaxname.rexx,caption=raisesyntaxname.rexx]{raisesyntaxname.rexx}

If the name is a trace-only label then a condition is raised:

\lstinputlisting[language=rexx,label=raisetraceonlysymbol.rexx,caption=raisetraceonlysymbol.rexx]{raisetraceonlysymbol.rexx}

If the name matches a label, execution continues at that label after
these settings:

\lstinputlisting[language=rexx,label=executioncontinues.rexx,caption=executioncontinues.rexx]{executioncontinues.rexx}

\subsection{TRACE}\label{trace}

For a definition of the syntax of this instruction, see nnn.

The TRACE instruction is used to control the trace setting which in turn
controls the tracing of execution of the program.

The TRACE instruction is ignored if it occurs within the program (as
opposed to source obtained by \texttt{Config\_Trace\_Input}) and
interactive trace is requested
(\texttt{\#Interactive.\#Level\ =\ \textquotesingle{}1\textquotesingle{}}).
Otherwise:

\lstinputlisting[language=rexx,label=trace.rexx,caption=trace.rexx]{trace.rexx}

\subsection{Trace output}\label{trace-output}

If \texttt{\#NoSource} is \texttt{\textquotesingle{}1\textquotesingle{}}
there is no trace output.

The routines \texttt{\#TraceSource} and \texttt{\#Trace} specify the
output that results from the trace settings. That output is presented to
the configuration by \texttt{Config\_Trace\_Output} as lines. Each line
has a clause identifier at the left, followed by a blank, followed by a
three character tag, followed by a blank, followed by the trace data.

The width of the clause identifier shall be large enough to hold the
line number of the last line in the program, and no larger. The clause
identifier is the source program line number, or all blank if the line
number is the same as the previous line number indicated and no
execution with trace Off has occurred since. The line number is
right-aligned with leading zeros replaced by blank characters.

When input at a pause is being executed
(\texttt{\#AtPause\ \textbackslash{}=\ 0}), \texttt{\#Trace} does
nothing when the tag is not
\texttt{\textquotesingle{}+++\textquotesingle{}}.

When input at a pause is being executed, \texttt{\#TraceSource} does
nothing.

If \texttt{\#InhibitTrace} is greater than zero, \texttt{\#TraceSource}
does nothing except decrement \texttt{\#InhibitTrace}. Otherwise, unless
the current clause is a null clause, \texttt{\#TraceSource} outputs all
lines of the source program which contain any part of the current
clause, with any characters in those lines which are not part of the
current clause and not \texttt{other\_blank\_characters} replaced by
blank characters. The possible replacement of
\texttt{other\_blank\_characters} is defined by the configuration. The
tag is \texttt{\textquotesingle{}*-*\textquotesingle{}}, or if the line
is not the first line of the clause.
\texttt{\textquotesingle{}*,*\textquotesingle{}}.

\texttt{\#Trace} output also has a clause identifier and has a tag which
is the argument to the \texttt{\#Trace} invocation. The data is
truncated, if necessary, to \texttt{\#Limit\_TraceData} characters. The
data is enclosed by quotation marks and the quoted data preceded by two
blanks. If the data is truncated, the trailing quote has the three
characters \texttt{\textquotesingle{}...\textquotesingle{}} appended.

\begin{itemize}
\tightlist
\item
  when \texttt{\#Tracing.\#Level} is
  \texttt{\textquotesingle{}C\textquotesingle{}} or
  \texttt{\textquotesingle{}E\textquotesingle{}} or
  \texttt{\textquotesingle{}F\textquotesingle{}} or
  \texttt{\textquotesingle{}N\textquotesingle{}} or
  \texttt{\textquotesingle{}A\textquotesingle{}} and the tag is
  \texttt{\textquotesingle{}\textgreater{}\textgreater{}\textgreater{}\textquotesingle{}}
  then the data is the value of the command passed to the environment;
\item
  when the tag is \texttt{\textquotesingle{}+++\textquotesingle{}} then
  the data is the four characters
  \texttt{\textquotesingle{}RC\ "\textquotesingle{}} concatenated with
  the character \texttt{\textquotesingle{}"\textquotesingle{}};
\item
  when \texttt{\#Tracing.\#Level} is
  \texttt{\textquotesingle{}l\textquotesingle{}} or
  \texttt{\textquotesingle{}R\textquotesingle{}} the data is the most
  recently evaluated value.
\end{itemize}

Trace output can also appear as the result of a'SYNTAX' condition
occurring, irrespective of the trace setting. If a'SYNTAX' condition
occurs and it is not trapped by SIGNAL ON SYNTAX, then the clause in
error shall be traced, along with a traceback. A traceback is a display
of each active CALL and INTERPRET instruction, and function invocation,
displayed in reverse order of execution, each with a tag of
\texttt{\textquotesingle{}+++\textquotesingle{}}.

\subsection{USE}\label{use}

For a definition of the syntax of this instruction, see nnn.

The USE instruction assigns the values of arguments to variables.

\emph{Better not say copies since COPY method has different semantics.}

The optional VAR\_SYMBOL positions, positions 1, 2, \ldots, of the
instruction are considered from left to right. If the position has a
VAR\_SYMBOL then its value is assigned to:

\lstinputlisting[language=rexx,label=use.rexx,caption=use.rexx]{use.rexx}

\emph{Messy because VALUE bif won't DROP and var\_drop needs to know if
compound.}

\section{Conditions and Messages}\label{conditions-and-messages}

When an error occurs during execution of a program, an error number and
message are associated with it. The error number has two parts, the
error code and the error subcode. These are the integer and decimal
parts of the error number. Subcodes beginning or ending in zero are not
used.

Error codes in the range 1 to 90 and error subcodes up to .9 are
reserved for errors described here and for future extensions of this
standard.

Error number 3 is available to report error conditions occuring during
the initialization phase; error number 2 is available to report error
conditions during the termination phase. These are error conditions
recognized by the language processor, but the circumstances of their
detection is outside of the scope of this standard.

The ERRORTEXT built-in function returns the text as initialized in nnn
when called with the `Standard' option. When the `Standard' option is
omitted, implementation-dependent text may be returned.

When messages are issued any message inserts are replaced by actual
values.

The notation for detection of a condition is:

\lstinputlisting[language=rexx,label=detectcondition.rexx,caption=detectcondition.rexx]{detectcondition.rexx}

Some of the arguments may be omitted. In the case of condition `SYNTAX'
the arguments are the message number and the inserts for the message. In
other cases the argument is a further description of the condition.

The action of the program as a result of a condition is dependent on any
\emph{signal\_spec} and \emph{callon\_spec} in the program.

\subsection{Raising of conditions}\label{raising-of-conditions}

The routine \texttt{\#Raise} corresponds to raising a condition. In the
following definition, the instructions containing SIGNAL VALUE and
INTERPRET denote transfers of control in the program being processed.
The instruction EXIT denotes termination. If not at an interactive
pause, this will be termination of the program, see nnn, and there will
be output by \texttt{Config\_Trace\_Output} of the message (with prefix
\_ see nnn) and tracing (see nnn). If at an interactive pause
(\texttt{\#AtPause\ \textbackslash{}=\ 0}), this will be termination of
the interpretation of the interactive input; there will be output by
\texttt{Config\_Trace\_Output} of the message (without traceback) before
continuing. The description of the continuation is in nnn after the
\texttt{"interpret\ \#Outcome”} instruction.

The instruction
\texttt{“interpret\ \textquotesingle{}CALL\textquotesingle{}\ \#TrapName.\#Condition.\#Level"}
below does not set the variables RESULT and .RESULT; any result returned
is discarded.

\lstinputlisting[language=rexx,label=interpretraise.rexx,caption=interpretraise.rexx]{interpretraise.rexx}

\subsection{Messages during execution}\label{messages-during-execution}

The state function \texttt{\#Message} corresponds to constructing a
message.

This definition is for the message text in nnn. Translations in which
the message inserts are in a different order are permitted.

In addition to the result defined below, the values of
\texttt{MsgNumber} and \texttt{\#LineNumber} shall be shown when a
message is output. Also there shall be an indication of whether the
error occurred in code executed at an interactive pause, see nnn.

Messages are shown by writing them to the default error stream.

\lstinputlisting[language=rexx,label=executionmessages.rexx,caption=executionmessages.rexx]{executionmessages.rexx}
