%preprocessed texin
\chapter{Syntax constructs}\label{syntax-constructs}

\section{Notation}\label{notation}

\subsection{Backus-Naur Form (BNF)}\label{backus-naur-form-bnf}

The syntax constructs in this standard are defined in Backus-Naur Form
(BNF). The syntax used in these BNF productions has

\begin{itemize}
\item
  a left-hand side (called \emph{identifier});
\item
  the characters \texttt{\textquotesingle{}:="};
\item
  a right-hand side (called \emph{bnf\_expression}).
\end{itemize}

The left-hand side identifies syntactic constructs. The right-hand side
describes valid ways of writing a specific syntactic construct.

The right-hand side consists of operands and operators, and may be
grouped.

\subsection{Operands}\label{operands}

Operands may be terminals or non-terminals. If an operand appears as
identifier in some other production it is called a non-terminal,
otherwise it is called a terminal. Terminals are either literal or
symbolic.

Literal terminals are enclosed in quotes and represent literally (apart
from case) what must be present in the source being described.

Symbolic terminals formed with lower case characters represent something
which the configuration may, or may not, allow in the source program,
see nnn, nnn, nnn, nnn.

Symbolic terminals formed with uppercase characters represent events and
tokens, see nnn and nnn.

\subsection{Operators}\label{operators}

The following lists the valid operators, their meaning, and their
precedence; the operator listed first has the highest precedence; apart
from precedence recognition is from left to right:

\begin{itemize}
\item
  the postfix plus operator specifies one or more repetitions of the
  preceding construct;
\item
  abuttal specifies that the preceding and the following construct must
  appear in the given order;
\item
  the operator \texttt{\textquotesingle{}\textbar{}\textquotesingle{}}
  specifies alternatives between the preceding and the following
  constructs.
\end{itemize}

\subsection{Grouping}\label{grouping}

Parentheses and square brackets are used to group constructs.
Parentheses are used for the purpose of grouping only. Square brackets
specify that the enclosed construct is optional.

\subsection{BNF syntax definition}\label{bnf-syntax-definition}

The BNF syntax, described in BNF, is:

\lstinputlisting[language=rexx,label=ebnfgrouping.ebnf,caption=ebnfgrouping.ebnf]{ebnfgrouping.ebnf}

\subsection{Syntactic errors}\label{syntactic-errors}

The syntax descriptions (see nnn and nnn) make use of
\emph{message\_identifiers} which are shown as Msgnn.nn or Msgnn, where
nn is a number. These actions produce the correspondingly numbered error
messages (see nnn and nnn).

\section{Lexical}\label{lexical}

The lexical level processes the source and provides tokens for further
recognition by the top syntax level.

\subsection{Lexical elements}\label{lexical-elements}

\subsubsection{Events}\label{events}

The fully-capitalized identifiers in the BNF syntax (see nnn) represent
events. An event is either supplied by the configuration or occurs as
result of a look-ahead in left-to-right parsing. The following events
are defined:

\begin{itemize}
\item
  \emph{EOL} occurs at the end of a line of the source. It is provided
  by \texttt{Config\_SourceChar}, see nnn;
\item
  \emph{EOS} occurs at the end of the source program. It is provided by
  \texttt{Config\_SourceChar};
\item
  \emph{RADIX} occurs when the character about to be scanned is
  \texttt{\textquotesingle{}X\textquotesingle{}} or
  \texttt{\textquotesingle{}x\textquotesingle{}} or
  \texttt{\textquotesingle{}B\textquotesingle{}} or
  \texttt{\textquotesingle{}b\textquotesingle{}} not followed by a
  \emph{general\_letter}, or a \emph{digit}, or
  \texttt{\textquotesingle{}.\textquotesingle{}};
\item
  \emph{CONTINUE} occurs when the character about to be scanned is
  \texttt{\textquotesingle{},\textquotesingle{}}, and the characters
  after the \texttt{\textquotesingle{},\textquotesingle{}} up to
  \emph{EOL} represent a repetition of \emph{comment} or \emph{blank},
  and the \emph{EOL} is not immediately followed by an \emph{EOS};
\item
  \emph{EXPONENT\_SIGN} occurs when the character about to be scanned is
  \texttt{\textquotesingle{}+\textquotesingle{}} or
  \texttt{\textquotesingle{}-\textquotesingle{}}, and the characters to
  the left of the sign, currently parsed as part of
  \emph{Const\_symbol}, represent a \emph{plain\_number} followed by
  \texttt{\textquotesingle{}E\textquotesingle{}} or
  \texttt{\textquotesingle{}e\textquotesingle{}}, and the characters to
  the right of the sign represent a repetition of \emph{digit} not
  followed by a \emph{general\_letter} or
  \texttt{\textquotesingle{}.\textquotesingle{}}.
\end{itemize}

\emph{- I would put \emph{ASSIGN} here for the leftmost
\texttt{\textquotesingle{}=\textquotesingle{}} in a clause that is not
within parentheses or brackets. But Simon not happy with message term
being an assignment?}

\subsubsection{Actions and tokens}\label{actions-and-tokens}

Mixed case identifiers with an initial capital letter cause an action
when they appear as operands ina production. These actions perform
further tests and create tokens for use by the top syntax level. The
following actions are defined:

\begin{itemize}
\item
  Special supplies the source recognized as special to the top syntax
  level;
\item
  Eol supplies a semicolon to the top syntax level;
\item
  Eos supplies an end of source indication to the top syntax level;
\item
  Var\_symbol supplies the source recognized as Var\_symbol to the top
  syntax level, as keywords or VAR\_SYMBOL tokens, see nnn. The
  characters in a Var\_symbol are converted by Config\_Upper to
  uppercase. Msg30.1 shall be produced if Var\_symbo/ contains more than
  \#Limit\_Name characters, see nnn;
\item
  Const\_symbol supplies the source recognized as Const\_symbo! to the
  top syntax level. If itis a number it is passed as a NUMBER token,
  otherwise it is passed as a CONST\_SYMBOL token. The characters in a
  Const\_symbol are converted by Config\_Upper to become the characters
  that comprise that NUMBER or CONST\_SYMBOL. Msg30.1 shall be produced
  if Const\_symbo! contains more than \#Limit\_Name characters;
\item
  Embedded\_quotation\_mark records an occurrence of two consecutive
  quotation marks within a string delimited by quotation marks for
  further processing by the String action;
\item
  Embedded\_apostrophe records an occurrence of two consecutive
  apostrophes within a string delimited by apostrophes for further
  processing by the String action;
\item
  String supplies the source recognized as String to the top syntax
  level as a STRING token. Any occurrence of Embedded\_quotation\_mark
  or Embedded\_apostrophe is replaced by a single quotation mark or
  apostrophe, respectively. Msg30.2 shall be produced if the resulting
  string contains more than \#Limit\_Literal characters;
\item
  Binary\_string supplies the converted binary string to the top syntax
  level as a STRING token, after checking conformance to the
  binary\_string syntax. If the binary\_string does not contain any
  occurrence of a binary\_digit, a string of length 0 is passed to the
  top syntax level. The occurrences of binary\_digit are concatenated to
  form a number in radix 2. Zero or 4 digits are added at the left if
  necessary to make the number of digits a multiple of 8. If the
  resulting number of digits exceeds 8 times \#Limit\_Literal then
  Msg30.2 shall be produced. The binary digits are converted to an
  encoding, see nnn. The encoding is supplied to the top syntax level as
  a STRING token;
\item
  Hex\_string supplies the converted hexadecimal string to the top
  syntax level as a STRING token, after checking conformance to the
  hex\_string syntax. If the hex\_string does not contain any occurrence
  of a hex\_digit, a string of length 0 is passed to the top syntax
  level. The occurrences of hex\_digit are each converted to a number
  with four binary digits and concatenated. 0 to 7 digits are added at
  the left if necessary to make the number of digits a multiple of 8. If
  the resulting number of digits exceeds 8 times \#Limit\_Literal then
  Msg30.2 shall be produced. The binary digits are converted to an
  encoding. The encoding is supplied to the top syntax level as a STRING
  token;
\item
  Operator supplies the source recognized as Operator (excluding
  characters that are not operator\_char ) to the top syntax level. Any
  occurrence of an ofher\_negator within Operator is supplied as
  '\textquotesingle;
\item
  Blank records the presence of a blank. This may subsequently be tested
  (see nnn). Constructions of type Number, Const\_symbol, Var\_symbol or
  String are called operands. 6.2.1.3 Source characters The source is
  obtained from the configuration by the use of Config\_SourceChar (see
  nnn). If no character is available because the source is not a correct
  encoding of characters, message Msg22.1 shall be produced. The terms
  extra\_letter, other\_blank\_character, other\_negator, and
  other\_character used in the productions of the lexical level refer to
  characters of the groups extra\_letters (see nnn),
\end{itemize}

other\_blank\_characters (see nnn), other\_negators (see nnn) and
other\_characters (see nnn), respectively.

\subsubsection{Rules}\label{rules}

In scanning, recognition that causes an action (see nnn) only occurs if
no other recognition is possible, except that Embedded\_apostrophe and
Embedded\_quotation\_mark actions occur wherever possible.

\subsection{Lexical level}\label{lexical-level}

\subsection{Interaction between levels of
syntax}\label{interaction-between-levels-of-syntax}

When the lexical process recognizes tokens to be supplied to the top
level, there can be changes made or tokens added. Recognition is
performed by the lexical process and the top level process ina
synchronized way. The tokens produced by the lexical level can be
affected by what the top level syntax has recognized. Those tokens will
affect subsequent recognition by the top level. Both processes operate
on the characters and the tokens in the order they are produced. The
term ``context'' refers to the progress of the recognition at some
point, without consideration of unprocessed characters and tokens. If a
token which is `+', `-', \textquotesingle{} or `(' appears in a lexical
level context (other than after the keyword `PARSE') where the keyword
`VALUE' could appear in the corresponding top level context, then
`VALUE' is passed to the top level before the token is passed. If an `='
operator\_char appears in a lexical level context where it could be the
`=' of an assignment or message\_instruction in the corresponding top
level context then it is recognized as the `=``' of that instruction.
(It will be outside of brackets and parentheses, and any Var\_symbo/
immediately preceding it is passed as a VAR\_SYMBOL). If an operand is
followed by a colon token in the lexical level context then the operand
only is passed to the top level syntax as a LABEL, provided the context
permits a LABEL. Except where the rules above determine the token
passed, a Var\_symbol is passed as a terminal (a keyword) rather than as
a VAR\_SYMBOL under the following circumstances:

\begin{itemize}
\item
  if the symbol is spelled `WHILE' or `UNTIL' it is a keyword wherever a
  VAR\_SYMBOL would be part of an expression within a do\_specification,
\item
  if the symbol is spelled `TO' , `BY', or `FOR' it is a keyword
  wherever a VAR\_SYMBOL would be part of an expression within a
  do\_rep;
\item
  if the symbol is spelled `WITH' it is a keyword wherever a VAR\_SYMBOL
  would be part of a parsevalue, or part of an expression or
  taken\_constant within address;
\item
  if the symbol is spelled `THEN' it is keyword wherever a VAR\_SYMBOL
  would be part of an expression immediately following the keyword `IF'
  or `WHEN'. Except where the rules above determine the token passed, a
  Var\_symbol is passed as a keyword if the spelling of it matches a
  keyword which the top level syntax recognizes in its current context,
  otherwise the Var\_symbol is passed as a VAR\_SYMBOL token. In a
  context where the top level syntax could accept a `\textbar\textbar{}'
  token as the next token, a'\textbar\textbar' operator ora'\,' operator
  may be inferred and passed to the top level provided that the next
  token from the lexical level is a left parenthesis or an operand that
  is not a keyword. If the blank action has recorded the presence of one
  or more blanks to the left of the next token then the '\,' operator is
  inferred. Otherwise, a'\textbar\textbar' operator is inferred, except
  if the next token is a left parenthesis following an operand (see
  nnn); in this case no operator is inferred. When any of the keywords
  `OTHERWISE', `THEN', or `ELSE' is recognized, a semicolon token is
  supplied as the following token. A semicolon token is supplied as the
  previous token when the `THEN' keyword is recognized. A semicolon
  token is supplied as the token following a LABEL.
\end{itemize}

\subsubsection{Reserved symbols}\label{reserved-symbols}

A Const\_symbol which starts with a period and is not a Number shall be
spelled .MN, .RESULT, .RC, .RS, or .SIGL otherwise Msg50.1 is issued.

\subsubsection{Function name syntax}\label{function-name-syntax}

A symbol which is the leftmost component of a function shall not end
with a period, otherwise Msg51.1 is issued.

\section{Syntax}\label{syntax}

\subsection{Syntax elements}\label{syntax-elements}

The tokens generated by the actions described in nnn form the basis for
recognizing larger constructs.

\subsection{Syntax level}\label{syntax-level}

\lstinputlisting[language=rexx,label=syntaxlevel.ebnf,caption=syntaxlevel.ebnf]{syntaxlevel.ebnf}

\section{Syntactic information}\label{syntactic-information}

\subsection{VAR\_SYMBOL matching}\label{var_symbol-matching}

Any \texttt{VAR\_SYMBOL} in a \emph{do\_ending} must be matched by the
same \texttt{VAR\_SYMBOL} occurring at the start of an \emph{assignment}
contained in the \emph{do\_specification} of the \emph{do} that contains
both the \emph{do\_specification} and the \emph{do\_ending}, as
described in nnn.

If there is a \emph{VAR\_SYMBOL} in a \emph{do\_ending} for which there
is no \emph{assignment} in the corresponding \emph{do\_specification}
then message Msg10.3 is produced and no further activity is defined.

If there is a :VAR\_SYMBOL\_ in a \emph{do\_ending} which does not match
the one occurring in the \emph{assignment} then message Msg10.2 is
produced and no further activity is defined.

An \emph{iterate} or \emph{leave} must be contained in the
\emph{instruction\_list} of some \emph{do} with a
\emph{do\_specification} which is \emph{do\_repetitive}, otherwise a
message (Msg28.2 or Msg28.1 respectively) is produced and no further
activity is defined.

If an \emph{iterate} or \emph{leave} contains a \emph{VAR\_SYMBOL} there
must be a matching \emph{VAR\_SYMBOL} in a \emph{do\_specification},
otherwise a message (Msg28.1, Msg28.2, Msg28.3 or Msg28.4 appropriately)
is produced and no further activity is defined. The matching
\texttt{VAR\_SYMBOL} will occur at the start of an \emph{assignment} in
the \emph{do\_specification}. Tne \emph{do\_specification} will be
associated with a \emph{do} by nnn. The \emph{iterate} or \emph{leave}
will be a single \emph{instruction} in an \emph{instruction\_list}
associated with a \emph{do} by nnn. These two dos shall be the same, or
the latter nested one or more levels within the former. The number of
levels is called the \emph{nesting\_correction} and influences the
semantics of the \emph{iterate} or \emph{leave}. It is zero if the two
dos are the same. The \emph{nesting\_correction} for \emph{iterates} or
\emph{leaves} that do not contain \emph{VAR\_SYMBOL} is zero.

\subsection{Trace-only labels}\label{trace-only-labels}

Instances of \emph{LABEL} which occur within a
\emph{grouping\_instruction} and are not in a \emph{ncl} at the end of
that \emph{grouping\_instruction} are instances of trace-only labels.

\subsection{Clauses and line numbers}\label{clauses-and-line-numbers}

The activity of tracing execution is defined in terms of clauses. A
program consists of clauses, each clause ended by a semicolon special
token. The semicolon may be explicit in the program or inferred. The
line number of a clause is one more than the number of \emph{EOL} events
recognized before the first token of the clause was recognized.

\subsection{Nested IF instructions}\label{nested-if-instructions}

The syntax specification nnn allows
\texttt{\textquotesingle{}IF\textquotesingle{}} instructions to be
nested and does not fully specify the association of an
\texttt{\textquotesingle{}ELSE\textquotesingle{}} keyword with an
\texttt{\textquotesingle{}IF\textquotesingle{}} keyword. An
\texttt{\textquotesingle{}ELSE\textquotesingle{}} associates with the
closest prior \texttt{\textquotesingle{}IF\textquotesingle{}} that it
can associate with in conformance with the syntax.

\subsection{Choice of messages}\label{choice-of-messages}

The specifications nnn and nnn permit two alternative messages in some
circumstances. The following rules apply:

\begin{itemize}
\item
  \emph{Msg15.1} shall be preferred to \emph{Msg15.3} if the choice of
  \emph{Msg15.3} would result in the replacement for the insertion being
  a blank character;
\item
  \emph{Msg15.2} shall be preferred to \emph{Msg15.4} if the choice of
  \emph{Msg15.4} would result in the replacement for the insertion being
  a blank character;
\item
  \emph{Msg31.3} shall be preferred to \emph{Msg31.2} if the replacement
  for the insertion in the message starts with a period;
\item
  Preference is given to the message that appears later in the list:
  \emph{Msg21.1}, \emph{Msg27.1}, \emph{Msg25.16}, \emph{Msg36},
  \emph{Msg38.3}, \emph{Msg35.1}, other messages.
\end{itemize}

\subsection{Creation of messages}\label{creation-of-messages}

The \emph{message\_identifiers} in clause 6 correlate with the tails of
stem \#ErrorText., which is initialized in nnn to identify particular
messages. The action of producing an error message will replace any
insertions in the message text and present the resulting text, together
with information on the origin of the error, to the configuration by
writing on the default error stream.

Further activity by the language processor is permitted, but not defined
by this standard.

The effect of an error during the writing of an error message is not
defined.

\subsubsection{Error message prefix}\label{error-message-prefix}

The error message selected by the message number is preceded by a
prefix. The text of the prefix is \emph{\#ErrorText.0.1} except when the
error is in source that execution of an interactive trace
\emph{interpret} instruction (see nnn) is processing, in which case the
text is \emph{\#ErrorText.0.2}. The insert called
\texttt{\textless{}value\textgreater{}} in these texts is the message
number. The insert called \texttt{\textless{}linenumber\textgreater{}}
is the line number of the error. The line number of the error is one
more than the number of \emph{EOL} events encountered before the error
was detectable, except for messages \emph{Msg6.1}, \emph{Msg14},
\emph{Msg14.1}, \emph{Msg14.2}, \emph{Msg14.3}, and \emph{Msg14.4}. For
\emph{Msg6.1} it is one more than the number of \emph{EOL} events
encountered before the line containing the unmatched
\texttt{\textquotesingle{}/*\textquotesingle{}}. For the others, it is
the line number of the clause containing the keyword referenced in the
message text.

The insert called \texttt{\textless{}source\textgreater{}} is the value
provided on the \texttt{API\_Start} function which started processing of
the program, see nnn.

\section{Replacement of insertions}\label{replacement-of-insertions}

Within the text of error messages, an insertion consists of the
characters \texttt{\textquotesingle{}\textless{}\textquotesingle{}},
\texttt{\textquotesingle{}\textgreater{}\textquotesingle{}}, and what is
between those characters. There will be a word in the insertion that
specifies the replacement text, with the following meaning:

\begin{itemize}
\item
  if the word is
  \texttt{\textquotesingle{}hex-encoding\textquotesingle{}} and the
  message is not \emph{Msg23.1} then the replacement text is the value
  of the leftmost character which caused the source to be syntactically
  incorrect. The value is in hexadecimal notation;
\item
  if the word is \texttt{\textquotesingle{}token\textquotesingle{}} then
  the replacement text is the part of the source program which was
  recognized as the detection token, or in the case of \emph{Msg31.1}
  and \emph{Msg31.2}, the token before the detection token.
\end{itemize}

The detection token is the leftmost token for which the program up to
and including the token could not be parsed as the left part of a
program without causing a message. If the detection token is a semicolon
that was not present in the source but was supplied during recognition
then the replacement is the previous token;

\begin{itemize}
\item
  if the word is \texttt{\textquotesingle{}position\textquotesingle{}}
  then the replacement text is a number identifying the detection
  character. The detection character is the leftmost character in the
  \emph{hex\_string} or \emph{binary\_string} which did not match the
  required syntax. The number is a count of the characters in the string
  which preceded the detection character, including the initial quote or
  apostrophe. In deciding the leftmost blank in a quoted string of radix
  \texttt{\textquotesingle{}X\textquotesingle{}} or
  \texttt{\textquotesingle{}B\textquotesingle{}} that is erroneous note
  that:

  \begin{itemize}
  \item
    A blank as the first character of the quoted string is an error.
  \item
    The leftmost embedded sequence of blanks can validly follow any
    number of non-blank characters.
  \item
    Otherwise a blank run that follows an odd numbered sequence of
    non-blanks (or a number not a multiple of four in the case of radix
    \texttt{\textquotesingle{}B\textquotesingle{}}) is not valid.
  \item
    If the string is invalid for a reason not described above, the
    leftmost blank of the rightmost sequence of blanks is the invalid
    blank to be referenced in the message;
  \end{itemize}
\item
  if the word is \texttt{\textquotesingle{}char\textquotesingle{}} then
  the replacement text is the detection character;
\item
  if the word is \texttt{\textquotesingle{}linenumber\textquotesingle{}}
  then the replacement text is the line number of a clause associated
  with the error. The wording of the message text specifies which clause
  that is;
\item
  if the word is \texttt{\textquotesingle{}keywords\textquotesingle{}}
  then the replacement text is a list of the keywords that the syntax
  would allow at the context where the error occurred. If there are two
  keywords they shall be separated by the four characters
  \texttt{\textquotesingle{}\ or\ \textquotesingle{}}. If more, the last
  shall be preceded by the three characters
  \texttt{\textquotesingle{}or\textquotesingle{}} and the others shall
  be followed by the two characters
  \texttt{\textquotesingle{},\textquotesingle{}}. The keywords will be
  uppercased and in alphabetical order.
\end{itemize}

Replacement text is truncated to \texttt{\#Limit\_Messagelnsert}
characters if it would otherwise be longer than that, except for a
keywords replacement. When an insert is both truncated and appears
within quotes in the message, the three characters
\texttt{\textquotesingle{}...\textquotesingle{}} are inserted in the
message after the trailing quote.

\section{Syntactic equivalence}\label{syntactic-equivalence}

If a message\_term contains a
\texttt{\textquotesingle{}{[}\textquotesingle{}} it is regarded as an
equivalent message\_term without a
\texttt{\textquotesingle{}{[}\textquotesingle{}}, for execution. The
equivalent is
\texttt{term\textasciitilde{}\textquotesingle{}{[}{]}\textquotesingle{}(expression\_list)}.
See nnn. If a \emph{message\_instruction} has the construction
\texttt{message\_term\ \textquotesingle{}=\textquotesingle{}\ expression}
it is regarded as equivalent to a \emph{message\_term} with the same
components as the \emph{message\_term} left of the
\texttt{\textquotesingle{}=\textquotesingle{}}, except that the
\emph{taken\_constant} has an
\texttt{\textquotesingle{}=\textquotesingle{}} character appended and
\emph{arguments} has the expression from the right of the
\texttt{\textquotesingle{}=\textquotesingle{}} as an extra first
argument. See nnn.
