%preprocessed texin
\hypertarget{syntax-constructs}{%
\chapter{Syntax constructs}\label{syntax-constructs}}

\hypertarget{notation}{%
\section{Notation}\label{notation}}

\hypertarget{backus-naur-form-bnf}{%
\subsection{Backus-Naur Form (BNF)}\label{backus-naur-form-bnf}}

The syntax constructs in this standard are defined in Backus-Naur Form
(BNF). The syntax used in these BNF productions has

\begin{itemize}
\item
  a left-hand side (called identifier);
\item
  the characters ':=``;
\item
  a right-hand side (called bnf\_expression). The left-hand side
  identifies syntactic constructs. The right-hand side describes valid
  ways of writing a specific syntactic construct. The right-hand side
  consists of operands and operators, and may be grouped.
\end{itemize}

\hypertarget{operands}{%
\subsection{Operands}\label{operands}}

Operands may be terminals or non-terminals. If an operand appears as
identifier in some other production it is called a non-terminal,
otherwise it is called a terminal. Terminals are either literal or
symbolic. Literal terminals are enclosed in quotes and represent
literally (apart from case) what must be present in the source being
described. Symbolic terminals formed with lower case characters
represent something which the configuration may, or may not, allow in
the source program, see nnn, nnn, nnn, nnn. Symbolic terminals formed
with uppercase characters represent events and tokens, see nnn and nnn.
\#\#\# Operators The following lists the valid operators, their meaning,
and their precedence; the operator listed first has the highest
precedence; apart from precedence recognition is from left to right:

\begin{itemize}
\item
  the postfix plus operator specifies one or more repetitions of the
  preceding construct;
\item
  abuttal specifies that the preceding and the following construct must
  appear in the given order;
\item
  the operator `\textbar{}' specifies alternatives between the preceding
  and the following constructs.
\end{itemize}

\hypertarget{grouping}{%
\subsection{Grouping}\label{grouping}}

Parentheses and square brackets are used to group constructs.
Parentheses are used for the purpose of grouping only. Square brackets
specify that the enclosed construct is optional.

\hypertarget{bnf-syntax-definition}{%
\subsection{BNF syntax definition}\label{bnf-syntax-definition}}

The BNF syntax, described in BNF, is:

production := identifier `:=' bnf expression

bnf expression t= abuttal \textbar{} bnf expression `\textbar{}' abuttal

abuttal t= {[}abuttal{]} bnf primary

bnf primary := `{[}T' bnf expression '{]}' \textbar{} `(' bnf expression
`)' \textbar{} literal \textbar{}

identifier \textbar{} message identifier \textbar{} bnf primary `+'

\hypertarget{syntactic-errors}{%
\subsection{Syntactic errors}\label{syntactic-errors}}

The syntax descriptions (see nnn and nnn) make use of
message\_identifiers which are shown as Msgnn.nn or Msgnn, where nn is a
number. These actions produce the correspondingly numbered error
messages (see nnn and nnn).

\hypertarget{lexical}{%
\section{Lexical}\label{lexical}}

The lexical level processes the source and provides tokens for further
recognition by the top syntax level.

\hypertarget{lexical-elements}{%
\subsection{Lexical elements}\label{lexical-elements}}

\hypertarget{events}{%
\subsubsection{Events}\label{events}}

The fully-capitalized identifiers in the BNF syntax (see nnn) represent
events. An event is either supplied by the configuration or occurs as
result of a look-ahead in left-to-right parsing. The following events
are defined:

\begin{itemize}
\item
  EOL occurs at the end of a line of the source. It is provided by
  Config\_SourceChar, see nnn;
\item
  EOS occurs at the end of the source program. It is provided by
  Config\_SourceChar;
\item
  RADIX occurs when the character about to be scanned is `X' or `x' or
  `B' or `b' not followed by a general\_letter, or a digit, or'.';
\item
  CONTINUE occurs when the character about to be scanned is `,', and the
  characters after the `,' up to EOL represent a repetition of comment
  or blank, and the EOL is not immediately followed by an EOS;
\item
  EXPONENT\_SIGN occurs when the character about to be scanned is `+' or
  `-', and the characters to the left of the sign, currently parsed as
  part of Const\_symbol, represent a plain\_number followed by `E' or
  `e', and the characters to the right of the sign represent a
  repetition of digit not followed by a general\_letter or'.'.
\item
  would put ASSIGN here for the leftmost `=' in a clause that is not
  within parentheses or brackets. But Simon not

  happy with message term being an assignment? \#\#\#\# Actions and
  tokens Mixed case identifiers with an initial capital letter cause an
  action when they appear as operands ina production. These actions
  perform further tests and create tokens for use by the top syntax
  level. The following actions are defined:
\item
  Special supplies the source recognized as special to the top syntax
  level;
\item
  Eol supplies a semicolon to the top syntax level;
\item
  Eos supplies an end of source indication to the top syntax level;
\item
  Var\_symbol supplies the source recognized as Var\_symbol to the top
  syntax level, as keywords or VAR\_SYMBOL tokens, see nnn. The
  characters in a Var\_symbol are converted by Config\_Upper to
  uppercase. Msg30.1 shall be produced if Var\_symbo/ contains more than
  \#Limit\_Name characters, see nnn;
\item
  Const\_symbol supplies the source recognized as Const\_symbo! to the
  top syntax level. If itis a number it is passed as a NUMBER token,
  otherwise it is passed as a CONST\_SYMBOL token. The characters in a
  Const\_symbol are converted by Config\_Upper to become the characters
  that comprise that NUMBER or CONST\_SYMBOL. Msg30.1 shall be produced
  if Const\_symbo! contains more than \#Limit\_Name characters;
\item
  Embedded\_quotation\_mark records an occurrence of two consecutive
  quotation marks within a string delimited by quotation marks for
  further processing by the String action;
\item
  Embedded\_apostrophe records an occurrence of two consecutive
  apostrophes within a string delimited by apostrophes for further
  processing by the String action;
\item
  String supplies the source recognized as String to the top syntax
  level as a STRING token. Any occurrence of Embedded\_quotation\_mark
  or Embedded\_apostrophe is replaced by a single quotation mark or
  apostrophe, respectively. Msg30.2 shall be produced if the resulting
  string contains more than \#Limit\_Literal characters;
\item
  Binary\_string supplies the converted binary string to the top syntax
  level as a STRING token, after checking conformance to the
  binary\_string syntax. If the binary\_string does not contain any
  occurrence of a binary\_digit, a string of length 0 is passed to the
  top syntax level. The occurrences of binary\_digit are concatenated to
  form a number in radix 2. Zero or 4 digits are added at the left if
  necessary to make the number of digits a multiple of 8. If the
  resulting number of digits exceeds 8 times \#Limit\_Literal then
  Msg30.2 shall be produced. The binary digits are converted to an
  encoding, see nnn. The encoding is supplied to the top syntax level as
  a STRING token;
\item
  Hex\_string supplies the converted hexadecimal string to the top
  syntax level as a STRING token, after checking conformance to the
  hex\_string syntax. If the hex\_string does not contain any occurrence
  of a hex\_digit, a string of length 0 is passed to the top syntax
  level. The occurrences of hex\_digit are each converted to a number
  with four binary digits and concatenated. 0 to 7 digits are added at
  the left if necessary to make the number of digits a multiple of 8. If
  the resulting number of digits exceeds 8 times \#Limit\_Literal then
  Msg30.2 shall be produced. The binary digits are converted to an
  encoding. The encoding is supplied to the top syntax level as a STRING
  token;
\item
  Operator supplies the source recognized as Operator (excluding
  characters that are not operator\_char ) to the top syntax level. Any
  occurrence of an ofher\_negator within Operator is supplied as
  '\textquotesingle;
\item
  Blank records the presence of a blank. This may subsequently be tested
  (see nnn). Constructions of type Number, Const\_symbol, Var\_symbol or
  String are called operands. 6.2.1.3 Source characters The source is
  obtained from the configuration by the use of Config\_SourceChar (see
  nnn). If no character is available because the source is not a correct
  encoding of characters, message Msg22.1 shall be produced. The terms
  extra\_letter, other\_blank\_character, other\_negator, and
  other\_character used in the productions of the lexical level refer to
  characters of the groups extra\_letters (see nnn),
\end{itemize}

other\_blank\_characters (see nnn), other\_negators (see nnn) and
other\_characters (see nnn), respectively.

\hypertarget{rules}{%
\subsubsection{Rules}\label{rules}}

In scanning, recognition that causes an action (see nnn) only occurs if
no other recognition is possible, except that Embedded\_apostrophe and
Embedded\_quotation\_mark actions occur wherever possible.

\hypertarget{lexical-level}{%
\subsection{Lexical level}\label{lexical-level}}

\hypertarget{interaction-between-levels-of-syntax}{%
\subsection{Interaction between levels of
syntax}\label{interaction-between-levels-of-syntax}}

When the lexical process recognizes tokens to be supplied to the top
level, there can be changes made or tokens added. Recognition is
performed by the lexical process and the top level process ina
synchronized way. The tokens produced by the lexical level can be
affected by what the top level syntax has recognized. Those tokens will
affect subsequent recognition by the top level. Both processes operate
on the characters and the tokens in the order they are produced. The
term ``context'' refers to the progress of the recognition at some
point, without consideration of unprocessed characters and tokens. If a
token which is `+', `-', \textquotesingle{} or `(' appears in a lexical
level context (other than after the keyword `PARSE') where the keyword
`VALUE' could appear in the corresponding top level context, then
`VALUE' is passed to the top level before the token is passed. If an `='
operator\_char appears in a lexical level context where it could be the
`=' of an assignment or message\_instruction in the corresponding top
level context then it is recognized as the `=``' of that instruction.
(It will be outside of brackets and parentheses, and any Var\_symbo/
immediately preceding it is passed as a VAR\_SYMBOL). If an operand is
followed by a colon token in the lexical level context then the operand
only is passed to the top level syntax as a LABEL, provided the context
permits a LABEL. Except where the rules above determine the token
passed, a Var\_symbol is passed as a terminal (a keyword) rather than as
a VAR\_SYMBOL under the following circumstances:

\begin{itemize}
\item
  if the symbol is spelled `WHILE' or `UNTIL' it is a keyword wherever a
  VAR\_SYMBOL would be part of an expression within a do\_specification,
\item
  if the symbol is spelled `TO' , `BY', or `FOR' it is a keyword
  wherever a VAR\_SYMBOL would be part of an expression within a
  do\_rep;
\item
  if the symbol is spelled `WITH' it is a keyword wherever a VAR\_SYMBOL
  would be part of a parsevalue, or part of an expression or
  taken\_constant within address;
\item
  if the symbol is spelled `THEN' it is keyword wherever a VAR\_SYMBOL
  would be part of an expression immediately following the keyword `IF'
  or `WHEN'. Except where the rules above determine the token passed, a
  Var\_symbol is passed as a keyword if the spelling of it matches a
  keyword which the top level syntax recognizes in its current context,
  otherwise the Var\_symbol is passed as a VAR\_SYMBOL token. In a
  context where the top level syntax could accept a `\textbar\textbar{}'
  token as the next token, a'\textbar\textbar' operator ora'\,' operator
  may be inferred and passed to the top level provided that the next
  token from the lexical level is a left parenthesis or an operand that
  is not a keyword. If the blank action has recorded the presence of one
  or more blanks to the left of the next token then the '\,' operator is
  inferred. Otherwise, a'\textbar\textbar' operator is inferred, except
  if the next token is a left parenthesis following an operand (see
  nnn); in this case no operator is inferred. When any of the keywords
  `OTHERWISE', `THEN', or `ELSE' is recognized, a semicolon token is
  supplied as the following token. A semicolon token is supplied as the
  previous token when the `THEN' keyword is recognized. A semicolon
  token is supplied as the token following a LABEL.
\end{itemize}

\hypertarget{reserved-symbols}{%
\subsubsection{Reserved symbols}\label{reserved-symbols}}

A Const\_symbol which starts with a period and is not a Number shall be
spelled .MN, .RESULT, .RC, .RS, or .SIGL otherwise Msg50.1 is issued.

\hypertarget{function-name-syntax}{%
\subsubsection{Function name syntax}\label{function-name-syntax}}

A symbol which is the leftmost component of a function shall not end
with a period, otherwise Msg51.1 is issued.

\hypertarget{syntax}{%
\section{Syntax}\label{syntax}}

\hypertarget{syntax-elements}{%
\subsection{Syntax elements}\label{syntax-elements}}

The tokens generated by the actions described in nnn form the basis for
recognizing larger constructs.

\hypertarget{syntax-level}{%
\subsection{Syntax level}\label{syntax-level}}

starter:=x3j18

x3j18:=program Eos \textbar{} Msg35.1

program := {[}label list{]} {[}ncl{]} {[}requires+{]}
{[}prolog\_instruction+{]} (class definition {[}requires+{]})+ requires
:= `REQUIRES' ( taken constant \textbar{} Mgg19.8 ) ```;'+ prolog
instruction:= (package \textbar{} import \textbar{} options) nel package
= `PACKAGE'( NAME \textbar{} Msgnn ) import = `IMPORT' ( NAME \textbar{}
Msgnn ) {[}`.'{]} options := `OPTIONS' ( symbol+ \textbar{} Msgnn ) nel
:= null \_clause+ \textbar{} Msg21.1 null clause = `;' {[}label list{]}
label list = (LABEL `;')+ class definition = class {[}property info{]}
{[}method definition+{]} class = `CLASS' ( taken constant \textbar{}
Msg19.12 ) {[}class\_option+{]}

{[}`INHERIT' ( taken constant \textbar{} Msg19.13 )+{]} nel visibility
\textbar{} modifier \textbar{} `BINARY' \textbar{} `DEPRECATED'
`EXTENDS' ( NAME \textbar{} Msgnn ) `USES' ( NAMElist \textbar{} Msgnn )
\textbar{} `IMPLEMENTS' ( NAMElist \textbar{} Msgnn )

class option

numeric digits:= `DIGITS' {[}expression{]}

external \textbar{} metaclass \textbar{} submix /* \textbar{} 'PUBLIC!
*/

external = `EXTERNAL' (STRING \textbar{} Msg19.14) metaclass =
`METACLASS' ( taken constant \textbar{} Msg19.15 ) submix = `MIXINCLASS'
( taken constant \textbar{} Msg19.16 ) \textbar{} `SUBCLASS' ( taken
constant \textbar{} Msg19.17 ) visibility = `PUBLIC' \textbar{}
`PRIVATE' modifier = `ABSTRACT' \textbar{} `FINAL' \textbar{}
`INTERFACE' \textbar{} `ADAPTER'! NAMElist = NAME {[}(`,' ( NAME
\textbar{} Msgnn ) )+{]} property \_info = numeric \textbar{} property
assignment \textbar{} properties \textbar{} trace numeric = `NUMERIC'
(numeric digits \textbar{} numeric form \textbar{} Msg25.15) numeric
form = `FORM' {[}`ENGINEERING' \textbar{} `SCIENTIFIC'{]} property
agsignment := NAME \textbar{} assignment properties := `PROPERTIES' (
properties option+ \textbar{} Msgnn) properties option := properties
vigibility \textbar{} properties modifier properties visibility :=
`INHERITABLE' \textbar{} `PRIVATE' \textbar{} `PUBLIC' \textbar{}
`INDIRECT' properties modifier := `CONSTANT' \textbar{} `STATIC'
\textbar{} `VOLATILE' \textbar{} `TRANSIENT' trace := `TRACE' {[}`ALL'
\textbar{} `METHODS' \textbar{} `OFF' \textbar{} `RESULTS'{]} method
definition = (method {[}expose ncl{]}\textbar{} routine) balanced expose
= `EXPOSE' variable list method = `METHOD' (taken constant \textbar{}
Msg19.9) {[} `(' assigncommalist \textbar{} Msgnn ( `)' \textbar{} Msgnn
){]} {[}method option+{]} nel assigncommalist assignment {[}(`,' (
assignment \textbar{} Msgnn ) )+{]}

method visibility \textbar{} method modifier \textbar{} `PROTECT'
\textbar{} `RETURNS' ( term \textbar{} Msgnn ) \textbar{} `SIGNAL' (
termcommalist \textbar{} Msgnn )

method option

`DEPRECATED'! `CLASS' \textbar{} `ATTRIBUTE' \textbar{} /\emph{`PRIVATE'
\textbar{} }/ guarded guarded := `GUARDED' \textbar{} `UNGUARDED! method
visibility := 'INHERITABLE' \textbar{} `PRIVATE' \textbar{} `PUBLIC'
\textbar{} `SHARED!' method modifier := `ABSTRACT' \textbar{} `CONSTANT'
\textbar{} `FINAL' \textbar{} `NATIVE' \textbar{} `STATIC' termcommalist
:= term {[}(`,' ( term \textbar{} Msgnn ) )+{]} routine := `ROUTINE' (
taken constant \textbar{} Msg19.11 ) {[}`PUBLIC'{]} nel balanced:=
instruction list {[}`END' Msgl0.1{]} instruction list:= instruction+

/* The second part ig about groups */

instruction = group \textbar{} gingle instruction nel group = do ncl
\textbar{} if \textbar{} loop nel \textbar{} select nel do = do
specification nel {[}instruction+{]} {[}group\_handler{]} (`END'
{[}NAME{]} \textbar{} Eos Msg14.1 \textbar{} Msg35.1) group option :=
`LABEL' ( NAME \textbar{} Msgnn ) \textbar{} `PROTECT' ( term \textbar{}
Msgnn )

group handler catch \textbar{} finally catch finally

`CATCH' {[} NAME `=' {]} ( NAME \textbar{} Msgnn) nel {[}instruction+{]}

catch = /* FINALLY implies a semicolon. */ finally = `FINALLY' nel (
instruction+ \textbar{} Msgnn ) if := `IF' expression {[}ncl{]} (then
\textbar{} Msg18.1) {[}else{]} then := `THEN' nel (instruction
\textbar{} EOS Msg14.3 \textbar{} `END' Msg10.5) else := `ELSE' nel
(instruction \textbar{} EOS Msg14.4 \textbar{} `END' Msg10.6) loop :=
`LOOP' {[}group\_option+{]} {[}repetitor{]} {[}conditional{]} nel

instruction+ {[}group\_handler{]} loop ending

loop ending `END' {[}VAR SYMBOL{]} \textbar{} EOS Msg14.n \textbar{}
Msg35.1

conditional = `WHILE' whileexpr \textbar{} `UNTIL' untilexpr untilexpr =
expression whileexpr = expression repetitor = assignment {[}count
option+{]} \textbar{} expression \textbar{} over `FOREVER' count option
= loopt \textbar{} loopb \textbar{} loopf loopt = `TO' expression loopb
= `BY' expression loopf = `FOR' expression over = VAR SYMBOL `OVER'
expression

NUMBER `OVER' Msg31.1\\
CONST SYMBOL `OVER' (Msg31.2 \textbar{} Msg31.3)

select := `SELECT' {[}group option+{]} ncl select \_ body
{[}group\_handler{]} (`END' {[}NAME Msg10.4{]} \textbar{} EOS Msgl14.2
\textbar{} Msg7.2)

(when \textbar{} Msg7.1) {[}when+{]} {[}otherwise{]}

`WHEN' expresgion {[}ncl{]} (then \textbar{} Msg18.2)

`OTHERWISE' ncl {[}instruction+{]}

select body when otherwise

/* Third part is for single instructions. */ single instruction:=
assignment \textbar{} message instruction \textbar{} keyword instruction
\textbar{} command assignment := VAR SYMBOL `\#' expression NUMBER `\#'
Msg31.1 CONST SYMBOL `\#!' (Msg31.2 \textbar{} Mgg31.3)

message instruction := message term \textbar{} message term `\#'
expression keyword instruction:= address \textbar{} arg \textbar{} call
\textbar{} drop \textbar{} exit interpret \textbar{} iterate \textbar{}
leave

nop \textbar{} numeric \textbar{} options parse \textbar{} procedure
\textbar{} pull \textbar{} push \textbar{} queue

raise \textbar{} reply \textbar{} return \textbar{} say \textbar{}
signal \textbar{} trace \textbar{} use `THEN' Msg8.1 `ELSE' Msg8.2
`WHEN' Msg9.1 \textbar{} `OTHERWISE' Msg9.2 command = expression address
= `ADDRESS' {[}(taken constant {[}expression{]}

Msg19.1 \textbar{} valueexp) {[} `WITH' connection{]} {]}

taken constant symbol \textbar{} STRING

valueexp = `VALUE' expression connection = ad option+ ad option = error
\textbar{} input \textbar{} output \textbar{} Msg25.5 error = `ERROR!'
(resourceo \textbar{} Msg25.14) input = `INPUT' (resourcei \textbar{}
Msg25.6) resourcei := resources \textbar{} `NORMAL' output = `OUTPUT'
(resourceo \textbar{} Mgg25.7) resourceo := `APPEND' (resources
\textbar{} Msg25.8) \textbar{} `REPLACE' (resources \textbar{} Msg25.9)
\textbar{} resources \textbar{} `NORMAL' resources := `STREAM'
(VAR\_SYMBOL \textbar{} Msg53.1) \textbar{} `STEM' (VAR\_SYMBOL
\textbar{} Msg53.2) vref := `(' var symbol (`)' \textbar{} Msg46.1) var
symbol = VAR\_SYMBOL \textbar{} Msg20.1

arg := `ARG' {[}template list{]}

eall := `CALL' (callon\_spec \textbar{} (taken constant \textbar{} vref
\textbar{} Msg19.2) {[}expression list{]} ) callon spec := `ON'
(callable condition \textbar{} Msg25.1)

{[}`NAME' (symbol constant term \textbar{} Msg19.3){]} \textbar{} `OFF'
(callable condition \textbar{} Msg25.2)

symbol constant term := term

callable condition:= `ANY' \textbar{} `ERROR' \textbar{} `FAILURE'
\textbar{} `HALT' \textbar{} `NOTREADY' \textbar{} `USER' ( symbol
constant term \textbar{} Msg19.18 )

condition := callable condition \textbar{} `LOSTDIGITS' \textbar{}
`NOMETHOD' \textbar{} `NOSTRING' \textbar{} `NOVALUE' \textbar{}
'SYNTAX!

expression list do specification do simple

expr \textbar{} {[}expr{]} `,' {[}expression list{]} do simple
\textbar{} do repetitive `DO' {[}group\_option+{]}

do repetitive = do simple (dorep \textbar{} conditional \textbar{} dorep
conditional) dorep = `FOREVER' \textbar{} repetitor drop = `DROP'
variable list variable list = (vref \textbar{} var\_symbol)+ exit =
`EXIT' {[}expression{]} forward = `FORWARD' {[}forward \_option+
\textbar{} Msg25.18{]} forward option = `CONTINUE' \textbar{}
ArrayArgOption \textbar{} MessageOption \textbar{} ClassOption
\textbar{} ToOption ArrayArgOption:=`ARRAY' arguments \textbar{}
`ARGUMENTS' term MessageOption :=`MESSAGE' term ClassOption =`CLASS'
term ToOption =`TO' term guard = `GUARD' (`ON' \textbar{} Msg25.22)
{[}(`WHEN' \textbar{} Msg25.21) expression{]} \textbar{} ( `OFF'
\textbar{} Msg25.19) {[}(`WHEN' \textbar{} Msg25.21) expression{]}
interpret = `INTERPRET' expression iterate = `ITERATE' {[}VAR SYMBOL
\textbar{} Msg20.2{]} leave = `LEAVE' {[}VAR SYMBOL \textbar{}
Msg20.2{]} nop = `NOP!' numeric = `NUMERIC' (numeric digits \textbar{}
numeric form

numeric fuzz \textbar{} Msg25.15)

numeric digits `DIGITS' {[}expression{]} numeric form `FORM' {[}numeric
form suffix{]} numeric form suffix:=(`ENGINEERING'
\textbar{}`SCIENTIFIC'\textbar valueexp \textbar{} Msg25.11) numeric
fuzz `FUZZ' {[}expression{]}

options = `OPTIONS' expression parse = `PARSE' {[}translations{]} (parse
type \textbar Msg25.12) {[}template list{]} translations := `CASELESS'
{[}`UPPER' \textbar{} `LOWER'{]} \textbar{} (`UPPER' \textbar{} `LOWER')
{[}`CASELESS'{]} parse type = parse key \textbar{} parse value
\textbar{} parse var \textbar{} term parse key = `ARG' \textbar{} `PULL'
\textbar{} `SOURCE' \textbar{} `LINEIN' \textbar{} `VERSION! parse value
= 'VALUE' {[}expression{]} (`WITH' \textbar{} Mgg38.3) parse var = `VAR'
var symbol template := NAME {[}( {[}pattern{]} NAME) +{]} pattern:=
STRING \textbar{} {[}indicator{]} NUMBER \textbar{} {[}indicator{]} `('
symbol `)' indicator := `+' \textbar{} `-' \textbar{} `s! procedure =
'PROCEDURE' {[}expose \textbar{} Msg25.17{]} pull = `PULL' {[}template
list{]} push = `PUSH' {[}expression{]} queue = `QUEUE' {[}expression{]}
raise = `RAISE' conditions (raise option \textbar{} Msg25.24) conditions
= `ANY' \textbar{} `ERROR' term \textbar{} `FAILURE' term \textbar{}
`HALT'\textbar{} `LOSTDIGITS' \textbar{} `NOMETHOD' \textbar{}
`NOSTRING' \textbar{} ``NOTREADY' \textbar{} `NOVALUE' \textbar{}
`PROPAGATE' \textbar{} `SYNTAX' term \textbar{} `USER' ( symbol constant
term \textbar{} Msg19.18) \textbar{} Msg25.23 raise option :=
ExitRetOption \textbar{} Description \textbar{} ArrayOption

ExitRetOption := `EXIT! {[}term{]} \textbar{} 'RETURN' {[}term{]}
Description =`DESCRIPTION' term ArrayOption = `ADDITIONAL' term
\textbar{} ```ARRAY' arguments reply = `REPLY' {[} expression{]} return
= `RETURN' {[}expression{]} say = `SAY' {[}expression{]} signal =
`SIGNAL' (signal spec \textbar{} valueexp

symbol constant term \textbar{} Msg19.4)

signal spec := `ON' (condition \textbar{} Msg25.3) {[}`NAME' (symbol
constant term \textbar{} Msg19.3){]} \textbar{} `OFF' (condition
\textbar{} Msg25.4)

trace = `TRACE' {[}(taken\_constant \textbar{} Msgl19.6) \textbar{}
valueexp{]} use = `USE' (`ARG' \textbar{} Msg25.26) {[}use list{]} use
list = VAR\_SYMBOL \textbar{} {[}VAR SYMBOL{]} `,' {[}use list{]}

/* Note: The next part describes templates. */ template list template
\textbar{} {[}template{]} `,' {[}template list{]}

template = (trigger \textbar{} target \textbar{} Msg38.1)+ target =
VAR\_SYMBOL \textbar{} `.!' trigger = pattern \textbar{} positional
pattern = STRING \textbar{} vrefp vrefp = `(' (VAR\_SYMBOL \textbar{}
Msgl19.7) (`)' \textbar{} Msg46.1) positional = absolute positional
\textbar{} relative positional absolute positional:= NUMBER `=' position
pogition := NUMBER \textbar{} vrefp \textbar{} Msg38.2 relative
posgitional:= (`+' \textbar{} `-``') position

/* Note: The final part specifies the various forms of symbol, and
expression. */

symbol = VAR\_SYMBOL \textbar{} CONST SYMBOL \textbar{} NUMBER
expression = expr {[}(`,' Msg37.1) \textbar{} (`)' Msg37.2 ){]} expr =
expr alias

expr alias and expression

expr alias or operator and expression

or operator := `\textbar{}' \textbar{} `\&\&! and expression :=
comparison \textbar{} and expression'\&' comparison comparison :=
concatenation \textbar{} comparison comparison operator concatenation
comparison \_operator:= normal compare \textbar{} strict compare normal
compare:= `=! \textbar{} ``\s! \textbar{} hep! \textbar{} tact
\textbar{} tot \textbar{} tet \textbar{} toet len! W\textgreater!
\textless! strict\_compare:='==' \textbar{} `\s=' \textbar{}
`\textgreater\textgreater!' \textbar{} `\textless\textless!' \textbar{}
`\textgreater\textgreater e! \textbar{}'\textless\textless s! \textbar{}
```\e\textgreater t \textbar{}'\textless c! concatenation := addition
\textbar{} concatenation (' ' \textbar{} `\textbar\textbar{}') addition
addition := multiplication \textbar{} addition additive operator
multiplication additive operator:= `+' \textbar{} '-! multiplication t=
power expression

multiplication multiplicative operator

power expression multiplicative operator:= '*' \textbar{} `/' \textbar{}
`//' \textbar{} `\%! power expression := prefix expression \textbar{}
power expression'**' prefix expression prefix expression := (`+'
\textbar{} `-' \textbar{} '\textquotesingle) prefix expression term
\textbar{} Msg35.1 /* ``Stub'' has to be identified semantically? */

term = simple term {[} `.' ( term \textbar{} Msgnn ){]} simple term :=
symbol \textbar{} STRING \textbar{} invoke \textbar{} indexed `('
expression ( `)' \textbar{} Msg36 ) initializer \textbar{} message term
`\#\#! message term:= term ('\textasciitilde' \textbar{}
`\textasciitilde\textasciitilde{}') method name {[}arguments{]} term
`{[}'{[} expression list {]} ('{]}' \textbar{} Msg36.2)

method name:=(taken constant \textbar{} Msg19.19) {[}`:' ( VAR\_SYMBOL
\textbar{} Msg19.21 ){]} /* Method-call without arguments ig
syntactically like symbol. \emph{/ /} Editor - not sure of my notes
about here. */

invoke := (symbol \textbar{} STRING) arguments arguments := `\#('
{[}expression list{]} (`)' \textbar{} Meg36) expression list :=
expregsion \textbar{} {[}expression{]} `,' {[}expression list{]} indexed
= (symbol \textbar{} STRING) indices indices = `\#{[}' {[}expression
list{]} ('{]}' \textbar{} Msg36.n) initializer = `{[}'expression list
('{]}' \textbar{} Msg36.n)

\hypertarget{syntactic-information}{%
\section{Syntactic information}\label{syntactic-information}}

\hypertarget{var_symbol-matching}{%
\subsection{VAR\_SYMBOL matching}\label{var_symbol-matching}}

Any VAR\_SYMBOL in a do\_ending must be matched by the same VAR\_SYMBOL
occurring at the start of an assignment contained in the
do\_specification of the do that contains both the do\_specification and
the do\_ending, as described in nnn. If there is a VAR\_SYMBOL in a
do\_ending for which there is no assignment in the corresponding
do\_specification then message Msg10.3 is produced and no further
activity is defined. If there is a VAR\_SYMBOL in a do\_ending which
does not match the one occurring in the assignment then message Msg10.2
is produced and no further activity is defined. An iterate or leave must
be contained in the instruction\_list of some do with a
do\_specification which is do\_repetitive, otherwise a message (Msg28.2
or Msg28.1 respectively) is produced and no further activity is defined.
If an iterate or leave contains a VAR\_SYMBOL there must be a matching
VAR\_SYMBOL ina do\_specification, otherwise a message (Msg28.1,
Msg28.2, Msg28.3 or Msg28.4 appropriately) is produced and no further
activity is defined. The matching VAR\_SYMBOL will occur at the start of
an assignment in the do\_specification. Tne do\_specification will be
associated with a do by nnn. The /ferafe or leave will be a single
instruction in an instruction\_list associated with a do by nnn. These
two dos shall be the same, or the latter nested one or more levels
within the former. The number of levels is called the
nesting\_correction and influences the semantics of the iterafe or
leave. It is zero if the two dos are the same. The nesting\_correction
for /ferates or leaves that do not contain VAR\_SYMBOL is zero.

\hypertarget{trace-only-labels}{%
\subsection{Trace-only labels}\label{trace-only-labels}}

Instances of LABEL which occur within a grouping\_instruction and are
not in a nc/ at the end of that grouping\_instruction are instances of
trace-only labels.

\hypertarget{clauses-and-line-numbers}{%
\subsection{Clauses and line numbers}\label{clauses-and-line-numbers}}

The activity of tracing execution is defined in terms of clauses. A
program consists of clauses, each clause ended by a semicolon special
token. The semicolon may be explicit in the program or inferred. The
line number of a clause is one more than the number of EOL events
recognized before the first token of the clause was recognized.

\hypertarget{nested-if-instructions}{%
\subsection{Nested IF instructions}\label{nested-if-instructions}}

The syntax specification nnn allows `IF' instructions to be nested and
does not fully specify the association of an `ELSE' keyword with an `IF'
keyword. An `ELSE' associates with the closest prior `IF' that it can
associate with in conformance with the syntax.

\hypertarget{choice-of-messages}{%
\subsection{Choice of messages}\label{choice-of-messages}}

The specifications nnn and nnn permit two alternative messages in some
circumstances. The following rules apply:

\begin{itemize}
\item
  Msg15.1 shall be preferred to Msg15.3 if the choice of Msg15.3 would
  result in the replacement for the insertion being a blank character;
\item
  Msg15.2 shall be preferred to Msg15.4 if the choice of Msg15.4 would
  result in the replacement for the insertion being a blank character;
\item
  Msg31.3 shall be preferred to Msg31.2 if the replacement for the
  insertion in the message starts with a period;
\item
  Preference is given to the message that appears later in the list:
  Msg21.1, Msg27.1, Msg25.16, Msg36, Msg38.3, Msg35.1, other messages.
\end{itemize}

\hypertarget{creation-of-messages}{%
\subsection{Creation of messages}\label{creation-of-messages}}

The message\_identifiers in clause 6 correlate with the tails of stem
\#ErrorText., which is initialized in nnn to identify particular
messages. The action of producing an error message will replace any
insertions in the message text and present the resulting text, together
with information on the origin of the error, to the configuration by
writing on the default error stream. Further activity by the language
processor is permitted, but not defined by this standard. The effect of
an error during the writing of an error message is not defined.

\hypertarget{error-message-prefix}{%
\subsubsection{Error message prefix}\label{error-message-prefix}}

The error message selected by the message number is preceded by a
prefix. The text of the prefix is \#ErrorText.0.1 except when the error
is in source that execution of an interactive trace interpret
instruction (see nnn) is processing, in which case the text is
\#ErrorText.0.2. The insert called in these texts is the message number.
The insert called is the line number of the error. The line number of
the error is one more than the number of EOL events encountered before
the error was detectable, except for messages Msg6.1, Msg14, Msg14.1,
Msg14.2, Msg14.3, and Msg14.4. For Msg6.1 it is one more than the number
of EOL events encountered before the line containing the unmatched '/*'.
For the others, it is the line number of the clause containing the
keyword referenced in the message text. The insert called is the value
provided on the API\_ Start function which started processing of the
program, see nnn.

\hypertarget{replacement-of-insertions}{%
\section{Replacement of insertions}\label{replacement-of-insertions}}

Within the text of error messages, an insertion consists of the
characters `\textless{}', `\textgreater{}', and what is between those
characters. There will be a word in the insertion that specifies the
replacement text, with the following meaning:

\begin{itemize}
\item
  if the word is `hex-encoding' and the message is not Msg23.1 then the
  replacement text is the value of the leftmost character which caused
  the source to be syntactically incorrect. The value is in hexadecimal
  notation;
\item
  if the word is `token' then the replacement text is the part of the
  source program which was recognized as the detection token, or in the
  case of Msg31.1 and Msg31.2, the token before the detection token. The
  detection token is the leftmost token for which the program up to and
  including the token could not be parsed as the left part of a program
  without causing a message. If the detection token is a semicolon that
  was not present in the source but was supplied during recognition then
  the replacement is the previous token;
\item
  if the word is `position' then the replacement text is a number
  identifying the detection character. The detection character is the
  leftmost character in the hex\_string or binary\_string which did not
  match the required syntax. The number is a count of the characters in
  the string which preceded the detection character, including the
  initial quote or apostrophe. In deciding the leftmost blank in a
  quoted string of radix `X' or `B' that is erroneous not that: A blank
  as the first character of the quoted string is an error. The leftmost
  embedded sequence of blanks can validly follow any number of non-blank
  characters. Otherwise a blank run that follows an odd numbered
  sequence of non-blanks (or a number not a multiple of four in the case
  of radix `B') is not valid. If the string is invalid for a reason not
  described above, the leftmost blank of the rightmost sequence of
  blanks is the invalid blank to be referenced in the message;
\item
  if the word is `char' then the replacement text is the detection
  character;
\item
  if the word is `linenumber' then the replacement text is the line
  number of a clause associated with the error. The wording of the
  message text specifies which clause that is;
\item
  if the word is `keywords' then the replacement text is a list of the
  keywords that the syntax would allow at the context where the error
  occurred. If there are two keywords they shall be separated by the
  four characters ' or `. If more, the last shall be preceded by the
  three characters 'or' and the others shall be followed by the two
  characters `,'. The keywords will be uppercased and in alphabetical
  order.
\end{itemize}

Replacement text is truncated to \#Limit\_Messagelnsert characters if it
would otherwise be longer than that, except for a keywords replacement.
When an insert is both truncated and appears within quotes in the
message, the three characters `\ldots{}' are inserted in the message
after the trailing quote.

\hypertarget{syntactic-equivalence}{%
\section{Syntactic equivalence}\label{syntactic-equivalence}}

If a message\_term contains a `{[}' it is regarded as an equivalent
message\_term without a `{[}', for execution. The equivalent is
term\textasciitilde{}`{[}{]}'(expression\_list). See nnn. If a
message\_instruction has the construction message\_term `=' expression
it is regarded as equivalent to a message\_term with the same components
as the message\_term left of the `=', except that the taken\_constant
has an `=' character appended and arguments has the expression from the
right of the `=' as an extra first argument. See nnn.
