Microsoft (R) Macro Assembler Version 6.11		    01/29/12 11:35:02
bcode.asm						     Page 1 - 1


				     ; Copyright Formcroft Ltd 1997
				      .model small
				      .486
 0000				      .code
				     MyGroup GROUP _TEXT, BifSeg, FanSegB
				     ; These are the routines the Bcode interpreter calls upon, other than the ones
				     ; shared with the Pcode interpreter.
				     ; Only used in this module so using a segment is convenience rather than
				     ; necessity.
 0000				     FanSegB SEGMENT WORD PUBLIC 'CODE'
 0000				     BcodesBase$:
 0000  2240 R			      dw Zero$$
 0002  224B R			      dw One$$
 0004  2252 R			      dw Null$$
 0006  2272 R			      dw String$$
 0008  225A R			      dw String1$$
 000A  2266 R			      dw String2$$
 000C  22A4 R			      dw _RetBc$$
 000E  22A8 R			      dw _RetB$$
 0010  22BF R			      dw _RetF$$
 0012  22CD R			      dw _IterCV$$
 0014  22C2 R			      dw _Exists$$
 0016  22F1 R			      dw _Then$$
 0018  2304 R			      dw _Jump$$
 001A  0000 E			      dw _Eq$$
 001C  0000 E			      dw _Ne$$
 001E  0000 E			      dw _Lt$$
 0020  0000 E			      dw _Le$$
 0022  0000 E			      dw _Ge$$
 0024  0000 E			      dw _Gt$$
 0026  0000 E			      dw _Seq$$
 0028  0000 E			      dw _Sne$$
 002A  0000 E			      dw _Slt$$
				     ; See CRX.RX, the code from ANSI that is processed into Bcode. These are
				     ; the machine code routines that code uses but does not contain.
 002C  2397 R			      dw CONFIG_RAISE$$
 002E  0000 E			      dw CONFIG_RAISE40$$
 0030  112C R			      dw CONFIG_UPPER$$
 0032  1166 R			      dw CONFIG_MSG$$
 0034  11A8 R			      dw CONFIG_C2B$$
 0036  11F2 R			      dw CONFIG_B2C$$
 0038  1222 R			      dw CONFIG_STREAM_POSITION$$
 003A  137A R			      dw CONFIG_STREAM_CHARIN$$
 003C  1451 R			      dw CONFIG_STREAM_QUERY$$
 003E  1453 R			      dw CONFIG_STREAM_CLOSE$$
 0040  146D R			      dw CONFIG_STREAM_CHAROUT$$
 0042  149A R			      dw CONFIG_STREAM_COUNT$$
 0044  1550 R			      dw CONFIG_STREAM_QUALIFIED$$
 0046  15DF R			      dw CONFIG_STREAM_COMMAND$$
 0048  15E1 R			      dw CONFIG_STREAM_STATE$$
 004A  15E3 R			      dw CONFIG_TIME$$
 004C  230B R			      dw CONFIG_ARITH$$
 0000				     FanSegB ENDS
				     ; The Bcode comparisons are the same as the Pcode ones except for having
				     ; relative jumping so they are put with Pcode implementation.
				      EXTERN _Eq$$:near, _Ne$$:near, _Lt$$:near, _Le$$:near, _Ge$$:near, _Gt$$:near
				      EXTERN _Seq$$:near, _Sne$$:near, _Slt$$:near
				      EXTERN BifCHARIN:near, BifCHAROUT:near, BifSTREAM:near
 0000				     BifSeg SEGMENT WORD PUBLIC 'CODE'
 0000				     Bswitch:
				     ; Ordering of Bifs is exploited. Early ones required NOP at end-clause.
 0000  0169 R			      dw BifDATE
 0002  0B94 R			      dw BifTIME
 0004  0A9D R			      dw BifLINES
 0006  0A8C R			      dw BifCHARS
 0008  0000 E			      dw BifCHARIN
 000A  0000 E			      dw BifCHAROUT
 000C  0A0D R			      dw BifLINEIN
 000E  0A7F R			      dw BifLINEOUT
 0010  0000 E			      dw BifSTREAM
 0012  0B12 R			      dw BifSTRIP
 0014  1081 R			      dw BifVERIFY
 0016  0AAB R			      dw BifQUALIFY
 0018  1113 R			      dw BifWORDS
 001A  1045 R			      dw BifTRUNC
 001C  045C R			      dw BifERRORTEXT
 001E  0AD3 R			      dw BifSPACE
 0020  0FE2 R			      dw BifTRANSLATE
 0022  04AF R			      dw BifFORMAT ; Have to special case 1,4
 0024  10D8 R			      dw BifWORDLENGTH
 0026  10E2 R			      dw BifWORDPOS
 0028  007D R			      dw BifABBREV
 002A  00A9 R			      dw BifCENTER
 002C  00A9 R			      dw BifCENTRE
 002E  00F6 R			      dw BifCOMPARE
 0030  03F5 R			      dw BifDELSTR
 0032  0424 R			      dw BifDELWORD
 0034  0ABD R			      dw BifRIGHT
 0036  0753 R			      dw BifLASTPOS
 0038  0734 R			      dw BifINSERT
 003A  078E R			      dw BifOVERLAY
 0000				      BifSeg ENDS
				      PUBLIC BifCHANGESTR; Grouped with BifQUEUED hence not in this module's BifSeg.
				      PUBLIC BifCOUNTSTR
				      PUBLIC BifMAX; Needs high BifNum hence not in this module's BifSeg.
				      PUBLIC BifMIN
				      PUBLIC BifX2B; !! could avoid this
				      PUBLIC BifD2X; !! could avoid this
				      PUBLIC BifC2X; !! could avoid this
				      PUBLIC BifB2X; !! could avoid this
				      PUBLIC BifX2C; !! could avoid this
				      PUBLIC BifX2D; !! could avoid this
				      PUBLIC BifC2D; !! could avoid this
				      PUBLIC BifD2C; !! could avoid this
				      PUBLIC BifBITAND; !! could avoid this
				      PUBLIC BifBITOR; !! could avoid this
				      PUBLIC BifBITXOR; !! could avoid this
				      PUBLIC B4VALUE1
				      PUBLIC B4VALUE2
				      PUBLIC B4DROP
				      PUBLIC B4EXPOSE
				      PUBLIC PATHQUALIFY
				      PUBLIC LINESPLIT
				      PUBLIC COMMANDWRAP

				      PUBLIC Bswitch; Start of list of Bifs. In module's BifSeg but not used here.
				      PUBLIC ARITHOP$$; Bcode routine for arithmetic.
				      PUBLIC Bassign; Call here to do assignment to Bcode variable (on the stack).
				      PUBLIC One$$,String1$$; So Parse$$ can load things.
				      PUBLIC CloseBx; So Exit$$ can close things.
				      EXTERN TargetMsg:near
				     ; Iteration in Bcode is in this module but uses parts of the Pcode
				     ; implementation
				      EXTERN AddRegs:near
				      EXTERN CompareTO:near
				      EXTERN Raise49:near
				     ;------------------------------------------------------------------------------
				     ; Literal and numeric replacements
				     ;------------------------------------------------------------------------------
 = textequ			     is textequ <textequ>
 = byte ptr			     Bptr  is <byte ptr>
 = word ptr			     Wptr  is <word ptr>
 = dword ptr			     Dptr  is <dword ptr>
 = jmp $			     Hang  is <jmp $>
 = 0dh				     $Cr   is <0dh>
 = 0ah				     $Lf   is <0ah>
 = 1ah				     $Eof  is <1ah>
 = 0 dup(?)			     Overlay is <0 dup(?)>
 = .erre			     Assert is <.erre>
				     ;------------------------------------------------------------------------------
				     ; Typedefs. MASMs pointers are offsets in a segment.
				     ; Some of this is to indicate the purpose to the reader rather than MASM,
				     ; ie CHAR v BYTE since both are unsigned 8 bits.
				     ; However, pointerness is worth saying for words containing offsets since
				     ; debugger will take note.
				     ; WORD will tend not to get used since a word is either an integer (USHORT)
				     ; or an offset.
				     ; I haven't yet found the penalty in giving up SHORT as a keyword so as to
				     ; use it in the 'C' sense.
				     ;------------------------------------------------------------------------------
				       option nokeyword:<short>
				       option nokeyword:<C>
				     ; One byte target:
				     char   typedef byte
				     Bool   typedef byte
				     bytep  typedef ptr byte
				     charp  typedef ptr byte
				     charfp  typedef far ptr byte
				     Boolp  typedef ptr byte
				     ; Two byte
				     Ushort typedef word
				     Ushortp typedef ptr word
				     short typedef sword
				     shortp typedef ptr sword
				     Handle typedef word
				     Handlep typedef ptr word
				     Segp typedef word; Slightly different sense.
				     ; Four byte
				     Ulong typedef dword
 0004				     Farp struc; For les,lds
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
				     Farp ends

				     ;------------------------------------------------------------------------------
				     ; Macros
				     ;------------------------------------------------------------------------------

				     MkMajMin macro Maj:req, Min:req
				      
; Makes parts of msg number into one number.
				      exitm %(256*Maj+Min)
				     endm

				     StringOrder macro a:req, b:req, c, d
				      
; Load so that a store puts them in the written order.
				      ifnb <d>
				       exitm %(256*256*256*(d)+256*256*(c)+256*(b)+(a))
				      endif
				      exitm %(256*(b)+(a))
				     endm

				     ; Splat makes a visual 'noise' on the output.
				     Splat macro It:=<'*'>
				      mov dl,It
				      mov ah,02h
				      int 21h
				     endm

				     LoopQ macro tgt:req
				     
; Faster than single loop instruction
				       dec cx
				       jnz tgt
				     endm

				     JcxzQ macro tgt:req
				     
; jcxz is written only where retaining flags matters, else JcxzQ
				     
; JcxzQ can be rendered in way that can do long jump. (And maybe faster)
				       test cx,cx
				       je tgt
				     endm

				     Pos macro Needle:req, Hay:req
				      exitm % @InStr(1,Hay,Needle)
				     endm

				     ; As provided in MASM readme, plus fixing:
				      la macro Dest:req, Symbol:req
				     ; This can go wrong because replacement in operand occurs later.
				     ; Page 583 of Waite suggests we can test this but...
				      if (opattr(Symbol)) and 20h
				        if (opattr(Symbol)) and 08h
				          mov Dest, offset Symbol
				        else
				          lea Dest, Symbol
				        endif
				      else
				        ; Assume MOV if errors
				        mov Dest, offset Symbol
				      endif
				      endm

				     ; Having bp=0 makes a difference to zeroing.
				     ; XOR is no better than MOV of 0, and disturbs flags so this is just shorthand.
				     ; XOR faster than MOV of 0 on some machines?
				     ; Actually XOR is better for accum, but macro can't distinquish accum.
				     ; If Ax is positive CWD is better for DX, but macro doesn't do that.
				      z macro Dest:req
				     ; Drop this bit because XOR never better than register move.
				          if (type Dest) eq 1
				            mov Dest,0
				          else
				            if (type Dest) eq 2
				              mov Dest,bp
				            else
				              if (type Dest) eq 4
				                mov Dest,ebp
				              else
				                Whoops
				              endif
				            endif
				          endif
				      endm

				     ; Illuminate special use of test to set flags.
				     TestReg macro arg:req
				            test arg,arg
				     endm

				     ; Illuminate pop that discards.
				     PopJunk  macro arg:req
				       pop arg
				     endm

				     ; Setting bits in records.
				     ; I'm having trouble with MASM. If arg is complicated, it uses two byte
				     ; offsets where one would do. (Cured by overlay of word on record)
				     ; I cannot get MASM to put what I want on the listing. I would like the
				     ; values computed to show in the listed expansion but MASM will only show
				     ; the macro variable names there.  A % at the beginning of the line returned
				     ; by the macro does nothing. A % before the macro variable name in it is seen
				     ; as a syntax error. Short of conditional generation returning lines with
				     ; only the macro arguments in (these do get replaced on the listing), I don't
				     ; see a solution.

				     On      macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             or  arg,masksum
				       else
				         if masksum gt 255
				             or  Bptr(arg+1), high masksum
				         else
				             or  Bptr(arg), low masksum
				         endif
				       endif
				     endm
				     Off     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             and arg, not masksum
				       else
				         if masksum gt 255
				             and Bptr(arg+1), high not masksum
				         else
				             and Bptr(arg), low not masksum
				         endif
				       endif
				     endm
				     Qry     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             test arg, masksum
				       else
				         if masksum gt 255
				           if @SizeStr("&arg") gt 4
				             test Bptr(arg+1), high masksum
				           else
				             if "cx" ne "&arg"
				               test Bptr(arg+1), high masksum
				             else
				               test ch, high masksum
				             endif
				           endif
				         else
				             test Bptr(arg), low masksum
				         endif
				       endif
				     endm

				     mv   macro To:req,From:req
				     ; Used for segment moves
				      push From
				      pop To
				     endm

				     xax macro To:req
				     ; Used for ax moves when xchg saves a byte. (At expense of cycles)
				     ; Don't use xax form if exchange is "real" exchange.
				      if (type To) eq 2
				        xchg ax,To
				      else
				        xchg eax,To
				      endif
				     endm

				     inc2 macro Subj:req
				     ; Shorter than add Subj,2 when non-acc 16 bit reg.
				      inc Subj
				      inc Subj
				     endm

				     dec2 macro Subj:req
				     ; Shorter than dec Subj,2 when non-acc 16 bit reg.
				      dec Subj
				      dec Subj
				     endm

				     top macro To:req
				     ; Top element of hardware stack without disturbing it.
				      pop To
				      push To
				     endm

				     move macro To:req,From:req,Via
				     ; Memory to memory with arguments in same order as a mov.
				      ifb <Via>
				       if (type To) eq 2
				         mov ax,From
				         mov To,ax
				       elseif (type To) eq 1
				         mov al,From
				         mov To,al
				       else
				         mov eax,From
				         mov To,eax
				       endif
				      else
				       mov Via,From
				       mov To,Via
				      endif
				     endm

				     ;------------------------------------------------------------------------------
				     ; Shapes of structures for based addressing.
				     ;------------------------------------------------------------------------------
				     ; If we PUSHA and then copy SP to BP the caller's
				     ; registers have become locals accessible on [BP].
				     ; Structure PushShape holds the shape for this.
 0010				     PushShape struct
 0000  0000			      di_ word ?
 0002  0000			      si_ word ?
 0004  0000			      bp_ word ?
 0006  0000			      sp_ word ?
 0008	    0000 [		      bx_ word Overlay
	     0000
	    ]
 0008  00			      bl_ byte ?
 0009  00			      bh_ byte ?
 000A	    0000 [		      dx_ word Overlay
	     0000
	    ]
 000A  00			      dl_ byte ?
 000B  00			      dh_ byte ?
 000C	    0000 [		      cx_ word Overlay
	     0000
	    ]
 000C  00			      cl_ byte ?
 000D  00			      ch_ byte ?
 000E	    0000 [		      ax_ word Overlay
	     0000
	    ]
 000E  00			      al_ byte ?
 000F  00			      ah_ byte ?
				     PushShape ends
				     ; Build characteristics:
 = 0000				      CD equ 0; On when dump of compaction activity needed. See CD.REXX
 = 0001				      Debug equ 1; On for normal checks detecting internal flaws early.
 = 0001				      MemCheck equ 1; On for DOS memory checks.
 = 0000				      ForBcode equ 0; When making code that will be turned to BCode.
 = 0000				      ForBig equ 0; When making code that will be turned into one big assembly.
 = 0001				      SortSpaceSS equ 1; Design has compaction list under SS.
 = 0000				      Trial equ 0; Design change experiment.
 = 0001				      Solid equ 1; Always 1, used to mark sensitive areas for ForBig technology.
				     ;(Solid section with following label is assumed not to fall through.)
				     if ForBig
				      endif
				     if Debug
				     CheckType macro
				      test V.Dtype,$Test
				      jz @F
				      cmp V.Dtype,$AwayString
				      je @F
				      cmp V.Dtype,$NullString
				      je @F
				      cmp V.Dtype,$NullString+1
				      je @F
				      cmp V.Dtype,$NullString+2
				      je @F
				      cmp V.Dtype,$NullString+3
				      je @F
				      cmp V.Dtype,$NullString+4
				      je @F
				      cmp V.Dtype,$NullString+5
				      je @F
				      cmp V.Dtype,$NullString+6
				      je @F
				      cmp V.Dtype,$NullString+7
				      je @F
				     endm
				     endif
				      EXTERNDEF ToWholeEbx:near; Converts from Rexx variable to integer in EBX.
				      EXTERNDEF Zero$$:near; Puts zero on the stack.
				      EXTERNDEF Then$$:near; Execution of THEN
				      EXTERNDEF DigitsChange:near; Called at places where Digits() setting may change.
				      EXTERNDEF ZoneNumerics:near; Updates Zone for fast access to numeric settings.
				      EXTERNDEF SetInherit:near; Inherit, for an external routine.
				      EXTERNDEF Compiling:near; To start compiling something.
				      EXTERNDEF Compiler:near; To start compiling something.
				      EXTERNDEF StartExecution:near; To start executing made Pcode.
				      EXTERNDEF StartExecutionY:near; To start executing made Pcode.
				      EXTERNDEF ResumeP$:near; To start executing Pcode after Bcode.
				      EXTERNDEF Command:near; To start compiling source named on a command.
				      EXTERNDEF AssureSiPlus:near
				      EXTERNDEF AssignExposed:near
				      EXTERNDEF Name2File:near
				      EXTERNDEF ZoneToLevel:near
				      EXTERNDEF BifBound:near; A place separating code on basis of address
				      EXTERNDEF ConstValue:near
				      EXTERNDEF ConstValueX:near
				      EXTERNDEF Terminate:near
				      EXTERNDEF UpperFirstAh:near
				      EXTERNDEF NotPresent:near
				      EXTERNDEF Consist:near
				      EXTERNDEF Serialize:near
				      EXTERNDEF RetEsSi:near
				      EXTERNDEF ExposedFs:near, DotsExposed:near
				     ; Make the memory services available to all modules.
				      EXTERNDEF InitMemory:near, AllocateCx_EsAx:near, InitSegDs:near
				      EXTERNDEF MoreSpaceEs:near,GiveDosMem:near
				      EXTERNDEF ParaAllocAx:near, Raise5p1:near, Raise5p1d:near
				      EXTERNDEF StackSafe:near, SetStack:near, UpStack:near
				     ; Most modules need to load values from Rexx variables to registers.
				      EXTERNDEF ToDsSiCx:near, NumDxBx:near
				     ; Many modules create pseudo-code, test operator attributes..
				      EXTERNDEF Scode:near, Pcode1:near, Pcode2:near, PcodeArg:near
				      EXTERNDEF PcodeGapBx:near, PcodeOp:near, OpFlags:near
				     ; Lookup things may be needed in execution, eg for DROP (abc)
				      EXTERNDEF Lookup:near,SymbolsSafe:near,SetSymLenJa:near,SymbolLook:near
				      EXTERNDEF VasDsSiCx:near
				     ; And a few more in common use.
				      EXTERNDEF Ax2DsSiCx:near,HeritageDi:near, Raise:near
				      EXTERNDEF Attributes:near; Table for uppercasing, etc.
				      EXTERNDEF ResultSpace:near, AwayEsAxCx:near
				      EXTERNDEF LinkBcode:near, LinkBcodeX:near
				      EXTERNDEF CONFIG_UPPER$$:near
				      EXTERNDEF CONFIG_RAISE40$$:near
				      EXTERNDEF PcodesBase$:near
				      EXTERNDEF DotsFsBxDsSi:near
				      EXTERNDEF DotsFsBxDsSiX:near
				      EXTERNDEF XCycle:near,Rejumps:near,Boolery:near,BooleryRejumps:abs
				      EXTERNDEF LookFileDsBx:near
				      EXTERNDEF Away:near
				      EXTERNDEF ClauseSourceEnd:near
				      EXTERNDEF DualSwitch:near
				     if Debug
				      EXTERNDEF Say$$:near ; only for Consist debug
				      EXTERNDEF DosMemCheck:near
				      EXTERNDEF Create4Dump:near
				      EXTERNDEF Dumper:near
				     endif

 = 0001				     $PcodesBase equ 01h
 = 005D				     $BPcodesCeil equ 05Dh
 = 00C5				     $PcodesCeil equ 0C5h
 = 0057				     $PjumpBase equ 057h
 = 0089				     $PjumpCeil equ 089h
 = 0001				     $pAbut equ 01h
 = 0003				     $pCat equ 03h
 = 0005				     $pNop equ 05h
 = 0007				     $pAssignDotsP equ 07h
 = 0009				     $pParse equ 09h
 = 000B				     $pResumeParse equ 0Bh
 = 000D				     $pNumber equ 0Dh
 = 000F				     $pTo equ 0Fh
 = 0011				     $pBy equ 011h
 = 0013				     $pFor equ 013h
 = 0015				     $pWhile equ 015h
 = 0017				     $pUntil equ 017h
 = 0019				     $pIterRep equ 019h
 = 001B				     $pIterate equ 01Bh
 = 001D				     $pLeave equ 01Dh
 = 001F				     $pUnDo equ 01Fh
 = 0021				     $pResult equ 021h
 = 0023				     $pReturn equ 023h
 = 0025				     $pReturns equ 025h
 = 0027				     $pExit equ 027h
 = 0029				     $pSay equ 029h
 = 002B				     $pBifq equ 02Bh
 = 002D				     $pLength equ 02Dh
 = 002F				     $pMax equ 02Fh
 = 0031				     $pMin equ 031h
 = 0033				     $pNot equ 033h
 = 0035				     $pAnd equ 035h
 = 0037				     $pOr equ 037h
 = 0039				     $pXor equ 039h
 = 003B				     $pPositive equ 03Bh
 = 003D				     $pNegate equ 03Dh
 = 003F				     $pAdd equ 03Fh
 = 0041				     $pSubtract equ 041h
 = 0043				     $pMultiply equ 043h
 = 0045				     $pDivide equ 045h
 = 0047				     $pIntDivide equ 047h
 = 0049				     $pRemainder equ 049h
 = 004B				     $pPower equ 04Bh
 = 004D				     $pCommand equ 04Dh
 = 004F				     $pInterpret equ 04Fh
 = 0051				     $pNumeric equ 051h
 = 0053				     $pInvoke equ 053h
 = 0055				     $pCall equ 055h
 = 0057				     $pRep equ 057h
 = 0059				     $pRepEver equ 059h
 = 005B				     $pControlVar equ 05Bh
 = 005D				     $pDotControlVar equ 05Dh
 = 005F				     $pThen equ 05Fh
 = 0061				     $pWhen equ 061h
 = 0063				     $pJump equ 063h
 = 0065				     $pEq equ 065h
 = 0067				     $pNe equ 067h
 = 0069				     $pLt equ 069h
 = 006B				     $pLe equ 06Bh
 = 006D				     $pGe equ 06Dh
 = 006F				     $pGt equ 06Fh
 = 0071				     $pSeq equ 071h
 = 0073				     $pSne equ 073h
 = 0075				     $pSlt equ 075h
 = 0077				     $pSle equ 077h
 = 0079				     $pSge equ 079h
 = 007B				     $pSgt equ 07Bh
 = 007D				     $pCeq equ 07Dh
 = 007F				     $pCne equ 07Fh
 = 0081				     $pClt equ 081h
 = 0083				     $pCle equ 083h
 = 0085				     $pCge equ 085h
 = 0087				     $pCgt equ 087h
 = 0089				     $pInterpEnd equ 089h
 = 008B				     $pSignal equ 08Bh
 = 008D				     $pSignalOn equ 08Dh
 = 008F				     $pCallOn equ 08Fh
 = 0091				     $pDots equ 091h
 = 0093				     $pAssign equ 093h
 = 0095				     $pAssignStem equ 095h
 = 0097				     $pAssignDots equ 097h
 = 0099				     $pAssignConst equ 099h
 = 009B				     $pUnstore equ 09Bh
 = 009D				     $pDrop equ 09Dh
 = 009F				     $pExpose equ 09Fh
 = 00A1				     $pBool equ 0A1h
 = 00A3				     $pIterCV equ 0A3h
 = 00A5				     $pAddress equ 0A5h
 = 00A7				     $pCommandEnv equ 0A7h
 = 00A9				     $pEnvName equ 0A9h
 = 00AB				     $pBif equ 0ABh
 = 00AD				     $pBifGroup equ 0ADh
 = 00AF				     $pRaise equ 0AFh
 = 00B1				     $pSignalOff equ 0B1h
 = 00B3				     $pSignalV equ 0B3h
 = 00B5				     $pSysVar equ 0B5h
 = 00B7				     $pDropList equ 0B7h
 = 00B9				     $pExposeList equ 0B9h
 = 00BB				     $pPush equ 0BBh
 = 00BD				     $pQueue equ 0BDh
 = 00BF				     $pTrace equ 0BFh
 = 00C1				     $pTraceEvent equ 0C1h
 = 00C3				     $pOptions equ 0C3h
 = 0000				     $BifDATE equ 0
 = 0001				     $BifTIME equ 1
 = 0002				     $BifLINES equ 2
 = 0003				     $BifCHARS equ 3
 = 0004				     $BifCHARIN equ 4
 = 0005				     $BifCHAROUT equ 5
 = 0006				     $BifLINEIN equ 6
 = 0007				     $BifLINEOUT equ 7
 = 0008				     $BifSTREAM equ 8
 = 0009				     $BifSTRIP equ 9
 = 000A				     $BifVERIFY equ 10
 = 000B				     $BifQUALIFY equ 11
 = 000C				     $BifWORDS equ 12
 = 000D				     $BifTRUNC equ 13
 = 000E				     $BifERRORTEXT equ 14
 = 000F				     $BifSPACE equ 15
 = 0010				     $BifTRANSLATE equ 16
 = 0011				     $BifFORMAT equ 17
 = 0012				     $BifWORDLENGTH equ 18
 = 0013				     $BifWORDPOS equ 19
 = 0014				     $BifABBREV equ 20
 = 0015				     $BifCENTER equ 21
 = 0016				     $BifCENTRE equ 22
 = 0017				     $BifCOMPARE equ 23
 = 0018				     $BifDELSTR equ 24
 = 0019				     $BifDELWORD equ 25
 = 001A				     $BifRIGHT equ 26
 = 001B				     $BifLASTPOS equ 27
 = 001C				     $BifINSERT equ 28
 = 001D				     $BifOVERLAY equ 29
 = 001E				     $BifFORM equ 30
 = 001F				     $BifDATATYPE equ 31
 = 0020				     $BifADDRESS equ 32
 = 0021				     $BifARG equ 33
 = 0022				     $BifCONDITION equ 34
 = 0023				     $BifTRACE equ 35
 = 0024				     $BifFUZZ equ 36
 = 0025				     $BifDIGITS equ 37
 = 0026				     $BifSOURCELINE equ 38
 = 0027				     $BifXRANGE equ 39
 = 0028				     $BifRANDOM equ 40
 = 0029				     $BifREVERSE equ 41
 = 002A				     $BifABS equ 42
 = 002B				     $BifSIGN equ 43
 = 002C				     $BifC2X equ 44
 = 002D				     $BifB2X equ 45
 = 002E				     $BifX2B equ 46
 = 002F				     $BifX2C equ 47
 = 0030				     $BifX2D equ 48
 = 0031				     $BifC2D equ 49
 = 0032				     $BifD2C equ 50
 = 0033				     $BifD2X equ 51
 = 0034				     $BifBITAND equ 52
 = 0035				     $BifBITOR equ 53
 = 0036				     $BifBITXOR equ 54
 = 0037				     $BifVALUE equ 55
 = 0038				     $BifCOPIES equ 56
 = 0039				     $BifWORD equ 57
 = 003A				     $BifWORDINDEX equ 58
 = 003B				     $BifSUBWORD equ 59
 = 003C				     $BifPOS equ 60
 = 003D				     $BifLEFT equ 61
 = 003E				     $BifSUBSTR equ 62
 = 003F				     $BifQUEUED equ 63
 = 0040				     $BifSYMBOL equ 64
 = 0041				     $BifCOUNTSTR equ 65
 = 0042				     $BifCHANGESTR equ 66
 = 0043				     $BifLENGTH equ 67
 = 0044				     $BifMAX equ 68
 = 0045				     $BifMIN equ 69
 = 00B3				     $BcodesBase equ 0B3h
 = 00B3				     Zero equ 0B3h
 = 00B5				     One equ 0B5h
 = 00B7				     Null equ 0B7h
 = 00B9				     String equ 0B9h
 = 00BB				     String1 equ 0BBh
 = 00BD				     String2 equ 0BDh
 = 00BF				     _RetBc equ 0BFh
 = 00C1				     _RetB equ 0C1h
 = 00C3				     _RetF equ 0C3h
 = 00C5				     _IterCV equ 0C5h
 = 00C7				     _Exists equ 0C7h
 = 00C9				     _Then equ 0C9h
 = 00CB				     _Jump equ 0CBh
 = 00CD				     _Eq equ 0CDh
 = 00CF				     _Ne equ 0CFh
 = 00D1				     _Lt equ 0D1h
 = 00D3				     _Le equ 0D3h
 = 00D5				     _Ge equ 0D5h
 = 00D7				     _Gt equ 0D7h
 = 00D9				     _Seq equ 0D9h
 = 00DB				     _Sne equ 0DBh
 = 00DD				     _Slt equ 0DDh
 = 00DF				     CONFIG_RAISE equ 0DFh
 = 00E1				     CONFIG_RAISE40 equ 0E1h
 = 00E3				     CONFIG_UPPER equ 0E3h
 = 00E5				     CONFIG_MSG equ 0E5h
 = 00E7				     CONFIG_C2B equ 0E7h
 = 00E9				     CONFIG_B2C equ 0E9h
 = 00EB				     CONFIG_STREAM_POSITION equ 0EBh
 = 00ED				     CONFIG_STREAM_CHARIN equ 0EDh
 = 00EF				     CONFIG_STREAM_QUERY equ 0EFh
 = 00F1				     CONFIG_STREAM_CLOSE equ 0F1h
 = 00F3				     CONFIG_STREAM_CHAROUT equ 0F3h
 = 00F5				     CONFIG_STREAM_COUNT equ 0F5h
 = 00F7				     CONFIG_STREAM_QUALIFIED equ 0F7h
 = 00F9				     CONFIG_STREAM_COMMAND equ 0F9h
 = 00FB				     CONFIG_STREAM_STATE equ 0FBh
 = 00FD				     CONFIG_TIME equ 0FDh
 = 00FF				     CONFIG_ARITH equ 0FFh
 = 0000				     $0 equ 0
 = 0000				     $Eos equ 0*4
 = 0001				     $12 equ 1
 = 0004				     $Semi equ 1*4
 = 0002				     $11 equ 2
 = 0008				     $UnAccept equ 2*4
 = 0003				     $6 equ 3
 = 000C				     $Lparen equ 3*4
 = 0004				     $3 equ 4
 = 0010				     $Percent equ 4*4
 = 0011				     $Asterisk equ 4*(5-1) + 1
 = 0012				     $Slash equ 4*(5-1) + 2
 = 0013				     $Rem equ 4*(5-1) + 3
 = 0014				     $Xor equ 5*4
 = 0015				     $Or equ 4*(6-1) + 1
 = 0006				     $5 equ 6
 = 0018				     $And equ 6*4
 = 0007				     $10 equ 7
 = 001C				     $Comma equ 7*4
 = 0020				     $Not equ 8*4
 = 0009				     $9 equ 9
 = 0024				     $Minus equ 9*4
 = 0025				     $Plus equ 4*(10-1) + 1
 = 002B				     $Eq equ 10*4+3
 = 002C				     $Ne equ 11*4
 = 002D				     $Lt equ 4*(12-1) + 1
 = 002E				     $Le equ 4*(12-1) + 2
 = 002F				     $Ge equ 4*(12-1) + 3
 = 0030				     $Gt equ 12*4
 = 0031				     $Seq equ 4*(13-1) + 1
 = 0032				     $Sne equ 4*(13-1) + 2
 = 0033				     $Slt equ 4*(13-1) + 3
 = 0034				     $Sle equ 13*4
 = 0035				     $Sge equ 4*(14-1) + 1
 = 0036				     $Sgt equ 4*(14-1) + 2
 = 000E				     $7 equ 14
 = 0038				     $Rparen equ 14*4
 = 003C				     $STRING equ 15*4
 = 0040				     $CONST_SYMBOL equ 16*4
 = 0044				     $NUMBER equ 17*4
 = 0012				     $28 equ 18
 = 0048				     $VAR_SYMBOL equ 18*4
 = 0013				     $1 equ 19
 = 004C				     $Abut equ 19*4
 = 004D				     $Cat equ 4*(20-1) + 1
 = 0014				     $8 equ 20
 = 0050				     $Power equ 20*4
 = 0015				     $2 equ 21
 = 0054				     $Assign equ 21*4
 = 0016				     $21 equ 22
 = 0058				     $VALUE equ 22*4
 = 0017				     $16 equ 23
 = 005C				     $END equ 23*4
 = 0018				     $18 equ 24
 = 0060				     $THEN equ 24*4
 = 0019				     $17 equ 25
 = 0064				     $FOR equ 25*4
 = 001A				     $19 equ 26
 = 0068				     $TO equ 26*4
 = 001B				     $15 equ 27
 = 006C				     $BY equ 27*4
 = 0070				     $UNTIL equ 28*4
 = 0074				     $WHILE equ 29*4
 = 001E				     $23 equ 30
 = 0078				     $WITH equ 30*4
 = 007C				     $LINEIN equ 31*4
 = 007D				     $SOURCE equ 4*(32-1) + 1
 = 007E				     $VERSION equ 4*(32-1) + 2
 = 0080				     $PULL equ 32*4
 = 0084				     $VAR equ 33*4
 = 0088				     $ARG equ 34*4
 = 008C				     $ADDRESS equ 35*4
 = 0090				     $APPEND equ 36*4
 = 0094				     $CALL equ 37*4
 = 0098				     $DO equ 38*4
 = 009C				     $ELSE equ 39*4
 = 00A0				     $NOP equ 40*4
 = 00A4				     $INTERPRET equ 41*4
 = 00A5				     $OPTIONS equ 4*(42-1) + 1
 = 00A8				     $EXIT equ 42*4
 = 00A9				     $PUSH equ 4*(43-1) + 1
 = 00AA				     $QUEUE equ 4*(43-1) + 2
 = 00AB				     $RETURN equ 4*(43-1) + 3
 = 00AC				     $SAY equ 43*4
 = 00B0				     $TRACE equ 44*4
 = 00B4				     $LEAVE equ 45*4
 = 00B5				     $ITERATE equ 4*(46-1) + 1
 = 00B8				     $DROP equ 46*4
 = 00BC				     $EXPOSE equ 47*4
 = 00C0				     $SIGNAL equ 48*4
 = 00C4				     $SYNTAX equ 49*4
 = 00C5				     $LOSTDIGITS equ 4*(50-1) + 1
 = 00C6				     $NOVALUE equ 4*(50-1) + 2
 = 00C8				     $NOTREADY equ 50*4
 = 00C9				     $FAILURE equ 4*(51-1) + 1
 = 00CA				     $HALT equ 4*(51-1) + 2
 = 00CC				     $ERROR equ 51*4
 = 00D0				     $UPPER equ 52*4
 = 00D4				     $IF equ 53*4
 = 00D8				     $INPUT equ 54*4
 = 00DC				     $NAME equ 55*4
 = 00E0				     $NUMERIC equ 56*4
 = 00E4				     $DIGITS equ 57*4
 = 00E5$FUZZ equ 4*(58-1) + 1
 = 00E8				     $FORM equ 58*4
 = 00EC				     $ENGINEERING equ 59*4
 = 00ED				     $SCIENTIFIC equ 4*(60-1) + 1
 = 00F0				     $OTHERWISE equ 60*4
 = 00F4				     $OUTPUT equ 61*4
 = 00F8				     $PARSE equ 62*4
 = 00FC				     $PROCEDURE equ 63*4
 = 0100				     $SELECT equ 64*4
 = 0104				     $WHEN equ 65*4
 = 0108				     $REPLACE equ 66*4
 = 010C				     $STEM equ 67*4
 = 0110				     $STREAM equ 68*4
 = 0114				     $NORMAL equ 69*4
 = 0118				     $FOREVER equ 70*4
 = 011C				     $OFF equ 71*4
 = 0120				     $ON equ 72*4
 = 0000				     $sPercent equ 0
 = 0006				     $sDrop equ 6
 = 0009				     $sStem equ 9
 = 000A				     $sWith equ 10
 = 000B				     $sDropList equ 11
 = 0014				     $sMinus equ 20
 = 0017				     $sLength equ 23
 = 001B				     $sEq equ 27
 = 0021				     $sSeq equ 33
 = 0027				     $sDigits equ 39
 = 002A				     $sNop equ 42
 = 002B				     $sForm equ 43
 = 002D				     $sAddress equ 45
 = 0030				     $sNegate equ 48
 = 0031				     $sPositive equ 49
 = 0032				     $sExit equ 50
 = 0035				     $sReturns equ 53
 = 0037				     $sNumber equ 55
 = 0039				     $sRaise equ 57
 = 003E				     $sLeave equ 62
 = 003F				     $sIterate equ 63
 = 00FE				     ParseDot equ 254; A non-operator Bcode value otherwise unused.
 = 0028				     KeysBase equ 4*10; Manual
				     ; Here are some symbolic names of registers, used for readability of this code.
 = bp				     ZeroBp is <bp>
 = di				     StackDi is <di>      ; The soft stack pointer.
 = si				     StackSi is <si>      ; Another soft stack pointer.
 = dx				     StackDx is <dx>      ; Limit of range on soft stack.
 = bx				     ArrayBx is <bx>      ; To an element of Vshape.
 = bx				     StemBx is <bx>       ; When the subject is a stem.
 = si				     TailSi is <si>       ; When the subject is a tailed variable.
 = bx				     FileBx is <bx>       ; To an element of Fshape.
 = si				     ArraySi is <si>      ; To an element of Vshape.
 = bx				     OperandBx is <bx>    ; A pointer to an operand in one of the arrays of Vshapes.
 = bl				     OperandBl is <bl>    ;
 = bx				     ProbeBx is <bx>      ; Used when searching a binary tree for a stemmed variable.
 = si				     LowSi is <si>        ; Used when searching a binary tree.
 = di				     HighDi is <di>       ; Used when searching a binary tree.
 = ax				     ToFindLenAx is <ax>  ; Used when searching a binary tree.
 = dx				     ToFindDx is <dx>     ; Used when searching a binary tree.
 = cx				     KeyListCx is <cx>;   ; Parameter to keyword lookup.
 = ch				     TokNowCh is <ch>;    ; One of the places numbers for tokens are held.
 = si				     StateSi is <si>      ; The state in parsing.
 = si				     ParseSi is <si>      ; Parse state pushed on hard stack.
 = di				     StateDi is <di>      ; Address first word of the state.
 = bx				     StateBx is <bx>      ; Often distance from StateOrig to some state data.
 = dx				     ParseDx is <dx>      ; Token data in form the parser uses.
 = ah				     RtypeAh is <ah>      ; Type of reduction done in Cycle.
 = ah				     TokNumAh is <ah>     ; Where next token is returned, becoming TokNum.
 = si				     LookupSi is <si>     ; Where Lookup finds unresolved compound symbol.
 = si				     LevelSi is <si>      ; To block for this invocation level.
 = di				     LevelDi is <di>
 = si				     CursorSi is <si>     ; Offset in Pcode.
 = bx				     CursorBx is <bx>     ; Offset in Pcode.
 = cx				     OpAppendCx is <cx>   ; Numeric argument to PcodeOp routine.
 = si				     ScanSi is <si>       ; Scanning the user's source program.
 = cl				     OpAppendCl is <cl>
 = al				     RawCharAl is <al>
 = ah				     RawCharAh is <ah>
 = al				     AttribAl is <al>
 = dl				     RadixTypeDl is <dl>
 = cx				     ParmsCx is <cx>
 = cl				     ParmsCl is <cl>
 = bx				     LengthAtBx is <bx>
 = dx				     SymsZiDx is <dx>
 = di				     SegOffDi is <di> ; Offset in Zone of a segment pointer.
				     ; Special use of bp for two-byte call.
 = call bp			     Error49Bp is <call bp>
				     ; Shorthand for current byte of input.
 = byte ptr ss:[si+bp]		     RawChar is <byte ptr ss:[si+bp]>
				     ; These for making messages.
 = bl				     DepthBl is <bl>; of recursion.
 = bx				     DepthBx is <bx>; Bug if inc/dec affects bh.
 = bh				     TheMsgBh is <bh>; on when scanning the target.
 = cx				     PartLenCx is <cx>; Amount of compressed to expand.
 = cl				     LowPartLenCl is <cl>
 = cx				     KeywordOffsetCx is <cx>
 = dx				     MajMinDx is <dx>
 = dh				     MajorDh is <dh>
 = dl				     MinorDl is <dl>
 = dx				     MinorDx is <dx>; inc/dec
 = si				     ScannerSi is <si>; SI the address in table. (LODS used)
				     ; For segment registers.
				     ; ES has some transient uses (particularly because it cannot be overridden
				     ; in movsb) but mainly it is set to the symbols segment during compilation
				     ; and the program scope segment during execution.  Tailed variable references
				     ; also use it (transiently) because each stem variable has it's own segment.
 = es				     SymbolsEs is <es>
 = es				     ProgEs is <es>
 = es				     StemEs is <es>

 = 0019				     $DosDisk equ 19h
 = 002A				     $DosDate equ 2Ah
 = 002C				     $DosTime equ 2Ch
 = 003C				     $DosCreate equ 3Ch
 = 003D				     $DosOpen equ 3Dh
 = 003E				     $DosClose equ 3Eh
 = 003F				     $DosRead equ 3Fh
 = 0040				     $DosWrite equ 40h
 = 0041				     $DosDelete equ 41h
 = 0042				     $DosSeek equ 42h
 = 0043				     $DosChmod equ 43h
 = 0047				     $DosPath equ 47h
 = 0048				     $DosAllocate equ 48h
 = 0049				     $DosFree equ 49h
 = 004A				     $DosModifyAllocated equ 4Ah
 = 004B				     $DosExecute equ 4Bh
 = 004C				     $DosExit equ 4Ch
 = 004D				     $DosReturnCode equ 4Dh
 = 0059				     $DosGetError equ 59h
 = 0062				     $DosPSP equ 62h
				     ; As allowed by the Standard:
 = 000A				     $Limit_EnvironmentName equ 10
 = C350				     $Limit_String equ 50000
 = 00FA				     $Limit_Literal equ 250
 = 00FA				     $Limit_Name equ 250
 = 270F				     $Limit_Digits equ 9999; Note Msg33.2 must be generated to match.
 = 0009				     $Limit_ExponentDigits equ 9
 = 0032				     $Limit_Insert equ 50; Longest insert.
				     ; Ours
 = 0036				     $Limit_Major equ 54; Highest message user sees.
 = 0037				     $Descriptions equ 55; A place in the message numbering for oddment prose.
 = 00C8				     $MsgRoom equ 4*$Limit_Insert
 = 00AF				     $MaxPreInsert equ 175; Chars in message.
 = 0050				     $MsgChunk equ 80; Strictly, ANSI says leave chunking to system.
 = 0064				     $MaxParms equ 100; Per invokation. (Or temporary results within an expression)
 = 0400				     $FileBufferSize equ 1024
 = 0003				     $Leeway equ 3
				     ; Data types within symbols segment:
 = 00FF				     $tChar equ 0FFh
 = 00FE				     $tLabel equ 0FEh
 = 00FD				     $tBinary equ 0FDh
				     ; Minor bits on an operand reference.
 = 0006				     $CaseTarget equ 6
				     ; Subcodes to Pcodes.
				     ; These are used by the utility. Avoid putting semicolon abutting the "h".
				     ; These markers share values with Sysvar references in Bcode but we don't
				     ; parse into sysvars in our Bcode.
				     ; If we want to detect presence/absence of these they need to be 2 modulo 8.
				     ; However if they always follow something known, any value will do.
				     ; In practice we sometimes use the modulo 8 approach (even at the expense of
				     ; a shift when they are used) so as to make scanning of Pcode simpler.
 = 0002				     $mRepTail equ 02h        ; Used when $pDotControlVar addresses tails.
 = 000A				     $mUpper equ 0Ah          ; Modifier on parse source.
 = 0012				     $mParseEscape equ 12h    ; Parse part too complex to handle as single action.
 = 001A				     $mParseEnd equ 1Ah       ; Parse ends.
 = 0022				     $mPosRest equ 22h        ; Parse trigger
 = 002A				     $mPattern equ 2Ah        ; Parse trigger after operand
 = 0032				     $mPosEq equ 32h          ; Parse trigger after operand
 = 003A				     $mPosPlus equ 3Ah        ; Parse trigger after operand
 = 0042				     $mPosMinus equ 42h       ; Parse trigger after operand
 = 004A				     $mTemplateComma equ 4Ah  ; Parse trigger
				     ; These in number field of $pParse:
 = 0000				     $nVar equ 0              ; These
 = 0002				     $nWith equ 2             ;       two lowest of parse sources.
 = 0004				     $nArg equ 4
 = 0006				     $nLineIn equ 6
 = 0008				     $nPull equ 8
 = 000A				     $nSource equ 10
 = 000C				     $nVersion equ 12
				     ; These in number field of $pCommandEnv
 = 0000				     $nStem equ 00h
 = 0020				     $nStream equ 20h
 = 0040				     $nNormal equ 40h
				     ; These in number field of $pNumeric
 = 0000				     $nDigits equ 00h
 = 0002				     $nFuzz equ 02h
 = 0004				     $nForm equ 04h
				     ; These in number field of $pRaise
 = 0000				     $n7p3 equ 0
 = 0002				     $n17p1 equ 2
 = 0004				     $n40p3 equ 4
 = 0006				     $n40p4 equ 6
 = 0008				     $n40p5 equ 8
				     ; Types for things in Z.Serial
				     ; $SerialNone is also used for message building.
				     ; $SerialSource is qualified by Z.RelativeNow - what part of source file.
				     ; These are modals except for $SerialCompaction which saves/restores previous.
 = 0000				     $SerialNone equ 0
 = 0001				     $SerialQue equ 1
 = 0002				     $SerialCompaction equ 2
 = 0003				     $SerialInterpret equ 3
 = 0004				     $SerialSource equ 4
				     ; Trace events. (Order unexploited except for highest.)
 = 0000				     $TraceAssign equ 0
 = 0002				     $TraceBY equ 1*2
 = 0004				     $TraceClause equ 2*2
 = 0006				     $TraceCompound equ 3*2
 = 0008				     $TraceDot equ 4*2
 = 000A				     $TraceError equ 5*2
 = 000C				     $TraceExpr equ 6*2
 = 000E				     $TraceFailure equ 7*2
 = 0010				     $TraceFunction equ 8*2
 = 0012				     $TraceOperator equ 9*2
 = 0014				     $TracePrefix equ 10*2
 = 0016				     $TraceLit equ 11*2
 = 0018				     $TraceVar equ 12*2
 = 001A				     $TraceBack equ 13*2; Highest for $TrEv.
 = 001C				     $TraceParse equ 14*2; Only sets flag.
 = 001E				     $TraceEndClause equ 15*2; Compiled at end of a traced clause.
				     ; Descriptions on messages.    See OverfullMem for some.
				     Assert Zshape.SysFiles-Zshape.SysFiles eq 2*1-2
				     Assert Zshape.Consts-Zshape.SysFiles eq 2*2-2
				     Assert Zshape.Vars-Zshape.SysFiles eq 2*3-2
				     Assert Zshape.ProgScope-Zshape.SysFiles eq 2*4-2 ; Used for 'memory' msg.
				     Assert Zshape.VarScope-Zshape.SysFiles eq 2*5-2 ; Used for 'string length'
				     Assert Zshape.Symbols-Zshape.SysFiles eq 2*6-2
				     Assert Zshape.Code-Zshape.SysFiles eq 2*7-2
				     Assert Zshape.Zone-Zshape.SysFiles eq 2*8-2
				     Assert Zshape.Stem-Zshape.SysFiles eq 2*9-2
 = 0005				     $DescString equ 5
 = 000A				     $DescArgs   equ 10
 = 000B				     $Desc59H    equ 11
 = 000C				     $DescFiles  equ 12
 = 000D				     $DescQueue  equ 13
 = 0080				     $BifTag equ 80h; Helps with reverse lookup
				     ; As well as source coming from a file, there are the cases of INTERPRET,
				     ; VALUE, and SYMBOL where some compiling is needed.  Also VarPool cases.
				     ; Even if only Lookup is needed, it can be simplest to compile and pick
				     ; the answer up from the generated code.
 = 11C8				     $SourceBufferSize equ 4552; Allows for long bit literal.
 = 2000				     $InitStackSize equ 8192
 = 0000				      $White equ 0
 = 0040				      $Digit equ 64
 = 0080				      $Letter equ 128
 = 00C0				      $Special equ 192
 = 0008				      $NonUpable equ 8
 = 0004				      $Bb equ 4
 = 0002				      $Xx equ 2
 = 0001				      $Ee equ 1
 = 0048				      $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; Constants for Bifs.
 = FFB9				     $BifBase equ 65535-70; 68 bifs at high numbers.
				     ; The equates for pseudo code operations are with the P switch.
				     ; (See also $Reserved)
 = 00C0				     $Test       equ 11000000b; To test the most vital bits.
 = 0080				     $NullString equ 10000000b; 01000nnn for 0-7 length strings.
 = 0088				     $Omitted    equ 10001000b; Value of omitted is null string.
 = 0089				     $Variable   equ 10001001b; Only used at compile time.
 = 008A				     $Constant   equ 10001010b; Only used at compile time. (Untyped constant.)
 = 008B				     $Label      equ 10001011b;
 = 00C0				     $AwayString equ 11000000b;
				     ; NYI $AwayNumber equ 11110000b;
				     ; The 01 tags don't reach the runtime stack.
				     ; (That avoids a test when type checking operands now and allows future use.)
 = 0040				     $Dropped    equ 01000000b;
 = 0050				     $Exposed    equ 01010000b;
 = 0060				     $Stem       equ 01100000b;
 = 0044				     $MsgNum     equ 01000100b; Msg number in Major/Minor form.
 = 0048				     $Sigl       equ 01001000b; Jump point still as code offset.
				     ; Not to be confused with the bits from the table of characters:
				     XlatBDLS macro ;; 0=Blanks 1=Digits 2=Letters 3=Special
				      
; Picks up attributes of current char and sets flags.
				      xlat Bptr cs:[bx]
				      test al,0C0h
				     endm
				     Down macro
				      sub StackDi,$StrideV
				     endm
				     Up macro
				      add StackDi,$StrideV
				     endm
				     DownCare macro
				      lea StackDi,(-$StrideV)[StackDi]
				     endm
				     UpCare macro
				      lea StackDi,$StrideV[StackDi]
				     endm
				     ; Hard & soft cursors return.
				     RetSi macro
				      pop CursorSi
				      ret
				     endm
				     ; Macros for some common idioms in Pcode making.
				     OpAl macro $p
				       mov al,$p
				       call PcodeOp
				     endm
				     OpRet macro $p
				       mov al,$p
				       jmp PcodeOp
				     endm
				     EvAh macro $p
				       mov ah,$p
				       call TraceEvent
				     endm
				     EvRet macro $p
				       mov ah,$p
				       jmp TraceEvent
				     endm

				     ; Macros are used to make that clear where code is run out of the interpreter
				     ; loop, and to allow experiments in how the return is made.
				     ; These experiments never worked out because of the difficulty in having some
				     ; operations that needed to be routines (eg Assign as part of ControlVar) and
				     ; some that didn't.  Changing code to achieve sometimes-routine is a speed
				     ; killer.

				     Back macro
				     jmp XCycle
				     endm
				     BackRet macro
				     ret
				     endm

				     ; When all the operations end with a jump to XCycle we can turn them into
				     ; callable routines by sticking a ret instruction the code at XCycle.
				     ; Performance killer so rarely used.
 = 00C3				     $ret equ 0C3h
				     CodeModeR macro
				      push Wptr cs:XCycle
				      mov Bptr cs:XCycle,$ret
				     endm
				     UnCodeMode macro
				      pop Wptr cs:XCycle
				     endm

				     Repmovsb macro
				     local IsEven
				     if 1
				      rep movsb
				     endif
				     if 0
				     ; This ought to be faster but didn't seem to be. Perhaps jnc high cost.
				      shr cx,1
				      rep movsw
				      jnc IsEven
				      movsb
				      IsEven:
				     endif
				     endm

				     ; There is a "mv" macro that moves registers by push & pop.
				     ; There is a "move" that saves typing when memory-to-memory.
				     ; Here is "Mv" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by push & pop.
				     ; Here is "Move" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by shuffling through general registers.
				     Mv macro To,From
				     ; "Move" is faster than "Mv" and no bigger, if there is a spare register.
				        pushd From.OverExpo
				        pop To.OverExpo
				        pushd From.OverMant
				        pop To.OverMant
				     endm

				     Move macro To,From,Via
				     ; Move of a Rexx value. Convention is to use ecx:eax
				      ifb <To>
				     ; No target means load usual registers.
				        mov ecx,From.OverExpo
				        mov eax,From.OverMant
				      elseifb <From>
				     ; No source means store from usual registers.
				        mov To.OverExpo,ecx
				        mov To.OverMant,eax
				      elseifb <Via>
				     ; Copy via usual registers.
				        mov ecx,From.OverExpo
				        mov To.OverExpo,ecx
				        mov eax,From.OverMant
				        mov To.OverMant,eax
				      else
				     ; Copy via specified register.
				       mov Via,From.OverExpo
				       mov To.OverExpo,Via
				       mov Via,From.OverMant
				       mov To.OverMant,Via
				      endif
				     endm

 0006				     FarpX struc
 0000	    0000 [ Fr dword Overlay
	     00000000
	    ]
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
 0004	    0000 [		      Limit word Overlay
	     0000
	    ]
 0004  0000			      Len word 0
				     FarpX ends


 0008				     Vshape union
				      struc; When containing a short string.
 0000	    0007 [		       String db 7 dup(?)
	     00
	    ]
 0007  00			       Dtype db ?                        ; Whether string or not and used length.
				      ends
				      struc; When binary number
				       Sign byte Overlay     ; Odd means negative mantissa.
				       ExpAnd dword Overlay  ; Exponent and sign of mantissa.
				        ExpoUses db 3 dup(?)
				        ExpoSign db ?        ; Sign of exponent.
				       Mantissa dword Overlay
				        MantLow word ?
				        MantHigh word ?
				      ends
				      struc; When treated as just bytes.
				       OverExpo dword ?
				       OverMant dword ?
				      ends
				      struc; When referencing a long string.
				       FarpX <>
				       dw ?                              ; Covers Dtype.
				      ends
				      struc; When referencing label information
				       LabelValue word ?                 ; Offset in Pcode.
				       dword ?
				       LabelType word Overlay
				       byte ?                            ; 0 = normal, 1 = TraceOnly
				       db ?                              ; Covers Dtype. Will be $Label.
				      ends
				      struc; When compile time stack item for a constant.
				       WhichCon word ?                  ; Offset under ProgScope.
				       PcodePos word ?                  ; Where it will be in Pcode.
				       db 4 dup(?)                       ; Covers Dtype. Will be $Constant.
				      ends
				      struc; When compile time stack item for a resolved target.
				       HeldOver word ?                   ; To go in Pcode eventually.
				       db 6 dup(?)                       ; Covers Dtype. Will be $NullString
				      ends
				      struc ; When used to look up symbols.  Dtype not relevant then.
				     ; Moot whether this is really a Vshape but pretending it is allows use of Vbx.
				       Pair dd 0 dup(?)                  ; Next two together.
				        Lower Ushortp ?                  ; a subtree.
				        Higher Ushortp ?                 ; a subtree
				       Here charp ?                      ; to the symbol.
				      ends
				     Vshape ends
				     ; V. is for Vshape objects addressed by [di+bp]; eg variables on the stack.
 = (Vshape ptr[bp+di])		     V is <(Vshape ptr[bp+di])>
				     ; 1-origin numbers for the parameters of bif, but V is used for V1 (and result).
				     ; So lhs and rhs of binary operation are V and V2, result overlays V.
				     ; Of course, changing di by $StrideV is an alternative to using different Vn.
 = 0008				     $StrideV equ size Vshape
 = 0003				     $ShiftV equ 3
 = (Vshape ptr[bp+di-$StrideV])	     V0 is <(Vshape ptr[bp+di-$StrideV])>
 = (Vshape ptr[bp+di-2*$StrideV]     V00 is <(Vshape ptr[bp+di-2*$StrideV])>
   )
 = (Vshape ptr[bp+di+$StrideV])	     V2 is <(Vshape ptr[bp+di+$StrideV])>
 = (Vshape ptr[bp+di+2*$StrideV]     V3 is <(Vshape ptr[bp+di+2*$StrideV])>
   )
 = (Vshape ptr[bp+di+3*$StrideV]     V4 is <(Vshape ptr[bp+di+3*$StrideV])>
   )
				     ; Vsi. is for Vshape objects addressed by [si+bp]; variables on the stack.
 = (Vshape ptr[bp+si])		     Vsi is <(Vshape ptr[bp+si])>
				     ;Vsif. is for Vshape objects addressed by fs:[si]; Variables of procedure.
 = fs:(Vshape ptr[si])		     Vsif is <fs:(Vshape ptr[si])>
				     ; Vdid. is for Vshape objects addressed by ds:[di]
 = ds:(Vshape ptr[di])		     Vdid is <ds:(Vshape ptr[di])>
				     ; Vsid. is for Vshape objects addressed by ds:[si]
 = ds:(Vshape ptr[si])		     Vsid is <ds:(Vshape ptr[si])>
				     ;Vbx. is for Vshape objects addressed by ds:[bx]
 = ds:(Vshape ptr[bx])		     Vbx is <ds:(Vshape ptr[bx])>
				     ;Vbxf. is for Vshape objects addressed by fs:[bx]; Variables of procedure.
 = fs:(Vshape ptr[bx])		     Vbxf is <fs:(Vshape ptr[bx])>
 = fs:(Vshape ptr[bx-$CaseTarget     Vbxt is <fs:(Vshape ptr[bx-$CaseTarget])>
   ])
 = fs:(Vshape ptr[bx+$StrideV])	     Vbxf2 is <fs:(Vshape ptr[bx+$StrideV])>
				     ;Vbxs. is for Vshape objects addressed by ss:[bx]; Variables on the stack.
 = ss:(Vshape ptr[bx])		     Vbxs is <ss:(Vshape ptr[bx])>
				     ;Ve. is for Vshape objects addressed by es:[bp]; (Saves a byte sometimes)
 = es:(Vshape ptr[bp])		     Ve is <es:(Vshape ptr[bp])>
 = fs:(Vshape ptr[bp])		     Vf is <fs:(Vshape ptr[bp])>
				     ;Vbxe. is for Vshape objects addressed by es:[bx]
 = es:(Vshape ptr[bx])		     Vbxe is <es:(Vshape ptr[bx])>
				     if 0
				     endif
 0028				     Dshape struc; The elements of soft stack for DO loops.    (And INTERPRET)
				     ; Here the n of "DO n;" will wind up.
				     ; Also x of DO j=x...  We don't need to retain that through the DO-END, but
				     ; harmless to do so. (Overlaid when DO A.K=....)
 0000	    0000 [		      TailsAt word Overlay; Where the pcode to reload tails is.
	     0000
	    ]
 0000	    0000 [		      Subject Vshape 0 dup(<>); When block is for an INTERPRET.
	     0007 [
	      00 00
	     ]
 0000	     0000 [		      CVinit Vshape 0 dup(<>)
	      0007 [
	       00 00
	      ]
 0000	      0007 [		      Reps Vshape <>
	       00
	      ] 00
 0008	      0007 [		      To Vshape <>
	       00
	      ] 00
 0010	      0007 [		      By Vshape <>
	       00
	      ] 00
 0018	      0007 [		      ForCount Vshape <>
	       00
	      ] 00
				     ; The rest is made similar to a Vshape so that Bcode can overlay Dshape as
				     ; variables.
 0020	      0000 [		      PcodePos charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0020  0000			      Iteration charp ?; Where to branch on ITERATE
 0022  0000			      Leaving charp ?  ; Where to branch on LEAVE
 0024	      0000 [		      UpDO charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0024  0000			      CV charp ?; Offset of the control variable.
 0026  00			      byte ?
 0027  00			      Rec byte ?;  MASM confused when LoopsRec<> used.
				     Dshape ends
 = 0028				     $StrideD equ size Dshape
				     ; D. is for Dshape objects addressed by [di+bp]; the DO nesting.
				     ; These objects are addressed from partway through them.  This is because the
				     ; XCycle loop benefits from moving StackDi over the "previous operand" when
				     ; loading the latest operand. But the "previous operand" may actually have
				     ; been one of these DO control blocks.
				     ; Use D1 to address the DO block when StackDi has been upped to indicate
				     ; there is a value stacked later than the DO block.
 = (Dshape ptr[bp+di-$StrideD+$S     D is <(Dshape ptr[bp+di-$StrideD+$StrideV])>
   trideV])
 = (Dshape ptr[bp+di-$StrideD])	     D1 is <(Dshape ptr[bp+di-$StrideD])>

				      FRec record Qual:1,Read:1,Open:1,BeenRead:1,BeenWrite:1,
				                  WriteMode:1,IsSource:1,BeenCompiled:1,FFpad:8
 001A				     Fshape struct ; Data for a file, the key is the file name.
 0000  0000			       Flags FRec <>
 0002  0000			       ToQual word ? ; To item for fully qualified name.
 0004  00000000			       Lines Ulong ?
 0008  0000			       Hand Handle ?
 000A  00000000			       Other_Position Ulong ? ; A position on the file, provided by DOS.
 000E  00			       Exten byte ?; 1=REX/CMD 2=COM 3=EXE 4=BAT
 000F  00			       TraceWidth byte ?; How many chars in a clause identifier.
 0010  0000			       Symbols Segp ? ; Saved from Zone when file inactive.
 0012  0000			       Code Segp ?
 0014  0000			       Vars Segp ?
 0016  0000			       Consts Segp ?
 0018  0000			       ProgScope Segp ?
				     Fshape ends
 = 001A				     $StrideF equ size Fshape
				     ; F. is for Fshape objects addressed by [bx]; a file.
				     ; An Fshape is put ahead of a Jshape.
 = (Fshape ptr[bx-$StrideF])	     F is <(Fshape ptr[bx-$StrideF])>

 0008				     EnvBlock struc 2
 0000  0000			      EnvNumber    word ?
 0002  0000			      EnvResourceI word ?
 0004  0000			      EnvResourceO word ?
 0006  0000			      EnvResourceE word ?
				     EnvBlock ends
				     if 1; Private to memory object
 0006				     Ashape struc; Describe pieces of memory got from Dos, and part of them used.
 0000  0000 0000		      Fr Farp <>
 0004  0000			      Amount Ushort 0
				     Ashape ends
				     ; A. is for Ashape objects addressed by [si+bp]; For memory allocation.
 = (Ashape ptr[bp+si])		     A is <(Ashape ptr[bp+si])>
 = 0006				     $StrideA equ size Ashape
				     endif
 0015				     InsBlock struc;  Used by issuing of messages, to deduce inserts.
 0000	      0000 [		      MajMin word Overlay    ; This is an error detected.
	       0000
	      ]
 0000  00			       Minor byte ?
 0001  00			       Major byte ?
 0002  0000			      Value word ?           ; Soft stack offset of value.
 0004	      0000 [		      Named Ushort Overlay
	       0000
	      ]
 0004  0000			      Position Ushort ?
 0006  0000			      KeysList charp ?       ; Yields keyword list
 0008  00			      ArgNum byte ?
 0009  00			      Desc byte ?            ; To find text of <Description>
 000A	      0000 [		      Hex byte Overlay
	       00
	      ]
 000A  00			      Char byte ?
 000B  0000			      Options charp ?        ; Msg 40.28
 000D  0000			      OptsHi charp ?         ; Msg 40.28
 000F  0000			      Digits word ?          ; Msgs 26.1 and 33.1  Don't overlay, zero meaningful.
 0011  0000			      TokPos charp ?         ; Position of token within segment holding source.
 0013  0000			      TokLen Ushort ?        ; Ushort although inserts have low limit length.
				     InsBlock ends

				     ; "Interacting" is a bug for "Interactive" ?. Pad 8 makes byte offset zero.
				     LevelRec record Lpad:8,InheritDone:1,DigitsSet:1,IsProcedure:1,IsExternal:1,
				         IsFunction:1,Lpad2:3

				     LevelRecI record LIPad:14,Interactive:1,ConditionInstruction:1
				     ; Instruction.Condition and ConditionInstruction are the same value.

				     ConditionRec record Enabling:1,Delayed:1,PendingNow:1,Instruction:1,CRspare:4

 007C				     Lshape struc; The elements of soft stack for invocations.
				     ; The part inherited from the level above. (When there is one.)
				      align 4; We move the inherited bit using doublewords.
 0000	      0000 [		       DigitsFuzz dword Overlay
	       00000000
	      ]
 0000  0000			       Digits Ushort ?
 0002  0000			       Fuzz Ushort ?
 0004  00			       Form char ?
 0005  0000000000000000		       StartTime qword ?
 000D	      0000 [		       TraceLetter char Overlay
	       00
	      ]
 000D  0000			       TraceWord word ?; LevelRecI <>.
 000F  0000 0000 0000 0000	       Active EnvBlock <>
 0017  0000 0000 0000 0000	       Alternate EnvBlock <>
 001F  00			       Syntax ConditionRec <>
 0020  00			       LostDigits ConditionRec <>
 0021  00			       NoValue ConditionRec <>
 0022  00			       NotReady ConditionRec <>
 0023  00			       Error ConditionRec <>
 0024  00			       Failure ConditionRec <>
 0025  00			       Halt ConditionRec <>
 0026	      0007 [		       TrapName word 7 dup(?)
	       0000
	      ]
 0034  0000			       EventLevel word ?   ; Only used for Halt.
 0036  0000			       Condition word ?    ; As CONDITION bif result(C)
 0038	      0007 [		       ConditionDescription Vshape <>; As CONDITION bif result(D)
	       00
	      ] 00
 0040	      0007 [		       ConditionExtra Vshape <>; As CONDITION bif result(E)
	       00
	      ] 00
				      align 4; We move the inherited bit using doublewords.
 0048	      0000 [		       Inherit char Overlay; End of inherited.
	       00
	      ]
 0048  0000000000000000		      ClauseTime qword ?
 0050  0000000000000000		      ClauseLocal qword ?
 0058  0000000000000000		      PendingDescription qword ?
 0060  0000000000000000		      PendingExtra qword ?
 0068  0000			      LevelDO charp ?;  Level's CurrentDO held over call.
 006A  0000 0000		      StackSave Farp <>; To make save over DosExecute recursive.
 006E  0000			      File charp ?     ; Save which external file is source when external call made.
 0070  0000			      ProgScope Segp ? ; Saved values of constants, when external call.
 0072  0000			      VarScope Segp ?  ; Saved values of variables, when external call.
				      align 4
				     ;The Lshape is normally addressed a few bytes ($StrideV) down from its high end.
 0074	      0000 [		      Access word Overlay; MASM gets confused if this is attached to the LevelRec.
	       0000
	      ]
 0074  0000			      Flags LevelRec <>
 0076  0000			      UpLevel charp ?; Invoker's block.
 0078  0000			      Resume charp ? ; On return from invoke from here.
 007A  0000			      Arg0 charp ?   ; Parameters to this invoke.
				     Lshape ends
 = 007C				      $StrideL equ size Lshape
				     ; L. is for Lshape objects addressed by ss:[di+bp]; the level of the execution.
 = (Lshape ptr[bp+di-$StrideL+$S     L is <(Lshape ptr[bp+di-$StrideL+$StrideV])>
   trideV])
				     ; Lsi. is for Lshape objects addressed by ss:[si+bp]
 = (Lshape ptr[bp+si-$StrideL+$S     Lsi is <(Lshape ptr[bp+si-$StrideL+$StrideV])>
   trideV])
				     ; Lbx. is for Lshape objects addressed by ss:[bx]; the level of the execution.
 = ss:(Lshape ptr[bx-$StrideL+$S     Lbx is <ss:(Lshape ptr[bx-$StrideL+$StrideV])>
   trideV])

				     ; LoopsRec is used only in Dshape.
				     ;HasDot:1,      ; When DO X.=
				     ;HasDots:1,     ; When DO X.Y =
				     ;HasTo:1,
				     ;HasFor:1,
				     ;ByDown:1,      ; When control variable values are going down.
				     ;IsInterp:1     ; When block is for INTERPRET, not DO.
				     LoopsRec record LoopsPad:2,HasDot:1,HasDots:1,HasTo:1,HasFor:1,IsInterp:1,
				                     ByDown:1; ByDown last - see use in CompareTo

				     ; API_Enabled:1,   Controls "Variable Pool" interface.
				     ; NoSource:1,      $5.10.11, but no need to implement.
				     ; RandomSeeded:1,  Has the seed been initialized?
				     ; NotS9:1,         Off if numerics are 9 digit SCIENTIFIC.
				     ; The following are to do with compiling - they are off in execution.
				     ; LabelsBad:1,     On when the compile is of text from INTERPRET.
				     ; Repass:1,        When user overides Bif name.
				     ; FirstBetween:1,  On when parsing should start with a Between call.
				     ; EndSource:1,     Helps parser detect end-of-source.
				     ; BifCheck:1,      Tells whether Bif check failed, for compile time .
				     ; TraceIF:1,       Controls trace output.
				     ; ShowELSE:1,      Controls trace output.
				     ProgramRec record API_Enabled:1,
				        Repass:1,
				        LabelsBad:1,
				        FirstBetween:1,
				        EndSource:1,
				        BifCheck:1,RandomSeeded:1,NotS9:1,TraceIF:1,ShowELSE:1,PRSpare:6

				     ; InTypes:2     What are the types of the input operand(s)?
				     ; ResultType:2  Mark result on stack with its type.
				     ; AppendNum:1   When opcode is followed by a number.
				     ; AppendRef:1   When opcode (plus maybe number) is followed by a reference.
				     ; DownOne:1     On if operator leaves stack down one on when it started.
				     ; EndsClause:1  On if operator ends a clause. (Only for internal checks)
				     OperatorRec record InTypes:2,ResultType:2,AppendNum:1,AppendRef:1,DownOne:1,
				                        EndsClause:1

				     ; The Dtype byte is too complex to describe as individual flags. See equates.

 000E				     Jshape struc
 0000	      0007 [		      Valued Vshape <>                  ; Will be addressable Vsid. and J.
	       00
	      ] 00
 0008	      0000 [		      Pair dd 0 dup(?)                  ; Next two together.
	       00000000
	      ]
 0008  0000			      Lower Ushortp ?                   ; a subtree.
 000A  0000			      Higher Ushortp ?                  ; a subtree
 000C  0000			      KeyLen word ?                     ; Always a word of length. Chars may follow.
 000E	      0000 [		      Key char 0 dup(?)
	       00
	      ]
				     Jshape ends
 = 000E				     $StrideJ equ size Jshape
				     ; J. is for Jshape objects addressed by [si]; To look up tails.
 = (Jshape ptr[si])		     J is <(Jshape ptr[si])>
				     ; Jbx. is for Jshape objects addressed by [bx]; To look up tails.
 = (Jshape ptr[bx])		     Jbx is <(Jshape ptr[bx])>
				     ; Jdi. is for Jshape objects addressed by [di]; To look up tails.
 = (Jshape ptr[di])		     Jdi is <(Jshape ptr[di])>

				     TokVal record  GrpNdx:6,SubNum:2; Shape of $name
				     TokRec record X02:1, NdxbT:5, Aim:10
				     KeyRec record KeyFlags:3,EndList:1, KeyLen:4
				     ; Shapes for interpreting syntax tables. Ensure match with table generator.
				     ShiftRec record HasShift:1, ErrorAlone:1, CatFlag:1, HasKeys:1, Reference:1,
				                     Direct:1,Indexb:5, Index:5
				     ErrorRec record HasShiftOn:1, ErrorAloneOn:1, MajorField:8, MinorField:6
				     RedRec record HasShiftOff:1, HasAction:1, PruneCt:2, Rtype:2, Rstate:10
				     ; Every element on the parser stack will have the same size but the contents
				     ; are not always the same, except for State which is the reference state
				     ; needed by the parser mechanism.  The other fields are used for error
				     ; message data, and code generation.
				     ; Field order of Sshape is sensitive, matched to pushes that create an item.
				     ParserRec record ParserPad:12,DoRep:1,DoCV:1,Forever:1,DoDataHost:1
 0010				     Sshape struc
 0000  0000			      State word ?
 0002	      0000 [		      Parser word Overlay
	       0000
	      ]
 0002  0000			      ParserRec <>
				     ; Some of these fields could logically be overlaid but they are not, so that
				     ; logic is avoided in deciding what to push. (They are all pushed)
				     ; Actually that applies to just ClauseWas.
 0004  0000			      ClauseWas  word ?; Line number for message 10.n and 7.n
				      union
				       struct; This one for an operation. Element is made on basis that it is this.
 0006  0000			        Token Ushort ?; Numeric coding of the operation.
 0008  00000000			        Operation dword ?; ASCII coding with length ahead, eg 3,">>=".
 000C  0000			        Caller word ?; Resolved reference to what is to be invoked.
 000E  0000			        Parms Ushort ?; To compute how many arguments there are.
				       ends
				       struct; This overlay for info on a SELECT structure. (Also IF & DO)
				        JumpSite word ?; Records how Pcode jumps from WHEN test to WHEN test.
				                       ; (Also used by IF-ELSE)
				        SoFar charp Overlay; For TraceOnly
				        WhatCV charp Overlay; Control variable identification.
				        SelectSite word ?; Records how Pcode jumps from end of WHENs to end SELECT.
				       ends
				      ends
				     Sshape ends
				     ; S. is for Sshape objects addressed by [si+bp]; the parser stack.
 = (Sshape ptr[bp+si])		     S is <(Sshape ptr[bp+si])>
 = 0010				     $StrideS equ size Sshape
 = (Sshape ptr[bp+si+$StrideS])	     S1 is <(Sshape ptr[bp+si+$StrideS])>
 = (Sshape ptr[bp+si+2*$StrideS]     S2 is <(Sshape ptr[bp+si+2*$StrideS])>
   )
				     ParmsRec record ParmsMin:2,ParmsXtr:2,NonCheck:4
				     MiddleRec record NotLabel:1,SemiAfter:1,ValueBefore:1,
				       AbutOK:1,NoBlanks:1,ModEquals:1,EndClause:1,ImplicitValue:1,
				       CheckDO:1,TargetSymbol:1,Function:1,TakenConstant:1,LookLabel:1,
				       LookBin:1,DotOK:1,MRspare:1

				     ; More flags for clause level.
				     ; NotAssign:1,     Off includes DO j=
				     ; ClauseSet:1,     On when ClauseLine set.
				     ; Tailed:1,        Tells Lookup that compound name is on stack.
				     ; WasTailed:1,     Last Lookup was of tailed.
				     ; WasUpper:1,      Remembers UPPER option on PARSE.
				     ; OffFlag:1,       Remembers OFF of CALL OFF.
				     ; Condition:1,     Remembers there was a condition on CALL ON or SIGNAL ON.
				     ; Append:1,        Remembers there is APPEND during ADDRESS.
				     ; Signal:1,        Remembers when the verb was SIGNAL
				     ; CVar:1,          Remembers when there is a control variable on DO.
				     ; Repit:1,         Remembers when there is repetition part in DO.
				     ; PosEq:1,         Grouped with PosPlus & PosMinus - triggers in PARSE.
				     ; InParse:1,       On during Parse instruction. (Off when escape)
				     ; WasParse:1,      On during Parse instruction.
				       ClauseRec record WasUpper:1,OffFlag:1,Condition:1,Append:1,Signal:1,
				       ClauseSet:1,CVar:1,Repit:1,PosEq:1,NotAssign:1,
				       WasParse:1,InParse:1,Tailed:1,WasTailed:1,
				       PosPlus:1,PosMinus:1; Using 5-gap of PosEq and PosPlus.

				     ; Format5:1,       On for FORMAT bif with five args.
				     ; AssignDO:1,      On when assignment is for DO.
				     ; ForExpose:1,     On while executing EXPOSE.
				     ; FromIterCV:1,    Used when DO loop execution has dotted control variable.
				     ; ForBIF:1,        TargetMsg without expanding inserts. Needed for ERRORTEXT.
				     ; TokIsValue:1     Conditions error message insert.
				     ; ExpRange:1,      Number failure due to exponent oversize.
				     ; Description:1,   Used in msg production.
				     ; Compacted:1,     Used to detect a loop within Compaction.
				     ; BcodeInterpret:1, On when INTERPRET executing on behalf of Bcode.
				     ; MapOnly:1,       Used by Debug for when to fill allocations.
				     ; ParseUpper:1,    On when PARSE has UPPER, in execution.
				     ; ParseTrace:1,    On when PARSE tracing, in execution.
				     ; SourceFiles:1, On when source files rather than ordinary data files relevant.
				     ; BoolBefore:1,    On to prevent code generated for trace making undue prefix.
				     ; WasDropped:1     On to tell us that last load of variable found it dropped.
				     CancelRec record Format5:1,AssignDO:1,ForExpose:1,FromIterCV:1,
				      ForBIF:1,TokIsValue:1, ExpRange:1, Description:1, Compacted:1,
				      BcodeInterpret:1, MapOnly:1, ParseUpper:1, ParseTrace:1, SourceFiles:1,
				      BoolBefore:1, WasDropped:1

				     ; Dual:1,          On when the purpose of compiling is clause by clause run.
				     ; DualPending:1,   On when DualGen is to be set later.
				     ; DualGen:1,       On when Pcode for trace events is being made.
				     ; DualOnly:1,      On when Pcode for Dual differs from original.
				     GenRec record Dual:1,DualPending:1,DualGen:1,DualOnly:1,
				      GenSpare:12

				     ; Experience may show how many allocations the Dos space will be in.
 = 000A				     $Ashapes equ 10
				     ; Shortest code for addressing Header fields is varied. If mov with ax, then
				     ; 2-byte offset is reasonable because there are dedicated opcodes. Else it
				     ; will usually pay to specify indexing with a zero-value index because that
				     ; uses a one byte offset. The index can be bp when there is segment override.
				     ; Otherwise it may pay to zero si especially for the purpose.
 0010				     Hshape struct
 0000	      0000 [		      Hdw0 dword Overlay; This and next dword used when making a copy of a segment.
	       00000000
	      ]
 0000  0000			      SegSize Ushort ?  ; Bytes including our header.
				     ; The segments for different purposes need different subsets of these fields.
				     ; They all need SegSize because Compaction uses it.
				     ; The stack segment needs only SegSize because it has its own routine for
				     ; expansion on demand.
				     ; The pool-type segments only need SegSize&Bump; their size changes only when
				     ; the relevant Vars or Consts segment changes size.
 0002  0000			      Bump Ushort ?   ; Number of new bytes added each expansion
				     ; Things that grow independently (Symbols, Vars, Consts, SysFiles, and each
				     ; compound variable) need Avail and Trigger.
 0004  0000			      Avail Ushort ?  ; Place, below Trigger, for new-stuff-at-end.
 0006  0000			      Trigger Ushort ?; Limit before extension.
				     ; Link identifies the type of segment and allows Zone updates.
 0008  0000			      Link Ushort ?   ; To find slot in Zone that addresses this segment.
 000A	      0000 [		      TreeBin Ushort Overlay ; Field reused in the constants lookup segment.
	       0000
	      ]
 000A	      0000 [		      Original Ushort Overlay ; Field reused in the Pcode segment.
	       0000
	      ]
				                              ; (End of original Pcode.)
 000A  0000			      UpPool Segp ?   ; When segment is a pool. (Also used as chain of free ones)
 000C  0000			      Probe Ushort ?  ; Place to start search if this is a lookup type segment.
 000E	      0000 [		      TreeProg Ushort Overlay ; Field reused as root for source file names lookup.
	       0000
	      ]
 000E  0000			      Labels Ushort ? ; Alternative needed since label and constant trees same seg.
				     Hshape ends
 = 0010				     $StrideH equ size Hshape
				     ; H. is for Hshape objects addressed by [si]; Headers on segments (si=0).
 = (Hshape ptr[si])		     H is <(Hshape ptr[si])>
				     ; Hd. is for Hshape objects addressed by ds:; Headers on segments.
 = (Hshape ptr ds:[0])		     Hd is <(Hshape ptr ds:[0])>
				     ; He. is for Hshape objects addressed by es:[bp]; Headers on segments.
 = (Hshape ptr es:[bp])		     He is <(Hshape ptr es:[bp])>
				     ; Hf. is for Hshape objects addressed by fs:[bp]; Headers on segments.
 = (Hshape ptr fs:[bp])		     Hf is <(Hshape ptr fs:[bp])>
				     ; Hg. is for Hshape objects addressed by gs:[bp]; Headers on segments.
 = (Hshape ptr gs:[bp])		     Hg is <(Hshape ptr gs:[bp])>

				     ; Zshape is resized by StackSafe, not by MoreSpaceEs, so doesn't need all
				     ; the Hshape header. It does need SegSize in correct location though because
				     ; Compaction treats it like a headed segment.
 137C				     Zshape struc
 0000	      0000 [		      w word Overlay       ; Not used in this position - always used like Z.w[index]
	       0000
	      ]
 0000  0000			      SegSize word ?       ; Bytes.
 0002	      0000 [		      ProgramCancel dword Overlay; Used for zeroing.
	       00000000
	      ]
 0002  0000			      Program ProgramRec <>; Program flags
 0004  0000			      Cancel CancelRec <>  ; Flags for transient logic.
 0006  0000			      Stack word ? ; Current variable for Compaction. (Top of soft stack-$StrideV)
 0008  0000			      ClauseLine Ushort ?  ; Line this clause starts on. (First token)
 000A  0000			      Middles MiddleRec <> ; Extension of Clause. Keep with Clause for zeroing.
 000C  0000			      Clause ClauseRec <>  ; Compile time clause flags
 000E  0000			      Gen GenRec <>        ; Flags for control of what gets compiled.
 0010  0000			      KWMiddle charp ?     ; List of search keywords.
 0012  0000			      KWFound Ushort ?     ; Latest keyword found.
 0014  0000			      Stdout Handle ?      ; A constant but potential redirection.
 0016  0000			      Stderr Handle ?      ; A constant but potential redirection.
 0018  0000			      SourceHandle Handle ?
 001A  0000			      HowInvoked Ushort ?  ; Length of COMMAND/FUNCTION/SUBROUTINE.
 001C  00			      Radix byte ?         ; Normally has value 10.
 001D	      0006 [		      AxAsNum char 6 dup(?); For result of Ax2DsSiCx
	       00
	      ]
 0023	      0005 [		      Tag char 5 dup(?)    ; For trace. Joined to AxAsNum
	       00
	      ]
 0028  00000000			      Seed dword ?         ; For Random bif.
 002C  0000			      ParseResetSp charp ? ; Where the parser started work on the hard stack.
 002E  0000			      XCycleResetSp charp ?; Where the execution started work on the hard stack.
 0030  0000			      Dumper word ?        ; Handle when we are writing Pcode to disk.
 0032  0000			      Stash word ?         ; Various
 0034  0000			      Resolved charp ?     ; Result of Lookup.
 0036  0000			      Cursor charp ?       ; Offset into code. (Compile time)
 0038  0000			      Stream charp ?       ; The current stream.  In SysFiles segment.
 003A  0000			      Queue  charp ?       ; The FileBx for CRXREXX.QUE in SysFiles segment.
				     ; Compaction exploits these Segp things being adjacent.
 003C	      0000 [		      InsSource dword Overlay
	       00000000
	      ]
 003C	      0000 [		      SysFile dword Overlay
	       00000000
	      ]
 003C  0000			      File charp ?         ; Current external file of source.
 003E  0000			      SysFiles Segp ?      ; DOS interface
 0040  0000			      Consts Segp ?        ; To an array, fixed size per constant.
 0042  0000			      Vars Segp ?          ; To an array, fixed size per variable.
 0044  0000			      ProgScope Segp ?     ; Shadow of Consts. Order is exploited, see MoreSpaceEs.
 0046  0000			      VarScope Segp ?      ; Shadow of Vars.
 0048  0000			      Symbols Segp ?       ; To a write-once for names and constants.
 004A  0000			      Code Segp ?          ; To the internal code.
 004C  0000			      Zone Segp ?          ; Convenient place for Compaction to find address.
				     ; End of section organised for Compaction.
 004E  0000			      Stem Segp ?          ; Used when a stem wants MoreSpaceEs.
 0050  0000			      PoolPool Segp ?      ; Spare VarScope copies.
 0052  0000			      Level charp ?        ; Latest level of invocation.
 0054  0000			      Base0 charp ?        ; Parser time, for checking how many operands pushed.
 0056  0000			      CurrentDO charp ?    ; Junction of DO blocks and stacked values.
 0058  0000			      ResumeP word ?       ; Save Pcode address while Bcode execution.
 005A	      0000 [		      ResumeDF dword Overlay
	       00000000
	      ]
 005A  0000			      ResumeD word ?       ; Digits() preserved over Bcode execution.
 005C  0000			      ResumeF word ?       ; Fuzz() preserved over Bcode execution.
 005E  00			      ResumeS char ?       ; S/E mode preserved over Bcode execution.
				     ; Section set by ZoneNumerics.  (cf NotS9)
 005F	      0000 [		      DigitsFuzz dword Overlay
	       00000000
	      ]
 005F  0000			      Digits Ushort ?      ; Current digits().
 0061  0000			      Fuzz Ushort ?        ; Current fuzz().
 0063  00000000			      Ceiling dword ?      ; 1eN where N is current digits().
 0067  00000000			      DivBreak dword ?     ; To test for enough digits made in division.
 006B  00000000			      TwiceDigits dword ?  ; 2*N where N is current digits().
 006F  0000			      UseGeneral Ushort ?  ; On for mandatory use of ArithGeneral
				     ; end section set by ZoneNumerics.
				     ; Inserts for messages are divided into (a) those that stay constant or which
				     ; we always want to set when compiling, and (b) those that might be undesirably
				     ; changed when we rescan during execution to find the line number for a message.
				     ; The latter are in a block for save/restore.
				     ; "Ins..." is used as help to identify.
 0071  0000			      InsLine Ushort ?     ; Value for insert
 0073  00			      InsBif byte ?        ; Bif offset.
 0074  00000000			      InsOperator dword ?  ; Actual chars.
 0078  0000			      InsUnqual charp ?    ; Offset in SysFiles. For <source> insert, msg 43.1
 007A	      0000 [		      Insert InsBlock <>   ; For message. The saved copy is Inserts.
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 008F	      0000 [		      Inserts InsBlock <>
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 00A4  00			      SignM byte ?         ; Of mantissa
 00A5  00			      SignE byte ?         ; Of exponent
 00A6  0000			      MantPos charp ?      ; Where mantissa starts.
 00A8  0000			      MantPosZi charp ?    ; Beyond end
 00AA  0000			      ExpPos charp ?       ; Where exponent starts.
 00AC  0000			      ExpPosZi charp ?     ; Beyond end
 00AE  0000			      ExpSign word ?
 00B0  0000			      MantSize word ?
 00B2  00			      OpIs byte ?          ; Remembers operator in execution of it.
 00B3  00			      Flags byte ?         ; In BifTypes
 00B4  00			      BifParmsHi byte ?    ; For Bifs to test how many parameters on instance.
 00B5  00			      BifByte byte ?       ; Combines bif number and a parms count.
				     ; Trace section
 00B6  00000000			      TraceAlign dword ?; Beginning of line of source as offset on source file.
 00BA  00000000			      TraceSource dword ?; Beginning of section of source to be shown.
 00BE  00000000			      TraceEnds dword ?; End of section of source to be shown.
 00C2  0000			      TraceSourceColumn word ?
 00C4  0000			      TraceEndsColumn word ?
 00C6  0000			      DualCode charp ?; Beginning of Pcode for one clause.
 00C8  00			      TraceOp byte ?   ; Trace info for current Pcode operation.
 00C9  00000000			      Relative dword ?; Adjustment between position on file and position in buffer.
 00CD  00000000			      RelativeNow dword ?; Used when Serial contains section of source.
 00D1  0000			      Continue word ?; Pcode offset of next clause.
 00D3  0000			      StackX word ?; Hold StackDi over parsing.
 00D5  0000			      TraceLine word ?; Last shown ClauseLine.
 00D7  00000000			      InhibitTrace dword ?
 00DB  00000000			      InhibitPauses dword ?
 00DF  0000			      Target word ?; Used to carry branch value from original pcode to dual.
				     ; Trace section end
				     ; Main also [ Tokens
 00E1  0000			        Scanp charp ?        ; Where the scan has reached. Zero when executing.
 00E3  0000			        EndUsedBuffer charp ?; Where marker to interrupt scan is placed.
 00E5  0000			        NearEnd charp ?      ; Towards end of buffer.
				     ;]
 00E7  00			        CatOp byte ?         ; $pCat or $pAbut
 00E8  00			        RadixBadWhite byte ?
 00E9  0000			        BackExponent charp ?
 00EB  0000			        LastContent charp ?
 00ED  0000			        CommaLine word ?; NonZero if previous line ended with non-continuation comma.
 00EF  0000			        Condition Ushort ?   ; Latest condition keyword.
 00F1  0000			        UntilPlace Ushort ?  ; Place in Pcode. Held just over UNTIL expression.
 00F3  0000			        StemSym charp ?      ; Temp for A.B.C type Lookup
 00F5  0000			        SoFar word ?         ; Temp for A.B.C type Lookup
 00F7  0000			        PcodePos word ?      ; Used by ConstValue
 00F9  0000			        TraceOnly word ?     ; Used to detect 'trace only' labels.
 00FB  0000			      CompareAt word ?       ; For detecting compare Pcode optimizing.
 00FD  0000			      StackHi charp ?        ; Used for compound lookup.
 00FF  0000			      StackLo charp ?        ; Also for function arguments.
 0101  0000			      OnSoft charp ?         ; Where stacked target symbols start. PARSE compiletime.
				                             ; Tokens tells Pcode.
 0103  0000			      Tail charp ?           ; Work when Pcode made for tailed.
 0105  0000			      TokNum word ?          ; As tokenizer makes, parser sees.
 0107  0000			      TokNow word ?
 0109  0000			      TokWas word ?
 010B  0000			        TokData word ?       ; Data for parser derived from TokNum
 010D  0000			        Synch charp ?        ; Instruction pointer, into Pcode, for synching.
 010F  0000			        Lines Ushort ?       ; Count of lines
 0111  0000			        MsgBegin charp ?     ; Where sub-messages concatenated.
 0113  0000			        MsgSoFar charp ?     ; As sub-messages concatenated.
 0115  0000			        PreZi charp ?        ; End of message before expanding insertions.
 0117	      0000 [		        TargetMajMin word Overlay; This is message being output.
	       0000
	      ]
 0117  00			         TargetMinor byte ?
 0118  00			         TargetMajor byte ?
				        struc                ; See DOS command 4Bh
 0119  0000			         EnvSeg Segp ?
 011B  0000 0000		         ForPSP Farp <>
 011F  0000 0000		         Fcb1 Farp <>
 0123  0000 0000		         Fcb2 Farp <>
				        ends
 0127  0000			        AtPause charp ?       ; NYI
 0129  00			        ArgsB byte ?; For Arg() of BCycle bif.
 012A  0000			        ArgsB0 charp ?; For Arg(exp) of BCycle bif.
				     ; Workspace for the verbs can be shared.
				        struct; For Parse
 012C	      0000 [		         Parsee FarpX <>
	       00000000
	      ] 0000 0000
	      0000 [
	       0000
	      ] 0000
 0132  0000			         ParseeNum Ushort ?; Counts arguments for commas in parsing template.
 0134  0000			         PattLenEtc Ushort ?  ; Length of pattern. Temp for cursor.
 0136  0000			         BreakStart charp ?; Beginning of previous section delimiter.
 0138  0000			         BreakEnd charp ?  ; End of previous section delimiter.
				        ends
 013A  0000 0000 0000 0000	        EnvNow EnvBlock <> ; Used to execute ADDRESS
 0142  0000			      CatTotal word ?      ; Used by Abut$$ & Cat$$
 0144  0000			      LastTarget word ?    ; For detecting when to make $pUnstore.
 0146  0000			      NewJshape charp ?    ; Used by FindKey.
 0148  0000			      FromDos charp ?; A slot addressing a segment DOS gave us. (Cat optim. uses)
 014A  0000			      FromDosWas word ?; To test for cycled through them.
 014C  0000			      FromDosZi charp ?; Bound for FromDos
 014E	      000A [		      MemoryTable Ashape $Ashapes dup(<>)
	       0000 0000 0000
	      ]
 018A	      0000 [		      MemoryTableZi byte Overlay; Just used as an offset.
	       00
	      ]
 018A  0000			      Left charp ?     ; For compaction.
 018C  0000			      Right charp ?    ; For compaction.
 018E  00000000			      AllocBase dword ?; For compaction.
				     ; Grouping matters here.
 0192  0000			      DsWas Segp ?
 0194  0000			      DsNew Segp ?
 0196  0000			      EsWas Segp ?
 0198  0000			      EsNew Segp ?     ; Sometimes reloaded from.
 019A  0000			      FsWas Segp ?
 019C  0000			      FsNew Segp ?
 019E  0000			      GsWas Segp ?
 01A0  0000			      GsNew Segp ?
				     if Debug
 01A2  0000			      DebugStash word ?
 01A4  00000000			      DebugD dword ?
				     endif
 01A8  0000			      DigitCount Ushort ?  ; Checking radix string, Compile and execute.
				     ; Byte before Serial better not accidentally look like $Eof.
 01AA  00			      SerialNow byte ? ; Indicates what is in Serial.
 01AB	      11C8 [		      Serial char $SourceBufferSize dup(?)
	       00
	      ]
				      align 4
 1374	      0007 [		      CommandArg Vshape <>; Parameters from Command line.
	       00
	      ] 00
				     Zshape ends
				     ; Z. is for Zshape objects addressed by [bp]; the Zone
 = (Zshape ptr[bp])		     Z is <(Zshape ptr[bp])>

 0053				     Yshape struc
 0000  00000000			      dword ?; Overlays jmp.
 0004  00000001			      N1 dword 1
 0008  0000000A			      N10 dword 10
 000C  00000064			      N100 dword 100
 0010  000003E8			      N1000 dword 1000
 0014  00002710			      N1e4 dword 10000
 0018  000186A0			      N1e5 dword 100000
 001C  000F4240			      N1e6  dword 1000000
 0020  00989680			      N1e7 dword 10000000
 0024  05F5E100			      N1e8 dword 100000000
 0028  3B9ACA00			      N1e9 dword 1000000000
 002C  0019660D			      N1664525 dword 1664525; For Random
				      Assert $Limit_ExponentDigits eq 9
 0030  3B9AA2F1			      ExponHi dword 1000000000-$Limit_Digits
 0034  C4653602			      ExponLo dword -1000000000+2
 0038  0000			      Cseg Segp ?          ; To be where the machine code is.
 003A	      0000 [		      DOS dword Overlay; Default ADDRESS
	       00000000
	      ]
 003A	      0001 [		       db "DOS "
	       44 4F 53 20
	      ]
 003E	      0001 [		      DosPool db "ENVIRONMENT"; Pool name
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
 0049	      0001 [		       db "..."; Joined to following CrLf
	       2E 2E 2E
	      ]
 004C  22			      DqCrLf db '"'
 004D  0D 0A			      CrLf db 13,10
 004F  0000 0000		      StackSave Farp <>    ; To recover when only CS:IP survives.
				     Yshape ends
				     ; Y. is for Yshape objects addressed by [bp]; the constants.
 = (Yshape ptr cs:[bp])		     Y is <(Yshape ptr cs:[bp])>
 = (Yshape ptr cs:[2*ecx+ebp])	     Ycx2 is <(Yshape ptr cs:[2*ecx+ebp])>
 = (Yshape ptr cs:[si])		     Ysi is <(Yshape ptr cs:[si])>

				     ; These equs should follow the declares of shapes they depend on.
 = 0014				     $SizeConstsHeader equ $StrideH+4
				     ; Configuration variables (used by the implementation but not seen by the user's
				     ; program) are in the order the utility that makes Bcode has numbered them. The
				     ; $Reserved string matches.
				     ; Also constants & reserved variables that are always in ProgScope area.
 = 0014				     $?Omitted equ $SizeConstsHeader
 = 001C				     $?MN equ $?Omitted+$StrideV
 = 0024				     $?RS equ $?MN+$StrideV
 = 002C				     $?RESULT equ $?RS+$StrideV
 = 0034				     $?RC equ $?RESULT+$StrideV
 = 003C				     $?SIGL equ $?RC+$StrideV
 = 0044				     $?SysVars equ $?SIGL+$StrideV
				     ; See $Reserved for number of vars here.
 = 000B				     $SysCount equ 11
 = 0000				     ?OUTCOME equ 0; These are the numbers used in Bcode references.
 = 0044				     $?OUTCOME equ $?SysVars; These are the offsets used in machine code references.
				     ; ie where the system variables are in the ProgScope segment.
 = 0002				     ?BIF equ 2
 = 004C				     $?BIF equ $?SysVars+$StrideV
 = 0004				     ?STREAM equ 4
 = 0054				     $?STREAM equ $?SysVars+2*$StrideV
 = 0006				     ?STREAMSTATE equ 6
 = 005C				     $?STREAMSTATE equ $?SysVars+3*$StrideV
 = 0008				     ?RESPONSE equ 8
 = 0064				     $?RESPONSE equ $?SysVars+4*$StrideV
 = 000A				     ?LINEIN_POSITION equ 10
 = 006C				     $?LINEIN_POSITION equ $?SysVars+5*$StrideV
 = 000C				     ?CLAUSETIME equ 12
 = 0074				     $?CLAUSETIME equ $?SysVars+6*$StrideV
 = 000E				     ?CLAUSELOCAL equ 14
 = 007C				     $?CLAUSELOCAL equ $?SysVars+7*$StrideV
 = 0010				     ?MONTHS equ 16
 = 0084				     $?MONTHS equ $?SysVars+8*$StrideV
 = 0012				     ?WEEKDAYS equ 18
 = 008C				     $?WEEKDAYS equ $?SysVars+9*$StrideV
 = 0014				     ?STARTTIME equ 20
 = 0094				     $?STARTTIME equ $?SysVars+10*$StrideV
 = 009C				     $?Nine equ $?SysVars+11*$StrideV
 = 00A4				     $?Zero equ $?Nine+$StrideV
 = 00AC				     $?Null equ $?Zero+$StrideV
 = 00B4				     $?E equ $?Null+$StrideV
 = 00BC				     $?S equ $?E+$StrideV
				     ; These are variables that are always in current VarScope area.
 = 0010				     $?Discard equ $StrideH; Takes two because ends in dot.
 = 0020				     $?RESULTx equ $?Discard+2*$StrideV
 = 0028				     $?RCx equ $?RESULTx+$StrideV
 = 0030				     $?SIGLx equ $?RCx+$StrideV
				     ; Not in the table, but we need to use some character as an end-used-buffer
				     ; mark. (Saves checking address repeatedly) Using Linefeed helps comment scan.
 = 000A				     $EndBuffer equ $Lf
 = 0000				     $Whole     equ 0
 = 0004				     $WholeGE   equ 4
 = 0008				     $WholeGT   equ 8
 = 000C				     $Num       equ 12
 = 0010				     $M090      equ 16
 = 0014				     $WholeNum  equ 20
 = 0018				     $Pad       equ 24
 = 001C				     $Hex       equ 28
 = 0020				     $Stream    equ 32
 = 0024				     $Bin       equ 36
 = 0028				     $Symbol    equ 40

				     AllocAppend macro Goes:req
				      push si
				      mov si,Z.FromDos; The current allocation source.
				      mov ax,A.Fr.Pt
				      sub ax,V.Len
				      cmp ax,V.Pt
				      jne Goes
				     ; Here if offset fits. Also need to check same segment.
				      mov ax,V.Sg
				      cmp ax,A.Fr.Sg
				      jne Goes
				      mov es,ax
				     ; The segment could be full, but if possible take the extra.
				      mov ax,V.Pt
				      add ax,cx
				      jc Goes
				      cmp ax,A.Amount
				      ja Goes
				      mov A.Fr.Pt,ax
				      sub ax,cx
				      mov V.Len,cx
				      endm
				     ; Here are the numbers which go in the Attributes table.
				     ; Most of this is just for compiling but some equates are relevant to
				     ; execution so those have been put in declares.inc
				     ; First two bits for quick test of Whitespace, Letter, Digit, Special
				     ; $White equ 0 $Digit equ 64 $Letter equ 128 $Special equ 192
				     ; When it is not Special, the remaining bits can be flags.
				     ; When it is Special, there is a switch indexed by the rest of the byte.
				     ; This corresponds to the right six bits of TokVal so we can test in groups.
				     ; In practice it is "+ or -" that gets tested this way.
 = 00FC				      $Group equ 0FCh
 = $AttribPlus and $Group	      $PlusMinus equ $AttribPlus and $Group
				     ; The bits to the right of $White are free, and we could distinquish the
				     ; reak blank from blank equivalents but there seems no reason to do so.
				     ; We are short of a bit for letters. It would be nice to have flags for
				     ; conveniently testing "Ee", "Xx", "Bb", "01", ok as hex digit, having upper
				     ; case, and real-letter, as well as $Letter for the purposes of a symbol.
				     ; Something has to be left out, and real-letter would only be used in
				     ; DATATYPE().
				     ; We are short of a bit for digits. It is highly desirable to be able to scan
				     ; a number using lods and not have to refer to the value before xlat (since
				     ; xlat overwrites al). So we would like to have the value of the digit in the
				     ; low order of the attribute, as opposed to subtracting character '0' from the
				     ; raw character. That leaves two, which gives us difficulty if we want
				     ; OK-for-radix-B, OK-for-radix-X, and a Lower-case-letter. (Since we would
				     ; like to test the latter in the symbol recognition loop without distinquishing
				     ; letter/digit first.)
				     ; The solution seems to be to invert the lowercase flag. Then with blanks and
				     ; specials out of the way (jpe), the upperableness can be tested as zeroness
				     ; of Digit flag and NonUpable flag, together.
				     ; So the scheme for Letter-or-Digit is to make the right nibble dependent on
				     ; whether letter or digit, leaving two bits for OK-for-radix.
 = 0020				      $OKb equ 32
 = 0010				      $OKx equ 16
				     ; For letters:
				     ; $NonUpable equ 8 $Bb equ 4 $Xx equ 2 $Ee equ 1
				     ; $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; These values above $STRING go through switching like specials but are not
				     ; seen by the parser.
 = 0027				     $LineFeed equ $Eq-4
 = 0009				     $Invalid equ $UnAccept+1
 = 000A				     $Colon equ $UnAccept+2
 = 00D8				     $AttribAnd equ $Special+$And
 = 00D5				     $AttribOr equ $Special+$Or
 = 00EB				     $AttribEq equ $Special+$Eq
 = 00E4				     $AttribMinus equ $Special+$Minus
 = 00ED				     $AttribLt equ $Special+$Lt
 = 00F0				     $AttribGt equ $Special+$Gt
 = 00D2				     $AttribSlash equ $Special+$Slash
 = 00DC				     $AttribComma equ $Special+$Comma
 = 00E7				     $AttribLine equ $Special+$LineFeed
 = 00E5				     $AttribPlus equ $Special+$Plus
 = 00D1				     $AttribStar equ $Special+$Asterisk
 = 00FF				     $NoMatch equ $Special+63; No character has these attributes.

				     ;------------------------------------------------------------------------------
				     ; (Bcode is in the first module so that Bcode offsets on bcode.lst have the
				     ; same values as those occurring in registers during execution)
				     ;------------------------------------------------------------------------------
				     if Solid
				     ; Because of link order, this jump is at cs:0
 0000   3   E9 0000 E		     R:jmp Raise49
 0003   3   90			      nop
				     ; By putting constants in the first 128 bytes we can save a byte when
				     ; addressing them.
				      org 0
 0000  00000000 00000001	      Yshape <>
	      0000000A
	      00000064
	      000003E8
	      00002710
	      000186A0
	      000F4240
	      00989680
	      05F5E100
	      3B9ACA00
	      0019660D
	      3B9AA2F1
	      C4653602 0000
	      0001 [
	       44 4F 53 20
	      ]
	      0001 [
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
	      0001 [
	       2E 2E 2E
	      ] 22 0D 0A 0000
	      0000
				     ;------------------------------------------------------------------------------
				     ; The builtins done this way just need the code from ANSI and argument specs.
				     ;------------------------------------------------------------------------------
				     ; Firstness of MAX/MIN is used, see BcodeEntry.
				     ;$9.4.4
 0053  F7			     ParmsRec <3,3,0111b>
 0054				     BifMIN:
 0054 18 71 5B F0		     BIFMIN db 3*8+0,Frag11,$pControlVar,I_N-10
 0058  000D R			      dw $+13
 005A  F0 2B C2 9E F2 F2 D7	     db I_N-10,$pBifq,2*$BifARG+128,_NEXT-Tgt-10,MIN-10,_NEXT-12,_Gt
 0061  03 F4 9C C5 FC C1	      db +3,_NEXT-10,MIN-Tgt-10,_IterCV,MIN,_RetB

				     ;$9.4.3
				     ; All $Num
 0067  F7			     ParmsRec <3,3,0111b>
 0068				     BifMAX:; Note MAX MIN have their own Pcodes.
 0068 18 71 5B F0		     BIFMAX db 3*8+0,Frag11,$pControlVar,I_M-10
 006C  000D R			      dw $+13
 006E  F0 2B C2 9E F2 F2 D1	     db I_M-10,$pBifq,2*$BifARG+128,NEXT-Tgt-10,MAX-10,NEXT-12,_Lt
 0075  03 F4 9C C5 FC C1	      db +3,NEXT-10,MAX-Tgt-10,_IterCV,MAX,_RetB

				     ;$9.3.1
 007B  04			     db $WholeGE
 007C  9D			     ParmsRec <2,1,1101b>
 007D				     BifABBREV:
 007D 33 F2 C7 C9 05 F2 A8	     BIFABBREV db 6*8+3,Arg3-20,_Exists,_Then,+5,Arg3-20,LENGTH_-Tgt
 0084  CB 04 F0 2D A8 EE 2D EE	      db _Jump,+4,SUBJ,$pLength,LENGTH_-Tgt,SUBJECT,$pLength,SUBJ-2
 008C  2D D5 00 A6 F0 2D FC D5	      db $pLength,_Ge,00h,COND1-Tgt,SUBJ,$pLength,LENGTH_-2,_Ge,00h
	      00
 0095  A4 EE B5 EC 2D 2B FC	      db COND2-Tgt,SUBJECT,One,SUBJ-4,$pLength,$pBifq,2*$BifSUBSTR+128
 009C  EE D9 00 A2 FC F8 35 F6	      db SUBJ-2,_Seq,00h,COND3-Tgt,COND1,COND2-2,$pAnd,COND3-2,$pAnd
	      35
 00A5  C1			      db _RetB

				     ;$9.3.2
 00A6  18			     db $Pad
 00A7  04			     db $WholeGE
 00A8  99			     ParmsRec <2,1,1001b>
 00A9				     BifCENTER:
				     ;$9.3.3
				     ;ParmsRec <2,1,1001b> This one for benefit of utility seeking CENTRE info.
 00A9				     BifCENTRE:
 00A9 23 87 D7 0C F2 FA BB 32	     BIFCENTER db 4*8+3,Frag22,_Gt,+12,STRING,TRIM-2,String1,"2",$pIntDivide
	      47
 00B2  B5 3F F0 2B FC C1 F2	      db One,$pAdd,C_LENGTH-4,$pBifq,2*$BifSUBSTR+128,_RetB,STRING
 00B9  FC F0 2B 70 F8 3D BB	      db PAD-2,C_LENGTH-4,$pBifq,2*$BifCOPIES,TRIM-4,$pNegate,String1
 00C0  32 47 B5 3F 2B BA C1	      db "2",$pIntDivide,One,$pAdd,$pBifq,2*$BifOVERLAY+128,_RetB

				     ;$9.3.4
 00C7  CF			     ParmsRec <3,0,1111b>
 00C8				     BifCHANGESTR:
 00C8 1B B7 A8 B5 A6 59		     BIFCHANGESTR db 3*8+3,Null,OUTPUT-Tgt,One,POSITION-Tgt,$pRepEver
 00CE  001F R			      dw $+31
 00D0  EA EA EE 2B F8 9A	     db Arg1-14-10,Arg2-14-12,POSITION-14,$pBifq,2*$BifPOS+128,FOUNDPOS-Tgt-10
 00D6  F0 B3 CD 02 1D F4 EA EE	      db FOUNDPOS-10,Zero,_Eq,+2,$pLeave,OUTPUT-10,Arg2-14-12,POSITION-14
 00DE  EA EA 41 2B FC		      db FOUNDPOS-16,POSITION-18,$pSubtract,$pBifq,2*$BifSUBSTR+128
 00E3  01 EC 01 9E F0 E8	      db $pAbut,Arg3-14-12,$pAbut,OUTPUT-Tgt-10,FOUNDPOS-10,Arg1-14-12
 00E9  2D 3F 9C 1B FE F4	      db $pLength,$pAdd,POSITION-Tgt-10,$pIterate,OUTPUT,Arg2-14-2
 00EF  F8 2B 7C 01 C1		      db POSITION-4,$pBifq,2*$BifSUBSTR,$pAbut,_RetB

				     ;$9.3.5
 00F4  18			     db $Pad
 00F5  9D			     ParmsRec <2,1,1101b>
 00F6				     BifCOMPARE:
 00F6 33 F2 C7 C9 05 F2 A8	     BIFCOMPARE db 6*8+3,Arg3-20,_Exists,_Then,+5,Arg3-20,C_PAD-Tgt
 00FD  CB 04 BB 20 A8 EE 2D EE	      db _Jump,+4,String1," ",C_PAD-Tgt,STR1,$pLength,STR2-2,$pLength
	      2D
 0106  D7 0C EE 2D A6 F0 FA FA	      db _Gt,+12,STR1,$pLength,CO_LENGTH-Tgt,STR2,CO_LENGTH-2,C_PAD-4
 010E  2B FA 9A CB 0A F0 2D A6	      db $pBifq,2*$BifLEFT+128,STR2-Tgt,_Jump,+10,STR2,$pLength,CO_LENGTH-Tgt
 0116  EE FA FA 2B FA 98 B5	      db STR1,CO_LENGTH-2,C_PAD-4,$pBifq,2*$BifLEFT+128,STR1-Tgt,One
 011D  0D F2 0F 5B F0		      db $pNumber,CO_LENGTH-10,$pTo,$pControlVar,C_I-10
 0122  0011 R			      dw $+17
 0124  E4 EE B5 2B FC E4 EC	     db STR1-10,C_I-12,One,$pBifq,2*$BifSUBSTR+128,STR2-12,C_I-14
 012B  B5 2B FC DB 03 F0 C1 C5	      db One,$pBifq,2*$BifSUBSTR+128,_Sne,+3,C_I-10,_RetB,_IterCV
 0133  B3 C1			      db Zero,_RetB

				     ;$9.3.7
 0135  8F			     ParmsRec <2,0,1111b>
 0136				     BifCOUNTSTR:
 0136 12 B3 A8 F8 F8 2B		     BIFCOUNTSTR db 2*8+2,Zero,C_OUTPUT-Tgt,Arg1-10,Arg2-10-2,$pBifq
 013C  78 A6 59			      db 2*$BifPOS,C_POSITION-Tgt,$pRepEver
 013F  0015 R			      dw $+21
 0141  F2 B3 D7 00 15 F4 B5 3F	     db C_POSITION-10,Zero,_Gt,00h,$pWhile,C_OUTPUT-10,One,$pAdd,C_OUTPUT-Tgt-10
	      9E
 014A  EE EE EE E8 2D 3F	      db Arg1-10-10,Arg2-10-12,C_POSITION-14,Arg1-10-16,$pLength,$pAdd
 0150  2B F8 9C 1B FE		      db $pBifq,2*$BifPOS+128,C_POSITION-Tgt-10,$pIterate,C_OUTPUT
 0155  C1			      db _RetB

				     ;$9.8.1
 0156  42 44 45 4E 4F 53 55	     db "BDENOSU"
 015D  F9			     db -@SizeStr(<BDENOSU>)
 015E  42 44 45 4D 4E 4F 53 55	     db "BDEMNOSUW"
	      57
 0167  F7			      db -@SizeStr(<BDEMNOSUW>)
 0168  35			      ParmsRec <0,3,0101b>
 0169				     BifDATE:
 0169 6B BD 31 38 93 B9 2A 4A	     BIFDATE db 13*8+3,String2,"18",Frag28,String,42,
	      61 6E 75 61 72
	      79 20 46 65 62
	      72 75 61 72 79
	      20 4D 61 72 63
	      68 20 41 70 72
	      69 6C 20 4D 61
	      79 20 4A 75 6E
	      65 20 4A 75 6C
	      79 B9 2A 41 75
	      67 75 73 74 20
	      53 65 70 74 65
	      6D 62 65 72 20
	      4F 63 74 6F 62
	      65 72 20 4E 6F
	      76 65 6D 62 65
	      72 20 44 65 63
	      65 6D 62 65 72
	      03 26
				     "January February March April May June July",String,42,
				     "August September October November December",$pCat,?MONTHS+Tgts
 01C8  B9 38 4D 6F 6E 64 61 79	      db String,56,"Monday Tuesday Wednesday Thursday Friday Saturday Sunday"
	      20 54 75 65 73
	      64 61 79 20 57
	      65 64 6E 65 73
	      64 61 79 20 54
	      68 75 72 73 64
	      61 79 20 46 72
	      69 64 61 79 20
	      53 61 74 75 72
	      64 61 79 20 53
	      75 6E 64 61 79
 0202  28 E2 C7 33 C9 05 0E	      db ?WEEKDAYS+Tgts,Arg2-34,_Exists,$pNot,_Then,+5,?CLAUSELOCAL
 0209  FC 46 C1 83 BD 4E 53 96	      db D_OPTION-2,DATEFORMAT,_RetB,Frag20,String2,"NS",LOGIC-Tgt
 0211  F4 BB 4E D9 23 F6 09 00	      db INOPTION,String1,"N",_Seq,+35,VALUE,$pParse,00h,022h,DAY-2
	      22 EE
 021B  E8 FA 1A B5 0D BD 31 32	      db MONTHIS-2,YEAR-2,01ah,One,$pNumber,String2,"12",$pTo,$pControlVar
	      0F 5B
 0225  E8			      db MONTH-10
 0226  0010 R			      dw $+16
 0228  10 E6 2B 72 BB 33 3B	     db ?MONTHS,MONTH-12,$pBifq,2*$BifWORD,String1,"3",$pPositive
 022F  2B 7A DE D9 02 1D C5 CB	      db $pBifq,2*$BifLEFT,MONTHIS-12,_Seq,+2,$pLeave,_IterCV,_Jump
 0237  1C F4 BB 53 D9 11 F6 09	      db +28,INOPTION,String1,"S",_Seq,+17,VALUE,$pParse,00h,String1
	      00 BB
 0241  34 3A FA BB 32 3A F0 22	      db "4",03ah,YEAR-2,String1,"2",03ah,MONTH-2,022h,DAY-2,01ah
	      EE 1A
 024B  CB 07 B9 03 45 4F 55 96	      db _Jump,+7,String,3,"EOU",LOGIC-Tgt,LOGIC,String,3,"EOU",_Seq
	      EC B9 03 45 4F
	      55 D9
 025A  44 F4 BB 45 D9 11 F6 09	      db +68,INOPTION,String1,"E",_Seq,+17,VALUE,$pParse,00h,String1
	      00 BB
 0264  2F 2A EE BB 2F 2A F0 22	      db "/",02ah,DAY-2,String1,"/",02ah,MONTH-2,022h,YY-2,01ah,_Jump
	      E6 1A CB
 026F  2F F4 BB 4F D9 11 F6 09	      db +47,INOPTION,String1,"O",_Seq,+17,VALUE,$pParse,00h,String1
	      00 BB
 0279  2F 2A E6 BB 2F 2A F0 22	      db "/",02ah,YY-2,String1,"/",02ah,MONTH-2,022h,DAY-2,01ah,_Jump
	      EE 1A CB
 0284  1A F4 BB 55 D9 11 F6 09	      db +26,INOPTION,String1,"U",_Seq,+17,VALUE,$pParse,00h,String1
	      00 BB
 028E  2F 2A F0 BB 2F 2A EE 22	      db "/",02ah,MONTH-2,String1,"/",02ah,DAY-2,022h,YY-2,01ah,_Jump
	      E6 1A CB
 0299  05 BD 42 44 96 EC B9 03	      db +5,String2,"BD",LOGIC-Tgt,LOGIC,String,3,"EOU",_Seq,+34,YY
	      45 4F 55 D9 22
	      E8
 02A7  6F 0E 3C 09 02 22 E4	      db Frag10,?CLAUSELOCAL,TIME2DATE,$pParse,02h,022h,YEARNOW-2
 02AE  FE 1A E8 A6 59		      db ParseDot,01ah,YY,YEAR-Tgt,$pRepEver
 02B3  0014 R			      dw $+20
 02B5  F2 DA BD 35 30 41 D1 00	     db YEAR-10,YEARNOW-12,String2,"50",$pSubtract,_Lt,00h,$pWhile
	      15
 02BE  F2 B9 03 31 30 30 3F 9C	      db YEAR-10,String,3,"100",$pAdd,YEAR-Tgt-10,$pIterate,LOGIC
	      1B EC
 02C8  BD 42 44 DB 3C F2 63 BB	      db String2,"BD",_Sne,+60,MONTH,Frag4,String1,"W",Frag6,String
	      57 67 B9
 02D3  2C 30 20 33 31 20 35 39	      db 44,"0 31 59 90 120 151 181 212 243 273 304 334 0",MONTH-2
	      20 39 30 20 31
	      32 30 20 31 35
	      31 20 31 38 31
	      20 32 31 32 20
	      32 34 33 20 32
	      37 33 20 33 30
	      34 20 33 33 34
	      20 30 F0
 0301  2B 72 A4 FA 7D CB 03 F6	      db $pBifq,2*$BifWORD,DAYS-Tgt,DAYS,Frag17,_Jump,+3,VALUE,Frag10
	      6F
 030A  F4 BB 44 D9 0D 0E 3C 09	      db INOPTION,String1,"D",_Seq,+13,?CLAUSELOCAL,TIME2DATE,$pParse
 0312  02 22 FA FE 1A F6 B5 41	      db 02h,022h,YEAR-2,ParseDot,01ah,VALUE,One,$pSubtract,DAYS-Tgt
	      A4
 031B  F4 BB 42 DB 04 8D CB 03	      db INOPTION,String1,"B",_Sne,+4,Frag25,_Jump,+3,VALUE,BASEDAYS-Tgt
	      F6 A2
 0325  F8 B9 05 38 36 34 45 38	      db BASEDAYS,String,5,"864E8",$pMultiply,MICRO-Tgt,MICRO,INOPTION-2
	      43 98 EE F2
 0331  46 7B 46 C1		      db DATEFORMAT,Frag16,DATEFORMAT,_RetB

 0335 4A EA 3C 09 02 22 F8	     DATEFORMAT$$ db 9*8+2,Arg1-24,TIME2DATE,$pParse,02h,022h,D_YEAR-2
 033C  FC FA F6 F4 F2 F0	      db D_MONTH-2,D_DAY-2,D_HOUR-2,D_MINUTE-2,D_SECOND-2,D_MICROSECOND-2
 0342  EE EC 1A EC BB 42 D9 05	      db D_BASE-2,D_DAYS-2,01ah,Arg2-24,String1,"B",_Seq,+5,D_BASE
	      F0
 034B  C1 CB A5 EC BB 44 D9 05	      db _RetB,_Jump,+165,Arg2-24,String1,"D",_Seq,+5,D_DAYS,_RetB
	      EE C1
 0355  CB 9C EC BB 45 D9 0E FC	      db _Jump,+156,Arg2-24,String1,"E",_Seq,+14,D_DAY,Frag18,D_YEAR-2
	      7F F8
 035F  BB 32 3B B3 2B B4 01	      db String1,"2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128,$pAbut
 0366  C1 CB 8A EC BB 4D D9 09	      db _RetB,_Jump,+138,Arg2-24,String1,"M",_Seq,+9,?MONTHS,D_MONTH-2
	      10 FC
 0370  3B 2B 72 C1 CB 7D EC BB	      db $pPositive,$pBifq,2*$BifWORD,_RetB,_Jump,+125,Arg2-24,String1
 0378  4E D9 18 FC 10 FA 3B 2B	      db "N",_Seq,+24,D_DAY,?MONTHS,D_MONTH-4,$pPositive,$pBifq,2*$BifWORD
	      72
 0381  BB 33 3B 2B 7A 03 F8 BB	      db String1,"3",$pPositive,$pBifq,2*$BifLEFT,$pCat,D_YEAR-2,String1
 0389  34 3B B3 2B B4 03 C1 CB	      db "4",$pPositive,Zero,$pBifq,2*$BifRIGHT+128,$pCat,_RetB,_Jump
 0391  61 EC BB 4F D9 0E FA 7F	      db +97,Arg2-24,String1,"O",_Seq,+14,D_YEAR,Frag18,D_DAY-2,String1
	      FA BB
 039B  32 3B B3 2B B4 01 C1 CB	      db "2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128,$pAbut,_RetB,_Jump
 03A3  4F EC BB 53 D9 1B FA BB	      db +79,Arg2-24,String1,"S",_Seq,+27,D_YEAR,String1,"4",$pPositive
	      34 3B
 03AD  B3 2B B4 FC BB 32 3B	      db Zero,$pBifq,2*$BifRIGHT+128,D_MONTH-2,String1,"2",$pPositive
 03B4  B3 2B B4 01 FA BB 32 3B	      db Zero,$pBifq,2*$BifRIGHT+128,$pAbut,D_DAY-2,String1,"2",$pPositive
 03BC  B3 2B B4 01 C1 CB 30 EC	      db Zero,$pBifq,2*$BifRIGHT+128,$pAbut,_RetB,_Jump,+48,Arg2-24
 03C4  BB 55 D9 21 FE BB 32 3B	      db String1,"U",_Seq,+33,D_MONTH,String1,"2",$pPositive,Zero
	      B3
 03CD  2B B4 BB 2F 01 FA BB	      db $pBifq,2*$BifRIGHT+128,String1,"/",$pAbut,D_DAY-2,String1
 03D4  32 3B B3 2B B4 01 BB	      db "2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128,$pAbut,String1
 03DB  2F 01 F8 BB 32 3B B3 2B	      db "/",$pAbut,D_YEAR-2,String1,"2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128
	      B4
 03E4  01 C1 CB 0B 12 B5 EC BB	      db $pAbut,_RetB,_Jump,+11,?WEEKDAYS,One,D_BASE-4,String1,"7"
	      37
 03ED  49 3F 2B 72 C1		      db $pRemainder,$pAdd,$pBifq,2*$BifWORD,_RetB

				     ;$9.3.9
 03F2  04			     db $WholeGE
 03F3  08			     db $WholeGT
 03F4  99			     ParmsRec <2,1,1001b>
 03F5				     BifDELSTR:
 03F5 33 F2 C7 C9 03 F2 A8 F0	     BIFDELSTR db 6*8+3,Arg3-20,_Exists,_Then,+3,Arg3-20,LEN-Tgt,NUM
 03FD  EC 2D D7 03 EE C1 EE B5	      db D_STRING-2,$pLength,_Gt,+3,D_STRING,_RetB,D_STRING,One,NUM-4
	      EC
 0406  B5 41 2B FC A6 F2	      db One,$pSubtract,$pBifq,2*$BifSUBSTR+128,D_OUTPUT-Tgt,Arg3-20
 040C  C7 C9 11 F0 FC 3F EC 2D	      db _Exists,_Then,+17,NUM,LEN-2,$pAdd,D_STRING-2,$pLength,_Le
	      D3
 0415  0A FC EC EC F8 3F 2B 7C	      db +10,D_OUTPUT,D_STRING-2,NUM-4,LEN-6,$pAdd,$pBifq,2*$BifSUBSTR
 041D  01 A6 FC C1		      db $pAbut,D_OUTPUT-Tgt,D_OUTPUT,_RetB

				     ;$9.3.10
 0421  04			     db $WholeGE
 0422  08			     db $WholeGT
 0423  99			     ParmsRec <2,1,1001b>
 0424				     BifDELWORD:
 0424 33 F2 C7 C9 03 F2 A8	     BIFDELWORD db 6*8+3,Arg3-20,_Exists,_Then,+3,Arg3-20,DW_LEN-Tgt
 042B  F0 EC 2B 18 D7 03 EE C1	      db DW_NUM,DW_STRING-2,$pBifq,2*$BifWORDS,_Gt,+3,DW_STRING,_RetB
 0433  EE EE 2B 74 B5 41	      db DW_STRING,DW_NUM-2,$pBifq,2*$BifWORDINDEX,One,$pSubtract
 0439  A4 EE F8 2B 7A A2	      db ENDLEFT-Tgt,DW_STRING,ENDLEFT-2,$pBifq,2*$BifLEFT,DW_OUTPUT-Tgt
 043F  F2 C7 C9 13 EE EE FA 3F	      db Arg3-20,_Exists,_Then,+19,DW_STRING,DW_NUM-2,DW_LEN-4,$pAdd
 0447  2B 74 A6 FC B3 D7	      db $pBifq,2*$BifWORDINDEX,BEGINRIGHT-Tgt,BEGINRIGHT,Zero,_Gt
 044D  08 F8 EC F8 2B 7C	      db +8,DW_OUTPUT,DW_STRING-2,BEGINRIGHT-4,$pBifq,2*$BifSUBSTR
 0453  01 A2 F8 C1		      db $pAbut,DW_OUTPUT-Tgt,DW_OUTPUT,_RetB

				     ;$9.5.5
 0457  53 4E			     db "SN"
 0459  FE			     db -@SizeStr(<SN>)
 045A  0C			     db $Num; Partial test.
 045B  53			     ParmsRec <1,1,0011b>
 045C				     BifERRORTEXT:
 045C BA CE A8 BB 4E 9E		     BIFERRORTEXT db 23*8+2,Arg1-52,MSGCODE-Tgt,String1,"N",E_OPTION-Tgt
 0462  D0 C7 C9 03 D0 9E FE B5	      db Arg2-52,_Exists,_Then,+3,Arg2-52,E_OPTION-Tgt,MSGCODE,One
 046A  47 A6 FE FA 41 A4	      db $pIntDivide,MAJOR-Tgt,MSGCODE,MAJOR-2,$pSubtract,MINOR-Tgt
 0470  FC B3 D1 00 FA BD 39 30	      db MAJOR,Zero,_Lt,00h,MAJOR-2,String2,"90",_Gt,00h,$pOr,MINOR-2
	      D7 00 37 F8
 047C  BD 2E 39 D7 00 37 BB 45	      db String2,".9",_Gt,00h,$pOr,String1,"E",MSGCODE-4,$pBifq,2*$BifPOS
	      FA 2B 78
 0487  B3 D7 00 37 C9 07 CE BD	      db Zero,_Gt,00h,$pOr,_Then,+7,Arg1-52,String2,"17",$pPositive
	      31 37 3B
 0492  E1 FA B3 D7 08 FA BB 33	      db CONFIG_RAISE40,MINOR,Zero,_Gt,+8,MINOR,String1,"3",$pPositive
	      3B
 049B  2B 7C A4 B9 03 32 35 36	      db $pBifq,2*$BifSUBSTR,MINOR-Tgt,String,3,"256",MAJOR-2,$pMultiply
	      FA 43
 04A5  F8 3F E5 C1		      db MINOR-2,$pAdd,CONFIG_MSG,_RetB

				     ;$9.4.2
 04A9  04			     db $WholeGE
 04AA  04			     db $WholeGE
 04AB  04			     db $WholeGE
 04AC  04			     db $WholeGE
 04AD  0C			     db $Num
				     ; FORMAT actually 1,4 but no room in ParmsRec record for that.
 04AE  70			      ParmsRec <1,3,0000b>
 04AF				     BifFORMAT:
 04AF A5 D0 C7 C9 03 D0 9E	     BIFFORMAT db 20*8+5,Arg2-52,_Exists,_Then,+3,Arg2-52,BEFORE-Tgt
 04B6  D2 C7 C9 03 D2 9C D4 C7	      db Arg3-52,_Exists,_Then,+3,Arg3-52,AFTER-Tgt,Arg4-52,_Exists
 04BE  C9 03 D4 9A D6 C7 C9 05	      db _Then,+3,Arg4-52,EXPP-Tgt,Arg5-52,_Exists,_Then,+5,Arg5-52
	      D6
 04C7  98 CB 04 2B 4A 98 CE 94	      db EXPT-Tgt,_Jump,+4,$pBifq,2*$BifDIGITS,EXPT-Tgt,Arg1-52,F_NUMBER-Tgt
 04CF  2B 42 BB 32 D1 03 EA C1	      db $pBifq,2*$BifARG,String1,"2",_Lt,+3,F_NUMBER,_RetB,F_NUMBER
	      EA
 04D8  09 00 BB 45 2A FC 22 F6	      db $pParse,00h,String1,"E",02ah,F_MANTISSA-2,022h,F_EXPONENT-2
 04E0  1A F8 B7 D9 03 B3 A2 B3	      db 01ah,F_EXPONENT,Null,_Seq,+3,Zero,F_EXPONENT-Tgt,Zero,F_SIGN-Tgt
	      92
 04E9  FE B5 2B 7A BB 2D D9 0A	      db F_MANTISSA,One,$pBifq,2*$BifLEFT,String1,"-",_Seq,+10,One
	      B5
 04F2  92 FE BB 32 3B 2B 7C	      db F_SIGN-Tgt,F_MANTISSA,String1,"2",$pPositive,$pBifq,2*$BifSUBSTR
 04F9  A8 FE 09 00 BB 2E 2A E4	      db F_MANTISSA-Tgt,F_MANTISSA,$pParse,00h,String1,".",02ah,BEFO-2
 0501  22 E2 1A E6 E2 01 A8 F8	      db 022h,AFTE-2,01ah,BEFO,AFTE-2,$pAbut,F_MANTISSA-Tgt,F_EXPONENT
 0509  E2 2D 41 A2 59		      db AFTE-2,$pLength,$pSubtract,F_EXPONENT-Tgt,$pRepEver
 050E  000C R			      dw $+12
 0510  6B 15 F4 BB 32 3B 2B	     db Frag8,$pWhile,F_MANTISSA-10,String1,"2",$pPositive,$pBifq
 0517  7C 9E 1B FE 2D		      db 2*$BifSUBSTR,F_MANTISSA-Tgt-10,$pIterate,F_MANTISSA,$pLength
 051C  A0 B3 8C FE 2D F6	      db POINT-Tgt,Zero,SHOWEXP-Tgt,F_MANTISSA,$pLength,F_EXPONENT-2
 0522  3F EC D7 03 B5 8C F8 3D	      db $pAdd,EXPT-2,_Gt,+3,One,SHOWEXP-Tgt,F_EXPONENT,$pNegate,F_MANTISSA-2
	      FC
 052B  2D 41 BB 36 D5 03 B5 8C	      db $pLength,$pSubtract,String1,"6",_Ge,+3,One,SHOWEXP-Tgt,Arg4-52
	      D4
 0534  C7 C9 07 F0 B3 CD 03 B3	      db _Exists,_Then,+7,EXPP,Zero,_Eq,+3,Zero,SHOWEXP-Tgt,SHOWEXP
	      8C E2
 053E  C9 35 B5 A0 F8 FC 2D	      db _Then,+53,One,POINT-Tgt,F_EXPONENT,F_MANTISSA-2,$pLength
 0545  3F B5 41 A2 2B 3C B9	      db $pAdd,One,$pSubtract,F_EXPONENT-Tgt,$pBifq,2*$BifFORM,String
 054C  0B 45 4E 47 49 4E 45 45	      db 11,"ENGINEERING",_Seq,+25,$pRepEver
	      52 49 4E 47 D9
	      19 59
 055B  0017 R			      dw $+23
 055D  EE BB 33 49 B3 CF 00 15	     db F_EXPONENT-10,String1,"3",$pRemainder,Zero,_Ne,00h,$pWhile
 0565  EC B5 3F 96 EE B5 41	      db POINT-10,One,$pAdd,POINT-Tgt-10,F_EXPONENT-10,One,$pSubtract
 056C  98 F4 B3 01 9E		      db F_EXPONENT-Tgt-10,F_MANTISSA-10,Zero,$pAbut,F_MANTISSA-Tgt-10
 0571  1B CB 36 FE 2D A0 59	      db $pIterate,_Jump,+54,F_MANTISSA,$pLength,POINT-Tgt,$pRepEver
 0578  0014 R			      dw $+20
 057A  EE B3 D7 00 15 F4 B3 01	     db F_EXPONENT-10,Zero,_Gt,00h,$pWhile,F_MANTISSA-10,Zero,$pAbut
 0582  9E EC B5 3F 96 EE	      db F_MANTISSA-Tgt-10,POINT-10,One,$pAdd,POINT-Tgt-10,F_EXPONENT-10
 0588  B5 41 98 1B 59		      db One,$pSubtract,F_EXPONENT-Tgt-10,$pIterate,$pRepEver
 058D  001C R			      dw $+28
 058F  EE B3 D1 00 15 EC B5 41	     db F_EXPONENT-10,Zero,_Lt,00h,$pWhile,POINT-10,One,$pSubtract
 0597  96 EC B5 D1 09 B3 F2 01	      db POINT-Tgt-10,POINT-10,One,_Lt,+9,Zero,F_MANTISSA-12,$pAbut
 059F  9E EC B5 3F 96 EE	      db F_MANTISSA-Tgt-10,POINT-10,One,$pAdd,POINT-Tgt-10,F_EXPONENT-10
 05A5  B5 3F 98 1B FE 2D	      db One,$pAdd,F_EXPONENT-Tgt-10,$pIterate,F_MANTISSA,$pLength
 05AB  F4 41 8A D2 C7 B3 CD 03	      db POINT-2,$pSubtract,AFTERS-Tgt,Arg3-52,_Exists,Zero,_Eq,+3
 05B3  E0 9C 59			      db AFTERS,AFTER-Tgt,$pRepEver
 05B6  0010 R			      dw $+16
 05B8  D6 E6 D1 00 15 D6 B5 3F	     db AFTERS-10,AFTER-12,_Lt,00h,$pWhile,AFTERS-10,One,$pAdd,AFTERS-Tgt-10
	      80
 05C1  F4 B3 01 9E 1B E0	      db F_MANTISSA-10,Zero,$pAbut,F_MANTISSA-Tgt-10,$pIterate,AFTERS
 05C7  F0 D7 73 FE F4 EE 3F B5	      db AFTER-2,_Gt,+115,F_MANTISSA,POINT-2,AFTER-4,$pAdd,One,$pAdd
	      3F
 05D0  B5 2B FC A6 FE F4 EE	      db One,$pBifq,2*$BifSUBSTR+128,F_R-Tgt,F_MANTISSA,POINT-2,AFTER-4
 05D7  3F 2B 7A A8 FE 2D	      db $pAdd,$pBifq,2*$BifLEFT,F_MANTISSA-Tgt,F_MANTISSA,$pLength
 05DD  88 FC BB 35 D5 05 FE B5	      db MANTLEN-Tgt,F_R,String1,"5",_Ge,+5,F_MANTISSA,One,$pAdd,F_MANTISSA-Tgt
	      3F A8
 05E7  FE B3 CD 03 B3 92 FE 2D	      db F_MANTISSA,Zero,_Eq,+3,Zero,F_SIGN-Tgt,F_MANTISSA,$pLength
 05EF  DC D1 0B B3 DC FA 2D 41	      db MANTLEN-2,_Lt,+11,Zero,MANTLEN-2,F_MANTISSA-4,$pLength,$pSubtract
 05F7  2B 70 FC 01 A8 FE	      db $pBifq,2*$BifCOPIES,F_MANTISSA-2,$pAbut,F_MANTISSA-Tgt,F_MANTISSA
 05FD  2D DC D7 0B F6 B5 3F A0	      db $pLength,MANTLEN-2,_Gt,+11,POINT,One,$pAdd,POINT-Tgt,POINT
	      F6
 0606  EC D7 03 B5 8C E2 B5 CD	      db EXPT-2,_Gt,+3,One,SHOWEXP-Tgt,SHOWEXP,One,_Eq,+46,F_EXPONENT
	      2E F8
 0610  F4 B5 41 3F A2 B5 A0	      db POINT-2,One,$pSubtract,$pAdd,F_EXPONENT-Tgt,One,POINT-Tgt
 0617  2B 3C B9 0B 45 4E 47 49	      db $pBifq,2*$BifFORM,String,11,"ENGINEERING",_Seq,+21,$pRepEver
	      4E 45 45 52 49
	      4E 47 D9 15 59
 0629  0013 R			      dw $+19
 062B  EE BB 33 49 B3 CF 00 15	     db F_EXPONENT-10,String1,"3",$pRemainder,Zero,_Ne,00h,$pWhile
 0633  EC B5 3F 96 EE B5 41	      db POINT-10,One,$pAdd,POINT-Tgt-10,F_EXPONENT-10,One,$pSubtract
 063A  98 1B F2 B3 D7 0E BB 2E	      db F_EXPONENT-Tgt-10,$pIterate,AFTER,Zero,_Gt,+14,String1,"."
 0642  FC F2 B5 3F EC 2B FC	      db F_MANTISSA-2,POINT-4,One,$pAdd,AFTER-6,$pBifq,2*$BifSUBSTR+128
 0649  01 8E CB 03 B7 8E FE F4	      db $pAbut,AFTE-Tgt,_Jump,+3,Null,AFTE-Tgt,F_MANTISSA,POINT-2
 0651  2B 7A A8 D0 C7 B3 CD	      db $pBifq,2*$BifLEFT,F_MANTISSA-Tgt,Arg2-52,_Exists,Zero,_Eq
 0658  05 F6 E6 3F 9E F6 F2 E4	      db +5,POINT,F_SIGN-2,$pAdd,BEFORE-Tgt,POINT,BEFORE-2,F_SIGN-4
 0660  41 D7 0A BB 32 3B CC BD	      db $pSubtract,_Gt,+10,String1,"2",$pPositive,Arg1-52-2,String2
 0668  33 38 3B E1 59		      db "38",$pPositive,CONFIG_RAISE40,$pRepEver
 066D  0010 R			      dw $+16
 066F  EC E8 D1 00 15 EC B5 3F	     db POINT-10,BEFORE-12,_Lt,00h,$pWhile,POINT-10,One,$pAdd,POINT-Tgt-10
	      96
 0678  B3 F2 01 9E 1B B7	      db Zero,F_MANTISSA-12,$pAbut,F_MANTISSA-Tgt-10,$pIterate,Null
 067E  A6 B3 A4 B5 0D F4 2D	      db F_R-Tgt,Zero,TRIGGERED-Tgt,One,$pNumber,F_MANTISSA-10,$pLength
 0685  0F 5B E2			      db $pTo,$pControlVar,F_Z-10
 0688  004C R			      dw $+76
 068A  F4 E0 B5 2B FC 7C	     db F_MANTISSA-10,F_Z-12,One,$pBifq,2*$BifSUBSTR+128,DIGIT-Tgt-10
 0690  F0 B5 CD 06 F2 D0 01 9C	      db TRIGGERED-10,One,_Eq,+6,F_R-10,DIGIT-12,$pAbut,F_R-Tgt-10
 0698  C5 D2 B3 CD 1B F4 E0 B5	      db _IterCV,DIGIT-10,Zero,_Eq,+27,F_MANTISSA-10,F_Z-12,One,$pAdd
	      3F
 06A1  B5 2B FC B3 CD 00 E0 B5	      db One,$pBifq,2*$BifSUBSTR+128,Zero,_Eq,00h,F_Z-12,One,$pAdd
	      3F
 06AA  F0 2D D1 00 35 C9 07 F2	      db F_MANTISSA-14,$pLength,_Lt,00h,$pAnd,_Then,+7,F_R-10,String1
	      BB
 06B3  20 01 9C C5 D2 B3 CD 00	      db " ",$pAbut,F_R-Tgt-10,_IterCV,DIGIT-10,Zero,_Eq,00h,F_Z-12
	      E0
 06BC  F0 2D CF 00 35 C9 04 BB	      db F_MANTISSA-14,$pLength,_Ne,00h,$pAnd,_Then,+4,String1," "
	      20
 06C5  7C DE B5 CD 04 BB 2D 7C	      db DIGIT-Tgt-10,F_SIGN-10,One,_Eq,+4,String1,"-",DIGIT-Tgt-10
 06CD  F2 D0 01 9C B5 9A C5	      db F_R-10,DIGIT-12,$pAbut,F_R-Tgt-10,One,TRIGGERED-Tgt-10,_IterCV
 06D4  FC E2 01 94 E2 B5 CD 53	      db F_R,AFTE-2,$pAbut,F_NUMBER-Tgt,SHOWEXP,One,_Eq,+83,Null,EXPART-Tgt
	      B7 84
 06DE  B3 82 F8 B3 D1 06 B5 82	      db Zero,SIGNEXP-Tgt,F_EXPONENT,Zero,_Lt,+6,One,SIGNEXP-Tgt,F_EXPONENT
	      F8
 06E7  3D A2 D4 C7 B3 CD 04 F8	      db $pNegate,F_EXPONENT-Tgt,Arg4-52,_Exists,Zero,_Eq,+4,F_EXPONENT
 06EF  2D 9A F8 2D EE D7 0A BB	      db $pLength,EXPP-Tgt,F_EXPONENT,$pLength,EXPP-2,_Gt,+10,String1
 06F7  34 3B CC BD 33 38 3B E1	      db "4",$pPositive,Arg1-52-2,String2,"38",$pPositive,CONFIG_RAISE40
 06FF  F8 EE B3 2B B4 A2	      db F_EXPONENT,EXPP-2,Zero,$pBifq,2*$BifRIGHT+128,F_EXPONENT-Tgt
 0705  F8 B3 CD 10 D4 C7 C9 0A	      db F_EXPONENT,Zero,_Eq,+16,Arg4-52,_Exists,_Then,+10,String1
	      BB
 070E  20 EE BB 32 3F 2B 70 84	      db " ",EXPP-2,String1,"2",$pAdd,$pBifq,2*$BifCOPIES,EXPART-Tgt
 0716  CB 13 D8 B3 CD 09 BD 45	      db _Jump,+19,SIGNEXP,Zero,_Eq,+9,String2,"E+",F_EXPONENT-2,$pAbut
	      2B F6 01
 0721  84 CB 07 BD 45 2D F6 01	      db EXPART-Tgt,_Jump,+7,String2,"E-",F_EXPONENT-2,$pAbut,EXPART-Tgt
	      84
 072A  EA D8 01 94 EA C1	      db F_NUMBER,EXPART-2,$pAbut,F_NUMBER-Tgt,F_NUMBER,_RetB

				     ;$9.3.11
 0730  18			     db $Pad
 0731  04			     db $WholeGE
 0732  04			     db $WholeGE
 0733  BC			     ParmsRec <2,3,1100b>
 0734				     BifINSERT:
 0734 2D F0 C7 C9 05 F0 A4	     BIFINSERT db 5*8+5,Arg3-22,_Exists,_Then,+5,Arg3-22,I_NUM-Tgt
 073B  CB 03 B3 A4 91 F8 2B FA	      db _Jump,+3,Zero,I_NUM-Tgt,Frag27,I_PAD-4,$pBifq,2*$BifLEFT+128
 0743  EA FA F6 2B FA 01 EC	      db NEW-2,I_LENGTH-4,I_PAD-6,$pBifq,2*$BifLEFT+128,$pAbut,TARGET-2
 074A  F6 B5 3F 2B 7C 01 C1	      db I_NUM-4,One,$pAdd,$pBifq,2*$BifSUBSTR,$pAbut,_RetB

				     ;$9.3.12
 0751  08			     db $WholeGT
 0752  9D			     ParmsRec <2,1,1101b>
 0753				     BifLASTPOS:
 0753 2B F2 2D A8 F4 C7		     BIFLASTPOS db 5*8+3,HAYSTACK,$pLength,START-Tgt,Arg3-18,_Exists
 0759  C9 06 F4 FC 31 01 A8 F0	      db _Then,+6,Arg3-18,START-2,$pMin,01h,START-Tgt,NEEDLE,$pLength
	      2D
 0762  A6 FC B3 CD 03 B3 C1 FE	      db NEEDLELENGTH-Tgt,NEEDLELENGTH,Zero,_Eq,+3,Zero,_RetB,START
 076A  FA 41 B5 3F A8 FE 0D	      db NEEDLELENGTH-2,$pSubtract,One,$pAdd,START-Tgt,START,$pNumber
 0771  B5 3D 11 5B F0		      db One,$pNegate,$pBy,$pControlVar,II-10
 0776  0012 R			      dw $+18
 0778  F0 B3 D7 00 15 E8 EE EE	     db II-10,Zero,_Gt,00h,$pWhile,HAYSTACK-10,II-12,NEEDLELENGTH-14
 0780  2B FC E4 D9 03 F0 C1 C5	      db $pBifq,2*$BifSUBSTR+128,NEEDLE-12,_Seq,+3,II-10,_RetB,_IterCV
 0788  B3 C1			      db Zero,_RetB

				     ;$9.3.15
 078A  18			     db $Pad
 078B  04			     db $WholeGE
 078C  08			     db $WholeGT
 078D  BC			     ParmsRec <2,3,1100b>
 078E				     BifOVERLAY:
 078E 2D F0 C7 C9 05 F0 A4	     BIFOVERLAY db 5*8+5,Arg3-22,_Exists,_Then,+5,Arg3-22,O_NUM-Tgt
 0795  CB 03 B5 A4 91 B5 41 F8	      db _Jump,+3,One,O_NUM-Tgt,Frag27,One,$pSubtract,O_PAD-4,$pBifq
	      2B
 079E  FA EA FA F6 2B FA	      db 2*$BifLEFT+128,O_NEW-2,O_LENGTH-4,O_PAD-6,$pBifq,2*$BifLEFT+128
 07A4  01 EC F6 F8 3F 2B 7C	      db $pAbut,O_TARGET-2,O_NUM-4,O_LENGTH-6,$pAdd,$pBifq,2*$BifSUBSTR
 07AB  01 C1			      db $pAbut,_RetB

				     if Solid
				     ;$9.6.1
 07AD  24			      db $Bin
 07AE  47			      ParmsRec <1,0,0111b>
 07AF				     BifB2X:
 07AF 09 FC B3 2B 9E A8		     BIFB2X db 1*8+1,Arg1-6,Zero,$pBifq,2*$BifSPACE+128,B_STRING-Tgt
 07B5  FE BB 32 BD 31 36 42 C1	      db B_STRING,String1,"2",String2,"16",RERADIX,_RetB
				     endif

				     if Solid
				     ;$9.6.2
				     ;$9.6.3
				     ;$9.6.4
 07BD  18			      db $Pad
 07BE  6D			      ParmsRec <1,2,1101b>
 07BF				     BifBITOR: ; Same Bcode as BITAND
 07BF				     BifBITAND:
 07BF				     BifBITXOR:
 07BF 4B EA C7 C9 05 EA A8	     BIFBITAND db 9*8+3,Arg2-26,_Exists,_Then,+5,Arg2-26,STRING2-Tgt
 07C6  CB 03 B7 A8 EC C7 C9 17	      db _Jump,+3,Null,STRING2-Tgt,Arg3-26,_Exists,_Then,+23,STRING1
	      E8
 07CF  2D FC 2D D7 0A FE E6 2D	      db $pLength,STRING2-2,$pLength,_Gt,+10,STRING2,STRING1-2,$pLength
 07D7  E8 2B FA A8 CB 08 E8	      db Arg3-26-4,$pBifq,2*$BifLEFT+128,STRING2-Tgt,_Jump,+8,STRING1
 07DE  FC 2D E8 2B FA 92	      db STRING2-2,$pLength,Arg3-26-4,$pBifq,2*$BifLEFT+128,STRING1-Tgt
 07E4  E8 E7 00 92 FE E7	      db STRING1,CONFIG_C2B,?OUTCOME,STRING1-Tgt,STRING2,CONFIG_C2B
 07EA  00 A8 E8 2D FC 2D	      db ?OUTCOME,STRING2-Tgt,STRING1,$pLength,STRING2-2,$pLength
 07F0  D1 07 E8 A6 FE 92 FC A8	      db _Lt,+7,STRING1,B_T-Tgt,STRING2,STRING1-Tgt,B_T,STRING2-Tgt
 07F8  B7 A4 B5 0D F4 2D 0F 5B	      db Null,B_R-Tgt,One,$pNumber,STRING2-10,$pLength,$pTo,$pControlVar
 0800  EE			      db B_J-10
 0801  0043 R			      dw $+67
 0803  DE EC B5 2B FC 96 F4	     db STRING1-10,B_J-12,One,$pBifq,2*$BifSUBSTR+128,B1-Tgt-10,STRING2-10
 080A  EC B5 2B FC 94 02 B9	      db B_J-12,One,$pBifq,2*$BifSUBSTR+128,B2-Tgt-10,?BIF,String
 0811  06 42 49 54 41 4E 44 D9	      db 6,"BITAND",_Seq,+7,B1-10,B2-12,$pAnd,B1-Tgt-10,_Jump,+32
	      07 EC E8 35 96
	      CB 20
 0820  02 B9 05 42 49 54 4F 52	      db ?BIF,String,5,"BITOR",_Seq,+7,B1-10,B2-12,$pOr,B1-Tgt-10
	      D9 07 EC E8 37
	      96
 082E  CB 10 02 B9 06 42 49 54	      db _Jump,+16,?BIF,String,6,"BITXOR",_Seq,+5,B1-10,B2-12,$pXor
	      58 4F 52 D9 05
	      EC E8 39
 083E  96 F0 EA 01 9A C5 FA E6	      db B1-Tgt-10,B_R-10,B1-12,$pAbut,B_R-Tgt-10,_IterCV,B_R,STRING1-2
 0846  E4 2D F8 2D 41 2B 34	      db STRING1-4,$pLength,STRING2-6,$pLength,$pSubtract,$pBifq,2*$BifRIGHT
 084D  01 A4 FA E9 00 C1	      db $pAbut,B_R-Tgt,B_R,CONFIG_B2C,?OUTCOME,_RetB
				     endif

				     if Solid
				     ;$9.6.5
 0853  04			      db $WholeGE
 0854  5B			      ParmsRec <1,1,1011b>
 0855				     BifC2D:
 0855 22 F4 2D B3 CD 03 B3 C1	     BIFC2D db 4*8+2,Arg1-14,$pLength,Zero,_Eq,+3,Zero,_RetB,String2
	      BD
 085E  31 30 61 F6 C7 C9 42 F6	      db "10",Frag3,Arg2-14,_Exists,_Then,+66,Arg2-14,SIZE_-Tgt,SIZE_
	      A4 FA
 0868  B3 CD 03 B3 C1 F4 F8 2B	      db Zero,_Eq,+3,Zero,_RetB,Arg1-14,SIZE_-2,$pBifq,2*$BifXRANGE
	      4E
 0871  B5 2B 7A 2B B4 A6 FC	      db One,$pBifq,2*$BifLEFT,$pBifq,2*$BifRIGHT+128,C_T-Tgt,C_T
 0878  E7 00 B5 2B 7A A2 00	      db CONFIG_C2B,?OUTCOME,One,$pBifq,2*$BifLEFT,C_SIGN-Tgt,?OUTCOME
 087F  BB 32 3B 2B 7C 16	      db String1,"2",$pPositive,$pBifq,2*$BifSUBSTR,?OUTCOME+Tgts
 0885  00 BB 32 BD 31 30 42 A6	      db ?OUTCOME,String1,"2",String2,"10",RERADIX,C_T-Tgt,C_SIGN
	      F8
 088E  C9 09 FC BB 32 00 2D 4B	      db _Then,+9,C_T,String1,"2",?OUTCOME,$pLength,$pPower,$pSubtract
	      41
 0897  A6 FC 2B 54 FC D7 07 FC	      db C_T-Tgt,C_T,$pBifq,2*$BifABS,C_MAX-2,_Gt,+7,C_T,String2,"35"
	      BD 33 35
 08A2  3B E1 FC C1 F4 E7 00	      db $pPositive,CONFIG_RAISE40,C_T,_RetB,Arg1-14,CONFIG_C2B,?OUTCOME
 08A9  BB 32 BD 31 30 42 A6 FC	      db String1,"2",String2,"10",RERADIX,C_T-Tgt,C_T,C_MAX-2,_Gt
	      FC D7
 08B3  07 FC BD 33 35 3B E1 FC	      db +7,C_T,String2,"35",$pPositive,CONFIG_RAISE40,C_T,_RetB
	      C1
				     endif

				     if Solid
				     ;$9.6.7
 08BC  00			      db $Whole
 08BD  14			      db $WholeNum
 08BE  53			      ParmsRec <1,1,0011b>
 08BF				     BifD2C:
 08BF 22 B9 03 39 39 39 51 00	     BIFD2C db 4*8+2,String,3,"999",$pNumeric,00h,Arg1-14,$pBifq,2*$BifABS
	      F4 2B 54
 08CA  73 59			      db Frag12,$pRepEver
 08CC  000F R			      dw $+15
 08CE  F0 BB 38 49 B3 CF 00 15	     db D_LENGTH-10,String1,"8",$pRemainder,Zero,_Ne,00h,$pWhile,D_LENGTH-10
	      F0
 08D7  B5 3F 9A 1B F4 B3 D1 18	      db One,$pAdd,D_LENGTH-Tgt-10,$pIterate,Arg1-14,Zero,_Lt,+24
 08DF  BB 32 F8 4B FC 41 73	      db String1,"2",D_LENGTH-2,$pPower,D_SUBJECT-2,$pSubtract,Frag12
 08E6  59			      db $pRepEver
 08E7  000F R			      dw $+15
 08E9  F0 BB 38 49 B3 CF 00 15	     db D_LENGTH-10,String1,"8",$pRemainder,Zero,_Ne,00h,$pWhile,D_LENGTH-10
	      F0
 08F2  B5 3F 9A 1B FC F8 B3 2B	      db One,$pAdd,D_LENGTH-Tgt-10,$pIterate,D_R,D_LENGTH-2,Zero,$pBifq
 08FA  B4 A6 FC E9 00 A2	      db 2*$BifRIGHT+128,D_R-Tgt,D_R,CONFIG_B2C,?OUTCOME,DC_OUTPUT-Tgt
 0900  F6 C7 33 C9 03 F8 C1 F4	      db Arg2-14,_Exists,$pNot,_Then,+3,DC_OUTPUT,_RetB,Arg1-14,Zero
	      B3
 0909  D5 0D F8 F4 2B 4E B5 2B	      db _Ge,+13,DC_OUTPUT,Arg2-14-2,$pBifq,2*$BifXRANGE,One,$pBifq
 0911  7A 2B B4 C1 CB 0B F8	      db 2*$BifLEFT,$pBifq,2*$BifRIGHT+128,_RetB,_Jump,+11,DC_OUTPUT
 0918  F4 2B 4E B5 2B 34 2B	      db Arg2-14-2,$pBifq,2*$BifXRANGE,One,$pBifq,2*$BifRIGHT,$pBifq
 091F  B4 C1			      db 2*$BifRIGHT+128,_RetB
				     endif

				     ;$9.6.6
				     if Solid
 0921  4F			      ParmsRec <1,0,1111b>
 0922				     BifC2X:
 0922 01 FE 2D B3 CD 03 B7 C1	     BIFC2X db 0*8+1,Arg1-4,$pLength,Zero,_Eq,+3,Null,_RetB,Arg1-4
	      FE
 092B  E7 00 BB 32 BD 31 36 42	      db CONFIG_C2B,?OUTCOME,String1,"2",String2,"16",RERADIX,_RetB
	      C1
				     endif

				     ;$9.6.8
				     ; Extra test also. NYI
				     if Solid
 0934  00			      db $Whole
 0935  14			      db $WholeNum
 0936  53			      ParmsRec <1,1,0011b>
 0937				     BifD2X:
 0937 12 B9 03 39 39 39 51 00	     BIFD2X db 2*8+2,String,3,"999",$pNumeric,00h,Arg1-10,$pBifq,2*$BifABS
	      F8 2B 54
 0942  A8 FE BD 31 30 BD 31 36	      db X_SUBJECT-Tgt,X_SUBJECT,String2,"10",String2,"16",RERADIX
	      42
 094B  A6 F8 B3 D1 13 BD 31 36	      db X_R-Tgt,Arg1-10,Zero,_Lt,+19,String2,"16",X_R-2,$pLength
	      FA 2D
 0955  4B FC 41 A8 FE BD	      db $pPower,X_SUBJECT-2,$pSubtract,X_SUBJECT-Tgt,X_SUBJECT,String2
 095B  31 30 BD 31 36 42 A6 FA	      db "10",String2,"16",RERADIX,X_R-Tgt,Arg2-10,_Exists,$pNot,_Then
	      C7 33 C9
 0966  03 FC C1 F8 B3 D5 09 FC	      db +3,X_R,_RetB,Arg1-10,Zero,_Ge,+9,X_R,Arg2-10-2,Zero,$pBifq
	      F8 B3 2B
 0971  B4 C1 CB 08 FC F8 BB 46	      db 2*$BifRIGHT+128,_RetB,_Jump,+8,X_R,Arg2-10-2,String1,"F"
 0979  2B B4 C1			      db $pBifq,2*$BifRIGHT+128,_RetB
				     endif

				     ;$9.6.9
 097C  1C			      db $Hex
 097D  47			      ParmsRec <1,0,0111b>
 097E				     BifX2B:
 097E 19 F8 B7 D9 03 B7 C1 F8	     BIFX2B db 3*8+1,XB_SUBJECT,Null,_Seq,+3,Null,_RetB,XB_SUBJECT
 0986  6D C1			      db Frag9,_RetB

				     if Solid
				     ;$9.6.10
 0988  1C			      db $Hex
 0989  47			      ParmsRec <1,0,0111b>
 098A				     BifX2C:
 098A 19 F8 B7 D9 03 B7 C1 F8	     BIFX2C db 3*8+1,XC_SUBJECT,Null,_Seq,+3,Null,_RetB,XC_SUBJECT
 0992  6D A8 BB 38 F6 2D B5 3F	      db Frag9,XC_R-Tgt,String1,"8",XC_SUBJECT-2,$pLength,One,$pAdd
 099A  BB 32 47 43 A6 FE FA	      db String1,"2",$pIntDivide,$pMultiply,XC_LENGTH-Tgt,XC_R,XC_LENGTH-2
 09A1  B3 2B B4 E9 00 C1	      db Zero,$pBifq,2*$BifRIGHT+128,CONFIG_B2C,?OUTCOME,_RetB
				     endif

				     if Solid
				     ;$9.6.11
 09A7  04			      db $WholeGE
 09A8  1C			      db $Hex
 09A9  53			      ParmsRec <1,1,0011b>
 09AA				     BifX2D:
 09AA 22 BD 31 30 61 F4 A6 FC	     BIFX2D db 4*8+2,String2,"10",Frag3,Arg1-14,XD_SUBJECT-Tgt,XD_SUBJECT
 09B2  B7 D9 03 B3 C1 FC B3 2B	      db Null,_Seq,+3,Zero,_RetB,XD_SUBJECT,Zero,$pBifq,2*$BifSPACE+128
	      9E
 09BB  2B 20 A6 F6 C7 C9	      db $pBifq,2*$BifTRANSLATE,XD_SUBJECT-Tgt,Arg2-14,_Exists,_Then
 09C1  0F F6 FA 2D B5 3F 31 01	      db +15,Arg2-14,XD_SUBJECT-2,$pLength,One,$pAdd,$pMin,01h,XD_R-Tgt
	      A4
 09CA  FC F8 B3 2B B4 A6	      db XD_SUBJECT,XD_R-2,Zero,$pBifq,2*$BifRIGHT+128,XD_SUBJECT-Tgt
 09D0  FC B7 D9 03 B3 C1 F6 C7	      db XD_SUBJECT,Null,_Seq,+3,Zero,_RetB,Arg2-14,_Exists,_Then
	      C9
 09D9  0A FC 2B 5C B5 2B 7A A2	      db +10,XD_SUBJECT,$pBifq,2*$BifX2B,One,$pBifq,2*$BifLEFT,SIGNBIT-Tgt
 09E1  CB 03 B3 A2 FC BD 31 36	      db _Jump,+3,Zero,SIGNBIT-Tgt,XD_SUBJECT,String2,"16",String2
	      BD
 09EA  31 30 42 A4 F8 C9 0B FA	      db "10",RERADIX,XD_R-Tgt,SIGNBIT,_Then,+11,XD_R,String1,"2"
	      BB 32
 09F4  BB 34 F0 43 4B 41 A4	      db String1,"4",Arg2-14-6,$pMultiply,$pPower,$pSubtract,XD_R-Tgt
 09FB  FA 2B 54 FC D7 07 FC BD	      db XD_R,$pBifq,2*$BifABS,XD_MAX-2,_Gt,+7,XD_SUBJECT,String2
 0A03  33 35 3B E1 FA C1	      db "35",$pPositive,CONFIG_RAISE40,XD_R,_RetB
				     endif

				     ;$9.7.4
 0A09  04			      db $WholeGE
 0A0A  08			      db $WholeGT
 0A0B  20			      db $Stream
 0A0C  31			      ParmsRec <0,3,0001b>
 0A0D				     BifLINEIN:
 0A0D 33 81 F0 C7 C9 1E B9 06	     BIFLINEIN db 6*8+3,Frag19,Arg2-20,_Exists,_Then,+30,String,6
 0A15  4C 49 4E 45 49 4E EE EB	      db "LINEIN",Arg2-20-2,CONFIG_STREAM_POSITION,?RESPONSE,Frag5
	      08 65
 0A1F  08 B5 2B 7A BB 52 D9 0A	      db ?RESPONSE,One,$pBifq,2*$BifLEFT,String1,"R",_Seq,+10,String1
	      BB
 0A28  32 3B EE BD 34 31 3B E1	      db "2",$pPositive,Arg2-20-2,String2,"41",$pPositive,CONFIG_RAISE40
 0A30  77 B5 D7 07 FE BD 33 39	      db Frag14,One,_Gt,+7,L_COUNT,String2,"39",$pPositive,CONFIG_RAISE40
	      3B E1
 0A3A  FE B3 CD 0A B9 04 4E 55	      db L_COUNT,Zero,_Eq,+10,String,4,"NULL",CONFIG_STREAM_CHARIN
	      4C 4C ED
 0A45  B7 C1 B9 06 4C 49 4E 45	      db Null,_RetB,String,6,"LINEIN",CONFIG_STREAM_CHARIN,?RESPONSE
	      49 4E ED 08
 0A51  B5 2B 7A BB 4E DB 23 08	      db One,$pBifq,2*$BifLEFT,String1,"N",_Sne,+35,?RESPONSE,One
	      B5
 0A5A  2B 7A BB 45 D9 09 B9 05	      db $pBifq,2*$BifLEFT,String1,"E",_Seq,+9,String,5,"ERROR",?STREAMSTATE+Tgts
	      45 52 52 4F 52
	      1C
 0A68  B9 08 4E 4F 54 52 45 41	      db String,8,"NOTREADY",?STREAM,?RESPONSE,String1,"2",$pPositive
	      44 59 04 08 BB
	      32 3B
 0A77  2B 7C DF 00 C1		      db $pBifq,2*$BifSUBSTR,CONFIG_RAISE,?OUTCOME,_RetB

				     if Solid
				     ;$9.7.5
 0A7C  08			      db $WholeGT
 0A7D  20			      db $Stream
 0A7E  35			      ParmsRec <0,3,0101b>
 0A7F				     BifLINEOUT:
 0A7F 33 81 F0 F3 B3		     BIFLINEOUT db 6*8+3,Frag19,Arg2-20,CONFIG_STREAM_CHAROUT,Zero
 0A84  C1 F2 C1			      db _RetB,Arg3-20,_RetB
				     endif

				     ;$9.7.3
 0A87  43 4E			      db "CN"
 0A89  FE			      db -@SizeStr(<CN>)
 0A8A  20			      db $Stream
 0A8B  23			      ParmsRec <0,2,0011b>
 0A8C				     BifCHARS:
 0A8C 0A 8B B9 05 43 48 41 52	     BIFCHARS db 1*8+2,Frag24,String,5,"CHARS",H_OPTION-2,CONFIG_STREAM_COUNT
	      53 FC F5
 0A97  C1			      db _RetB

				     ;$9.7.6
 0A98  43 4E			      db "CN"
 0A9A  FE			      db -@SizeStr(<CN>)
 0A9B  20			      db $Stream
 0A9C  23			      ParmsRec <0,2,0011b>
 0A9D				     BifLINES:
 0A9D 0A 8B B9 05 4C 49 4E 45	     BIFLINES db 1*8+2,Frag24,String,5,"LINES",N_OPTION-2,CONFIG_STREAM_COUNT
	      53 FC F5
 0AA8  C1			      db _RetB
				     ;$9.7.7
 0AA9  20			     db $Stream
 0AAA  17			     ParmsRec <0,1,0111b>
 0AAB				     BifQUALIFY:
 0AAB 41 EE C7 C9 05 EE 1A	     BIFQUALIFY db 8*8+1,Arg1-20,_Exists,_Then,+5,Arg1-20,?STREAM+Tgts
 0AB2  CB 03 B7 1A B7 B3 F7	      db _Jump,+3,Null,?STREAM+Tgts,Null,Zero,CONFIG_STREAM_QUALIFIED
 0AB9  C1			      db _RetB

				     ;$9.3.18
 0ABA  18			     db $Pad
 0ABB  04			     db $WholeGE
 0ABC  99			     ParmsRec <2,1,1001b>
 0ABD				     BifRIGHT:
 0ABD 23 87 D5 08 F2 FA B5 3F	     BIFRIGHT db 4*8+3,Frag22,_Ge,+8,R_STRING,R_TRIM-2,One,$pAdd,$pBifq
	      2B
 0AC6  7C C1 FE FA 3D 2B 70	      db 2*$BifSUBSTR,_RetB,R_PAD,R_TRIM-2,$pNegate,$pBifq,2*$BifCOPIES
 0ACD  F0 01 C1			      db R_STRING-2,$pAbut,_RetB

				     ;$9.3.19
 0AD0  18			     db $Pad
 0AD1  04			     db $WholeGE
 0AD2  69			     ParmsRec <1,2,1001b>
 0AD3				     BifSPACE:
 0AD3 33 F0 C7 C9 05 F0 A6	     BIFSPACE db 6*8+3,Arg2-20,_Exists,_Then,+5,Arg2-20,S_NUM-Tgt
 0ADA  CB 03 B5 A6 F2 C7 C9 05	      db _Jump,+3,One,S_NUM-Tgt,Arg3-20,_Exists,_Then,+5,Arg3-20,S_PAD-Tgt
	      F2 A8
 0AE4  CB 04 BB 20 A8 FE FA 2B	      db _Jump,+4,String1," ",S_PAD-Tgt,S_PAD,S_NUM-2,$pBifq,2*$BifCOPIES
	      70
 0AED  A4 EE B5 B5 2B F6 A2	      db PADDING-Tgt,S_STRING,One,One,$pBifq,2*$BifSUBWORD+128,S_OUTPUT-Tgt
 0AF4  BB 32 0D E4 2B 18 0F	      db String1,"2",$pNumber,S_STRING-10,$pBifq,2*$BifWORDS,$pTo
 0AFB  5B EC			      db $pControlVar,S_I-10
 0AFD  000D R			      dw $+13
 0AFF  EE EE 01 E2 E8 B5 2B	     db S_OUTPUT-10,PADDING-12,$pAbut,S_STRING-12,S_I-14,One,$pBifq
 0B06  F6 01 98 C5 F8		      db 2*$BifSUBWORD+128,$pAbut,S_OUTPUT-Tgt-10,_IterCV,S_OUTPUT
 0B0B  C1			      db _RetB

				     ;$9.3.20
 0B0C  18			     db $Pad
 0B0D  4C 54 42			     db "LTB"
 0B10  FD			     db -@SizeStr(<LTB>)
 0B11  69			     ParmsRec <1,2,1001b>
 0B12				     BifSTRIP:
 0B12 1B F6 C7 C9 05 F6 A8	     BIFSTRIP db 3*8+3,Arg2-14,_Exists,_Then,+5,Arg2-14,OPTION_-Tgt
 0B19  CB 04 BB 42 A8 F8 C7 C9	      db _Jump,+4,String1,"B",OPTION_-Tgt,Arg3-14,_Exists,_Then,+5
	      05
 0B22  F8 A6 CB 0A B9 06 09 0A	      db Arg3-14,UNWANTED-Tgt,_Jump,+10,String,6,09h,0ah,0bh,0ch,0dh
	      0B 0C 0D
 0B2D  20 A6 FE BB 4C D9 00 FC	      db 020h,UNWANTED-Tgt,OPTION_,String1,"L",_Seq,00h,OPTION_-2
 0B35  BB 42 D9 00 37 C9 1C 59	      db String1,"B",_Seq,00h,$pOr,_Then,+28,$pRepEver
 0B3D  001A R			      dw $+26
 0B3F  EA B7 DB 00 E8 B5 2B 7A	     db ST_STRING-10,Null,_Sne,00h,ST_STRING-12,One,$pBifq,2*$BifLEFT
 0B47  EE 2B 78 B3 D7 00 35 15	      db UNWANTED-14,$pBifq,2*$BifPOS,Zero,_Gt,00h,$pAnd,$pWhile,ST_STRING-10
	      EA
 0B50  BB 32 3B 2B 7C 94	      db String1,"2",$pPositive,$pBifq,2*$BifSUBSTR,ST_STRING-Tgt-10
 0B56  1B FE BB 54 D9 00 FC BB	      db $pIterate,OPTION_,String1,"T",_Seq,00h,OPTION_-2,String1
 0B5E  42 D9 00 37 C9 1D 59	      db "B",_Seq,00h,$pOr,_Then,+29,$pRepEver
 0B65  001B R			      dw $+27
 0B67  EA B7 DB 00 E8 B5 2B 34	     db ST_STRING-10,Null,_Sne,00h,ST_STRING-12,One,$pBifq,2*$BifRIGHT
 0B6F  EE 2B 78 B3 D7 00 35 15	      db UNWANTED-14,$pBifq,2*$BifPOS,Zero,_Gt,00h,$pAnd,$pWhile,ST_STRING-10
	      EA
 0B78  E8 2D B5 41 2B 7A 94	      db ST_STRING-12,$pLength,One,$pSubtract,$pBifq,2*$BifLEFT,ST_STRING-Tgt-10
 0B7F  1B F4 C1			      db $pIterate,ST_STRING,_RetB
				     ;$9.8.5
 0B82  43 48 4C 4D 4E 53	      db "CHLMNS"
 0B88  FA			      db -@SizeStr(<CHLMNS>)
 0B89  43 45 48 4C 4D 4E 4F 52	      db "CEHLMNORS"
	      53
 0B92  F7			      db -@SizeStr(<CEHLMNORS>)
 0B93  35			      ParmsRec <0,3,0101b>
 0B94				     BifTIME:
 0B94 6B BD 31 38 93 E2 C7 33	     BIFTIME db 13*8+3,String2,"18",Frag28,Arg2-34,_Exists,$pNot,_Then
	      C9
 0B9D  05 0E FC 48 C1 FE B9	      db +5,?CLAUSELOCAL,T_OPTION-2,TIMEFORMAT,_RetB,T_OPTION,String
 0BA4  03 45 52 4F 2B 78 B3 D7	      db 3,"ERO",$pBifq,2*$BifPOS,Zero,_Gt,+7,T_OPTION,String2,"29"
	      07 FE BD 32 39
 0BB1  3B E1 83 B3 A4 B3 9A	      db $pPositive,CONFIG_RAISE40,Frag20,Zero,HH-Tgt,Zero,MM-Tgt
 0BB8  B3 A6 B3 A2 F4 BB 43 D9	      db Zero,SS_-Tgt,Zero,HOURADJUST-Tgt,T_INOPTION,String1,"C",_Seq
 0BC0  25 F6 09 00 BB 3A 2A F8	      db +37,INVALUE,$pParse,00h,String1,":",02ah,HH-2,One,03ah,String1
	      B5 3A BB
 0BCB  32 3A EE 22 F0 1A FA BD	      db "2",03ah,MM-2,022h,XX-2,01ah,HH,String2,"12",_Eq,+3,Zero
	      31 32 CD 03 B3
 0BD8  A4 F2 BD 70 6D D9 05 BD	      db HH-Tgt,XX,String2,"pm",_Seq,+5,String2,"12",HOURADJUST-Tgt
	      31 32 A2
 0BE3  CB 32 F4 BB 48 D9 05 F6	      db _Jump,+50,T_INOPTION,String1,"H",_Seq,+5,INVALUE,HH-Tgt,_Jump
	      A4 CB
 0BED  29 F4 BB 4C D9 00 F2 BB	      db +41,T_INOPTION,String1,"L",_Seq,00h,T_INOPTION-2,String1
 0BF5  4E D9 00 37 C9 11 F6 09	      db "N",_Seq,00h,$pOr,_Then,+17,INVALUE,$pParse,00h,String1,":"
	      00 BB 3A
 0C00  2A F8 BB 3A 2A EE 22 FA	      db 02ah,HH-2,String1,":",02ah,MM-2,022h,SS_-2,01ah,_Jump,+12
	      1A CB 0C
 0C0B  F4 BB 4D D9 05 F6 9A CB	      db T_INOPTION,String1,"M",_Seq,+5,INVALUE,MM-Tgt,_Jump,+3,INVALUE
	      03 F6
 0C15  A6 FA 63 BB 4E 67 FA F6	      db SS_-Tgt,HH,Frag4,String1,"N",Frag6,HH,HOURADJUST-2,$pAdd
	      3F
 0C1E  A4 FA BD 36 30 43 EE 3F	      db HH-Tgt,HH,String2,"60",$pMultiply,MM-2,$pAdd,String2,"60"
	      BD 36 30
 0C29  43 FA 3F B9 07 31 30 30	      db $pMultiply,SS_-2,$pAdd,String,7,"1000000",$pMultiply,$pBifq
	      30 30 30 30 43
	      2B
 0C37  1A 98 EE B3 D1 00 EC BD	      db 2*$BifTRUNC,T_MICRO-Tgt,T_MICRO,Zero,_Lt,00h,T_MICRO-2,String2
 0C3F  32 34 B9 04 33 36 30 30	      db "24",String,4,"3600",$pMultiply,String,7,"1000000",$pMultiply
	      43 B9 07 31 30
	      30 30 30 30 30
	      43
 0C52  D7 00 37 C9 08 F6 F2 BD	      db _Gt,00h,$pOr,_Then,+8,INVALUE,T_INOPTION-2,String2,"19",$pPositive
	      31 39 3B
 0C5D  E1 EE F2 48 7B 48	      db CONFIG_RAISE40,T_MICRO,T_INOPTION-2,TIMEFORMAT,Frag16,TIMEFORMAT
 0C63  C1			      db _RetB

 0C64 2A F2 3C 09 02 22 FE	     TIMEFORMAT$$ db 5*8+2,Arg1-16,TIME2DATE,$pParse,02h,022h,ParseDot
 0C6B  FE FE F8 FC FA F6	      db ParseDot,ParseDot,T_HOUR-2,T_MINUTE-2,T_SECOND-2,T_MICROSECOND-2
 0C71  FE 1A F4 BB 43 D9 3B FA	      db ParseDot,01ah,Arg2-16,String1,"C",_Seq,+59,T_HOUR,String2
	      BD
 0C7A  31 32 D7 0E FA BD 31 32	      db "12",_Gt,+14,T_HOUR,String2,"12",$pSubtract,Frag2,String2
	      41 5F BD
 0C85  70 6D 01 C1 CB 26 FA BD	      db "pm",$pAbut,_RetB,_Jump,+38,T_HOUR,String2,"12",_Eq,+9,Frag1
	      31 32 CD 09 5D
 0C92  BD 70 6D 01 C1 CB 18 FA	      db String2,"pm",$pAbut,_RetB,_Jump,+24,T_HOUR,Zero,_Gt,+10,T_HOUR
	      B3 D7 0A FA
 0C9E  5F BD 61 6D 01 C1 CB 0B	      db Frag2,String2,"am",$pAbut,_RetB,_Jump,+11,T_HOUR,Zero,_Eq
	      FA B3 CD
 0CA9  07 5D BD 61 6D 01 C1 CB	      db +7,Frag1,String2,"am",$pAbut,_RetB,_Jump,+134,Arg2-16,String1
	      86 F4 BB
 0CB4  45 D9 00 F2 BB 52 D9 00	      db "E",_Seq,00h,Arg2-16-2,String1,"R",_Seq,00h,$pOr,_Then,+31
	      37 C9 1F
 0CBF  14 B7 D9 05 0C 2A B3	      db ?STARTTIME,Null,_Seq,+5,?CLAUSETIME,?STARTTIME+Tgts,Zero
 0CC6  C1 0C 14 41 A0 F4	      db _RetB,?CLAUSETIME,?STARTTIME,$pSubtract,TF_OUTPUT-Tgt,Arg2-16
 0CCC  BB 52 D9 03 0C 2A F6	      db String1,"R",_Seq,+3,?CLAUSETIME,?STARTTIME+Tgts,TF_OUTPUT
 0CD3  B9 04 31 45 2D 36 43 C1	      db String,4,"1E-6",$pMultiply,_RetB,_Jump,+91,Arg2-16,String1
	      CB 5B F4 BB
 0CDF  48 D9 05 FA C1 CB 52 F4	      db "H",_Seq,+5,T_HOUR,_RetB,_Jump,+82,Arg2-16,String1,"L",_Seq
	      BB 4C D9
 0CEA  10 89 BB 2E 01 F6 BB 36	      db +16,Frag23,String1,".",$pAbut,T_MICROSECOND-2,String1,"6"
 0CF2  3B B3 2B B4 01 C1 CB	      db $pPositive,Zero,$pBifq,2*$BifRIGHT+128,$pAbut,_RetB,_Jump
 0CF9  3E F4 BB 4D D9 0B BD 36	      db +62,Arg2-16,String1,"M",_Seq,+11,String2,"60",T_HOUR-2,$pMultiply
	      30 F8 43
 0D04  FC 3F C1 CB 2F F4 BB 4E	      db T_MINUTE-2,$pAdd,_RetB,_Jump,+47,Arg2-16,String1,"N",_Seq
	      D9
 0D0D  05 89 C1 CB 26 F4 BB 4F	      db +5,Frag23,_RetB,_Jump,+38,Arg2-16,String1,"O",_Seq,+16,?CLAUSELOCAL
	      D9 10 0E
 0D18  0C 41 B9 04 31 45 2B 36	      db ?CLAUSETIME,$pSubtract,String,4,"1E+6",$pDivide,$pBifq,2*$BifTRUNC
	      45 2B 1A
 0D23  C1 CB 12 B9 04 33 36 30	      db _RetB,_Jump,+18,String,4,"3600",T_HOUR-2,$pMultiply,String2
	      30 F8 43 BD
 0D2F  36 30 FA 43 3F FA 3F C1	      db "60",T_MINUTE-4,$pMultiply,$pAdd,T_SECOND-2,$pAdd,_RetB

 0D37 41 B9 04 31 39 38 30 EC	     DOS_TIME$$ db 8*8+1,String,4,"1980",TV-2,String1,"7",$pPositive
	      BB 37 3B
 0D42  B5 2B FC 2B 62 3F A6	      db One,$pBifq,2*$BifSUBSTR+128,$pBifq,2*$BifC2D,$pAdd,DT_YEAR-Tgt
 0D49  EE BB 36 3B B5 2B FC 2B	      db TV,String1,"6",$pPositive,One,$pBifq,2*$BifSUBSTR+128,$pBifq
 0D51  62 9C EE BB 35 3B B5 2B	      db 2*$BifC2D,DT_MONTH-Tgt,TV,String1,"5",$pPositive,One,$pBifq
 0D59  FC 2B 62 9A B9 2A 30 20	      db 2*$BifSUBSTR+128,$pBifq,2*$BifC2D,DT_DAY-Tgt,String,42,
	      33 31 20 35 39
	      20 39 30 20 31
	      32 30 20 31 35
	      31 20 31 38 31
	      20 32 31 32 20
	      32 34 33 20 32
	      37 33 20 33 30
	      34 20 33 33 34
	      F0 3B
				     "0 31 59 90 120 151 181 212 243 273 304 334",DT_MONTH-2,$pPositive
 0D8B  2B 72 7D 8D F8 B9 05 38	      db $pBifq,2*$BifWORD,Frag17,Frag25,DT_BASEDAYS,String,5,"864E8"
	      36 34 45 38
 0D97  43 B9 04 33 36 45 38 EA	      db $pMultiply,String,4,"36E8",TV-4,String1,"4",$pPositive,One
	      BB 34 3B B5
 0DA3  2B FC 2B 62 43 3F	      db $pBifq,2*$BifSUBSTR+128,$pBifq,2*$BifC2D,$pMultiply,$pAdd
 0DA9  B9 03 36 45 37 EA BB 33	      db String,3,"6E7",TV-4,String1,"3",$pPositive,One,$pBifq,2*$BifSUBSTR+128
	      3B B5 2B FC
 0DB5  2B 62 43 3F B9 03 31 45	      db $pBifq,2*$BifC2D,$pMultiply,$pAdd,String,3,"1E6",TV-4,String1
	      36 EA BB
 0DC0  32 3B B5 2B FC 2B 62	      db "2",$pPositive,One,$pBifq,2*$BifSUBSTR+128,$pBifq,2*$BifC2D
 0DC7  43 3F B9 03 31 45 34 EA	      db $pMultiply,$pAdd,String,3,"1E4",TV-4,One,$pBifq,2*$BifLEFT
	      B5 2B 7A
 0DD2  2B 62 43 3F C1		      db $pBifq,2*$BifC2D,$pMultiply,$pAdd,_RetB

 0DD7 01 FE 4F BF		     B4VALUE1 db 0*8+1,Arg1-4,$pInterpret,_RetBc

 0DDB 0A FA 2B 6E A8 FC 16	     B4VALUE2 db 1*8+2,Arg1-8,$pBifq,2*$BifVALUE,B4V-Tgt,Arg2-8,?OUTCOME+Tgts
 0DE2  FA B9 0C 3D 20 27 51 55	      db Arg1-8,String,12,"= 'QUEUED'()",$pAbut,$pInterpret,B4V,_RetB
	      45 55 45 44 27
	      28 29 01 4F FE
	      C1

 0DF5 01 B9 04 44 52 4F 50 FC	     B4DROP db 0*8+1,String,4,"DROP",Arg1-4-2,$pCat,$pInterpret,_RetBc
	      03 4F BF

 0E00 01 B9 10 50 52 4F 43 45	     B4EXPOSE db 0*8+1,String,16,"PROCEDURE EXPOSE",Arg1-4-2,$pCat
	      44 55 52 45 20
	      45 58 50 4F 53
	      45 FC 03
 0E15  4F BF			      db $pInterpret,_RetBc

 0E17 28 04 A8 FE BB 32 3B	     STREAMQUALIFY db 5*8+0,?STREAM,Q_T-Tgt,Q_T,String1,"2",$pPositive
 0E1E  B5 2B FC BB 3A D9 0D FE	      db One,$pBifq,2*$BifSUBSTR+128,String1,":",_Seq,+13,Q_T,$pParse
	      09
 0E27  00 BB 3A 2A F4 22 FC 1A	      db 00h,String1,":",02ah,Q_DRIVE-2,022h,Q_T-2,01ah,_Jump,+5,Null
	      CB 05 B7
 0E32  B5 F7 A0 BB 5C 8F	      db One,CONFIG_STREAM_QUALIFIED,Q_DRIVE-Tgt,String1,"\",Frag26
 0E38  F8 B5 2B 7A BB 5C DB 0F	      db Q_PATH,One,$pBifq,2*$BifLEFT,String1,"\",_Sne,+15,String1
	      BB
 0E41  5C F4 BB 32 3B F7	      db "\",Q_DRIVE-2,String1,"2",$pPositive,CONFIG_STREAM_QUALIFIED
 0E47  01 BB 5C 01 F6 01 A2 F6	      db $pAbut,String1,"\",$pAbut,Q_PATH-2,$pAbut,Q_PATH-Tgt,Q_DRIVE
 0E4F  BB 3A 01 F6 01 F8 01 E3	      db String1,":",$pAbut,Q_PATH-2,$pAbut,Q_NAME-2,$pAbut,CONFIG_UPPER
 0E57  A8 FE BB 33 3B F7	      db Q_T-Tgt,Q_T,String1,"3",$pPositive,CONFIG_STREAM_QUALIFIED
 0E5D  A8 BF			      db Q_T-Tgt,_RetBc

 0E5F 69 E4 E3 A8 B3 9E		     PATHQUALIFY db 13*8+1,Arg1-30,CONFIG_UPPER,PQ_T-Tgt,Zero,PQ_HAVEENV-Tgt
 0E65  B7 A0 FE BB 32 3B B5 2B	      db Null,PQ_DRIVE-Tgt,PQ_T,String1,"2",$pPositive,One,$pBifq
 0E6D  FC BB 3A D9 0B FE 09 00	      db 2*$BifSUBSTR+128,String1,":",_Seq,+11,PQ_T,$pParse,00h,String1
	      BB
 0E76  3A 2A F4 22 FC 1A BB 5C	      db ":",02ah,PQ_DRIVE-2,022h,PQ_T-2,01ah,String1,"\",Frag26,PQ_NAME
	      8F FA
 0E80  09 00 BB 2E 2A F8 22 F0	      db $pParse,00h,String1,".",02ah,PQ_NAME-2,022h,PQ_EXTEN-2,01ah
	      1A
 0E89  B3 9A B7 B5 F7 98	      db Zero,PQ_EXISTS-Tgt,Null,One,CONFIG_STREAM_QUALIFIED,PQ_LETTER-Tgt
 0E8F  BB 5C EC BB 32 3B F7	      db String1,"\",PQ_LETTER-2,String1,"2",$pPositive,CONFIG_STREAM_QUALIFIED
 0E96  01 96 F8 94 59		      db $pAbut,PQ_PREFIX-Tgt,PQ_PATH,PQ_DIR-Tgt,$pRepEver
 0E9B  00BD R			      dw $+189
 0E9D  EC B7 D9 00 EA E0 D9 00	     db PQ_DRIVE-10,Null,_Seq,00h,PQ_DRIVE-12,PQ_LETTER-14,_Seq,00h
 0EA5  37 C9 69 E0 9E E0 B5 2B	      db $pOr,_Then,+105,PQ_DIR-10,PQ_T-Tgt-10,PQ_DIR-10,One,$pBifq
 0EAD  7A BB 5C DB 08 E2 BB 5C	      db 2*$BifLEFT,String1,"\",_Sne,+8,PQ_PREFIX-10,String1,"\",$pAbut
	      01
 0EB6  DE 01 9E F4 EC 2D	      db PQ_DIR-12,$pAbut,PQ_T-Tgt-10,PQ_T-10,PQ_PATH-12,$pLength
 0EBC  2B 34 EC D9 50 E4 BB	      db $pBifq,2*$BifRIGHT,PQ_PATH-12,_Seq,+80,PQ_LETTER-10,String1
 0EC3  3A 01 F2 01 EE 01 BB 2E	      db ":",$pAbut,PQ_T-12,$pAbut,PQ_NAME-12,$pAbut,String1,".",$pAbut
	      01
 0ECC  9E E8 B7 DB 0D F4 E6	      db PQ_T-Tgt-10,PQ_EXTEN-10,Null,_Sne,+13,PQ_T-10,PQ_EXTEN-12
 0ED3  01 88 DE BB 34 3B F7	      db $pAbut,PQ_R-Tgt-10,PQ_R-10,String1,"4",$pPositive,CONFIG_STREAM_QUALIFIED
 0EDA  90 CB 30 B5 0D BB 35 0F	      db PQ_EXISTS-Tgt-10,_Jump,+48,One,$pNumber,String1,"5",$pTo
 0EE2  5B E8			      db $pControlVar,PQ_J-20
 0EE4  0028 R			      dw $+40
 0EE6  EA B9 13 43 4F 4D 20 45	     db PQ_T-20,String,19,"COM EXE REX CMD BAT",PQ_J-24,$pBifq,2*$BifWORD
	      58 45 20 52 45
	      58 20 43 4D 44
	      20 42 41 54 E4
	      2B 72
 0EFF  01 7E D4 BB 34 3B F7	      db $pAbut,PQ_R-Tgt-20,PQ_R-20,String1,"4",$pPositive,CONFIG_STREAM_QUALIFIED
 0F06  86 DC C9 02 1D C5 E6	      db PQ_EXISTS-Tgt-20,PQ_EXISTS-20,_Then,+2,$pLeave,_IterCV,PQ_EXISTS-10
 0F0D  C9 02 1D EA B3 CD 12 B5	      db _Then,+2,$pLeave,PQ_HAVEENV-10,Zero,_Eq,+18,One,PQ_HAVEENV-Tgt-10
	      94
 0F16  B9 04 50 41 54 48 B7 B9	      db String,4,"PATH",Null,String,3,"DOS",$pBifq,2*$BifVALUE+1
	      03 44 4F 53 2B
	      6F
 0F24  86 DC 09 00 BB 3B 2A DE	      db PQ_REST-Tgt-10,PQ_REST-10,$pParse,00h,String1,";",02ah,PQ_DIR-12
 0F2C  22 DA 1A E0 B7 D9 02 1D	      db 022h,PQ_REST-12,01ah,PQ_DIR-10,Null,_Seq,+2,$pLeave,PQ_DIR-10
	      E0
 0F35  BB 5C 01 8A E0 BB 32 3B	      db String1,"\",$pAbut,PQ_DIR-Tgt-10,PQ_DIR-10,String1,"2",$pPositive
 0F3D  B5 2B FC BB 3A D9 14 E0	      db One,$pBifq,2*$BifSUBSTR+128,String1,":",_Seq,+20,PQ_DIR-10
 0F45  09 00 BB 3A 2A E2 22 DE	      db $pParse,00h,String1,":",02ah,PQ_LETTER-12,022h,PQ_DIR-12
 0F4D  1A BB 5C E2 BB 32 3B F7	      db 01ah,String1,"\",PQ_LETTER-12,String1,"2",$pPositive,
	      01 8C 1B F0
				     CONFIG_STREAM_QUALIFIED,$pAbut,PQ_PREFIX-Tgt-10,$pIterate,PQ_EXISTS
 0F59  B3 CD 03 B7 92 E8 BB 33	      db Zero,_Eq,+3,Null,PQ_R-Tgt,PQ_R,String1,"3",$pPositive,
	      3B F7 92 BF
				     CONFIG_STREAM_QUALIFIED,PQ_R-Tgt,_RetBc

 0F65 19 F8 09 00 22 FC FA 1A	     LINESPLIT db 3*8+1,LS_T,$pParse,00h,022h,LS_N-2,LS_P-2,01ah,LS_P
	      FC
 0F6E  2B 12 4D FE C1		      db $pBifq,2*$BifSTRIP,$pCommand,LS_N,_RetB

 0F73 09 FC A8 FE 2D BB 34	     COMMANDWRAP db 1*8+1,Arg1-6,CW_T-Tgt,CW_T,$pLength,String1,"4"
 0F7A  3F 2B 64 B9 03 2F 43 20	      db $pAdd,$pBifq,2*$BifD2C,String,3,"/C ",$pAbut,Arg1-6-2,$pAbut
	      01 FA 01
 0F85  B9 01 0D 01 C1		      db String,1,0dh,$pAbut,_RetB
 0F8A = 0F8A			     RoutineBase$ equ $
 0F8A  1808 R			      dw ARITHOP$$
 0F8C  184F R			      dw PREPARE$$
 0F8E  1B93 R			      dw _MULTIPLY$$
 0F90  1BF5 R			      dw _DIVTYPE$$
 0F92  1D1E R			      dw _POWER$$
 0F94  1A72 R			      dw _ADDSUBCOMP$$
 0F96  1912 R			      dw _POSTOP$$
 0F98  1A57 R			      dw _FLOATING$$
 0F9A  1DA6 R			      dw TIME2DATE$$
 0F9C  1DCF R			      dw TIME2DATE2$$
 0F9E  1EB8 R			      dw LEAP$$
 0FA0  1ED7 R			      dw RERADIX$$
 0FA2  0D37 R			      dw DOS_TIME$$
 0FA4  0335 R			      dw DATEFORMAT$$
 0FA6  0C64 R			      dw TIMEFORMAT$$
 0FA8 = 0FA8			     FragsBase$ equ $
 0FA8  160B R			      dw Frag1$$
 0FAA  1619 R			      dw Frag2$$
 0FAC  1625 R			      dw Frag3$$
 0FAE  1633 R			      dw Frag4$$
 0FB0  1641 R			      dw Frag5$$
 0FB2  164F R			      dw Frag6$$
 0FB4  165D R			      dw Frag7$$
 0FB6  166B R			      dw Frag8$$
 0FB8  1679 R			      dw Frag9$$
 0FBA  1687 R			      dw Frag10$$
 0FBC  1696 R			      dw Frag11$$
 0FBE  16A5 R			      dw Frag12$$
 0FC0  16B2 R			      dw Frag13$$
 0FC2  16BE R			      dw Frag14$$
 0FC4  16CA R			      dw Frag15$$
 0FC6  16DA R			      dw Frag16$$
 0FC8  16E7 R			      dw Frag17$$
 0FCA  16F6 R			      dw Frag18$$
 0FCC  170B R			      dw Frag19$$
 0FCE  1718 R			      dw Frag20$$
 0FD0  1726 R			      dw Frag21$$
 0FD2  1749 R			      dw Frag22$$
 0FD4  175C R			      dw Frag23$$
 0FD6  1770 R			      dw Frag24$$
 0FD8  1786 R			      dw Frag25$$
 0FDA  17AE R			      dw Frag26$$
 0FDC  17C9 R			      dw Frag27$$
 0FDE  17E2 R			      dw Frag28$$

				     ;$9.3.23
 0FE0  18			     db $Pad
 0FE1  7E			     ParmsRec <1,3,1110b>
 0FE2				     BifTRANSLATE:
 0FE2 44 EA C7 33 EA C7		     BIFTRANSLATE db 8*8+4,Arg2-26,_Exists,$pNot,Arg3-26-2,_Exists
 0FE8  33 35 C9 04 E8 E3 C1 EC	      db $pNot,$pAnd,_Then,+4,T_STRING,CONFIG_UPPER,_RetB,Arg3-26
 0FF0  C7 33 C9 06 2B 4E A6 CB	      db _Exists,$pNot,_Then,+6,$pBifq,2*$BifXRANGE,TABLEI-Tgt,_Jump
 0FF8  03 EC A6 EA C7 C9 05 EA	      db +3,Arg3-26,TABLEI-Tgt,Arg2-26,_Exists,_Then,+5,Arg2-26,TABLEO-Tgt
	      A8
 1001  CB 03 B7 A8 EE C7 C9 05	      db _Jump,+3,Null,TABLEO-Tgt,Arg4-26,_Exists,_Then,+5,Arg4-26
	      EE
 100A  A4 CB 04 BB 20 A4 FE FA	      db T_PAD-Tgt,_Jump,+4,String1," ",T_PAD-Tgt,TABLEO,TABLEI-2
 1012  2D F6 2B FA A8 B7 A2	      db $pLength,T_PAD-4,$pBifq,2*$BifLEFT+128,TABLEO-Tgt,Null,T_OUTPUT-Tgt
 1019  B5 0D DE 2D 0F 5B EC	      db One,$pNumber,T_STRING-10,$pLength,$pTo,$pControlVar,T_J-10
 1020  0020 R			      dw $+32
 1022  DE EA B5 2B FC 94	     db T_STRING-10,T_J-12,One,$pBifq,2*$BifSUBSTR+128,T_C-Tgt-10
 1028  EA F0 2B 78 92 E8 B3 CD	      db T_C-10,TABLEI-12,$pBifq,2*$BifPOS,KK-Tgt-10,KK-10,Zero,_Eq
 1030  07 EE E8 01 98 CB 09 EE	      db +7,T_OUTPUT-10,T_C-12,$pAbut,T_OUTPUT-Tgt-10,_Jump,+9,T_OUTPUT-10
 1038  F2 E4 B5 2B FC 01 98	      db TABLEO-12,KK-14,One,$pBifq,2*$BifSUBSTR+128,$pAbut,T_OUTPUT-Tgt-10
 103F  C5 F8 C1			      db _IterCV,T_OUTPUT,_RetB
				     ;$9.4.6
 1042  04			     db $WholeGE
 1043  0C			     db $Num
 1044  53			     ParmsRec <1,1,0011b>
 1045				     BifTRUNC:
 1045 22 F6 C7 C9 05 F6 A8	     BIFTRUNC db 4*8+2,Arg2-14,_Exists,_Then,+5,Arg2-14,T_NUM-Tgt
 104C  CB 03 B3 A8 BD 31 30 FC	      db _Jump,+3,Zero,T_NUM-Tgt,String2,"10",T_NUM-2,$pPower,T_NUMBER-2
	      4B F2
 1056  43 B5 47 A6 FE B3 CD 03	      db $pMultiply,One,$pIntDivide,T_INTEGER-Tgt,T_NUM,Zero,_Eq,+3
 105E  FC C1 FC 2D FC 41 A4	      db T_INTEGER,_RetB,T_INTEGER,$pLength,T_NUM-2,$pSubtract,T_T-Tgt
 1065  FA B3 D3 0D BD 30 2E FA	      db T_T,Zero,_Le,+13,String2,"0.",T_INTEGER-2,T_NUM-4,Zero,$pBifq
	      FA B3 2B
 1070  B4 01 C1 CB 08 BB 2E FA	      db 2*$BifRIGHT+128,$pAbut,_RetB,_Jump,+8,String1,".",T_INTEGER-2
 1078  F6 2B B8 C1		      db T_T-4,$pBifq,2*$BifINSERT+128,_RetB
				     ;$9.3.24
 107C  08			     db $WholeGT
 107D  4D 4E			     db "MN"
 107F  FE			     db -@SizeStr(<MN>)
 1080  AC			     ParmsRec <2,2,1100b>
 1081				     BifVERIFY:
 1081 64 E4 C7 C9 05 E4 9E	     BIFVERIFY db 12*8+4,Arg3-34,_Exists,_Then,+5,Arg3-34,V_OPTION-Tgt
 1088  CB 04 BB 4E 9E E6 C7 C9	      db _Jump,+4,String1,"N",V_OPTION-Tgt,Arg4-34,_Exists,_Then,+5
	      05
 1091  E6 A8 CB 03 B5 A8 E0 2D	      db Arg4-34,V_START-Tgt,_Jump,+3,One,V_START-Tgt,V_STRING,$pLength
 1099  A6 FE FA D7 03 B3 C1 E2	      db LAST-Tgt,V_START,LAST-2,_Gt,+3,Zero,_RetB,REFERENCE,Null
	      B7
 10A2  D9 0C F4 BB 4E D9 05 FE	      db _Seq,+12,V_OPTION,String1,"N",_Seq,+5,V_START,_RetB,_Jump
	      C1 CB
 10AC  03 B3 C1 FE 0D F2 0F 5B	      db +3,Zero,_RetB,V_START,$pNumber,LAST-10,$pTo,$pControlVar
 10B4  F0			      db V_I-10
 10B5  001F R			      dw $+31
 10B7  D6 EE B5 2B FC D6	     db V_STRING-10,V_I-12,One,$pBifq,2*$BifSUBSTR+128,REFERENCE-12
 10BD  2B 78 98 EA BB 4E D9	      db $pBifq,2*$BifPOS,V_T-Tgt-10,V_OPTION-10,String1,"N",_Seq
 10C4  09 EE B3 CD 03 F0 C1 CB	      db +9,V_T-10,Zero,_Eq,+3,V_I-10,_RetB,_Jump,+7,V_T-10,Zero,_Gt
	      07 EE B3 D7
 10D0  03 F0 C1 C5 B3 C1	      db +3,V_I-10,_RetB,_IterCV,Zero,_RetB

				     ;$9.3.27
 10D6  08			     db $WholeGT
 10D7  8B			     ParmsRec <2,0,1011b>
 10D8				     BifWORDLENGTH:
 10D8 02 FC FC B5 2B F6		     BIFWORDLENGTH db 0*8+2,Arg1-6,Arg2-6-2,One,$pBifq,2*$BifSUBWORD+128
 10DE  2D C1			      db $pLength,_RetB

				     ;$9.3.28
 10E0  08			     db $WholeGT
 10E1  9D			     ParmsRec <2,1,1101b>
 10E2				     BifWORDPOS:
 10E2 33 75 2B 1E 98 EE		     BIFWORDPOS db 6*8+3,Frag13,$pBifq,2*$BifSPACE,PHRASE-Tgt,PHRASE
 10E8  2B 18 A6 FC B3 CD 03	      db $pBifq,2*$BifWORDS,PHRASEWORDS-Tgt,PHRASEWORDS,Zero,_Eq,+3
 10EF  B3 C1 F0 2B 1E 9A F0	      db Zero,_RetB,WP_STRING,$pBifq,2*$BifSPACE,WP_STRING-Tgt,WP_STRING
 10F6  2B 18 A4 FE 0D F0	      db $pBifq,2*$BifWORDS,STRINGWORDS-Tgt,R_START,$pNumber,STRINGWORDS-10
 10FC  F0 41 B5 3F 0F 5B EE	      db PHRASEWORDS-12,$pSubtract,One,$pAdd,$pTo,$pControlVar,WORDNUMBER-10
 1103  000D R			      dw $+13
 1105  E4 E4 EA EC 2B		     db PHRASE-10,WP_STRING-12,WORDNUMBER-14,PHRASEWORDS-16,$pBifq
 110A  F6 D9 03 EE C1 C5 B3	      db 2*$BifSUBWORD+128,_Seq,+3,WORDNUMBER-10,_RetB,_IterCV,Zero
 1111  C1			      db _RetB

				     ;$9.3.29
 1112  4F			     ParmsRec <1,0,1111b>
 1113				     BifWORDS:
 1113 11 B3 A8 59		     BIFWORDS db 2*8+1,Zero,S_COUNT-Tgt,$pRepEver
 1117  0013 R			      dw $+19
 1119  F0 B7 CF 00 15 F4 B5 3F	     db S_PART-10,Null,_Ne,00h,$pWhile,S_COUNT-10,One,$pAdd,S_COUNT-Tgt-10
	      9E
 1122  F0 09 00 22 FE EE 1A 1B	      db S_PART-10,$pParse,00h,022h,ParseDot,S_PART-12,01ah,$pIterate
 112A  FE C1			      db S_COUNT,_RetB

 112C				     BifBound:; A place separating code on basis of address

				     endif

				     ; ES:AX,CX  to the answer.
 112C   1   56			      CONFIG_UPPER$$:push CursorSi
				     ; !! Faster to check if already upper?
 112D   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ UpperRet
 1130   1   85 C9		  1    test cx,cx
 1132  3,1  74 30		  1    je UpperRet
				     ; !! Better with test for cx < 8 ?
 1134   3   E8 0000 E		      call AllocateCx_EsAx
 1137  3,1  73 03		      jnc @F
 1139   3   E8 0000 E		      call ToDsSiCx
 113C				      @@:
 113C   1   51			      push cx
 113D   1   50			      push ax
 113E   1   57			      push StackDi
 113F   1   8B F8		      mov di,ax
 1141   1   BB 0000 E		      mov bx,Attributes
				     ;MASM ..........................
 1144   5   AC			     UpperLoop:lodsb
 1145   1   8A E0		     mov RawCharAh,al
				     XlatBDLS
 1147   4   2E: D7		  1   xlat Bptr cs:[bx]
 1149   1   A8 C0		  1   test al,0C0h
 114B  3,1  7A 07		     jpe @F
 114D   1   A8 48		      test AttribAl,$Lowercase
 114F  3,1  75 03		      jnz @F
 1151   1   80 E4 DF		      and RawCharAh,0DFh
 1154				      @@:
 1154   1   26: 88 25		      mov Bptr es:[di],ah
 1157   1   47			      inc di
				      LoopQ UpperLoop
 1158   1   49			  1    dec cx
 1159  3,1  75 E9		  1    jnz UpperLoop
 115B   1   5F			      pop StackDi
 115C   1   58			      pop ax
 115D   1   59			      pop cx
 115E   3   E8 0000 E		      call AwayEsAxCx
 1161   3p  8E 46 44		     RetEsSi:mov ProgEs,Z.ProgScope
 1164				     UpperRet:RetSi
 1164   1   5E			  1   pop CursorSi
 1165   5   C3			  1   ret

 1166   1   56			     CONFIG_MSG$$:push CursorSi
				     ; Convert top from msg number to text.
				     ; This is the ERRORTEXT creation.  Since there is no conflict with inserts,
				     ; the Serial space can be used.
 1167   1   B0 00		      mov al,$SerialNone
 1169   3   E8 0000 E		      call Serialize
 116C   1   B8 01AB		      mov ax,Zshape.Serial
 116F   1   89 86 0113		      mov Z.MsgSoFar,ax
 1173   1   89 86 0111		      mov Z.MsgBegin,ax
 1177   2   8B 43 04		      mov ax,V.MantLow
				     ; Use 1 if major overlarge so <description> texts can be hidden.
 117A   1   80 FC 36		      cmp ah,$Limit_Major
 117D  3,1  76 02		      jbe @F
 117F   1   B4 01		      mov ah,1
 1181				      @@:
				      On Z.Cancel,ForBIF; Stops inserts.
 1181   3   80 4E 05 08		  1          or  Bptr(Z.Cancel+1), high ??0000
				      mv ds,cs
 1185   3   0E			  1   push cs
 1186   3p  1F			  1   pop ds
 1187   1   57			      push di
 1188   3   E8 0000 E		      call TargetMsg
 118B   1   8B C7		      mov ax,di
 118D   1   5F			      pop di
 118E   3p  8E 46 44		      mov ProgEs,Z.ProgScope
				      Off Z.Cancel,ForBIF
 1191   3   80 66 05 F7		  1          and Bptr(Z.Cancel+1), high not ??0001
 1195   4   8C 53 02		      mov V.Sg,ss
 1198   1   C7 03 01AB		      mov V.Pt,Zshape.Serial
 119C   1   2D 01AB		      sub ax,Zshape.Serial
 119F   2   89 43 04		      mov V.Len,ax
 11A2   2   C6 43 07 C0		      mov V.Dtype,$AwayString
				      RetSi
 11A6   1   5E			  1   pop CursorSi
 11A7   5   C3			  1   ret

 11A8   1   56			     CONFIG_C2B$$:push CursorSi
 11A9   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ C2Bret
 11AC   1   85 C9		  1    test cx,cx
 11AE  3,1  74 29		  1    je C2Bret
 11B0   1   81 F9 2000		      cmp cx,10000h/8
 11B4  3,1  0F 83 0000 E	      jnb Raise5p1d
 11B8   2   C1 E1 03		      shl cx,3
				     ; Source may be V so cannot use ResultSpace.
 11BB   3   E8 0000 E		      call AllocateCx_EsAx
				     ; The bits of Ds:Si to become 0/1 characters in the result, es:ax.
				     ; In and out cannot be the same place
 11BE   1   8B D8		      mov bx,ax
 11C0   1   51			      push cx
 11C1				     C2Bloop:
 11C1   1   F6 C1 07		      test cl,7
 11C4  3,1  75 03		      jnz @F
 11C6   1   8A 34		      mov dh,Bptr[si]
 11C8   1   46			      inc si
 11C9				      @@:
 11C9   3   D0 E6		      shl dh,1
 11CB   1   B2 30		      mov dl,'0'
 11CD   1   13 D5		      adc dx,ZeroBp
 11CF   1   26: 88 17		      mov Bptr es:[bx],dl
 11D2   1   43			      inc bx
 11D3  2,6  E2 EC		      loop C2Bloop
 11D5   1   59			      pop cx
 11D6   3   E8 0000 E		      call AwayEsAxCx
 11D9				     C2Bret:
 11D9   3p  8E 46 44		      mov ProgEs,Z.ProgScope
				      Move Ve[$?OUTCOME],V
 11DC   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 11DF   1   66| 26: 89 4E 44	  1     mov Ve[$?OUTCOME].OverExpo,ecx
 11E4   2   66| 8B 43 04	  1     mov eax,V.OverMant
 11E8   1   66| 26: 89 46 48	  1     mov Ve[$?OUTCOME].OverMant,eax
				      Down
 11ED   1   83 EF 08		  1   sub StackDi,$StrideV
				      RetSi
 11F0   1   5E			  1   pop CursorSi
 11F1   5   C3			  1   ret

 11F2   1   56			     CONFIG_B2C$$:push CursorSi
 11F3   3   E8 0000 E		      call ToDsSiCx
 11F6   2   C1 E9 03		      shr cx,3
				      JcxzQ C2Bret
 11F9   1   85 C9		  1    test cx,cx
 11FB  3,1  74 DC		  1    je C2Bret
 11FD   3   E8 0000 E		      call ResultSpace; Ok since process left to right.
 1200   2   C1 E1 03		      shl cx,3
 1203   1   8B D8		      mov bx,ax
				      z al
 1205   1   B0 00		  1         mov al,0
 1207   1   B2 80		      mov dl,128
 1209   2   80 3C 30		     B2Cloop:cmp Bptr[si],'0'
 120C  3,1  74 02		      je @F
 120E   1   02 C2		      add al,dl
 1210				      @@:
 1210   3   D0 EA		      shr dl,1
 1212  3,1  75 08		      jnz @F
 1214   1   26: 88 07		      mov Bptr es:[bx],al
 1217   1   43			      inc bx
				      z al
 1218   1   B0 00		  1         mov al,0
 121A   1   B2 80		      mov dl,128
 121C   1   46			     @@:inc si
				      LoopQ B2Cloop
 121D   1   49			  1    dec cx
 121E  3,1  75 E9		  1    jnz B2Cloop
 1220   3   EB B7		      jmp C2Bret

 1222				     CONFIG_STREAM_POSITION$$:; CHARIN/CHAROUT/LINEIN/LINEOUT and position.
				     ; Lots NYI - getting thru just so 40.39 can test later.
				     ; Present code does little more than throw away it arguments.
				     ; 2012 There was much unexplained in the original here.
				     ; 5.8.2 of the standard does not explicitly say, but 'N' is the
				     ; response when this function is able to do what is intended.
 1222   1   B0 4E		      mov al,'N'
				     ; 2012 parameter checking has established what file we are talking
				     ; about
 1224   1   8B 5E 38		      mov FileBx,Z.Stream
 1227   1   8A 13		      mov dl,V.String; First char of LINEIN/LINEOUT/CHARIN/CHAROUT
				     ; 2012 Split OUT from IN by length of the parameter.
 1229   3   80 7B 07 86		      cmp V.Dtype,$NullString+6
				      DownCare
 122D   1+  8D 7D F8		  1   lea StackDi,(-$StrideV)[StackDi]
 1230  3,1  75 13		      jne CSPout
				     ; 2012 Select file cursor to match reading.
 1232   8   0F BA 77 E6 0A	      btr F.Flags,WriteMode
 1237  3,1  73 03		      jnc @F
 1239   3   E8 0121		      call SwopReadWrite
 123C				      @@:
 123C   1   80 FA 43		      cmp dl,'C'
 123F  3,1  74 02		      je CSPinc
				     ; LINEIN
				     ; 2012 here we would reposition the file if respecting the third
				     ; argument.
 1241   3   EB 13		      jmp CSPret
 1243				     CSPinc:; CHARIN
 1243   3   EB 11		      jmp CSPret
 1245				     CSPout:
				     ; 2012 Select file cursor to match writing.
 1245   8   0F BA 6F E6 0A	      bts F.Flags,WriteMode
 124A  3,1  72 03		      jc @F
 124C   3   E8 010E		      call SwopReadWrite
 124F				      @@:
 124F   1   80 FA 43		     cmp dl,'C'
 1252  3,1  74 02		     je CSPoutc
				     ; LINEOUT
 1254   3   EB 00		      jmp CSPret
 1256				     CSPoutc:
				     ; CHAROUT
 1256				     CSPret:Down; 2012 Loses the 3rd argument to C S P. (?)
 1256   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; 2012 ES address the variable of which RESPONSE is one.
 1259   1   26: 88 46 64	      mov Ve.String[$?RESPONSE],al
 125D   5   C3			      ret

 125E				     LookFileDsBx:
				     ; V on entry is the string key value.
				     ; Conversion from stream name to file handle is by lookup in the interface.
				     ; Allow space ahead of anything this lookup adds, for file data.
				     ; Use the lookup mechanism that stems use.
				     ; Set FS:BX as if Z.SysFiles was the segment pointer of a $Stem variable.
				     ; Assert - EXPOSED not relevant to SysFiles.
				      mv fs,ss
 125E   3   16			  1   push ss
 125F   3p  0F A1		  1   pop fs
 1261   1   BB 0034		      mov bx,Zshape.SysFiles-Vshape.Sg-$StrideV; So now Vbxf2.
				     ; Allow extra space ahead of item to be made.
 1264   3p  8E 5E 3E		      mov ds,Z.SysFiles
 1267   3   83 06 0004 1A	      add Hd.Avail,$StrideF
				     ; Different trees are kept for normal data files versus source files.
				      Qry Z.Cancel,SourceFiles
 126C   2   F6 46 04 04		  1          test Bptr(Z.Cancel), low ??0002
 1270  3,1  74 0A		      jz @F
 1272   4   FF 36 000C		      push Hd.Probe
				      move Hd.Probe,Hd.TreeProg
 1276   1   A1 000E		  1      mov ax,Hd.TreeProg
 1279   1   A3 000C		  1      mov Hd.Probe,ax
 127C				     @@:z ax
 127C   1   8B C5		  1           mov ax,bp
 127E   3   E8 0000 E		      call DotsFsBxDsSiX
 1281   3p  8E 66 46		      mov fs,Z.VarScope
				      Qry Z.Cancel,SourceFiles
 1284   2   F6 46 04 04		  1          test Bptr(Z.Cancel), low ??0003
 1288  3,1  74 0A		      jz @F
 128A   1   A1 000C		      mov ax,Hd.Probe
 128D   6   8F 06 000C		      pop Hd.Probe
 1291   1   A3 000E mov Hd.TreeProg,ax
 1294   1   8B DE		     @@:mov FileBx,si; The result. Vbx for buffer, F. for file info.
				     ; Extra space not needed if item not new.
 1296   2   80 7F 07 88		      cmp Vbx.Dtype,$Omitted
 129A  3,1  74 06		      je @F
 129C   3   83 2E 0004 1A	      sub Hd.Avail,$StrideF
 12A1   5   C3			      ret
 12A2				     @@:z F.Flags
 12A2   1   89 6F E6		  1           mov F.Flags,bp
 12A5   5   C3			      ret

				     ; Dos I/O needs bx as the handle but we have it for the file data.
 12A6   1   53			     Int21DsBx:push FileBx
 12A7   3   1E			     push ds
 12A8   3p  8E 5E 3E		     mov ds,Z.SysFiles
 12AB   1   8B 5F EE		     mov bx,F.Hand
 12AE   3p  1F			     pop ds
 12AF  30   CD 21		      int 21h
 12B1   1   5B			      pop FileBx
 12B2   3p  8E 5E 3E		      mov ds,Z.SysFiles
 12B5   5   C3			      ret

 12B6   1   45			     OpenQ:inc bp
 12B7   1   45			     OpenW:inc bp
 12B8   1   45			     OpenR:inc bp
 12B9   1   8B CD		     mov cx,bp
 12BB   1   33 ED		     xor bp,bp
				     ; Rexx can do both reads and writes to the same stream name. If network files
				     ; are involved it might be best to have two different file handles for read
				     ; versus write but for now I will try just always opening for read & write.
				     ; DOS will only know of one "current position" for the file and Rexx has
				     ; both read and write positions so one of the positions has to be kept in
				     ; the Rexx Fshape file block.

				     ; The default for a Rexx write is to append. This is a difference from DOS
				     ; for a first write. (BeenWrite flag)

				     ; The first read needs to establish a buffer. (BeenRead flag)

				     ; Asking for the size of a file is not really read or write but it needs a
				     ; file handle. So open for read/write/query are different  (1/2/3 here).

				      Qry F.Flags,Open
 12BD   2   F6 47 E7 20		  1          test Bptr(F.Flags+1), high ??0004
 12C1  3,1  75 34		      jnz HaveHandle
				     ; Open for R&W, whatever this operation is.
 12C3   1   51			      push cx
				     ; To use the key string as a DOS parameter, it has to have a zero after it.
 12C4   1+  8D 77 0E		      lea si,Jbx.Key
 12C7   1   8B D6		      mov dx,si
 12C9   2   03 77 0C		      add si,Jbx.KeyLen
 12CC   1   8A 0C		      mov cl,Bptr[si]
				      z Bptr[si]
 12CE   1   C6 04 00		  1         mov Bptr[si],0
				     ; AL is the open mode.
 12D1   1   B0 02		      mov al,02h
 12D3   1   B4 3D		      mov ah,$DosOpen
 12D5  30   CD 21		      int 21h
				     ; 2012 sysout is always there but another file may not be.
 12D7  3,1  73 14		      jnc @F
 12D9   1   3C 02		      cmp al,2
 12DB  3,1  0F 85 0165		      jne FileErrorPop
 12DF   1   51			      push cx
				      z cx; file attributes
 12E0   1   8B CD		  1           mov cx,bp
 12E2   1   B0 02		      mov al,02h
 12E4   1   B4 3C		      mov ah,$DosCreate
 12E6  30   CD 21		      int 21h
 12E8   1   59			      pop cx
 12E9  3,1  0F 82 0157		      jc FileErrorPop
 12ED   1   88 0C		     @@:mov Bptr[si],cl
				      On F.Flags,Open
 12EF   3   80 4F E7 20		  1          or  Bptr(F.Flags+1), high ??0005
 12F3   1   89 47 EE		      mov F.Hand,ax; The handle.
 12F6   1   59			      pop cx
 12F7  2,6  E2 41		     HaveHandle:loop NotRead
 12F9   8   0F BA 6F E6 0C	      bts F.Flags,BeenRead
 12FE  3,1  72 2A		      jc HaveBuffer
				     ; On first read, establish a buffer.
				     ; Set up Vbx as the long string variable buffer and fill it.
 1300   1   B9 0400		     FillBuffer:mov cx,$FileBufferSize
 1303   3   E8 0000 E		      call AllocateCx_EsAx
				     ; 2011 Should compaction be maintaining DS here?
 1306   3p  8E 5E 3E		      mov ds,Z.SysFiles
 1309   1   C6 47 07 C0		      mov Vbx.Dtype,$AwayString
 130D   3   8C 47 02		      mov Vbx.Sg,es
 1310   1   89 07		      mov Vbx.Pt,ax
 1312   1   89 4F 04		      mov Vbx.Len,cx
				     ; Set registers for DosRead.
				      mv ds,es
 1315   3   06			  1   push es
 1316   3p  1F			  1   pop ds
 1317   1   8B D0		      mov dx,ax
 1319   1   B4 3F		      mov ah,$DosRead
 131B   3   E8 FF88		      call Int21DsBx
 131E   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 1321  3,1  0F 82 0121		      jc FileError
 1325   1   89 47 04		      mov Vbx.Len,ax
 1328   3   EB 05		      jmp @F
 132A				     HaveBuffer:; Take the chance to ensure empty buffer only at Eof.
 132A   2   39 6F 04		      cmp Vbx.Len,ZeroBp
 132D  3,1  74 D1		      je FillBuffer
				     ; If the last thing was a write, we have to swop file pointers.
 132F   8   0F BA 77 E6 0A	     @@:btr F.Flags,WriteMode
 1334  3,1  73 03		     jnc @F
 1336   3   E8 0024		     call SwopReadWrite
 1339   5   C3			     @@:ret
				     ;MASM...............................
 133A  2,6  E2 20		     NotRead:loop NotWrite
 133C   8   0F BA 6F E6 0B	     bts F.Flags,BeenWrite
 1341  3,1  72 0E		     jc @F
				     ; If this is the first go at writing, move the DOS pointer to end of file.
				      z dx
 1343   1   8B D5		  1           mov dx,bp
				      z cx
 1345   1   8B CD		  1           mov cx,bp
 1347   1   B8 4202		      mov ax,MkMajMin($DosSeek,2)
 134A   3   E8 FF59		      call Int21DsBx; Ask to move 0 from end.
				      On F.Flags,WriteMode
 134D   3   80 4F E7 04		  1          or  Bptr(F.Flags+1), high ??0006
				     ; If the last thing not a write, we have to swop file pointers.
 1351   8   0F BA 6F E6 0A	     @@:bts F.Flags,WriteMode
 1356  3,1  72 03		     jc @F
 1358   3   E8 0002		     call SwopReadWrite
 135B   5   C3			     @@:ret

 135C   5   C3			     NotWrite:ret; Here it is a query. Assuring FileBx is enough.

 135D				     SwopReadWrite:; First get the cursor from DOS.
 135D  11   60			      pusha
				      z dx
 135E   1   8B D5		  1           mov dx,bp
				      z cx
 1360   1   8B CD		  1           mov cx,bp
 1362   1   B8 4201		      mov ax,MkMajMin($DosSeek,1)
 1365   3   E8 FF3E		      call Int21DsBx; Ask to move 0 from current.
 1368   1   8B CA		      mov cx,dx
 136A   1   8B D0		      mov dx,ax; Move result to same registers as input.
				     ; Then exchange value with the one remembered.
 136C   5   87 57 F0		      xchg dx,Wptr F.Other_Position
 136F   5   87 4F F2		      xchg cx,Wptr F.Other_Position+2
 1372   1   B8 4200		      mov ax,MkMajMin($DosSeek,0)
 1375   3   E8 FF2E		      call Int21DsBx; Ask to move cx:dx from begin of file.
 1378   9   61			      popa
 1379   5   C3			      ret

 137A				     CONFIG_STREAM_CHARIN$$:; Like an operator, so must honour StackDi and CursorSi
 137A   1   56			      push CursorSi
 137B   3p  8E 5E 3E		      mov ds,Z.SysFiles
 137E   1   8B 5E 38		      mov FileBx,Z.Stream
 1381   2   80 3B 4C		      cmp V.String,'L'
 1384  3,1  0F 85 00C2		      jne NotLinein
 1388   3   E8 FF2D		      call OpenR
				     ; Scan for end-of-line.
				     ; We will put the line into V. and the residual buffer into Vbx.
				     ; ANSI doesn't say but it looks like Warp practice is to treat 0D, 0A, 1A as
				     ; equals to end lines. Then 0A following 0D ignored.

 138B   6p  C4 37		     FindLine:les si,Vbx.Fr
 138D   1   8B 4F 04		     mov cx,Vbx.Len
 1390   1   8B D6		     mov dx,si
				     ; Warp can read past Eof but that doesn't seem right.
 1392   2   26: 80 3C 1A	      cmp Bptr es:[si],$Eof
 1396  3,1  0F 84 009E		      je EndFile
				     ; Assert Eof is the largest of interest as eol control.
 139A   5   26: AC		     @@:lodsb es:[si]
 139C   1   3C 1A		     cmp al,$Eof
 139E  3,1  76 4B		     jbe TestEol
 13A0				     NotEol:LoopQ @B
 13A0   1   49			  1    dec cx
 13A1  3,1  75 F7		  1    jnz @B
 13A3				     TryLonger:
				     ; Found no eol. Read some more from the file and restart.
				     ; Build as V then set Vbx.
 13A3   1   8B CE		      mov cx,si
 13A5   1   2B CA		      sub cx,dx; Amount already scanned.
 13A7   1   51			      push cx
 13A8   1   81 C1 0400		      add cx,$FileBufferSize
 13AC   3   E8 0000 E		      call ResultSpace
				     ; Copy hangover to new buffer.
 13AF   1   59			      pop cx
 13B0   6p  C5 37		      lds si,Vbx.Fr; Hangover
 13B2   1   57			      push StackDi
 13B3   1   56			      push si
 13B4   1   8B 3B		      mov di,V.Pt
 13B6   7n  F3/ A4		      rep movsb
 13B8   1   5E			      pop si
 13B9   1   8B D7		      mov dx,di; Where data from file will go.
 13BB   1   5F			      pop StackDi
				     ; Append from the file.
 13BC   1   B9 0400		      mov cx,$FileBufferSize
				      mv ds,es
 13BF   3   06			  1   push es
 13C0   3p  1F			  1   pop ds
 13C1   1   B4 3F		      mov ah,$DosRead
 13C3   3   E8 FEE0		      call Int21DsBx
 13C6   1   2B C8		      sub cx,ax; Bytes not read.
				      Move Vbx,V,edx
 13C8   1   66| 8B 13		  1    mov edx,V.OverExpo
 13CB   1   66| 89 17		  1    mov Vbx.OverExpo,edx
 13CE   2   66| 8B 53 04	  1    mov edx,V.OverMant
 13D2   1   66| 89 57 04	  1    mov Vbx.OverMant,edx
 13D6   3   29 4F 04		      sub Vbx.Len,cx
				      TestReg ax
 13D9   1   85 C0		  1         test ax,ax
 13DB  3,1  75 AE		      jnz FindLine
				     ; Need some fixup for a file ending in an unterminated line.
				     ; Pretend an Eof
 13DD   6p  C4 37		      les si,Vbx.Fr
 13DF   2   03 77 04		      add si,Vbx.Len
 13E2   1   26: C6 04 1A	      mov Bptr es:[si],$Eof
 13E6   3   FF 47 04		      inc Vbx.Len
 13E9   3   EB A0		      jmp FindLine

 13EB  3,1  74 08		     TestEol:je WasEol;(Eof)
 13ED   1   3C 0D		     cmp al,$Cr
 13EF  3,1  74 34		     je WasCr
 13F1   1   3C 0A		     cmp al,$Lf
 13F3  3,1  75 AB		     jne NotEol
 13F5				     WasEol:; Here with some eol character.
				     ; ax is for line, si for residue.
 13F5   1   8B C6		      mov ax,si
 13F7				     WasCrLf:
 13F7   1   49			      dec cx
				     ; Update buffer to residue.
 13F8   1   89 37		      mov Vbx.Pt,si
 13FA   1   89 4F 04		      mov Vbx.Len,cx
				     ; ?OUTCOME is the line.
 13FD   1   2B C2		      sub ax,dx
 13FF   1   48			      dec ax
 1400   3p  8E 5E 44		      mov ds,Z.ProgScope
 1403   1   BE 0044		      mov ArraySi,$?OUTCOME
 1406   1   89 14		      mov Vsid.Pt,dx
 1408   3   8C 44 02		      mov Vsid.Sg,es
 140B   1   89 44 04		      mov Vsid.Len,ax
 140E   1   C6 44 07 C0		      mov Vsid.Dtype,$AwayString
				     ; ?LINEIN_POSITION indicates change of line.
 1412   3   66| FF 06 0070	      inc ds:Vshape.Mantissa[$?LINEIN_POSITION]
 1417   1   B0 4E		      mov al,'N'; ?RESPONSE is 'N'
 1419   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 141C   1   26: 88 46 64	     Respond:mov Ve.String[$?RESPONSE],al
				      Down
 1420   1   83 EF 08		  1   sub StackDi,$StrideV
				      RetSi
 1423   1   5E			  1   pop CursorSi
 1424   5   C3			  1   ret

 1425   1   83 F9 01		     WasCr:cmp cx,1
 1428  3,1  0F 84 FF77		      je TryLonger; Retry if it is a $Cr so as to be able to find $Lf that follows.
 142C   1   8B C6		      mov ax,si
				     ; Maybe $Lf to lose after $Cr.
 142E   2   26: 80 3C 0A	      cmp Bptr es:[si],$Lf
 1432  3,1  75 C3		      jne WasCrLf; No Lf
 1434   1   46			      inc si
 1435   1   49			      dec cx
 1436   3   EB BF		      jmp WasCrLf

 1438				     EndFile:
 1438   1   B0 4F		      mov al,'O'; ?RESPONSE is 'O'
				     ; Null line returned.
 143A   3p  8E 46 44		     EndNull:mov ProgEs,Z.ProgScope
 143D   1   26: C6 46 4B 80	     mov Ve.Dtype[$?OUTCOME],$NullString
 1442   3   EB D8		      jmp Respond

 1444				     FileErrorPop:PopJunk ax; Pushed CX
 1444   1   58			  1    pop ax
				     PopJunk ax; Link of OpenR
 1445   1   58			  1    pop ax
 1446				     FileError:; Respond with 'E'
 1446   1   B0 45		     mov al,'E'
 1448   3   EB F0		     jmp EndNull

 144A				     NotLinein:
 144A   2   80 3B 43		      cmp V.String,'C'
 144D  3,1  75 00		      jne NotCharin
 144F				     NotCharin:
 144F   5p  FF D5		      Error49Bp

 1451				     CONFIG_STREAM_QUERY$$:
 1451   5p  FF D5		      Error49Bp

 1453   1   8B 5E 38		     CONFIG_STREAM_CLOSE$$:mov FileBx,Z.Stream
 1456   1   56			     CloseBx:push CursorSi
 1457   3p  8E 5E 3E		      mov ds,Z.SysFiles
 145A   8   0F BA 77 E6 0D	      btr F.Flags,Open
 145F   1   89 6F E6		      mov F.Flags,ZeroBp
 1462  3,1  73 07		      jnc @F
 1464   1   8B 5F EE		      mov bx,F.Hand
 1467   1   B4 3E		      mov ah,$DosClose
 1469  30   CD 21		      int 21h
 146B				     @@:RetSi
 146B   1   5E			  1   pop CursorSi
 146C   5   C3			  1   ret

 146D				     CONFIG_STREAM_CHAROUT$$:
				     ; 2012 The Rexx form of close is lineout with nothing to write.
 146D   3   80 7B 07 88		      cmp V.Dtype,$Omitted
 1471  3,1  74 E0		      je CONFIG_STREAM_CLOSE$$
 1473   1   56			      push CursorSi
				     ; 2012 this was unimplemented in 1999 but the Say verb was implemented
				     ; and the difference of that from simple LINEOUT is only in the handle.
				     ; Hence this code, mostly copied from Say.
				     ; Get the Handle.
 1474   3p  8E 5E 3E		      mov ds,Z.SysFiles
 1477   1   8B 5E 38		      mov FileBx,Z.Stream
 147A   3   E8 FE3A		      call OpenW
 147D   1   8B 5F EE		      mov bx,F.Hand
				     ; Get what to write.
 1480   3   E8 0000 E		      call ToDsSiCx
 1483   1   8B D6		      mov dx,si
				     ; Write with newline
 1485   1   B4 40		      mov ah,$DosWrite
 1487  30   CD 21		      int 21h; Takes ds:dx:cx to file bx
				      mv ds,cs
 1489   3   0E			  1   push cs
 148A   3p  1F			  1   pop ds
 148B   1   BA 004D		      mov dx,Yshape.CrLf
 148E   1   B9 0002		      mov cx,2
 1491   1   B4 40		      mov ah,$DosWrite
 1493  30   CD 21		      int 21h
				      Down
 1495   1   83 EF 08		  1   sub StackDi,$StrideV
 1498   1   5E			      pop CursorSi
 1499   5   C3			      ret

 149A   1   56			     CONFIG_STREAM_COUNT$$:push CursorSi
				     ; First arg is CHARS/LINES, second is option N/C
 149B   3p  8E 5E 3E		      mov ds,Z.SysFiles
 149E   1   8B 5E 38		      mov FileBx,Z.Stream
 14A1   3   80 7B F8 43		      cmp V0.String,'C'
 14A5  3,1  75 4E		      jne NotChars
 14A7   4   FF 77 04		      push Vbx.Len
 14AA   3   E8 FE09		      call OpenQ
 14AD   1   8B 5F EE		      mov bx,F.Hand
				     ; Method is to seek both current and relative-to-eof positions. Difference
				     ; is chars remaining.    !! Part buffer processed?
				      z dx
 14B0   1   8B D5		  1           mov dx,bp
				      z cx
 14B2   1   8B CD		  1           mov cx,bp
 14B4   1   B8 4201		      mov ax,MkMajMin($DosSeek,1)
 14B7  30   CD 21		      int 21h; Ask for 0 from current.
				     ; Rexx position is not the same as DOS position because we read a buffersworth.
				     ; Adjustment comes later.
				     ; Save somewhere.  V2 and V3 as workspace.
 14B9   2   89 43 14		      mov Wptr V3.Mantissa,ax
 14BC   2   89 53 16		      mov Wptr V3.Mantissa+2,dx
				      z dx
 14BF   1   8B D5		  1           mov dx,bp
				      z cx
 14C1   1   8B CD		  1           mov cx,bp
 14C3   1   B8 4202		      mov ax,MkMajMin($DosSeek,2)
 14C6  30   CD 21		      int 21h; Ask for 0 from eof
 14C8   2   89 43 0C		      mov Wptr V2.Mantissa,ax
 14CB   2   89 53 0E		      mov Wptr V2.Mantissa+2,dx
				     ; Have to move it back from end to current.
 14CE   2   8B 53 14		      mov dx,Wptr V3.Mantissa
 14D1   2   8B 4B 16		      mov cx,Wptr V3.Mantissa+2
 14D4   1   B8 4200		      mov ax,MkMajMin($DosSeek,0)
 14D7  30   CD 21		      int 21h; Ask for cx:dx from origin.
				     ; Do the arithmetic
 14D9   2   66| 8B 53 0C	      mov edx,V2.Mantissa
 14DD   3   66| 2B 53 14	      sub edx,V3.Mantissa
				     ; Add unscanned part of buffer.
 14E1   1   59			      pop cx
 14E2   3   66| 0F B7 C9	      movzx ecx,cx
 14E6   1   66| 03 D1		      add edx,ecx
 14E9   2   66| 89 53 FC	      mov V0.Mantissa,edx
 14ED				     CSCret:Down
 14ED   1   83 EF 08		  1   sub StackDi,$StrideV
				      z V.ExpAnd
 14F0   1   66| 89 2B		  1             mov V.ExpAnd,ebp
				      RetSi
 14F3   1   5E			  1   pop CursorSi
 14F4   5   C3			  1   ret

 14F5				     NotChars:; N/C matters for LINES. NYI
				     ; Method is different for LINES.
				     ; If the option is 'N' we only need to know if the next available char is
				     ; $Eof.
				      z V0.Mantissa
 14F5   2   66| 89 6B FC	  1             mov V0.Mantissa,ebp
 14F9   3   E8 FDBC		      call OpenR
 14FC   2   80 3B 4E		      cmp V.String,'N'
 14FF  3,1  75 10		      jne LinesExact
				     ; Nothing read means no lines.
 1501   2   39 6F 04		      cmp Vbx.Len,ZeroBp
 1504  3,1  74 E7		      je CSCret
 1506   6p  C5 37		      lds si,Vbx.Fr
 1508   2   80 3C 1A		      cmp Bptr[si],$Eof
 150B   4   0F 95 43 FC		      setne Bptr V0.Mantissa
 150F   3   EB DC		      jmp CSCret

 1511				     LinesExact:
				     ; If the option is 'C', we checkpoint where we are on the file, then
				     ; actually read lines, restore from checkpoint.
 1511   3p  8E 46 44		      mov ProgEs,Z.ProgScope
				      Move Ve[$?Discard],Vbx
 1514   1   66| 8B 0F		  1     mov ecx,Vbx.OverExpo
 1517   1   66| 26: 89 4E 10	  1     mov Ve[$?Discard].OverExpo,ecx
 151C   1   66| 8B 47 04	  1     mov eax,Vbx.OverMant
 1520   1   66| 26: 89 46 14	  1     mov Ve[$?Discard].OverMant,eax
				      z dx
 1525   1   8B D5		  1           mov dx,bp
				      z cx
 1527   1   8B CD		  1           mov cx,bp
 1529   1   B8 4201		      mov ax,MkMajMin($DosSeek,1)
 152C   3   E8 FD77		      call Int21DsBx; Ask for 0 from current.
				     ; etc NYI
 152F   1   C6 03 4C		      mov V.String,'L'; Arg to say LINEIN
				     ; How do we stop it going to NOTREADY?
 1532   5p  FF D5		      Error49Bp
 1534   3   E8 FE43		      call CONFIG_STREAM_CHARIN$$

 1537				     CSQ0:; Z.STREAM will have been set by the assignment to ?STREAM.
				     ; Return tail of the fully qualified item.
 1537   1   8B 5E 38		      mov FileBx,Z.Stream
				      move V.Sg,Z.SysFiles
 153A   1   8B 46 3E		  1      mov ax,Z.SysFiles
 153D   2   89 43 02		  1      mov V.Sg,ax
 1540   1+  8D 47 0E		      lea ax,Jbx.Key
 1543   1   89 03		      mov V.Pt,ax
				      move V.Len,Jbx.KeyLen
 1545   1   8B 47 0C		  1      mov ax,Jbx.KeyLen
 1548   2   89 43 04		  1      mov V.Len,ax
 154B   3   E8 0000 E		      call Away
				      RetSi
 154E   1   5E			  1   pop CursorSi
 154F   5   C3			  1   ret

 1550   1   56			     CONFIG_STREAM_QUALIFIED$$:push CursorSi
				     ; Second argument is numeric and describes function requested.
				     ; When arg2 is 0 return QUALIFY() string.
				     ; When arg2 is 1 get the current drive letter.
				     ; When arg2 is 2 get the path associated with a drive letter.
				     ; When arg2 is 3 record qualified file.
				     ; When arg2 is 4 query file existence.

 1551   2   8B 4B 04		      mov cx,Wptr V.Mantissa
				      Down
 1554   1   83 EF 08		  1   sub StackDi,$StrideV
				      JcxzQ CSQ0
 1557   1   85 C9		  1    test cx,cx
 1559  3,1  74 DC		  1    je CSQ0
 155B  2,6  E2 0E		      loop NotCSQ1
				     ; When arg2 is 1 get the current drive letter.
 155D   1   B4 19		      mov ah,$DosDisk
 155F  30   CD 21		      int 21h
 1561   1   04 41		      add al,'A'
 1563   1   88 03		      mov V.String,al
 1565   2   C6 43 07 81		      mov V.Dtype,$NullString+1
				      RetSi
 1569   1   5E			  1   pop CursorSi
 156A   5   C3			  1   ret

 156B  2,6  E2 2A		     NotCSQ1:loop NotCSQ2
				     ; When arg2 is 2 get the path associated with a drive letter.
				     ; Arg1 is the drive letter.
				     ; 2011 should test fully but uppercase for now.
				     ; 2011 DOS buffer is 64.  Where is check? Giveback?
 156D   1   8A 13		      mov dl,V.String
 156F   1   80 E2 DF		      and dl,0DFh
 1572   1   80 EA 40		      sub dl,'A'-1
 1575   1   B9 0064		      mov cx,100
 1578   3   E8 0000 E		      call ResultSpace
				      mv ds,es
 157B   3   06			  1   push es
 157C   3p  1F			  1   pop ds
 157D   1   8B F0		      mov si,ax
 157F   1   B4 47		      mov ah,$DosPath
 1581  30   CD 21		      int 21h
				     ; Convert from ASCIIZ form.
				      z V.Len
 1583   2   89 6B 04		  1           mov V.Len,bp
 1586   2   80 3C 00		     @@:cmp Bptr[si],0
 1589  3,1  74 06		      je @F
 158B   1   46			      inc si
 158C   4   FF 43 04		      inc V.Len
 158F   3   EB F5		      jmp @B
 1591				      @@:
 1591   1   68 1161 R		      push RetEsSi
 1594   3   E9 0000 E		      jmp Away

 1597  2,6  E2 26		     NotCSQ2:loop NotCSQ3
				     ; When arg2 is 3 record qualified file.
 1599   4   FF 76 38		      push Z.Stream; From the unqualified lookup.
				     ; Arg1 is the qualified; look it up in SysFiles.
 159C   3   E8 FCBF		      call LookFileDsBx
				     ; Is it the same as the one we got for unqualified lookup?
				     ; (Unqualified could have, in fact, had all the qualifiers)
 159F   1   5A			      pop dx
 15A0   1   3B DA		      cmp FileBx,dx
 15A2  3,1  74 07		      je @F
				     ; No, point the unqualified item to it.
				      xax FileBx
 15A4   3   93			  1     xchg ax,FileBx
 15A5   1   8B DA		      mov bx,dx
 15A7   1   89 47 E8		      mov F.ToQual,ax
				      xax FileBx
 15AA   3   93			  1     xchg ax,FileBx
 15AB				     @@:; Has it been initialized?
 15AB   8   0F BA 6F E6 0F	      bts F.Flags,Qual
 15B0  3,1  72 08		      jc @F
				     ; Start the new item with no buffer.
				      On F.Flags,Qual
 15B2   3   80 4F E7 80		  1          or  Bptr(F.Flags+1), high ??0007
 15B6   1   C6 47 07 40		      mov Vbx.Dtype,$Dropped
 15BA   1   89 5E 38		     @@:mov Z.Stream,FileBx
				      RetSi
 15BD   1   5E			  1   pop CursorSi
 15BE   5   C3			  1   ret

 15BF				     NotCSQ3:
				     ; When arg2 is 4 query file existence.
				     ; Do this without SysFiles lookup because don't want to clutter that.
				     ; There may be a better way but CHMOD seems to work.
 15BF   3   E8 0000 E		       call ToDsSiCx
 15C2   1   B8 4300		       mov ax,MkMajMin($DosChmod,0)
				     ; Make it ASCIIZ for CHMOD request
 15C5   1   8B D6		       mov dx,si
 15C7   1   03 F1		       add si,cx
 15C9   1   8A 1C		       mov bl,Bptr[si]
 15CB   1   88 04		       mov Bptr[si],al
 15CD  30   CD 21		       int 21h
 15CF   1   88 1C		       mov Bptr[si],bl; Un-ASCIIZ-fy
				       z V.Mantissa
 15D1   2   66| 89 6B 04	  1             mov V.Mantissa,ebp
				       z V.ExpAnd
 15D5   1   66| 89 2B		  1             mov V.ExpAnd,ebp
 15D8  3,1  72 03		       jc @F
 15DA   4   FF 43 04		       inc V.MantLow
 15DD				       @@:
				       RetSi
 15DD   1   5E			  1   pop CursorSi
 15DE   5   C3			  1   ret

 15DF				     CONFIG_STREAM_COMMAND$$:
 15DF   5p  FF D5		      Error49Bp
 15E1				     CONFIG_STREAM_STATE$$:
 15E1   5p  FF D5		      Error49Bp

 15E3				     CONFIG_TIME$$:Up
 15E3   1   83 C7 08		  1   add StackDi,$StrideV
 15E6   2   C6 43 07 87		     mov V.Dtype,$NullString+7
				     if 0
				     endif
				     ; Construct a stack value with all that DOS tells us.
 15EA   1   B4 2A		     MidNight:mov ah,$DosDate
 15EC  30   CD 21		     int 21h;cx=year(1980+) dh=month dl=day
 15EE   1   81 E9 07BC		      sub cx,1980
 15F2   2   88 4B 06		      mov V.String+6,cl
 15F5   2   89 53 04		      mov Wptr V.String+4,dx
 15F8   1   B4 2C		      mov ah,$DosTime
 15FA  30   CD 21		      int 21h;ch=hour cl=minute dh=second dl=hundredth
 15FC   2   89 4B 02		      mov Wptr V.String+2,cx
 15FF   1   89 13		      mov Wptr V.String,dx
 1601   1   B4 2A		      mov ah,$DosDate
 1603  30   CD 21		      int 21h
 1605   3   3A 53 04		      cmp dl,V.String+4
 1608  3,1  75 E0		      jne MidNight
				     ; DOS doesn't tell local time adjustment for daylight.
 160A   5   C3			      ret

 = 0056				     Tgt equ 86
 = 00AA				     $Locals equ 256-Tgt
 = 0002				     Arg1 equ 2
 = 0004				     Arg2 equ 4
 = 0006				     Arg3 equ 6
 = 0008				     Arg4 equ 8
 = 000A				     Arg5 equ 10
				     ; LocalVars of ARITHOP
 =-003A				     NUMBER1 equ -58
 =-0038				     NUMBER2 equ -56
 =-0036				     OPERATOR equ -54
 =-0034				     DIGITS equ -52
 =-000C				     TT equ -12
 =-000E				     SIGN1 equ -14
 =-0004				     MANTISSA1 equ -4
 =-0010				     EXPONENT1 equ -16
 =-0012				     SIGN2 equ -18
 =-0014				     MANTISSA2 equ -20
 =-0016				     EXPONENT2 equ -22
 =-0018				     NUMBER3 equ -24
 =-001A				     MANTISSA3 equ -26
 =-0008				     EXPONENT3 equ -8
 =-0002				     ZZ equ -2
 =-000A				     A_X equ -10
 =-001C				     A_Y equ -28
 =-001E				     SIGN3 equ -30
 =-0020				     NOWDIGITS equ -32
 =-0022				     ALIGN1 equ -34
 =-0024				     ALIGN2 equ -36
 =-0006				     SIGDIGITS equ -6
 =-0026				     AA equ -38
 =-0028				     INTDIGITS equ -40
 =-002A				     RHS equ -42
				     ; LocalVars of PREPARE
 =-0016				     NUMBER equ -22
 =-0014				     P_DIGITS equ -20
 =-0002				     MANTISSA equ -2
 =-0008				     EXPONENT equ -8
 =-0004				     SIGN equ -4
 =-0006				     P_P equ -6
 =-000A				     P_Q equ -10
 =-000C				     JJ equ -12
 =-000E				     P_T equ -14
				     ; LocalVars of _POSTOP
				     ; LocalVars of _FLOATING
				     ; LocalVars of _ADDSUBCOMP
				     ; LocalVars of _MULTIPLY
				     ; LocalVars of _DIVTYPE
				     ; LocalVars of _POWER
				     ; LocalVars of TIME2DATE
				     ; LocalVars of TIME2DATE2
 =-001A				     Y_TIME equ -26
 =-0002				     Y_SECOND equ -2
 =-0004				     Y_MICROSECOND equ -4
 =-0006				     Y_MINUTE equ -6
 =-0008				     Y_HOUR equ -8
 =-000A				     Y_DAY equ -10
 =-000C				     Y_BASEDAYS equ -12
 =-000E				     Y_YEAR equ -14
 =-0010				     Y_YEARDAYS equ -16
 =-0012				     Y_DAYS equ -18
 =-0014				     Y_MONTH equ -20
 =-0016				     Y_THISMONTH equ -22
				     ; LocalVars of LEAP
				     ; LocalVars of RERADIX
 =-0002				     RR_SUBJECT equ -2
 =-0008				     RR_FROMRADIX equ -8
 =-0004				     RR_TORADIX equ -4
 =-0006				     RR_INTEGER equ -6
 =-000A				     RR_J equ -10
 =-000C				     RR_R equ -12
				     ; LocalVars of BIFABBREV
 =-0012				     SUBJECT equ -18
 =-0010				     SUBJ equ -16
 =-0002				     LENGTH_ equ -2
 =-0004				     COND1 equ -4
 =-0006				     COND2 equ -6
 =-0008				     COND3 equ -8
				     ; LocalVars of BIFCENTER
 =-000E				     STRING equ -14
 =-000C				     C_LENGTH equ -12
 =-0002				     PAD equ -2
 =-0004				     TRIM equ -4
				     ; LocalVars of BIFCHANGESTR
 =-0002				     OUTPUT equ -2
 =-0004				     POSITION equ -4
 =-0006				     FOUNDPOS equ -6
				     ; LocalVars of BIFCOMPARE
 =-0012				     STR1 equ -18
 =-0010				     STR2 equ -16
 =-0002				     C_PAD equ -2
 =-0004				     CO_LENGTH equ -4
 =-0006				     C_I equ -6
				     ; LocalVars of BIFCOUNTSTR
 =-0002				     C_OUTPUT equ -2
 =-0004				     C_POSITION equ -4
				     ; LocalVars of BIFDELSTR
 =-0012				     D_STRING equ -18
 =-0010				     NUM equ -16
 =-0002				     LEN equ -2
 =-0004				     D_OUTPUT equ -4
				     ; LocalVars of BIFDELWORD
 =-0012				     DW_STRING equ -18
 =-0010				     DW_NUM equ -16
 =-0002				     DW_LEN equ -2
 =-0006				     ENDLEFT equ -6
 =-0008				     DW_OUTPUT equ -8
 =-0004				     BEGINRIGHT equ -4
				     ; LocalVars of BIFINSERT
 =-0014				     NEW equ -20
 =-0012				     TARGET equ -18
 =-0006				     I_NUM equ -6
 =-0002				     I_LENGTH equ -2
 =-0004				     I_PAD equ -4
				     ; LocalVars of BIFLASTPOS
 =-0010				     NEEDLE equ -16
 =-000E				     HAYSTACK equ -14
 =-0002				     START equ -2
 =-0004				     NEEDLELENGTH equ -4
 =-0006				     II equ -6
				     ; LocalVars of BIFOVERLAY
 =-0014				     O_NEW equ -20
 =-0012				     O_TARGET equ -18
 =-0006				     O_NUM equ -6
 =-0002				     O_LENGTH equ -2
 =-0004				     O_PAD equ -4
				     ; LocalVars of BIFPOS
 =-0012				     P_NEEDLE equ -18
 =-0010				     P_HAYSTACK equ -16
 =-0002				     P_START equ -2
 =-0004				     P_I equ -4
 =-0006				     O_HAYSTACK equ -6
				     ; LocalVars of BIFRIGHT
 =-000E				     R_STRING equ -14
 =-000C				     R_LENGTH equ -12
 =-0002				     R_PAD equ -2
 =-0004				     R_TRIM equ -4
				     ; LocalVars of BIFSPACE
 =-0012				     S_STRING equ -18
 =-0004				     S_NUM equ -4
 =-0002				     S_PAD equ -2
 =-0006				     PADDING equ -6
 =-0008				     S_OUTPUT equ -8
 =-000A				     S_I equ -10
				     ; LocalVars of BIFSTRIP
 =-000C				     ST_STRING equ -12
 =-0002				     OPTION_ equ -2
 =-0004				     UNWANTED equ -4
				     ; LocalVars of BIFSUBWORD
 =-0012				     SW_STRING equ -18
 =-0010				     SW_NUM equ -16
 =-0002				     S_LENGTH equ -2
 =-0006				     S_START equ -6
 =-0004				     END_ equ -4
 =-0008				     SW_OUTPUT equ -8
				     ; LocalVars of BIFTRANSLATE
 =-0018				     T_STRING equ -24
 =-0004				     TABLEI equ -4
 =-0002				     TABLEO equ -2
 =-0006				     T_PAD equ -6
 =-0008				     T_OUTPUT equ -8
 =-000A				     T_J equ -10
 =-000C				     T_C equ -12
 =-000E				     KK equ -14
				     ; LocalVars of BIFVERIFY
 =-0020				     V_STRING equ -32
 =-001E				     REFERENCE equ -30
 =-000C				     V_OPTION equ -12
 =-0002				     V_START equ -2
 =-0004				     LAST equ -4
 =-0006				     V_I equ -6
 =-0008				     V_T equ -8
				     ; LocalVars of BIFWORD
				     ; LocalVars of BIFWORDINDEX
 =-000C				     W_STRING equ -12
 =-000A				     W_NUM equ -10
 =-0002				     W_START equ -2
 =-0004				     COUNT equ -4
				     ; LocalVars of BIFWORDLENGTH
				     ; LocalVars of BIFWORDPOS
 =-0012				     PHRASE equ -18
 =-0010				     WP_STRING equ -16
 =-0002				     R_START equ -2
 =-0004				     PHRASEWORDS equ -4
 =-0006				     STRINGWORDS equ -6
 =-0008				     WORDNUMBER equ -8
				     ; LocalVars of BIFWORDS
 =-0006				     S_PART equ -6
 =-0002				     S_COUNT equ -2
				     ; LocalVars of BIFFORMAT
 =-000C				     BEFORE equ -12
 =-000E				     AFTER equ -14
 =-0010				     EXPP equ -16
 =-0012				     EXPT equ -18
 =-0016				     F_NUMBER equ -22
 =-0002				     F_MANTISSA equ -2
 =-0008				     F_EXPONENT equ -8
 =-0018				     F_SIGN equ -24
 =-001A				     BEFO equ -26
 =-001C				     AFTE equ -28
 =-000A				     POINT equ -10
 =-001E				     SHOWEXP equ -30
 =-0020				     AFTERS equ -32
 =-0004				     F_R equ -4
 =-0022				     MANTLEN equ -34
 =-0006				     TRIGGERED equ -6
 =-0014				     F_Z equ -20
 =-0024				     DIGIT equ -36
 =-0026				     EXPART equ -38
 =-0028				     SIGNEXP equ -40
				     ; LocalVars of BIFMAX
 =-0002				     NEXT equ -2
 =-0004				     MAX equ -4
 =-0006				     I_M equ -6
				     ; LocalVars of BIFMIN
 =-0002				     _NEXT equ -2
 =-0004				     MIN equ -4
 =-0006				     I_N equ -6
				     ; LocalVars of BIFTRUNC
 =-000C				     T_NUMBER equ -12
 =-0002				     T_NUM equ -2
 =-0004				     T_INTEGER equ -4
 =-0006				     T_T equ -6
				     ; LocalVars of BIFERRORTEXT
 =-0002				     MSGCODE equ -2
 =-000C				     E_OPTION equ -12
 =-0004				     MAJOR equ -4
 =-0006				     MINOR equ -6
				     ; LocalVars of BIFB2X
 =-0002				     B_STRING equ -2
				     ; LocalVars of BIFBITAND
 =-0018				     STRING1 equ -24
 =-0002				     STRING2 equ -2
 =-0004				     B_T equ -4
 =-0006				     B_R equ -6
 =-0008				     B_J equ -8
 =-000A				     B1 equ -10
 =-000C				     B2 equ -12
				     ; LocalVars of BIFC2D
 =-0002				     C_MAX equ -2
 =-0006				     SIZE_ equ -6
 =-0004				     C_T equ -4
 =-0008				     C_SIGN equ -8
				     ; LocalVars of BIFC2X
				     ; LocalVars of BIFD2C
 =-0002				     D_SUBJECT equ -2
 =-0004				     D_R equ -4
 =-0006				     D_LENGTH equ -6
 =-0008				     DC_OUTPUT equ -8
				     ; LocalVars of BIFD2X
 =-0002				     X_SUBJECT equ -2
 =-0004				     X_R equ -4
				     ; LocalVars of BIFX2B
 =-0008				     XB_SUBJECT equ -8
				     ; LocalVars of BIFX2C
 =-0008				     XC_SUBJECT equ -8
 =-0002				     XC_R equ -2
 =-0004				     XC_LENGTH equ -4
				     ; LocalVars of BIFX2D
 =-0002				     XD_MAX equ -2
 =-0004				     XD_SUBJECT equ -4
 =-0006				     XD_R equ -6
 =-0008				     SIGNBIT equ -8
				     ; LocalVars of BIFCHARIN
 =-0002				     C_COUNT equ -2
 =-0004				     MODE equ -4
 =-0006				     C_R equ -6
				     ; LocalVars of BIFCHAROUT
 =-0002				     C_STRING equ -2
 =-0004				     O_MODE equ -4
 =-0006				     STRIDE equ -6
 =-0008				     RESIDUE equ -8
 =-000A				     CURSOR equ -10
 =-000C				     PIECE equ -12
				     ; LocalVars of BIFCHARS
 =-0002				     H_OPTION equ -2
				     ; LocalVars of BIFLINEIN
 =-0002				     L_COUNT equ -2
				     ; LocalVars of BIFLINEOUT
				     ; LocalVars of BIFLINES
 =-0002				     N_OPTION equ -2
				     ; LocalVars of BIFQUALIFY
				     ; LocalVars of BIFSTREAM
 =-0002				     OPERATION equ -2
				     ; LocalVars of BIFDATE
 =-0002				     D_OPTION equ -2
 =-000A				     VALUE equ -10
 =-000C				     INOPTION equ -12
 =-0014				     LOGIC equ -20
 =-0010				     DAY equ -16
 =-0016				     MONTHIS equ -22
 =-0004				     YEAR equ -4
 =-000E				     MONTH equ -14
 =-0018				     YY equ -24
 =-001A				     YEARNOW equ -26
 =-0006				     DAYS equ -6
 =-0008				     BASEDAYS equ -8
 =-0012				     MICRO equ -18
				     ; LocalVars of DATEFORMAT
 =-0006				     D_YEAR equ -6
 =-0002				     D_MONTH equ -2
 =-0004				     D_DAY equ -4
 =-0008				     D_HOUR equ -8
 =-000A				     D_MINUTE equ -10
 =-000C				     D_SECOND equ -12
 =-000E				     D_MICROSECOND equ -14
 =-0010				     D_BASE equ -16
 =-0012				     D_DAYS equ -18
				     ; LocalVars of BIFTIME
 =-0002				     T_OPTION equ -2
 =-000A				     INVALUE equ -10
 =-000C				     T_INOPTION equ -12
 =-0006				     HH equ -6
 =-0010				     MM equ -16
 =-0004				     SS_ equ -4
 =-0008				     HOURADJUST equ -8
 =-000E				     XX equ -14
 =-0012				     T_MICRO equ -18
				     ; LocalVars of TIMEFORMAT
 =-0006				     T_HOUR equ -6
 =-0002				     T_MINUTE equ -2
 =-0004				     T_SECOND equ -4
 =-0008				     T_MICROSECOND equ -8
 =-000A				     TF_OUTPUT equ -10
				     ; LocalVars of DOS_TIME
 =-0012				     TV equ -18
 =-0004				     DT_YEAR equ -4
 =-000E				     DT_MONTH equ -14
 =-0010				     DT_DAY equ -16
 =-0006				     DT_DAYS equ -6
 =-0008				     DT_BASEDAYS equ -8
				     ; LocalVars of B4VALUE1
				     ; LocalVars of B4VALUE2
 =-0002				     B4V equ -2
				     ; LocalVars of B4DROP
				     ; LocalVars of B4EXPOSE
				     ; LocalVars of STREAMQUALIFY
 =-0002				     Q_T equ -2
 =-000A				     Q_DRIVE equ -10
 =-0004				     Q_J equ -4
 =-0006				     Q_NAME equ -6
 =-0008				     Q_PATH equ -8
				     ; LocalVars of PATHQUALIFY
 =-0002				     PQ_T equ -2
 =-000C				     PQ_HAVEENV equ -12
 =-000A				     PQ_DRIVE equ -10
 =-0004				     PQ_J equ -4
 =-0006				     PQ_NAME equ -6
 =-0008				     PQ_PATH equ -8
 =-000E				     PQ_EXTEN equ -14
 =-0010				     PQ_EXISTS equ -16
 =-0012				     PQ_LETTER equ -18
 =-0014				     PQ_PREFIX equ -20
 =-0016				     PQ_DIR equ -22
 =-0018				     PQ_R equ -24
 =-001A				     PQ_REST equ -26
				     ; LocalVars of LINESPLIT
 =-0008				     LS_T equ -8
 =-0002				     LS_N equ -2
 =-0004				     LS_P equ -4
				     ; LocalVars of COMMANDWRAP
 =-0002				     CW_T equ -2
 = $RoutineBase+0		     ARITHOP equ $RoutineBase+0
 = $RoutineBase+2		     PREPARE equ $RoutineBase+2
 = $RoutineBase+4		     _MULTIPLY equ $RoutineBase+4
 = $RoutineBase+6		     _DIVTYPE equ $RoutineBase+6
 = $RoutineBase+8		     _POWER equ $RoutineBase+8
 = $RoutineBase+10		     _ADDSUBCOMP equ $RoutineBase+10
 = $RoutineBase+12		     _POSTOP equ $RoutineBase+12
 = $RoutineBase+14		     _FLOATING equ $RoutineBase+14
 = $RoutineBase+16		     TIME2DATE equ $RoutineBase+16
 = $RoutineBase+18		     TIME2DATE2 equ $RoutineBase+18
 = $RoutineBase+20		     LEAP equ $RoutineBase+20
 = $RoutineBase+22		     RERADIX equ $RoutineBase+22
 = $RoutineBase+24		     DOS_TIME equ $RoutineBase+24
 = $RoutineBase+26		     DATEFORMAT equ $RoutineBase+26
 = $RoutineBase+28		     TIMEFORMAT equ $RoutineBase+28

 = 005D				     Frag1 equ $BPcodesCeil+0
 = 005F				     Frag2 equ $BPcodesCeil+2
 = 0061				     Frag3 equ $BPcodesCeil+4
 = 0063				     Frag4 equ $BPcodesCeil+6
 = 0065				     Frag5 equ $BPcodesCeil+8
 = 0067				     Frag6 equ $BPcodesCeil+10
 = 0069				     Frag7 equ $BPcodesCeil+12
 = 006B				     Frag8 equ $BPcodesCeil+14
 = 006D				     Frag9 equ $BPcodesCeil+16
 = 006F				     Frag10 equ $BPcodesCeil+18
 = 0071				     Frag11 equ $BPcodesCeil+20
 = 0073				     Frag12 equ $BPcodesCeil+22
 = 0075				     Frag13 equ $BPcodesCeil+24
 = 0077				     Frag14 equ $BPcodesCeil+26
 = 0079				     Frag15 equ $BPcodesCeil+28
 = 007B				     Frag16 equ $BPcodesCeil+30
 = 007D				     Frag17 equ $BPcodesCeil+32
 = 007F				     Frag18 equ $BPcodesCeil+34
 = 0081				     Frag19 equ $BPcodesCeil+36
 = 0083				     Frag20 equ $BPcodesCeil+38
 = 0085				     Frag21 equ $BPcodesCeil+40
 = 0087				     Frag22 equ $BPcodesCeil+42
 = 0089				     Frag23 equ $BPcodesCeil+44
 = 008B				     Frag24 equ $BPcodesCeil+46
 = 008D				     Frag25 equ $BPcodesCeil+48
 = 008F				     Frag26 equ $BPcodesCeil+50
 = 0091				     Frag27 equ $BPcodesCeil+52
 = 0093				     Frag28 equ $BPcodesCeil+54

 160B B9 03 31 32 3A FC BB 32	     Frag1$$ db String,3,"12:",T_MINUTE-2,String1,"2",$pPositive,Zero
	      3B B3
 1615  2B B4 01 C3		      db $pBifq,2*$BifRIGHT+128,$pAbut,_RetF

 1619 BB 3A 01 FC BB 32 3B	     Frag2$$ db String1,":",$pAbut,T_MINUTE-2,String1,"2",$pPositive
 1620  B3 2B B4 01 C3		      db Zero,$pBifq,2*$BifRIGHT+128,$pAbut,_RetF

 1625 2B 4A 4B B5 41 A8		     Frag3$$ db $pBifq,2*$BifDIGITS,$pPower,One,$pSubtract,C_MAX-Tgt
 162B  B9 03 39 39 39 51 00 C3	      db String,3,"999",$pNumeric,00h,_RetF

 1633 BB 57 2B BE 33 EE		     Frag4$$ db String1,"W",$pBifq,2*$BifDATATYPE+128,$pNot,DAY-2
 1639  BB 57 2B BE 33 37 FA C3	      db String1,"W",$pBifq,2*$BifDATATYPE+128,$pNot,$pOr,YEAR-2,_RetF

 1641 B5 2B 7A BB 54 D9 07 04	     Frag5$$ db One,$pBifq,2*$BifLEFT,String1,"T",_Seq,+7,?STREAM
 1649  BD 34 32 3B E1 C3	      db String2,"42",$pPositive,CONFIG_RAISE40,_RetF

 164F 2B BE 33 37 C9 08 F6	     Frag6$$ db $pBifq,2*$BifDATATYPE+128,$pNot,$pOr,_Then,+8,VALUE
 1656  F2 BD 31 39 3B E1 C3	      db INOPTION-2,String2,"19",$pPositive,CONFIG_RAISE40,_RetF

 165D E2 BB 2B D9 06 BB 2D 8C	     Frag7$$ db SIGN3,String1,"+",_Seq,+6,String1,"-",SIGN3-Tgt,_Jump
	      CB
 1666  04 BB 2B 8C C3		      db +4,String1,"+",SIGN3-Tgt,_RetF

 166B F4 2D B5 D7 00 F2 B5 2B	     Frag8$$ db ZZ-10,$pLength,One,_Gt,00h,ZZ-12,One,$pBifq,2*$BifLEFT
	      7A
 1674  B3 D9 00 35 C3		      db Zero,_Seq,00h,$pAnd,_RetF

 1679 B3 2B 9E A2 F8		     Frag9$$ db Zero,$pBifq,2*$BifSPACE+128,XB_SUBJECT-Tgt,XB_SUBJECT
 167E  2B 20 BD 31 36 BB 32 42	      db $pBifq,2*$BifTRANSLATE,String2,"16",String1,"2",RERADIX,_RetF
	      C3

 1687 BB 57 2B BE 33 C9		     Frag10$$ db String1,"W",$pBifq,2*$BifDATATYPE+128,$pNot,_Then
 168D  08 F6 F2 BD 31 39 3B E1	      db +8,VALUE,INOPTION-2,String2,"19",$pPositive,CONFIG_RAISE40
 1695  C3			      db _RetF

 1696 B5 A8 FE 2B C2 A6 BB	     Frag11$$ db One,NEXT-Tgt,NEXT,$pBifq,2*$BifARG+128,MAX-Tgt,String1
 169D  32 0D 2B 42 0F B5 11 C3	      db "2",$pNumber,$pBifq,2*$BifARG,$pTo,One,$pBy,_RetF

 16A5 A8 FE BD 31 30 BB 32	     Frag12$$ db D_SUBJECT-Tgt,D_SUBJECT,String2,"10",String1,"2"
 16AC  42 A6 FC 2D A4 C3	      db RERADIX,D_R-Tgt,D_R,$pLength,D_LENGTH-Tgt,_RetF

 16B2 F2 C7 C9 05 F2 A8 CB	     Frag13$$ db Arg3-20,_Exists,_Then,+5,Arg3-20,P_START-Tgt,_Jump
 16B9  03 B5 A8 EE C3		      db +3,One,P_START-Tgt,P_NEEDLE,_RetF

 16BE F2 C7 C9 05 F2 A8 CB	     Frag14$$ db Arg3-20,_Exists,_Then,+5,Arg3-20,C_COUNT-Tgt,_Jump
 16C5  03 B5 A8 FE C3		      db +3,One,C_COUNT-Tgt,C_COUNT,_RetF

 16CA D9 0E CA BB 2B D9 06 BB	     Frag15$$ db _Seq,+14,OPERATOR,String1,"+",_Seq,+6,String1,"-"
	      2D
 16D3  74 CB 04 BB 2B 74 C3	      db OPERATOR-Tgt,_Jump,+4,String1,"+",OPERATOR-Tgt,_RetF

 16DA F4 DB 08 F6 F2 BD 31 39	     Frag16$$ db VALUE-2,_Sne,+8,VALUE,INOPTION-2,String2,"19",$pPositive
	      3B
 16E3  E1 EE FC C3		      db CONFIG_RAISE40,MICRO,D_OPTION-2,_RetF

 16E7 F0 BB 32 D7 00 F8 40 43	     Frag17$$ db MONTH-2,String1,"2",_Gt,00h,YEAR-4,LEAP,$pMultiply
 16EF  3F EE 3F B5 41 A4 C3	      db $pAdd,DAY-2,$pAdd,One,$pSubtract,DAYS-Tgt,_RetF

 16F6 BB 32 3B B3 2B B4		     Frag18$$ db String1,"2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128
 16FC  BB 2F 01 FC BB 32 3B B3	      db String1,"/",$pAbut,D_MONTH-2,String1,"2",$pPositive,Zero
 1704  2B B4 01 BB 2F 01 C3	      db $pBifq,2*$BifRIGHT+128,$pAbut,String1,"/",$pAbut,_RetF

 170B EE C7 C9 05 EE 1A CB	     Frag19$$ db Arg1-20,_Exists,_Then,+5,Arg1-20,?STREAM+Tgts,_Jump
 1712  03 B7 1A B7 1C C3	      db +3,Null,?STREAM+Tgts,Null,?STREAMSTATE+Tgts,_RetF

 1718 E2 A0 E4 C7 C9 05 E4	     Frag20$$ db Arg2-34,VALUE-Tgt,Arg3-34,_Exists,_Then,+5,Arg3-34
 171F  9E CB 04 BB 4E 9E C3	      db INOPTION-Tgt,_Jump,+4,String1,"N",INOPTION-Tgt,_RetF

 1726 08 B5 2B 7A BB 45 D9	     Frag21$$ db ?RESPONSE,One,$pBifq,2*$BifLEFT,String1,"E",_Seq
 172D  09 B9 05 45 52 52 4F 52	      db +9,String,5,"ERROR",?STREAMSTATE+Tgts,String,8,"NOTREADY"
	      1C B9 08 4E 4F
	      54 52 45 41 44
	      59
 1740  04 08 BB 32 3B 2B 7C	      db ?STREAM,?RESPONSE,String1,"2",$pPositive,$pBifq,2*$BifSUBSTR
 1747  DF C3			      db CONFIG_RAISE,_RetF

 1749 F6 C7 C9 05 F6 A8 CB 04	     Frag22$$ db Arg3-16,_Exists,_Then,+5,Arg3-16,PAD-Tgt,_Jump,+4
 1751  BB 20 A8 F2 2D F2 41	      db String1," ",PAD-Tgt,STRING,$pLength,C_LENGTH-2,$pSubtract
 1758  A6 FC B3 C3		      db TRIM-Tgt,TRIM,Zero,_RetF

 175C FA BB 32 3B B3 2B B4	     Frag23$$ db T_HOUR,String1,"2",$pPositive,Zero,$pBifq,2*$BifRIGHT+128
 1763  5F BB 3A 01 FA BB 32 3B	      db Frag2,String1,":",$pAbut,T_SECOND-2,String1,"2",$pPositive
 176B  B3 2B B4 01 C3		      db Zero,$pBifq,2*$BifRIGHT+128,$pAbut,_RetF

 1770 FA C7 C9 05 FA 1A CB	     Frag24$$ db Arg1-8,_Exists,_Then,+5,Arg1-8,?STREAM+Tgts,_Jump
 1777  03 B7 1A FC C7 C9 05 FC	      db +3,Null,?STREAM+Tgts,Arg2-8,_Exists,_Then,+5,Arg2-8,H_OPTION-Tgt
	      A8
 1780  CB 04 BB 4E A8 C3	      db _Jump,+4,String1,"N",H_OPTION-Tgt,_RetF

 1786 FC B5 41 B9 03 33 36 35	     Frag25$$ db YEAR,One,$pSubtract,String,3,"365",$pMultiply,YEAR-2
	      43 FA
 1790  B5 41 BB 34 47 3F FA B5	      db One,$pSubtract,String1,"4",$pIntDivide,$pAdd,YEAR-2,One,$pSubtract
	      41
 1799  B9 03 31 30 30 47 41 FA	      db String,3,"100",$pIntDivide,$pSubtract,YEAR-2,One,$pSubtract
	      B5 41
 17A3  B9 03 34 30 30 47 3F F8	      db String,3,"400",$pIntDivide,$pAdd,DAYS-2,$pAdd,BASEDAYS-Tgt
	      3F A2
 17AD  C3			      db _RetF

 17AE FC 2B 36 A6 FC B3 CD 07	     Frag26$$ db Q_T-2,$pBifq,2*$BifLASTPOS,Q_J-Tgt,Q_J,Zero,_Eq,+7
 17B6  FE A4 B7 A2 CB 0D FE FA	      db Q_T,Q_NAME-Tgt,Null,Q_PATH-Tgt,_Jump,+13,Q_T,Q_J-2,One,$pAdd
	      B5 3F
 17C0  2B 7C A4 FE FA 2B 7A	      db $pBifq,2*$BifSUBSTR,Q_NAME-Tgt,Q_T,Q_J-2,$pBifq,2*$BifLEFT
 17C7  A2 C3			      db Q_PATH-Tgt,_RetF

 17C9 F2 C7 C9 05 F2 A8 CB	     Frag27$$ db Arg4-22,_Exists,_Then,+5,Arg4-22,I_LENGTH-Tgt,_Jump
 17D0  04 EC 2D A8 F4 C7 C9 05	      db +4,NEW,$pLength,I_LENGTH-Tgt,Arg5-22,_Exists,_Then,+5,Arg5-22
	      F4
 17D9  A6 CB 04 BB 20 A6 EE F8	      db I_PAD-Tgt,_Jump,+4,String1," ",I_PAD-Tgt,TARGET,I_NUM-2,_RetF
	      C3

 17E2 51 00 E4 C7 E0 C7 33	     Frag28$$ db $pNumeric,00h,Arg3-34,_Exists,Arg2-34-2,_Exists,$pNot
 17E9  35 C9 08 B7 E2 BD 31 39	      db $pAnd,_Then,+8,Null,Arg3-34-2,String2,"19",$pPositive,CONFIG_RAISE40
	      3B E1
 17F3  E0 C7 C9 05 E0 A8 CB 04	      db Arg1-34,_Exists,_Then,+5,Arg1-34,D_OPTION-Tgt,_Jump,+4,String1
	      BB
 17FC  4E A8 0C B7 D9 06 FD 44	      db "N",D_OPTION-Tgt,?CLAUSETIME,Null,_Seq,+6,CONFIG_TIME,DOS_TIME
 1804  22 0C 24 C3		      db ?CLAUSETIME+Tgts,?CLAUSETIME,?CLAUSELOCAL+Tgts,_RetF
 1808 CC C6 CA 2E 9E F4 09	     ARITHOP$$ db 25*8+4,NUMBER1,DIGITS-2,PREPARE,TT-Tgt,TT,$pParse
 180F  00 22 F0 FA EE 1A C8 CA	      db 00h,022h,SIGN1-2,MANTISSA1-2,EXPONENT1-2,01ah,NUMBER2,DIGITS-2
 1817  2E 9E F4 09 00 22 EC EA	      db PREPARE,TT-Tgt,TT,$pParse,00h,022h,SIGN2-2,MANTISSA2-2,EXPONENT2-2
	      E8
 1820  1A CA BB 2A D9 04 30 CB	      db 01ah,OPERATOR,String1,"*",_Seq,+4,_MULTIPLY,_Jump,+36,OPERATOR
	      24 CA
 182A  BB 2F D9 04 32 CB 1C CA	      db String1,"/",_Seq,+4,_DIVTYPE,_Jump,+28,OPERATOR,String2,"**"
	      BD 2A 2A
 1835  D9 04 34 CB 13 CA BB 25	      db _Seq,+4,_POWER,_Jump,+19,OPERATOR,String1,"%",_Seq,+4,_DIVTYPE
	      D9 04 32
 1840  CB 0B CA BD 2F 2F D9 04	      db _Jump,+11,OPERATOR,String2,"//",_Seq,+4,_DIVTYPE,_Jump,+2
	      32 CB 02
 184B  36 38 E8 C1		      db _ADDSUBCOMP,_POSTOP,NUMBER3,_RetB

 184F 4A EA B3 2B 9E 09		     PREPARE$$ db 9*8+2,NUMBER,Zero,$pBifq,2*$BifSPACE+128,$pParse
 1855  02 0A BB 45 2A FC 22 F6	      db 02h,0ah,String1,"E",02ah,MANTISSA-2,022h,EXPONENT-2,01ah
	      1A
 185E  F8 B7 D9 03 B3 A2 BB 2B	      db EXPONENT,Null,_Seq,+3,Zero,EXPONENT-Tgt,String1,"+",SIGN-Tgt
	      A6
 1867  FE B5 2B 7A BB 2D D9 04	      db MANTISSA,One,$pBifq,2*$BifLEFT,String1,"-",_Seq,+4,String1
	      BB
 1870  2D A6 FE B5 2B 7A BD 2B	      db "-",SIGN-Tgt,MANTISSA,One,$pBifq,2*$BifLEFT,String2,"+-"
	      2D
 1879  2B 14 B3 CD 08 FE BB 32	      db $pBifq,2*$BifVERIFY,Zero,_Eq,+8,MANTISSA,String1,"2",$pPositive
	      3B
 1882  2B 7C A8 BB 2E FC 2B	      db $pBifq,2*$BifSUBSTR,MANTISSA-Tgt,String1,".",MANTISSA-2,$pBifq
 1889  78 A4 FA B3 D7 09 FE F8	      db 2*$BifPOS,P_P-Tgt,P_P,Zero,_Gt,+9,MANTISSA,P_P-2,One,$pBifq
	      B5 2B
 1893  B0 A8 CB 06 B5 FC 2D	      db 2*$BifDELSTR+128,MANTISSA-Tgt,_Jump,+6,One,MANTISSA-2,$pLength
 189A  3F A4 B5 0D F4 2D B5 41	      db $pAdd,P_P-Tgt,One,$pNumber,MANTISSA-10,$pLength,One,$pSubtract
 18A2  0F 5B EC			      db $pTo,$pControlVar,P_Q-10
 18A5  0010 R			      dw $+16
 18A7  F4 EA B5 2B FC B3 DB 02	     db MANTISSA-10,P_Q-12,One,$pBifq,2*$BifSUBSTR+128,Zero,_Sne,+2
 18AF  1D F0 B5 41 9A C5 FE	      db $pLeave,P_P-10,One,$pSubtract,P_P-Tgt-10,_IterCV,MANTISSA
 18B6  F4 2B 7C A8 F8 FC	      db P_Q-2,$pBifq,2*$BifSUBSTR,MANTISSA-Tgt,EXPONENT,MANTISSA-2
 18BC  2D F6 41 B5 3F 41 A2	      db $pLength,P_P-4,$pSubtract,One,$pAdd,$pSubtract,EXPONENT-Tgt
 18C3  EC B5 3F 0D F4 2D 0F 5B	      db P_DIGITS,One,$pAdd,$pNumber,MANTISSA-10,$pLength,$pTo,$pControlVar
 18CB  EA			      db JJ-10
 18CC  0029 R			      dw $+41
 18CE  F4 E8 B5 2B FC B3 DB 1F	     db MANTISSA-10,JJ-12,One,$pBifq,2*$BifSUBSTR+128,Zero,_Sne,+31
 18D6  EE F2 2D 3F E0 41	      db EXPONENT-10,MANTISSA-12,$pLength,$pAdd,P_DIGITS-12,$pSubtract
 18DC  98 F4 E0 B5 3F B5 2B	      db EXPONENT-Tgt-10,MANTISSA-10,P_DIGITS-12,One,$pAdd,One,$pBifq
 18E3  FC 92 F4 E0 2B		      db 2*$BifSUBSTR+128,P_T-Tgt-10,MANTISSA-10,P_DIGITS-12,$pBifq
 18E8  7A 9E E8 BB 35 D5 05 F4	      db 2*$BifLEFT,MANTISSA-Tgt-10,P_T-10,String1,"5",_Ge,+5,MANTISSA-10
 18F0  B5 3F 9E 1D C5 FE 2D	      db One,$pAdd,MANTISSA-Tgt-10,$pLeave,_IterCV,MANTISSA,$pLength
 18F7  EA D7 0D F8 FC 2D 3F EA	      db P_DIGITS-2,_Gt,+13,EXPONENT,MANTISSA-2,$pLength,$pAdd,P_DIGITS-2
 18FF  41 A2 FE EA 2B 7A	      db $pSubtract,EXPONENT-Tgt,MANTISSA,P_DIGITS-2,$pBifq,2*$BifLEFT
 1905  A8 FE B3 D9 03 B3 A2 FC	      db MANTISSA-Tgt,MANTISSA,Zero,_Seq,+3,Zero,EXPONENT-Tgt,SIGN
 190D  FC 03 F6 03 C1		      db MANTISSA-2,$pCat,EXPONENT-2,$pCat,_RetB

 1912 00 E6 2D CA 41 9E		     _POSTOP$$ db 0*8+0,MANTISSA3,$pLength,DIGITS-2,$pSubtract,TT-Tgt
 1918  F4 B3 D7 25 E6 CA B5 3F	      db TT,Zero,_Gt,+37,MANTISSA3,DIGITS-2,One,$pAdd,One,$pBifq,2*$BifSUBSTR+128
	      B5 2B FC
 1923  BB 34 D7 11 E6 CA 2B 7A	      db String1,"4",_Gt,+17,MANTISSA3,DIGITS-2,$pBifq,2*$BifLEFT
 192B  B5 3F 90 E6 2D CA D7 05	      db One,$pAdd,MANTISSA3-Tgt,MANTISSA3,$pLength,DIGITS-2,_Gt,+5
 1933  F8 B5 3F A2 E6 CA 2B	      db EXPONENT3,One,$pAdd,EXPONENT3-Tgt,MANTISSA3,DIGITS-2,$pBifq
 193A  7A 90 F8 F2 3F A2	      db 2*$BifLEFT,MANTISSA3-Tgt,EXPONENT3,TT-2,$pAdd,EXPONENT3-Tgt
 1940  E6 B3 2B 14 B3 CD 04 B3	      db MANTISSA3,Zero,$pBifq,2*$BifVERIFY,Zero,_Eq,+4,Zero,NUMBER3-Tgt
	      92
 1949  BF CA BB 2F D9 00 C8 BD	      db _RetBc,OPERATOR,String1,"/",_Seq,00h,OPERATOR-2,String2,"**"
	      2A 2A
 1953  D9 00 37 C9 22 E6 2D 0D	      db _Seq,00h,$pOr,_Then,+34,MANTISSA3,$pLength,$pNumber,One,$pNegate
	      B5 3D
 195D  11 BB 32 0F 5B F4	      db $pBy,String1,"2",$pTo,$pControlVar,ZZ-10
 1963  0010 R			      dw $+16
 1965  DC F2 B5 2B FC B3 DB 02	     db MANTISSA3-10,ZZ-12,One,$pBifq,2*$BifSUBSTR+128,Zero,_Sne,+2
 196D  1D EE B5 3F 98 C5 E6	      db $pLeave,EXPONENT3-10,One,$pAdd,EXPONENT3-Tgt-10,_IterCV,MANTISSA3
 1974  B5 FA 2B FC 90 3A	      db One,ZZ-4,$pBifq,2*$BifSUBSTR+128,MANTISSA3-Tgt,_FLOATING
 197A  BB 45 D9 9A F8 E4 2D B5	      db String1,"E",_Seq,+154,EXPONENT3,MANTISSA3-2,$pLength,One
 1982  41 3F A2 B5 A0 2B 3C	      db $pSubtract,$pAdd,EXPONENT3-Tgt,One,A_X-Tgt,$pBifq,2*$BifFORM
 1989  BB 45 D9 27 F8 BB 33 BD	      db String1,"E",_Seq,+39,EXPONENT3,String1,"3",String2,"//",EXPONENT3-6
	      2F 2F F2
 1994  2D 2C A0 F6 B3 D1 06 F6	      db $pLength,ARITHOP,A_X-Tgt,A_X,Zero,_Lt,+6,A_X,String1,"3"
	      BB 33
 199E  3F A0 F8 F4 41 A2 F6	      db $pAdd,A_X-Tgt,EXPONENT3,A_X-2,$pSubtract,EXPONENT3-Tgt,A_X
 19A5  B5 3F A0 E6 2D F4 D1 07	      db One,$pAdd,A_X-Tgt,MANTISSA3,$pLength,A_X-2,_Lt,+7,MANTISSA3
	      E6
 19AE  F4 B3 2B FA 90 F8	      db A_X-2,Zero,$pBifq,2*$BifLEFT+128,MANTISSA3-Tgt,EXPONENT3
 19B4  B9 09 39 39 39 39 39 39	      db String,9,"999999999",_Gt,+19,String,6,"SYNTAX",String,4,"42.1"
	      39 39 39 D7 13
	      B9 06 53 59 4E
	      54 41 58 B9 04
	      34 32 2E 31
 19CF  C2 C4 C0 DF B9 09 39 39	      db NUMBER1-4,OPERATOR-6,NUMBER2-8,CONFIG_RAISE,String,9,"999999999"
	      39 39 39 39 39
	      39 39
 19DE  3D F6 D7 13 B9 06 53 59	      db $pNegate,EXPONENT3-2,_Gt,+19,String,6,"SYNTAX",String,4,"42.2"
	      4E 54 41 58 B9
	      04 34 32 2E 32
 19F0  C2 C4 C0 DF E6 2D	      db NUMBER1-4,OPERATOR-6,NUMBER2-8,CONFIG_RAISE,MANTISSA3,$pLength
 19F6  F4 CF 08 BB 2E E4 F2 2B	      db A_X-2,_Ne,+8,String1,".",MANTISSA3-2,A_X-4,$pBifq,2*$BifINSERT+128
	      B8
 19FF  90 F8 B3 D5 0B E6 BD 45	      db MANTISSA3-Tgt,EXPONENT3,Zero,_Ge,+11,MANTISSA3,String2,"E+"
	      2B
 1A08  01 F6 01 92 CB 08 E6	      db $pAbut,EXPONENT3-2,$pAbut,NUMBER3-Tgt,_Jump,+8,MANTISSA3
 1A0F  BB 45 01 F6 01 92 CB 36	      db String1,"E",$pAbut,EXPONENT3-2,$pAbut,NUMBER3-Tgt,_Jump,+54
 1A17  E6 2D F6 3F 8E E4 B5 D1	      db MANTISSA3,$pLength,EXPONENT3-2,$pAdd,A_Y-Tgt,A_Y,One,_Lt
 1A1F  0C B3 B5 E0 41 2B 70 E4	      db +12,Zero,One,A_Y-4,$pSubtract,$pBifq,2*$BifCOPIES,MANTISSA3-2
 1A27  01 90 B5 8E E4 E4 2D	      db $pAbut,MANTISSA3-Tgt,One,A_Y-Tgt,A_Y,MANTISSA3-2,$pLength
 1A2E  D7 0B E6 B3 E0 E0 2D 41	      db _Gt,+11,MANTISSA3,Zero,A_Y-4,MANTISSA3-6,$pLength,$pSubtract
 1A36  2B 70 01 90 E6 92	      db $pBifq,2*$BifCOPIES,$pAbut,MANTISSA3-Tgt,MANTISSA3,NUMBER3-Tgt
 1A3C  E4 E6 2D D1 0A BB 2E E4	      db A_Y,NUMBER3-2,$pLength,_Lt,+10,String1,".",MANTISSA3-2,A_Y-4
	      E0
 1A45  2B B8 92 CB 03 E6 92	      db $pBifq,2*$BifINSERT+128,NUMBER3-Tgt,_Jump,+3,MANTISSA3,NUMBER3-Tgt
 1A4C  E2 BB 2D D9 06 BB 2D E6	      db SIGN3,String1,"-",_Seq,+6,String1,"-",NUMBER3-2,$pAbut,NUMBER3-Tgt
	      01 92
 1A56  BF			      db _RetBc

 1A57 00 B7 9E F8 E4 2D		     _FLOATING$$ db 0*8+0,Null,TT-Tgt,EXPONENT3,MANTISSA3-2,$pLength
 1A5D  3F CA D7 04 BB 45 9E E6	      db $pAdd,DIGITS-2,_Gt,+4,String1,"E",TT-Tgt,MANTISSA3,$pLength
	      2D
 1A66  F6 3F BB 35 3D D1 04 BB	      db EXPONENT3-2,$pAdd,String1,"5",$pNegate,_Lt,+4,String1,"E"
	      45
 1A6F  9E F4 C1			      db TT-Tgt,TT,_RetB

 1A72 00 CC 8A CA BB		     _ADDSUBCOMP$$ db 0*8+0,DIGITS,NOWDIGITS-Tgt,OPERATOR,String1
 1A77  2B DB 00 C8 BB 2D DB 00	      db "+",_Sne,00h,OPERATOR-2,String1,"-",_Sne,00h,$pAnd,_Then
	      35 C9
 1A81  04 BB 2D 74 EC B3 D9 08	      db +4,String1,"-",OPERATOR-Tgt,MANTISSA2,Zero,_Seq,+8,SIGN1
	      F2
 1A8A  8C FC 90 F0 A2		      db SIGN3-Tgt,MANTISSA1,MANTISSA3-Tgt,EXPONENT1,EXPONENT3-Tgt
 1A8F  BF FC B3 D9 0E EE 8C EC	      db _RetBc,MANTISSA1,Zero,_Seq,+14,SIGN2,SIGN3-Tgt,MANTISSA2
 1A97  90 EA A2 CA BB 2B	      db MANTISSA3-Tgt,EXPONENT2,EXPONENT3-Tgt,OPERATOR,String1,"+"
 1A9D  DB 02 69 BF F0 FA 2D 3F	      db _Sne,+2,Frag7,_RetBc,EXPONENT1,MANTISSA1-2,$pLength,$pAdd
 1AA5  9A EA EA 2D 3F 94	      db EXPONENT1-Tgt,EXPONENT2,MANTISSA2-2,$pLength,$pAdd,EXPONENT2-Tgt
 1AAB  B3 88 F0 E8 41 86	      db Zero,ALIGN1-Tgt,EXPONENT1,EXPONENT2-2,$pSubtract,ALIGN2-Tgt
 1AB1  DC B3 D7 11 DC DE B5 3F	      db ALIGN2,Zero,_Gt,+17,ALIGN2,NOWDIGITS-2,One,$pAdd,$pMin,01h
	      31 01
 1ABB  86 B3 DA 2B 70 EA	      db ALIGN2-Tgt,Zero,ALIGN2-2,$pBifq,2*$BifCOPIES,MANTISSA2-2
 1AC1  01 96 F0 94 DC B3	      db $pAbut,MANTISSA2-Tgt,EXPONENT1,EXPONENT2-Tgt,ALIGN2,Zero
 1AC7  D1 16 DC 3D 88 DE DE B5	      db _Lt,+22,ALIGN2,$pNegate,ALIGN1-Tgt,ALIGN1,NOWDIGITS-2,One
 1ACF  3F 31 01 88 B3 86 B3 DC	      db $pAdd,$pMin,01h,ALIGN1-Tgt,Zero,ALIGN2-Tgt,Zero,ALIGN1-2
 1AD7  2B 70 FA 01 A6 EA	      db $pBifq,2*$BifCOPIES,MANTISSA1-2,$pAbut,MANTISSA1-Tgt,EXPONENT2
 1ADD  9A FC 2D EA 2D 2F	      db EXPONENT1-Tgt,MANTISSA1,$pLength,MANTISSA2-2,$pLength,$pMax
 1AE3  01 A4 FA DE B5 3F 31 01	      db 01h,SIGDIGITS-Tgt,SIGDIGITS,NOWDIGITS-2,One,$pAdd,$pMin,01h
 1AEB  A4 FC F8 B3 2B FA	      db SIGDIGITS-Tgt,MANTISSA1,SIGDIGITS-2,Zero,$pBifq,2*$BifLEFT+128
 1AF1  A6 EC F8 B3 2B FA	      db MANTISSA1-Tgt,MANTISSA2,SIGDIGITS-2,Zero,$pBifq,2*$BifLEFT+128
 1AF7  96 F0 F8 41 A2		      db MANTISSA2-Tgt,EXPONENT1,SIGDIGITS-2,$pSubtract,EXPONENT3-Tgt
 1AFC  F8 9A F8 94 BB 2B	      db EXPONENT3,EXPONENT1-Tgt,EXPONENT3,EXPONENT2-Tgt,String1,"+"
 1B02  8C F2 BB 2D D9 0A EE BB	      db SIGN3-Tgt,SIGN1,String1,"-",_Seq,+10,SIGN2,String1,"+",Frag15
	      2B 79
 1B0C  BB 2D 8C CB 05 EE BB 2D	      db String1,"-",SIGN3-Tgt,_Jump,+5,SIGN2,String1,"-",Frag15,OPERATOR
	      79 CA
 1B16  BB 2D D9 0C FC EA DD 08	      db String1,"-",_Seq,+12,MANTISSA1,MANTISSA2-2,_Slt,+8,MANTISSA1
	      FC
 1B1F  84 EC A6 DA 96 69 FC	      db AA-Tgt,MANTISSA2,MANTISSA1-Tgt,AA,MANTISSA2-Tgt,Frag7,MANTISSA1
 1B26  EA C6 FF 90 59		      db MANTISSA2-2,OPERATOR-4,CONFIG_ARITH,MANTISSA3-Tgt,$pRepEver
 1B2B  0018 R			      dw $+24
 1B2D  DC B5 2B 7A B3 D9 00 DA	     db MANTISSA3-10,One,$pBifq,2*$BifLEFT,Zero,_Seq,00h,MANTISSA3-12
 1B35  2D B5 D7 00 35 15 DC BB	      db $pLength,One,_Gt,00h,$pAnd,$pWhile,MANTISSA3-10,String1,"2"
	      32
 1B3E  3B 2B 7C 86 1B		      db $pPositive,$pBifq,2*$BifSUBSTR,MANTISSA3-Tgt-10,$pIterate
 1B43  E6 2D F8 D7 05 FA B5 3F	      db MANTISSA3,$pLength,SIGDIGITS-2,_Gt,+5,SIGDIGITS,One,$pAdd
 1B4B  A4 FA DE 41 84 DA	      db SIGDIGITS-Tgt,SIGDIGITS,NOWDIGITS-2,$pSubtract,AA-Tgt,AA
 1B51  B3 D3 02 BF E6 2D D8 41	      db Zero,_Le,+2,_RetBc,MANTISSA3,$pLength,AA-2,$pSubtract,TT-Tgt
	      9E
 1B5A  F4 B3 D7 33 E6 F2 B5 3F	      db TT,Zero,_Gt,+51,MANTISSA3,TT-2,One,$pAdd,One,$pBifq,2*$BifSUBSTR+128
	      B5 2B FC
 1B65  BB 34 D7 20 E6 F2 2B 7A	      db String1,"4",_Gt,+32,MANTISSA3,TT-2,$pBifq,2*$BifLEFT,One
	      B5
 1B6E  3F 90 E6 2D F2 D7 0F F4	      db $pAdd,MANTISSA3-Tgt,MANTISSA3,$pLength,TT-2,_Gt,+15,TT,NOWDIGITS-2
	      DE
 1B77  D1 07 F4 B5 3F 9E CB 05	      db _Lt,+7,TT,One,$pAdd,TT-Tgt,_Jump,+5,EXPONENT3,One,$pAdd,EXPONENT3-Tgt
	      F8 B5 3F A2
 1B83  E6 F2 2B 7A 90 F8	      db MANTISSA3,TT-2,$pBifq,2*$BifLEFT,MANTISSA3-Tgt,EXPONENT3
 1B89  D8 3F B5 41 A2 CB 03 B3	      db AA-2,$pAdd,One,$pSubtract,EXPONENT3-Tgt,_Jump,+3,Zero,MANTISSA3-Tgt
	      90
 1B92  BF			      db _RetBc

 1B93 00 F2 EC D9 06 BB 2B 8C	     _MULTIPLY$$ db 0*8+0,SIGN1,SIGN2-2,_Seq,+6,String1,"+",SIGN3-Tgt
 1B9B  CB 04 BB 2D 8C F0 E8 3F	      db _Jump,+4,String1,"-",SIGN3-Tgt,EXPONENT1,EXPONENT2-2,$pAdd
 1BA3  A2 FC B3 D9 04 B3 90 BF	      db EXPONENT3-Tgt,MANTISSA1,Zero,_Seq,+4,Zero,MANTISSA3-Tgt,_RetBc
 1BAB  B7 90 B5 0D E2 2D 0F	      db Null,MANTISSA3-Tgt,One,$pNumber,MANTISSA2-10,$pLength,$pTo
 1BB2  5B F4			      db $pControlVar,ZZ-10
 1BB4  0040 R			      dw $+64
 1BB6  DC B3 01 86 E2 F2	     db MANTISSA3-10,Zero,$pAbut,MANTISSA3-Tgt-10,MANTISSA2-10,ZZ-12
 1BBC  B5 2B FC 57		      db One,$pBifq,2*$BifSUBSTR+128,$pRep
 1BC0  0033 R			      dw $+51
 1BC2  E8 2D D0 2D 41 8A	     db MANTISSA1-20,$pLength,MANTISSA3-22,$pLength,$pSubtract,TT-Tgt-20
 1BC8  E0 B3 D7 08 D2 E6 2D B3	      db TT-20,Zero,_Gt,+8,MANTISSA3-20,MANTISSA1-22,$pLength,Zero
 1BD0  2B B4 7C E0 B3 D1 08	      db $pBifq,2*$BifRIGHT+128,MANTISSA3-Tgt-20,TT-20,Zero,_Lt,+8
 1BD7  E8 D0 2D B3 2B B4	      db MANTISSA1-20,MANTISSA3-22,$pLength,Zero,$pBifq,2*$BifRIGHT+128
 1BDD  92 D2 E6 BB 2B FF	      db MANTISSA1-Tgt-20,MANTISSA3-20,MANTISSA1-22,String1,"+",CONFIG_ARITH
 1BE3  7C D2 B5 2B 7A B3	      db MANTISSA3-Tgt-20,MANTISSA3-20,One,$pBifq,2*$BifLEFT,Zero
 1BE9  CD 08 D2 BB 32 3B 2B 7C	      db _Eq,+8,MANTISSA3-20,String1,"2",$pPositive,$pBifq,2*$BifSUBSTR
 1BF1  7C 19 C5 BF		      db MANTISSA3-Tgt-20,$pIterRep,_IterCV,_RetBc

 1BF5 00 EC B3 D9 13 B9 06 53	     _DIVTYPE$$ db 0*8+0,MANTISSA2,Zero,_Seq,+19,String,6,"SYNTAX"
	      59 4E 54 41 58
 1C02  B9 04 34 32 2E 33 B3 B3	      db String,4,"42.3",Zero,Zero,Zero,CONFIG_RAISE,EXPONENT1,EXPONENT2-2
	      B3 DF F0 E8
 1C0E  41 A2 FC 2D EA 2D	      db $pSubtract,EXPONENT3-Tgt,MANTISSA1,$pLength,MANTISSA2-2,$pLength
 1C14  41 F6 3F 82 FC B3	      db $pSubtract,EXPONENT3-2,$pAdd,INTDIGITS-Tgt,MANTISSA1,Zero
 1C1A  CD 00 D6 B3 D1 00 C6 BB	      db _Eq,00h,INTDIGITS-2,Zero,_Lt,00h,OPERATOR-4,String1,"%",_Seq
	      25 D9
 1C24  00 35 37 C9 09 B3 90 BB	      db 00h,$pAnd,$pOr,_Then,+9,Zero,MANTISSA3-Tgt,String1,"+",SIGN3-Tgt
	      2B 8C
 1C2E  B3 A2 BF D8 B3 D1 00 C8	      db Zero,EXPONENT3-Tgt,_RetBc,INTDIGITS,Zero,_Lt,00h,OPERATOR-2
 1C36  BD 2F 2F D9 00 35 C9 08	      db String2,"//",_Seq,00h,$pAnd,_Then,+8,MANTISSA1,MANTISSA3-Tgt
	      FC 90
 1C40  F2 8C F0 A2 BF F2 EC	      db SIGN1,SIGN3-Tgt,EXPONENT1,EXPONENT3-Tgt,_RetBc,SIGN1,SIGN2-2
 1C47  D9 06 BB 2B 8C CB 04 BB	      db _Seq,+6,String1,"+",SIGN3-Tgt,_Jump,+4,String1,"-",SIGN3-Tgt
	      2D 8C
 1C51  B3 84 B7 90 FC EA 2D	      db Zero,AA-Tgt,Null,MANTISSA3-Tgt,MANTISSA1,MANTISSA2-2,$pLength
 1C58  2B 7A A0 FC EA 2D	      db $pBifq,2*$BifLEFT,A_X-Tgt,MANTISSA1,MANTISSA2-2,$pLength
 1C5E  B5 3F 2B 7C 8E 59	      db One,$pAdd,$pBifq,2*$BifSUBSTR,A_Y-Tgt,$pRepEver
 1C64  0061 R			      dw $+97
 1C66  B3 9E 59			     db Zero,ZZ-Tgt-10,$pRepEver
 1C69  0014 R			      dw $+20
 1C6B  E2 D6 41 8C E2 B5 2B	     db A_X-20,MANTISSA2-22,$pSubtract,A_X-Tgt-20,A_X-20,One,$pBifq
 1C72  7A BB 2D D9 02 1D EA B5	      db 2*$BifLEFT,String1,"-",_Seq,+2,$pLeave,ZZ-20,One,$pAdd,ZZ-Tgt-20
	      3F 94
 1C7C  1B EC E0 3F 96 DC	      db $pIterate,A_X-10,MANTISSA2-12,$pAdd,A_X-Tgt-10,MANTISSA3-10
 1C82  F2 01 86 DC B3 D9 03 B7	      db ZZ-12,$pAbut,MANTISSA3-Tgt-10,MANTISSA3-10,Zero,_Seq,+3,Null
 1C8A  86 DA B7 D9 06 EC B3 CD	      db MANTISSA3-Tgt-10,A_Y-10,Null,_Seq,+6,A_X-10,Zero,_Eq,+2,$pLeave
	      02 1D
 1C94  DC 2D C0 D7 02 1D C0	      db MANTISSA3-10,$pLength,DIGITS-12,_Gt,+2,$pLeave,OPERATOR-10
 1C9B  BB 2F DB 0A CE B3 CD 02	      db String1,"/",_Sne,+10,INTDIGITS-10,Zero,_Eq,+2,$pLeave,INTDIGITS-10
	      1D CE
 1CA5  B5 41 78 DA B7 D9 0B B3	      db One,$pSubtract,INTDIGITS-Tgt-10,A_Y-10,Null,_Seq,+11,Zero
 1CAD  84 EE B5 41 98 D0	      db A_Y-Tgt-10,EXPONENT3-10,One,$pSubtract,EXPONENT3-Tgt-10,AA-10
 1CB3  B5 3F 7A EC D8 B5 2B 7A	      db One,$pAdd,AA-Tgt-10,A_X-10,A_Y-12,One,$pBifq,2*$BifLEFT,$pAbut
	      01
 1CBC  96 DA BB 32 3B 2B 7C	      db A_X-Tgt-10,A_Y-10,String1,"2",$pPositive,$pBifq,2*$BifSUBSTR
 1CC3  84 1B E6 B7 CD 03 B3 90	      db A_Y-Tgt-10,$pIterate,MANTISSA3,Null,_Eq,+3,Zero,MANTISSA3-Tgt
 1CCB  F6 E2 01 A8 F8 E2 2D 3F	      db A_X,A_Y-2,$pAbut,ZZ-Tgt,EXPONENT3,A_Y-2,$pLength,$pAdd,EXPONENT3-Tgt
	      A2
 1CD4  59			      db $pRepEver
 1CD5  000C R			      dw $+12
 1CD7  6B 15 F4 BB 32 3B 2B 7C	     db Frag8,$pWhile,ZZ-10,String1,"2",$pPositive,$pBifq,2*$BifSUBSTR
 1CDF  9E 1B CA BB 2F DB 2A 3A	      db ZZ-Tgt-10,$pIterate,OPERATOR,String1,"/",_Sne,+42,_FLOATING
 1CE7  BB 45 D9 25 CA BB 25 D9	      db String1,"E",_Seq,+37,OPERATOR,String1,"%",_Seq,+11,String
	      0B B9
 1CF1  05 32 36 2E 31 31 9E CB	      db 5,"26.11",TT-Tgt,_Jump,+9,String,5,"26.12",TT-Tgt,String
	      09 B9 05 32 36
	      2E 31 32 9E B9
 1D03  06 53 59 4E 54 41 58 F2	      db 6,"SYNTAX",TT-2,NUMBER1-4,NUMBER2-6,DIGITS-8,CONFIG_RAISE
	      C2 C2 C4 DF
 1D0F  CA BD 2F 2F D9 09 F2 8C	      db OPERATOR,String2,"//",_Seq,+9,SIGN1,SIGN3-Tgt,ZZ,MANTISSA3-Tgt
	      FE 90
 1D19  F0 D8 41 A2 BF		      db EXPONENT1,AA-2,$pSubtract,EXPONENT3-Tgt,_RetBc

 1D1E 00 EC B3 D9 09 BB 2B 8C	     _POWER$$ db 0*8+0,MANTISSA2,Zero,_Seq,+9,String1,"+",SIGN3-Tgt
 1D26  B5 90 B3 A2 BF EC EA	      db One,MANTISSA3-Tgt,Zero,EXPONENT3-Tgt,_RetBc,MANTISSA2,MANTISSA2-2
 1D2D  2D E6 3F B3 2B FA 80	      db $pLength,EXPONENT2-4,$pAdd,Zero,$pBifq,2*$BifLEFT+128,RHS-Tgt
 1D34  D6 2D A0 D6 2B 66 2B 5C	      db RHS,$pLength,A_X-Tgt,RHS,$pBifq,2*$BifD2X,$pBifq,2*$BifX2B
 1D3C  8E B5 0D B5 11 5B F4	      db A_Y-Tgt,One,$pNumber,One,$pBy,$pControlVar,ZZ-10
 1D43  000C R			      dw $+12
 1D45  DA F2 B5 2B FC B3 DB 02	     db A_Y-10,ZZ-12,One,$pBifq,2*$BifSUBSTR+128,Zero,_Sne,+2,$pLeave
	      1D
 1D4E  C5 B5 84 59		      db _IterCV,One,AA-Tgt,$pRepEver
 1D52  0032 R			      dw $+50
 1D54  DA F2 B5 2B FC B5 D9 13	     db A_Y-10,ZZ-12,One,$pBifq,2*$BifSUBSTR+128,One,_Seq,+19,AA-10
	      D0
 1D5D  E6 EE 01 BB 45 01 E2	      db SIGN1-12,MANTISSA1-14,$pAbut,String1,"E",$pAbut,EXPONENT1-14
 1D64  01 BB 2A BC E4 3F B5 3F	      db $pAbut,String1,"*",DIGITS-16,A_X-18,$pAdd,One,$pAdd,ARITHOP
	      2C
 1D6D  7A F4 D8 2D CD 02 1D D0	      db AA-Tgt-10,ZZ-10,A_Y-12,$pLength,_Eq,+2,$pLeave,AA-10,AA-12
	      CE
 1D76  BB 2A BC E4 3F B5 3F 2C	      db String1,"*",DIGITS-16,A_X-18,$pAdd,One,$pAdd,ARITHOP,AA-Tgt-10
	      7A
 1D7F  F4 B5 3F 9E 1B EE BB 2D	      db ZZ-10,One,$pAdd,ZZ-Tgt-10,$pIterate,SIGN2,String1,"-",_Seq
	      D9
 1D88  0F BB 2B 98 B5 D8 BB 2F	      db +15,String1,"+",SIGN2-Tgt,One,AA-2,String1,"/",DIGITS-6,A_X-8
	      C6 EE
 1D92  3F B5 3F 2C 84 DA CA F2	      db $pAdd,One,$pAdd,ARITHOP,AA-Tgt,AA,DIGITS-2,A_X-4,$pAdd,One
	      3F B5
 1D9C  3F 2E 09 02 22 E0 E4 F6	      db $pAdd,PREPARE,$pParse,02h,022h,SIGN3-2,MANTISSA3-2,EXPONENT3-2
 1DA4  1A BF			      db 01ah,_RetBc

 1DA6 01 FE B3 D1 06 BD 31 38	     TIME2DATE$$ db 0*8+1,Arg1-4,Zero,_Lt,+6,String2,"18",$pPositive
	      3B
 1DAF  E1 FE B9 12 33 31 35 35	      db CONFIG_RAISE40,Arg1-4,String,18,"315537897600000000",_Ge
	      33 37 38 39 37
	      36 30 30 30 30
	      30 30 30 30 D5
 1DC6  06 BD 31 38 3B E1 FE 3E	      db +6,String2,"18",$pPositive,CONFIG_RAISE40,Arg1-4,TIME2DATE2
 1DCE  C1			      db _RetB

 1DCF 61 E6 B9 07 31 30 30 30	     TIME2DATE2$$ db 12*8+1,Y_TIME,String,7,"1000000",$pIntDivide
	      30 30 30 47
 1DDB  A8 E6 B9 07 31 30 30 30	      db Y_SECOND-Tgt,Y_TIME,String,7,"1000000",$pRemainder,Y_MICROSECOND-Tgt
	      30 30 30 49 A6
 1DE8  FE BD 36 30 47 A4 FE BD	      db Y_SECOND,String2,"60",$pIntDivide,Y_MINUTE-Tgt,Y_SECOND,String2
 1DF0  36 30 49 A8 FA BD 36 30	      db "60",$pRemainder,Y_SECOND-Tgt,Y_MINUTE,String2,"60",$pIntDivide
	      47
 1DF9  A2 FA BD 36 30 49 A4	      db Y_HOUR-Tgt,Y_MINUTE,String2,"60",$pRemainder,Y_MINUTE-Tgt
 1E00  F8 BD 32 34 47 A0 F8 BD	      db Y_HOUR,String2,"24",$pIntDivide,Y_DAY-Tgt,Y_HOUR,String2
 1E08  32 34 49 A2 F6 9E F6 B5	      db "24",$pRemainder,Y_HOUR-Tgt,Y_DAY,Y_BASEDAYS-Tgt,Y_DAY,One
 1E10  3F A0 F6 B9 03 33 36 36	      db $pAdd,Y_DAY-Tgt,Y_DAY,String,3,"366",$pIntDivide,Y_YEAR-Tgt
	      47 9C
 1E1A  F6 F0 B9 03 33 36 35 43	      db Y_DAY,Y_YEAR-2,String,3,"365",$pMultiply,Y_YEAR-4,String1
	      EE BB
 1E24  34 47 3F EE B9 03 31 30	      db "4",$pIntDivide,$pAdd,Y_YEAR-4,String,3,"100",$pIntDivide
	      30 47
 1E2E  41 EE B9 03 34 30 30 47	      db $pSubtract,Y_YEAR-4,String,3,"400",$pIntDivide,$pAdd,$pSubtract
	      3F 41
 1E38  A0 F2 B5 3F 9C 59	      db Y_DAY-Tgt,Y_YEAR,One,$pAdd,Y_YEAR-Tgt,$pRepEver
 1E3E  001E R			      dw $+30
 1E40  EC B9 03 33 36 35 E4 40	     db Y_DAY-10,String,3,"365",Y_YEAR-14,LEAP,$pAdd,_Gt,00h,$pWhile
	      3F D7 00 15
 1E4C  EC B9 03 33 36 35 E4 40	      db Y_DAY-10,String,3,"365",Y_YEAR-14,LEAP,$pAdd,$pSubtract,Y_DAY-Tgt-10
	      3F 41 96
 1E57  E8 B5 3F 92 1B F6 9A	      db Y_YEAR-10,One,$pAdd,Y_YEAR-Tgt-10,$pIterate,Y_DAY,Y_YEARDAYS-Tgt
 1E5E  B9 23 33 31 20 32 38 20	      db String,35,"31 28 31 30 31 30 31 31 30 31 30 31",Y_DAYS-Tgt
	      33 31 20 33 30
	      20 33 31 20 33
	      30 20 33 31 20
	      33 31 20 33 30
	      20 33 31 20 33
	      30 20 33 31 98
 1E84  B5 0D E4 2B 18 0F 5B	      db One,$pNumber,Y_DAYS-10,$pBifq,2*$BifWORDS,$pTo,$pControlVar
 1E8B  E2			      db Y_MONTH-10
 1E8C  001A R			      dw $+26
 1E8E  E4 E0 2B 72 E0 BB	     db Y_DAYS-10,Y_MONTH-12,$pBifq,2*$BifWORD,Y_MONTH-12,String1
 1E94  32 CD 00 E4 40 43 3F 8A	      db "2",_Eq,00h,Y_YEAR-14,LEAP,$pMultiply,$pAdd,Y_THISMONTH-Tgt-10
 1E9C  EC DE D3 02 1D EC DE	      db Y_DAY-10,Y_THISMONTH-12,_Le,+2,$pLeave,Y_DAY-10,Y_THISMONTH-12
 1EA3  41 96 C5 F2 EA 03 F4	      db $pSubtract,Y_DAY-Tgt-10,_IterCV,Y_YEAR,Y_MONTH-2,$pCat,Y_DAY-2
 1EAA  03 F6 03 F8 03 FC 03 FA	      db $pCat,Y_HOUR-2,$pCat,Y_MINUTE-2,$pCat,Y_SECOND-2,$pCat,Y_MICROSECOND-2
 1EB2  03 F2 03 EE 03 C1	      db $pCat,Y_BASEDAYS-2,$pCat,Y_YEARDAYS-2,$pCat,_RetB

 1EB8 01 FE BB 34 49 B3 CD 00	     LEAP$$ db 0*8+1,Arg1-4,String1,"4",$pRemainder,Zero,_Eq,00h,Arg1-4-2
	      FC
 1EC1  B9 03 31 30 30 49 B3 CF	      db String,3,"100",$pRemainder,Zero,_Ne,00h,Arg1-4-4,String,3
	      00 FA B9 03
 1ECD  34 30 30 49 B3 CD 00 37	      db "400",$pRemainder,Zero,_Eq,00h,$pOr,$pAnd,_RetB
	      35 C1

 1ED7 33 B9 03 39 39 39 51 00	     RERADIX$$ db 6*8+3,String,3,"999",$pNumeric,00h,Arg1-20,RR_SUBJECT-Tgt
	      EE A8
 1EE1  F0 A2 F2 A6 B3 A4	      db Arg2-20,RR_FROMRADIX-Tgt,Arg3-20,RR_TORADIX-Tgt,Zero,RR_INTEGER-Tgt
 1EE7  B5 0D F4 2D 0F 5B EC	      db One,$pNumber,RR_SUBJECT-10,$pLength,$pTo,$pControlVar,RR_J-10
 1EEE  0023 R			      dw $+35
 1EF0  F0 EC 43 F2 E8		     db RR_INTEGER-10,RR_FROMRADIX-12,$pMultiply,RR_SUBJECT-12,RR_J-14
 1EF5  B5 2B FC B9 10 30 31 32	      db One,$pBifq,2*$BifSUBSTR+128,String,16,"0123456789ABCDEF"
	      33 34 35 36 37
	      38 39 41 42 43
	      44 45 46
 1F0A  2B 78 3F B5 41 9A C5	      db $pBifq,2*$BifPOS,$pAdd,One,$pSubtract,RR_INTEGER-Tgt-10,_IterCV
 1F11  B7 9E FC BD 31 30 CD 07	      db Null,RR_R-Tgt,RR_TORADIX,String2,"10",_Eq,+7,RR_INTEGER,Zero
	      FA B3
 1F1B  CD 03 B3 9E 59		      db _Eq,+3,Zero,RR_R-Tgt,$pRepEver
 1F20  0029 R			      dw $+41
 1F22  F0 B3 D7 00 15 B9 10 30	     db RR_INTEGER-10,Zero,_Gt,00h,$pWhile,String,16,"0123456789ABCDEF"
	      31 32 33 34 35
	      36 37 38 39 41
	      42 43 44 45 46
 1F39  B5 EC EC 49 3F B5 2B	      db One,RR_INTEGER-14,RR_TORADIX-16,$pRemainder,$pAdd,One,$pBifq
 1F40  FC E8 01 94 F0		      db 2*$BifSUBSTR+128,RR_R-12,$pAbut,RR_R-Tgt-10,RR_INTEGER-10
 1F45  F0 47 9A 1B F8		      db RR_TORADIX-12,$pIntDivide,RR_INTEGER-Tgt-10,$pIterate,RR_FROMRADIX
 1F4A  BB 32 CD 00 FA BD 31 36	      db String1,"2",_Eq,00h,RR_TORADIX-2,String2,"16",_Eq,00h,$pAnd
	      CD 00 35
 1F55  C9 10 F4 FC 2D BB 33 3F	      db _Then,+16,RR_R,RR_SUBJECT-2,$pLength,String1,"3",$pAdd,String1
	      BB
 1F5E  34 47 B3 2B B4 9E CB	      db "4",$pIntDivide,Zero,$pBifq,2*$BifRIGHT+128,RR_R-Tgt,_Jump
 1F65  19 F8 BD 31 36 CD 00 FA	      db +25,RR_FROMRADIX,String2,"16",_Eq,00h,RR_TORADIX-2,String1
	      BB
 1F6E  32 CD 00 35 C9 0B F4 FC	      db "2",_Eq,00h,$pAnd,_Then,+11,RR_R,RR_SUBJECT-2,$pLength,String1
	      2D BB
 1F78  34 43 B3 2B B4 9E F4	      db "4",$pMultiply,Zero,$pBifq,2*$BifRIGHT+128,RR_R-Tgt,RR_R
 1F7F  C1			      db _RetB

 = 0016				     Tgts equ 2*$SysCount
 = 002C				     $RoutineBase equ 4*$SysCount
 = 005D				     $FragsBase equ $BPcodesCeil

				     ;As well as the opcodes common with Pcode, there are Bcode opcodes
				     ;for loading constants, accessing Config_ routines etc. The common
				     ;factor is a list of addresses that are called as a hardware call.
				     ;(call = pushreturn+jump)

 1F80				     BcodeRoutine:; This range is for Bcoded routines with variables.
 1F80   1   56			      push CursorSi
 1F81   1   2E: 8B B7 0F5E R	      mov CursorSi,(RoutineBase$-$RoutineBase)[bx]
				     ;------------------------------------------------------------------------------
				     ; Enter here to start a Bcode routine.
				     ; Already pushed hard return addresse and a soft CursorSi.
				     ; Enter with zero pushed when entering without Bcode continuation.
				     ;------------------------------------------------------------------------------
 1F86   5   2E: AC		     BcodeEntry:lodsb cs:[CursorSi]; 5 bits locals count, 3 bits args.
				     ; Compute in cx where Return has to reset stack in order to drop arguments.
				     ; Special when MAX,MIN
				     ; Will push a StackDi type value for use at return.
 1F88   1   81 FE 0069 R	      cmp CursorSi,BifMAX+1
 1F8C  3,1  77 06		      ja @F
 1F8E   1   8B 8E 012A		      mov cx,Z.ArgsB0
 1F92   3   EB 0D		      jmp Routx
 1F94				      @@:
 1F94   3   0F B6 D8		      movzx bx,al
 1F97   1   24 07		      and al,7
 1F99   2   C0 E0 03		      shl al,$ShiftV
 1F9C   3   98			      cbw
 1F9D   1   8B CF		      mov cx,StackDi
 1F9F   1   2B C8		      sub cx,ax
 1FA1   1   51			     Routx:push cx; For use at return.
				     ; Put local variables on stack, marked as uninitialized.
 1FA2   1   80 E3 F8		      and bl,-$StrideV
 1FA5   1   03 DF		      add ArrayBx,StackDi
 1FA7   1   3B FB		     @@:cmp StackDi,ArrayBx
 1FA9  3,1  74 09		      je @F
				      Up
 1FAB   1   83 C7 08		  1   add StackDi,$StrideV
 1FAE   2   C6 43 07 88		      mov V.Dtype,$Omitted
 1FB2   3   EB F3		      jmp @B
 1FB4   1   89 7E 06		     @@:mov Z.Stack,StackDi
 1FB7   3   E8 0000 E		      call StackSafe

 1FBA   1   89 7E 06		     BCycle:mov Z.Stack,StackDi
				     if Debug
 1FBD   1   50			       push ax
 1FBE   3   8C E8		       mov ax,gs
 1FC0   2   2E: 3B 46 38	       cmp ax,Y.Cseg
 1FC4  3,1  73 01		       jae @F
 1FC6  26   CC			       int 3
 1FC7   1   58			       @@:pop ax
 1FC8   2   3B B6 0127		       cmp CursorSi,Z.AtPause
 1FCC  3,1  75 01		       jne @F
				     ;2011 To have breakpoints on Bcode, set Z.AtPause (using CodeView)
				     ;2011 to the offset in Bcode (shown in Bcode.lst) and break here,
				     ; Bbp.
 1FCE   3   90			     Bbp:nop
 1FCF				     @@:
				     endif
				     if MemCheck
 1FCF   3   E8 0000 E		      call DosMemCheck
				     endif
 1FD2   1   68 1FBA R		      push BCycle
 1FD5   5   2E: AC		      lodsb cs:[CursorSi]
 1FD7   3   0F B6 D8		      movzx bx,al
 1FDA   1   A8 01		      test al,1
 1FDC  3,1  74 1A		      jz IsEven
 1FDE   1   3C B3		      cmp al,$BcodesBase
 1FE0  3,1  72 05		      jb NotBcode
				     ; This range means "execute operation al".  An opcode appearing in Bcode only.
				     ; CursorSi and StackDi are to be honoured but other registers will be free.
 1FE2   5p  2E: FF A7 FF4D R	      jmp cs:(BcodesBase$-$BcodesBase)[bx]

 1FE7   1   3C 5D		     NotBcode:cmp al,$FragsBase
 1FE9  3,1  73 05		     jae NotPcode
				     ; This is an opcode appearing in Bcode and Pcode. (In Bcode here)
 1FEB   5p  2E: FF A7 FFFF E	      jmp cs:(PcodesBase$-1)[bx]

				     ; This is a routine implemented in Bcode, with no variables. (A fragment)
 1FF0   1   56			     NotPcode:push CursorSi
 1FF1   1   2E: 8B B7 0F4B R	     mov CursorSi,cs:(FragsBase$-$FragsBase)[bx]
 1FF6   3   EB C2		     jmp BCycle

 1FF8   1   3C AA		     IsEven:cmp al,$Locals
 1FFA  3,1  72 66		     jb NotLocalFetch
				     ; A majority of operands will be local variables, using room reserved
				     ; on the stack. A copy of the variable is put at the top of
				     ; the stack when one of these is referenced.
				     ; These are negative because we want to add StackDi to them to address a local.

 1FFC   1   B7 FF		      mov bh,0FFh
				     ; This range means "fetch from stack to top of stack"
 1FFE				     Bfetch:; Can be called from elsewhere with bx set.  (DO iteration)
 1FFE   2   C1 E3 02		      shl ArrayBx,$ShiftV-1
 2001   2+  8D 59 08		      lea ArrayBx,$StrideV[ArrayBx+StackDi]
				      Up
 2004   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Vbxs
 2007   1   66| 36: 8B 0F	  1     mov ecx,Vbxs.OverExpo
 200B   1   66| 89 0B		  1     mov V.OverExpo,ecx
 200E   1   66| 36: 8B 47 04	  1     mov eax,Vbxs.OverMant
 2013   2   66| 89 43 04	  1     mov V.OverMant,eax
				     if Debug
				      CheckType
 2017   3   F6 43 07 C0		  1   test V.Dtype,$Test
 201B  3,1  74 44		  1   jz @F
 201D   3   80 7B 07 C0		  1   cmp V.Dtype,$AwayString
 2021  3,1  74 3E		  1   je @F
 2023   3   80 7B 07 80		  1   cmp V.Dtype,$NullString
 2027  3,1  74 38		  1   je @F
 2029   3   80 7B 07 81		  1   cmp V.Dtype,$NullString+1
 202D  3,1  74 32		  1   je @F
 202F   3   80 7B 07 82		  1   cmp V.Dtype,$NullString+2
 2033  3,1  74 2C		  1   je @F
 2035   3   80 7B 07 83		  1   cmp V.Dtype,$NullString+3
 2039  3,1  74 26		  1   je @F
 203B   3   80 7B 07 84		  1   cmp V.Dtype,$NullString+4
 203F  3,1  74 20		  1   je @F
 2041   3   80 7B 07 85		  1   cmp V.Dtype,$NullString+5
 2045  3,1  74 1A		  1   je @F
 2047   3   80 7B 07 86		  1   cmp V.Dtype,$NullString+6
 204B  3,1  74 14		  1   je @F
 204D   3   80 7B 07 87		  1   cmp V.Dtype,$NullString+7
 2051  3,1  74 0E		  1   je @F
				     ; OK to fetch Omitted if next thing is Exists test.
 2053   3   80 7B 07 88		      cmp V.Dtype,$Omitted
 2057  3,1  74 01		      je Om
 2059  26   CC			      int 3
 205A				      Om:
 205A   2   65: 80 3C C7	      cmp Bptr gs:[CursorSi],_Exists
 205E  3,1  74 01		      je @F
 2060  26   CC			      int 3
 2061				     @@:
				     endif
 2061   5   C3			      ret; To BCycle usually.

 2062   1   3C 54		     NotLocalFetch:cmp al,$Locals-Tgt
 2064  3,1  72 5B		     jb NotLocalPut
				     ; This range means "put from top of stack to [bx] down stack"
 2066   1   B7 FF		      mov bh,0FFh
 2068   1   83 C3 56		      add bx,Tgt
 206B				     Bassign:; Can be called from elsewhere with bx set.
 206B   2   C1 E3 02		      shl ArrayBx,$ShiftV-1
 206E   1   03 DF		      add ArrayBx,StackDi
				     ;When return from non-local call, having "Move" use the default ecx:eax matters.
				     if Debug
				      CheckType
 2070   3   F6 43 07 C0		  1   test V.Dtype,$Test
 2074  3,1  74 37		  1   jz @F
 2076   3   80 7B 07 C0		  1   cmp V.Dtype,$AwayString
 207A  3,1  74 31		  1   je @F
 207C   3   80 7B 07 80		  1   cmp V.Dtype,$NullString
 2080  3,1  74 2B		  1   je @F
 2082   3   80 7B 07 81		  1   cmp V.Dtype,$NullString+1
 2086  3,1  74 25		  1   je @F
 2088   3   80 7B 07 82		  1   cmp V.Dtype,$NullString+2
 208C  3,1  74 1F		  1   je @F
 208E   3   80 7B 07 83		  1   cmp V.Dtype,$NullString+3
 2092  3,1  74 19		  1   je @F
 2094   3   80 7B 07 84		  1   cmp V.Dtype,$NullString+4
 2098  3,1  74 13		  1   je @F
 209A   3   80 7B 07 85		  1   cmp V.Dtype,$NullString+5
 209E  3,1  74 0D		  1   je @F
 20A0   3   80 7B 07 86		  1   cmp V.Dtype,$NullString+6
 20A4  3,1  74 07		  1   je @F
 20A6   3   80 7B 07 87		  1   cmp V.Dtype,$NullString+7
 20AA  3,1  74 01		  1   je @F
 20AC  26   CC			      int 3
 20AD				     @@:
				     endif
				      Move Vbxs,V
 20AD   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 20B0   1   66| 36: 89 0F	  1     mov Vbxs.OverExpo,ecx
 20B4   2   66| 8B 43 04	  1     mov eax,V.OverMant
 20B8   1   66| 36: 89 47 04	  1     mov Vbxs.OverMant,eax
				      Down
 20BD   1   83 EF 08		  1   sub StackDi,$StrideV
 20C0   5   C3			      ret; To BCycle usually. (But eax:ecx used when to ControlVar)

				     ; The system variables have been put in with the ProgScope constants.
 20C1   1   3C 2C		     NotLocalPut:cmp al,$RoutineBase
 20C3  3,1  0F 83 FEB9		     jae BcodeRoutine
 20C7   2   C1 E3 02		      shl ArrayBx,$ShiftV-1
 20CA   1   83 C3 44		      add ArrayBx,$?SysVars
 20CD   1   3C 16		      cmp al,2*$SysCount
 20CF  3,1  73 51		      jae SysTgt
				     ; Lower half of range is get.
				      Up
 20D1   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Vbxe
 20D4   1   66| 26: 8B 0F	  1     mov ecx,Vbxe.OverExpo
 20D8   1   66| 89 0B		  1     mov V.OverExpo,ecx
 20DB   1   66| 26: 8B 47 04	  1     mov eax,Vbxe.OverMant
 20E0   2   66| 89 43 04	  1     mov V.OverMant,eax
				     if Debug
				      CheckType
 20E4   3   F6 43 07 C0		  1   test V.Dtype,$Test
 20E8  3,1  74 37		  1   jz @F
 20EA   3   80 7B 07 C0		  1   cmp V.Dtype,$AwayString
 20EE  3,1  74 31		  1   je @F
 20F0   3   80 7B 07 80		  1   cmp V.Dtype,$NullString
 20F4  3,1  74 2B		  1   je @F
 20F6   3   80 7B 07 81		  1   cmp V.Dtype,$NullString+1
 20FA  3,1  74 25		  1   je @F
 20FC   3   80 7B 07 82		  1   cmp V.Dtype,$NullString+2
 2100  3,1  74 1F		  1   je @F
 2102   3   80 7B 07 83		  1   cmp V.Dtype,$NullString+3
 2106  3,1  74 19		  1   je @F
 2108   3   80 7B 07 84		  1   cmp V.Dtype,$NullString+4
 210C  3,1  74 13		  1   je @F
 210E   3   80 7B 07 85		  1   cmp V.Dtype,$NullString+5
 2112  3,1  74 0D		  1   je @F
 2114   3   80 7B 07 86		  1   cmp V.Dtype,$NullString+6
 2118  3,1  74 07		  1   je @F
 211A   3   80 7B 07 87		  1   cmp V.Dtype,$NullString+7
 211E  3,1  74 01		  1   je @F
 2120  26   CC			      int 3
 2121				     @@:
				     endif
 2121   5   C3			      ret

 2122   1   83 EB 58		     SysTgt:sub ArrayBx,$SysCount*$StrideV
				     Move Vbxe,V
 2125   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 2128   1   66| 26: 89 0F	  1     mov Vbxe.OverExpo,ecx
 212C   2   66| 8B 43 04	  1     mov eax,V.OverMant
 2130   1   66| 26: 89 47 04	  1     mov Vbxe.OverMant,eax
				     if Debug
				      CheckType
 2135   3   F6 43 07 C0		  1   test V.Dtype,$Test
 2139  3,1  74 37		  1   jz @F
 213B   3   80 7B 07 C0		  1   cmp V.Dtype,$AwayString
 213F  3,1  74 31		  1   je @F
 2141   3   80 7B 07 80		  1   cmp V.Dtype,$NullString
 2145  3,1  74 2B		  1   je @F
 2147   3   80 7B 07 81		  1   cmp V.Dtype,$NullString+1
 214B  3,1  74 25		  1   je @F
 214D   3   80 7B 07 82		  1   cmp V.Dtype,$NullString+2
 2151  3,1  74 1F		  1   je @F
 2153   3   80 7B 07 83		  1   cmp V.Dtype,$NullString+3
 2157  3,1  74 19		  1   je @F
 2159   3   80 7B 07 84		  1   cmp V.Dtype,$NullString+4
 215D  3,1  74 13		  1   je @F
 215F   3   80 7B 07 85		  1   cmp V.Dtype,$NullString+5
 2163  3,1  74 0D		  1   je @F
 2165   3   80 7B 07 86		  1   cmp V.Dtype,$NullString+6
 2169  3,1  74 07		  1   je @F
 216B   3   80 7B 07 87		  1   cmp V.Dtype,$NullString+7
 216F  3,1  74 01		  1   je @F
 2171  26   CC			      int 3
 2172				     @@:
				     endif
				     ; Detect assignment to ?STREAM because of its side effects via QUALIFY
				     ; 2011 Name2File will do the Down
 2172   1   83 FB 54		      cmp ArrayBx,$?STREAM
 2175  3,1  74 04		      je Name2File
				      Down
 2177   1   83 EF 08		  1   sub StackDi,$StrideV
 217A   5   C3			      ret

				     ; Name2File is also used to look up the names of external source files.
 217B				     Name2File:; Stream name has been set and we want Z.Stream (a FileBx value) to
				     ; associate with it.
 217B   1   56			      push CursorSi
 217C   3   E8 F0DF		      call LookFileDsBx
 217F   1   5E			      pop CursorSi
 2180   1   89 5E 38		      mov Z.Stream,FileBx
 2183   1   89 5E 78		      mov Z.InsUnqual,FileBx; Possible need for a msg.
				     ; If this is first sighting, we need to get the qualified name.
 2186   2   80 7F 07 88		      cmp Vbx.Dtype,$Omitted
 218A  3,1  75 2F		      jne Name2Old
 218C   1   C6 47 07 40		      mov Vbx.Dtype,$Dropped
				     ; STREAMQUALIFY will look up the fully qualified stream and change to that.
				     ; It will do that by invoking Bcode which eventually does
				     ; CONFIG_STREAM_QUALIFIED$$ type 3.
				     ; Run STREAMQUALIFY to set Z.Stream.
				     ; The qualification algorithm is different for source files.
				      Qry Z.Cancel,SourceFiles
 2190   2   F6 46 04 04		  1          test Bptr(Z.Cancel), low ??0008
 2194  3,1  74 15		      jz @F
				      On F.Flags,IsSource
 2196   3   80 4F E7 02		  1          or  Bptr(F.Flags+1), high ??0009
 219A   1   BA 0E5F R		      mov dx,offset PATHQUALIFY
 219D   3   E8 002B		      call LinkBcode
 21A0   1   89 7E 06		      mov Z.Stack,StackDi
 21A3   1   8B 5E 38		      mov FileBx,Z.Stream
				      On F.Flags,IsSource
 21A6   3   80 4F E7 02		  1          or  Bptr(F.Flags+1), high ??000A
 21AA   5   C3			      ret
 21AB   1   BA 0E17 R		     @@:mov dx,offset STREAMQUALIFY
				     ; 2011 Extra Down
 21AE   3   E8 001A		      call LinkBcode
				      Down
 21B1   1   83 EF 08		  1   sub StackDi,$StrideV
 21B4   1   89 7E 06		      mov Z.Stack,StackDi
 21B7   1   8B 5E 38		      mov FileBx,Z.Stream
 21BA   5   C3			      ret

				     ; Lookup may have found the unqualified version.
 21BB				     Name2Old:Qry F.Flags,Qual
 21BB   2   F6 47 E7 80		  1          test Bptr(F.Flags+1), high ??000B
 21BF  3,1  75 03		     jnz @F
 21C1   1   8B 5F E8		     mov FileBx,F.ToQual
 21C4				     @@:
 21C4   1   89 5E 38		      mov Z.Stream,FileBx
				     if 0
				     endif
				      Down   ;2011
 21C7   1   83 EF 08		  1   sub StackDi,$StrideV
 21CA   5   C3			     @@: ret

				     ; Assisted linkage from m/c code to Bcode and back.

 21CB   1   56			     LinkBcode:push CursorSi
 21CC   1   8B F2		     mov CursorSi,dx
 21CE				     LinkBcodeX:; Jump (only) here when hard link & soft cursor already pushed.
				     ; (That will be the case from Bifq$$)
				     ; Note whether this is Pcode/Bcode boundary.
 21CE   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 21D1  3,1  0F 85 FDB1		      jne BcodeEntry; Nothing-or-Bcode to Bcode.

				     ; It is the boundary, Pcode calls Bcode.
				      mv gs,cs
 21D5   3   0E			  1   push cs
 21D6   3p  0F A9		  1   pop gs
 21D8   6   8F 46 58		      pop Z.ResumeP; The Pcode CursorSi.
				     ; Sadly, that copy of CursorSi is the one that Raise expects to pick up so
				     ; something will have to be done to replace it if CONFIG_RAISE happens.
				     ; Usually we will already be at default numerics so won't need to change.
				     ; Could simplify here since every case not S9 is UseGeneral
				      z Z.ResumeD; Marks as default.
 21DB   1   89 6E 5A		  1           mov Z.ResumeD,bp
 21DE   2   39 6E 6F		      cmp Z.UseGeneral,ZeroBp
 21E1  3,1  74 1A		      je @F
				     ; 2011 This fiddling of Digits() should have been done differently
				     ; since although bifs generally operate at digits 9 there are some
				     ; that record (and subsequently use) the user's current digits before
				     ; using whatever they use.  Here a fix for one-such.
 21E3   1   80 FB 60		      cmp bl,2*$BifX2D
 21E6  3,1  74 15		      je @F
 21E8   3   E8 0000 E		      call HeritageDi
				      move Z.ResumeDF,L.DigitsFuzz
 21EB   2   66| 8B 43 8C	  1      mov eax,L.DigitsFuzz
 21EF   1   66| 89 46 5A	  1      mov Z.ResumeDF,eax
				      move Z.ResumeS,L.Form
 21F3   2   8A 43 90		  1      mov al,L.Form
 21F6   1   88 46 5E		  1      mov Z.ResumeS,al
 21F9   1   5F			      pop StackDi
 21FA   3   E8 002F		      call SetS9
 21FD				     @@:
				     ; Extra level of invoke, to come back here.
 21FD   1   68 2203 R		      push ResumeP$
 2200   3   E8 FD83		      call BcodeEntry; Link of this call is not used. See _RetB
				     ; (It takes the place of unneeded CursorSi - see other path.)
				     ; Resume Pcode execution.  (This can be used after error raised in Bcode)
 2203				     ResumeP$:; If Z.ResumeD there is need to reset numerics.
 2203   2   39 6E 5A		      cmp Z.ResumeD,ZeroBp
 2206  3,1  74 17		      je @F
 2208   3   E8 0000 E		      call HeritageDi
				      move L.DigitsFuzz,Z.ResumeDF
 220B   1   66| 8B 46 5A	  1      mov eax,Z.ResumeDF
 220F   2   66| 89 43 8C	  1      mov L.DigitsFuzz,eax
				      move L.Form,Z.ResumeS
 2213   1   8A 46 5E		  1      mov al,Z.ResumeS
 2216   2   88 43 90		  1      mov L.Form,al
 2219   3   E8 0000 E		      call ZoneNumerics
 221C   1   5F			      pop StackDi
 221D   3   EB 00		      jmp ResumePret

 221F				     @@:; Assert SetS9 not needed.
 221F   1   8B 76 58		     ResumePret:mov CursorSi,Z.ResumeP
				     z Z.ResumeP
 2222   1   89 6E 58		  1           mov Z.ResumeP,bp
 2225   1   89 7E 06		     mov Z.Stack,StackDi
 2228   3p  8E 6E 4A		      mov gs,Z.Code
				      BackRet;
 222B   5   C3			  1  ret

 222C   3   E8 0000 E		     SetS9:call HeritageDi
 222F   2   C6 43 90 53		     mov L.Form,'S'
				     z L.Fuzz
 2233   2   89 6B 8E		  1           mov L.Fuzz,bp
 2236   2   C7 43 8C 0009	     mov L.Digits,9
 223B   3   E8 0000 E		     call ZoneNumerics
 223E   1   5F			      pop StackDi
 223F   5   C3			      ret

				     ;------------------------------------------------------------------------------
				     ; Here are administration routines supporting Bcode.
				     ;------------------------------------------------------------------------------
				     ; Loading top-of-stack with constants.
 2240				     Zero$$:Up
 2240   1   83 C7 08		  1   add StackDi,$StrideV
 2243   1   66| 89 2B		     ZeroIt:mov V.ExpAnd,ebp
 2246   2   66| 89 6B 04	     mov V.Mantissa,ebp
 224A   5   C3			     ret

 224B   3   E8 FFF2		     One$$:call Zero$$
 224E   4   FE 43 04		     IncrIt:inc Bptr V.Mantissa
 2251   5   C3			     ret

 2252				     Null$$:Up
 2252   1   83 C7 08		  1   add StackDi,$StrideV
 2255   2   C6 43 07 80		     mov V.Dtype,$NullString
 2259   5   C3			     ret
				     ; One byte constant operand follows String1.
 225A   5   2E: AC		     String1$$:lodsb cs:[CursorSi]
				     Up
 225C   1   83 C7 08		  1   add StackDi,$StrideV
 225F   2   C6 43 07 81		     mov V.Dtype,$NullString+1
 2263   1   88 03		     mov V.String,al
 2265   5   C3			     ret
 2266   5   2E: AD		     String2$$:lodsw cs:[CursorSi]
				     Up
 2268   1   83 C7 08		  1   add StackDi,$StrideV
 226B   2   C6 43 07 82		      mov V.Dtype,$NullString+2
 226F   1   89 03		      mov Wptr(V.String),ax
 2271   5   C3			      ret
 2272				     String$$:z ax
 2272   1   8B C5		  1           mov ax,bp
 2274   5   2E: AC		      lodsb cs:[CursorSi]
				      Up
 2276   1   83 C7 08		  1   add StackDi,$StrideV
 2279   1   83 F8 07		      cmp ax,7
 227C  3,1  77 18		      ja @F
				      Move V,cs:Vsid,edx
 227E   1   66| 2E: 8B 14	  1    mov edx,cs:Vsid.OverExpo
 2282   1   66| 89 13		  1    mov V.OverExpo,edx
 2285   1   66| 2E: 8B 54 04	  1    mov edx,cs:Vsid.OverMant
 228A   2   66| 89 53 04	  1    mov V.OverMant,edx
 228E   1   03 F0		      add CursorSi,ax
 2290   1   04 80		      add al,$NullString
 2292   2   88 43 07		      mov V.Dtype,al
 2295   5   C3			      ret
 2296   4   8C 4B 02		     @@:mov V.Sg,cs
 2299   1   89 33		      mov V.Pt,CursorSi
 229B   2   89 43 04		      mov V.Len,ax
 229E   3   E8 0000 E		      call Away
 22A1   1   03 F0		      add CursorSi,ax
 22A3   5   C3			      ret
				     ;MASM.......................
 22A4				     _RetBc$$:; Prune the stack on a return with no result.
				     ; The link to BCycle on stack is not needed.
				     ; The link on the original call is used.
				     ; That will usually be to continue BCycle but could be return to LinkBcode.
				      PopJunk di
 22A4   1   5F			  1    pop di
 22A5   1   5F			      pop StackDi
				      RetSi
 22A6   1   5E			  1   pop CursorSi
 22A7   5   C3			  1   ret

				     ; Return a level within Bcode.  Case when there is a result.
				     ; Restore StackDi to delete the local variables.
				     ;MASM ...........................
 22A8   1   8B F7		     _RetB$$:mov StackSi,StackDi
				     PopJunk di
 22AA   1   5F			  1    pop di
 22AB   1   5F			     pop StackDi
				     ; Move the result on to where the first argument was.
				      Up
 22AC   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Vsi
 22AF   1   66| 8B 0A		  1     mov ecx,Vsi.OverExpo
 22B2   1   66| 89 0B		  1     mov V.OverExpo,ecx
 22B5   2   66| 8B 42 04	  1     mov eax,Vsi.OverMant
 22B9   2   66| 89 43 04	  1     mov V.OverMant,eax
				      RetSi
 22BD   1   5E			  1   pop CursorSi
 22BE   5   C3			  1   ret

				     ; Return from fragment.
 22BF				     _RetF$$:PopJunk si
 22BF   1   5E			  1    pop si
				     RetSi
 22C0   1   5E			  1   pop CursorSi
 22C1   5   C3			  1   ret

				     ; Check if an argument was explicit.
 22C2   2   8A 43 07		     _Exists$$:mov al,V.Dtype
 22C5   3   E8 FF7B		     call ZeroIt
 22C8   1   3C 88		     cmp al,$Omitted
 22CA  3,1  75 82		     jne IncrIt
 22CC   5   C3			     ret

 22CD				     _IterCV$$:; This version used by Bcode because assignment to control
				     ; variable has to be different from Pcode version.
 22CD   2   8B 5B 04		      mov bx,D.CV
 22D0   1   53			      push bx
 22D1   3   E8 FD2A		      call Bfetch
 22D4   3   E8 0000 E		      call NumDxBx; Already checked.
				     ; Add on BY.
 22D7   2   66| 8B 4B E8	      mov ecx,D1.By.ExpAnd
 22DB   2   66| 89 4B 08	      mov V2.ExpAnd,ecx
 22DF   2   66| 8B 43 EC	      mov eax,D1.By.Mantissa
 22E3   2   66| 89 43 0C	      mov V2.Mantissa,eax
 22E7   3   E8 0000 E		      call AddRegs
				     ; Store that back in CV.
 22EA   1   5B			      pop bx
 22EB   3   E8 FD7D		      call Bassign
 22EE   3   E9 0000 E		      jmp CompareTO

				     ; NYI avoid test.
 22F1   3   F6 43 07 C0		     _Then$$:test V.Dtype,$Test
 22F5  3,1  74 03		     jz @F
 22F7   3   E8 0000 E		     call NumDxBx
 22FA				     @@:
 22FA   3   39 6B 04		      cmp V.MantLow,ZeroBp
				      DownCare
 22FD   1+  8D 7D F8		  1   lea StackDi,(-$StrideV)[StackDi]
 2300  3,1  74 02		      je _Jump$$
 2302   1   46			      inc CursorSi
 2303   5   C3			      ret

 2304   3   2E: 0F B6 04	     _Jump$$:movzx ax,Bptr cs:[CursorSi]
 2308   1   03 F0		     add CursorSi,ax
 230A   5   C3			     ret

 230B   1   56			     CONFIG_ARITH$$:push CursorSi; Add/Sub in decimal.
				     ; The arguments will be string because they were made by PARSEing.
				     ; The arguments have been made the same length.
				     ; The result might be one longer for add.
				     ; Leading zeros will be removed later.
				     ; Not OK to destruct arguments.
 230C   1   8A 33		      mov dh,V.String; The operator
				     ; Make copy of LHS with extra position.
				      Down
 230E   1   83 EF 08		  1   sub StackDi,$StrideV
 2311   3   E8 0000 E		      call ToDsSiCx
 2314   1   41			      inc cx
				      Up
 2315   1   83 C7 08		  1   add StackDi,$StrideV
 2318   3   E8 0000 E		      call ResultSpace
 231B   1   83 EF 10		      sub StackDi,2*$StrideV
 231E   3   E8 0000 E		      call ToDsSiCx
 2321   1   57			      push StackDi
 2322   1   8B F8		      mov di,ax
 2324   1   26: C6 05 30	      mov es:Bptr[di],'0'
 2328   1   47			      inc di
 2329   7n  F3/ A4		      rep movsb
 232B   1   5F			      pop StackDi
				      Move V,V3
 232C   2   66| 8B 4B 10	  1     mov ecx,V3.OverExpo
 2330   1   66| 89 0B		  1     mov V.OverExpo,ecx
 2333   2   66| 8B 43 14	  1     mov eax,V3.OverMant
 2337   2   66| 89 43 04	  1     mov V.OverMant,eax
 233B   3   E8 0000 E		      call ToDsSiCx
				      mv es,ds
 233E   3   1E			  1   push ds
 233F   3p  07			  1   pop es
 2340   1   8B DE		      mov bx,si
 2342   1   43			      inc bx
				      Up
 2343   1   83 C7 08		  1   add StackDi,$StrideV
 2346   3   E8 0000 E		      call ToDsSiCx
				      Down
 2349   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; Add/Sub DS:SI::CX to ES:BX which is addressed by V.
 234C   1   03 D9		      add bx,cx
 234E   1   03 F1		      add si,cx
				      z dl
 2350   1   B2 00		  1         mov dl,0
 2352   1   80 FE 2B		      cmp dh,'+'
 2355  3,1  75 26		      jne CAsubloop
				     ;MASM............................
 2357   1   4B			     CAaddloop:dec bx
 2358   1   4E			     dec si
 2359   1   26: 8A 07		     mov al,es:[bx]
 235C   1   2C 30		     sub al,'0'
 235E   2   02 04		     add al,[si]
 2360   1   02 C2		     add al,dl
				     z dl
 2362   1   B2 00		  1         mov dl,0
 2364   1   3C 39		      cmp al,'9'
 2366  3,1  76 03		      jna @F
 2368   1   2C 0A		      sub al,10
 236A   1   42			      inc dx
 236B   1   26: 88 07		      @@:mov es:[bx],al
				      LoopQ CAaddloop
 236E   1   49			  1    dec cx
 236F  3,1  75 E6		  1    jnz CAaddloop
 2371   1   80 FA 00		      cmp dl,0
 2374  3,1  74 05		      je @F
 2376   1   26: C6 47 FF 31	      mov Bptr es:[bx-1],'1'
 237B				      @@:
 237B   1   5E			      pop CursorSi
 237C   5   C3			      ret

 237D   1   4B			     CAsubloop:dec bx
 237E   1   4E			     dec si
 237F   1   26: 8A 07		     mov al,es:[bx]
 2382   2   2A 04		     sub al,[si]
 2384   1   2A C2		     sub al,dl
 2386   1   B2 00		     mov dl,0
 2388  3,1  79 03		      jns @F
 238A   1   04 0A		      add al,10
 238C   1   42			      inc dx
 238D   1   04 30		      @@:add al,'0'
 238F   1   26: 88 07		      mov es:[bx],al
				      LoopQ CAsubloop
 2392   1   49			  1    dec cx
 2393  3,1  75 E8		  1    jnz CAsubloop
				     ; Assert DL=0 was pre-arranged.
 2395   1   5E			      pop CursorSi
 2396   5   C3			      ret

				     ; Raise from Bcode.
 2397				     CONFIG_RAISE$$:; eg 'SYNTAX',26.11,<value>,<value>,<value>
 2397   1   8B 76 2E		      mov si,Z.XCycleResetSp
				      move Wptr[si+bp-4],Z.ResumeP
 239A   1   8B 46 58		  1      mov ax,Z.ResumeP
 239D   2   89 42 FC		  1      mov Wptr[si+bp-4],ax
 23A0   3   E8 FE60		      call ResumeP$
 23A3   1   83 EF 10		      sub StackDi,2*$StrideV
 23A6   3   80 7B F7 86		      cmp V00.Dtype,$NullString+6
 23AA  3,1  75 1B		      jne NotSyntax
				     ; Make it look like jmp Raise from hard code.
 23AC   1   B8 1A0B		      mov ax,MkMajMin(26,11)
 23AF   3   80 7B F8 32		      cmp V0.String,'2'; Only 26.xx and 42.xx come this way.
 23B3  3,1  75 0A		      jne CR42
 23B5   3   80 7B FC 32		      cmp V0.String+4,'2'
 23B9  3,1  75 01		      jne @F
 23BB   1   40			      inc ax
 23BC   3   E9 0000 E		      @@:jmp Raise
 23BF   2   8A 43 FA		     CR42:mov al,V0.String+2
 23C2   1   2C 30		      sub al,'0'
 23C4   3   E9 0000 E		      jmp Raise

 23C7   5p  FF D5		     NotSyntax:Error49Bp

				      end
Microsoft (R) Macro Assembler Version 6.11		    01/29/12 11:35:02
bcode.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

AllocAppend  . . . . . . . . . . . . .	Proc
BackRet  . . . . . . . . . . . . . . .	Proc
Back . . . . . . . . . . . . . . . . .	Proc
CheckType  . . . . . . . . . . . . . .	Proc
CodeModeR  . . . . . . . . . . . . . .	Proc
DownCare . . . . . . . . . . . . . . .	Proc
Down . . . . . . . . . . . . . . . . .	Proc
EvAh . . . . . . . . . . . . . . . . .	Proc
EvRet  . . . . . . . . . . . . . . . .	Proc
JcxzQ  . . . . . . . . . . . . . . . .	Proc
LoopQ  . . . . . . . . . . . . . . . .	Proc
MkMajMin . . . . . . . . . . . . . . .	Func
Move . . . . . . . . . . . . . . . . .	Proc
Mv . . . . . . . . . . . . . . . . . .	Proc
Off  . . . . . . . . . . . . . . . . .	Proc
On . . . . . . . . . . . . . . . . . .	Proc
OpAl . . . . . . . . . . . . . . . . .	Proc
OpRet  . . . . . . . . . . . . . . . .	Proc
PopJunk  . . . . . . . . . . . . . . .	Proc
Pos  . . . . . . . . . . . . . . . . .	Func
Qry  . . . . . . . . . . . . . . . . .	Proc
Repmovsb . . . . . . . . . . . . . . .	Proc
RetSi  . . . . . . . . . . . . . . . .	Proc
Splat  . . . . . . . . . . . . . . . .	Proc
StringOrder  . . . . . . . . . . . . .	Func
TestReg  . . . . . . . . . . . . . . .	Proc
UnCodeMode . . . . . . . . . . . . . .	Proc
UpCare . . . . . . . . . . . . . . . .	Proc
Up . . . . . . . . . . . . . . . . . .	Proc
XlatBDLS . . . . . . . . . . . . . . .	Proc
dec2 . . . . . . . . . . . . . . . . .	Proc
inc2 . . . . . . . . . . . . . . . . .	Proc
la . . . . . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . . . . .	Proc
mv . . . . . . . . . . . . . . . . . .	Proc
top  . . . . . . . . . . . . . . . . .	Proc
xax  . . . . . . . . . . . . . . . . .	Proc
z  . . . . . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Ashape . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Amount . . . . . . . . . . . . . . .	 0004	     Word
Dshape . . . . . . . . . . . . . . . .	 0028
  TailsAt  . . . . . . . . . . . . . .	 0000	     Word
  Subject  . . . . . . . . . . . . . .	 0000	     QWord
  CVinit . . . . . . . . . . . . . . .	 0000	     QWord
  Reps . . . . . . . . . . . . . . . .	 0000	     QWord
  To . . . . . . . . . . . . . . . . .	 0008	     QWord
  By . . . . . . . . . . . . . . . . .	 0010	     QWord
  ForCount . . . . . . . . . . . . . .	 0018	     QWord
  PcodePos . . . . . . . . . . . . . .	 0020	     Word
  Iteration  . . . . . . . . . . . . .	 0020	     Word
  Leaving  . . . . . . . . . . . . . .	 0022	     Word
  UpDO . . . . . . . . . . . . . . . .	 0024	     Word
  CV . . . . . . . . . . . . . . . . .	 0024	     Word
  Rec  . . . . . . . . . . . . . . . .	 0027	     Byte
EnvBlock . . . . . . . . . . . . . . .	 0008
  EnvNumber  . . . . . . . . . . . . .	 0000	     Word
  EnvResourceI . . . . . . . . . . . .	 0002	     Word
  EnvResourceO . . . . . . . . . . . .	 0004	     Word
  EnvResourceE . . . . . . . . . . . .	 0006	     Word
FarpX  . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
Farp . . . . . . . . . . . . . . . . .	 0004
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
Fshape . . . . . . . . . . . . . . . .	 001A
  Flags  . . . . . . . . . . . . . . .	 0000	     Word
  ToQual . . . . . . . . . . . . . . .	 0002	     Word
  Lines  . . . . . . . . . . . . . . .	 0004	     DWord
  Hand . . . . . . . . . . . . . . . .	 0008	     Word
  Other_Position . . . . . . . . . . .	 000A	     DWord
  Exten  . . . . . . . . . . . . . . .	 000E	     Byte
  TraceWidth . . . . . . . . . . . . .	 000F	     Byte
  Symbols  . . . . . . . . . . . . . .	 0010	     Word
  Code . . . . . . . . . . . . . . . .	 0012	     Word
  Vars . . . . . . . . . . . . . . . .	 0014	     Word
  Consts . . . . . . . . . . . . . . .	 0016	     Word
  ProgScope  . . . . . . . . . . . . .	 0018	     Word
Hshape . . . . . . . . . . . . . . . .	 0010
  Hdw0 . . . . . . . . . . . . . . . .	 0000	     DWord
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  Bump . . . . . . . . . . . . . . . .	 0002	     Word
  Avail  . . . . . . . . . . . . . . .	 0004	     Word
  Trigger  . . . . . . . . . . . . . .	 0006	     Word
  Link . . . . . . . . . . . . . . . .	 0008	     Word
  TreeBin  . . . . . . . . . . . . . .	 000A	     Word
  Original . . . . . . . . . . . . . .	 000A	     Word
  UpPool . . . . . . . . . . . . . . .	 000A	     Word
  Probe  . . . . . . . . . . . . . . .	 000C	     Word
  TreeProg . . . . . . . . . . . . . .	 000E	     Word
  Labels . . . . . . . . . . . . . . .	 000E	     Word
InsBlock . . . . . . . . . . . . . . .	 0015
  MajMin . . . . . . . . . . . . . . .	 0000	     Word
  Minor  . . . . . . . . . . . . . . .	 0000	     Byte
  Major  . . . . . . . . . . . . . . .	 0001	     Byte
  Value  . . . . . . . . . . . . . . .	 0002	     Word
  Named  . . . . . . . . . . . . . . .	 0004	     Word
  Position . . . . . . . . . . . . . .	 0004	     Word
  KeysList . . . . . . . . . . . . . .	 0006	     Word
  ArgNum . . . . . . . . . . . . . . .	 0008	     Byte
  Desc . . . . . . . . . . . . . . . .	 0009	     Byte
  Hex  . . . . . . . . . . . . . . . .	 000A	     Byte
  Char . . . . . . . . . . . . . . . .	 000A	     Byte
  Options  . . . . . . . . . . . . . .	 000B	     Word
  OptsHi . . . . . . . . . . . . . . .	 000D	     Word
  Digits . . . . . . . . . . . . . . .	 000F	     Word
  TokPos . . . . . . . . . . . . . . .	 0011	     Word
  TokLen . . . . . . . . . . . . . . .	 0013	     Word
Jshape . . . . . . . . . . . . . . . .	 000E
  Valued . . . . . . . . . . . . . . .	 0000	     QWord
  Pair . . . . . . . . . . . . . . . .	 0008	     DWord
  Lower  . . . . . . . . . . . . . . .	 0008	     Word
  Higher . . . . . . . . . . . . . . .	 000A	     Word
  KeyLen . . . . . . . . . . . . . . .	 000C	     Word
  Key  . . . . . . . . . . . . . . . .	 000E	     Byte
Lshape . . . . . . . . . . . . . . . .	 007C
  DigitsFuzz . . . . . . . . . . . . .	 0000	     DWord
  Digits . . . . . . . . . . . . . . .	 0000	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0002	     Word
  Form . . . . . . . . . . . . . . . .	 0004	     Byte
  StartTime  . . . . . . . . . . . . .	 0005	     QWord
  TraceLetter  . . . . . . . . . . . .	 000D	     Byte
  TraceWord  . . . . . . . . . . . . .	 000D	     Word
  Active . . . . . . . . . . . . . . .	 000F	     QWord
  Alternate  . . . . . . . . . . . . .	 0017	     QWord
  Syntax . . . . . . . . . . . . . . .	 001F	     Byte
  LostDigits . . . . . . . . . . . . .	 0020	     Byte
  NoValue  . . . . . . . . . . . . . .	 0021	     Byte
  NotReady . . . . . . . . . . . . . .	 0022	     Byte
  Error  . . . . . . . . . . . . . . .	 0023	     Byte
  Failure  . . . . . . . . . . . . . .	 0024	     Byte
  Halt . . . . . . . . . . . . . . . .	 0025	     Byte
  TrapName . . . . . . . . . . . . . .	 0026	     Word
  EventLevel . . . . . . . . . . . . .	 0034	     Word
  Condition  . . . . . . . . . . . . .	 0036	     Word
  ConditionDescription . . . . . . . .	 0038	     QWord
  ConditionExtra . . . . . . . . . . .	 0040	     QWord
  Inherit  . . . . . . . . . . . . . .	 0048	     Byte
  ClauseTime . . . . . . . . . . . . .	 0048	     QWord
  ClauseLocal  . . . . . . . . . . . .	 0050	     QWord
  PendingDescription . . . . . . . . .	 0058	     QWord
  PendingExtra . . . . . . . . . . . .	 0060	     QWord
  LevelDO  . . . . . . . . . . . . . .	 0068	     Word
  StackSave  . . . . . . . . . . . . .	 006A	     DWord
  File . . . . . . . . . . . . . . . .	 006E	     Word
  ProgScope  . . . . . . . . . . . . .	 0070	     Word
  VarScope . . . . . . . . . . . . . .	 0072	     Word
  Access . . . . . . . . . . . . . . .	 0074	     Word
  Flags  . . . . . . . . . . . . . . .	 0074	     Word
  UpLevel  . . . . . . . . . . . . . .	 0076	     Word
  Resume . . . . . . . . . . . . . . .	 0078	     Word
  Arg0 . . . . . . . . . . . . . . . .	 007A	     Word
PushShape  . . . . . . . . . . . . . .	 0010
  di_  . . . . . . . . . . . . . . . .	 0000	     Word
  si_  . . . . . . . . . . . . . . . .	 0002	     Word
  bp_  . . . . . . . . . . . . . . . .	 0004	     Word
  sp_  . . . . . . . . . . . . . . . .	 0006	     Word
  bx_  . . . . . . . . . . . . . . . .	 0008	     Word
  bl_  . . . . . . . . . . . . . . . .	 0008	     Byte
  bh_  . . . . . . . . . . . . . . . .	 0009	     Byte
  dx_  . . . . . . . . . . . . . . . .	 000A	     Word
  dl_  . . . . . . . . . . . . . . . .	 000A	     Byte
  dh_  . . . . . . . . . . . . . . . .	 000B	     Byte
  cx_  . . . . . . . . . . . . . . . .	 000C	     Word
  cl_  . . . . . . . . . . . . . . . .	 000C	     Byte
  ch_  . . . . . . . . . . . . . . . .	 000D	     Byte
  ax_  . . . . . . . . . . . . . . . .	 000E	     Word
  al_  . . . . . . . . . . . . . . . .	 000E	     Byte
  ah_  . . . . . . . . . . . . . . . .	 000F	     Byte
Sshape . . . . . . . . . . . . . . . .	 0010
  State  . . . . . . . . . . . . . . .	 0000	     Word
  Parser . . . . . . . . . . . . . . .	 0002	     Word
  ClauseWas  . . . . . . . . . . . . .	 0004	     Word
  Token  . . . . . . . . . . . . . . .	 0006	     Word
  Operation  . . . . . . . . . . . . .	 0008	     DWord
  Caller . . . . . . . . . . . . . . .	 000C	     Word
  Parms  . . . . . . . . . . . . . . .	 000E	     Word
  JumpSite . . . . . . . . . . . . . .	 0006	     Word
  SoFar  . . . . . . . . . . . . . . .	 0008	     Word
  WhatCV . . . . . . . . . . . . . . .	 0008	     Word
  SelectSite . . . . . . . . . . . . .	 0008	     Word
Vshape . . . . . . . . . . . . . . . .	 0008
  String . . . . . . . . . . . . . . .	 0000	     Byte
  Dtype  . . . . . . . . . . . . . . .	 0007	     Byte
  Sign . . . . . . . . . . . . . . . .	 0000	     Byte
  ExpAnd . . . . . . . . . . . . . . .	 0000	     DWord
  ExpoUses . . . . . . . . . . . . . .	 0000	     Byte
  ExpoSign . . . . . . . . . . . . . .	 0003	     Byte
  Mantissa . . . . . . . . . . . . . .	 0004	     DWord
  MantLow  . . . . . . . . . . . . . .	 0004	     Word
  MantHigh . . . . . . . . . . . . . .	 0006	     Word
  OverExpo . . . . . . . . . . . . . .	 0000	     DWord
  OverMant . . . . . . . . . . . . . .	 0004	     DWord
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
  LabelValue . . . . . . . . . . . . .	 0000	     Word
  LabelType  . . . . . . . . . . . . .	 0006	     Word
  WhichCon . . . . . . . . . . . . . .	 0000	     Word
  PcodePos . . . . . . . . . . . . . .	 0002	     Word
  HeldOver . . . . . . . . . . . . . .	 0000	     Word
  Pair . . . . . . . . . . . . . . . .	 0000	     DWord
  Lower  . . . . . . . . . . . . . . .	 0000	     Word
  Higher . . . . . . . . . . . . . . .	 0002	     Word
  Here . . . . . . . . . . . . . . . .	 0004	     Word
Yshape . . . . . . . . . . . . . . . .	 0053
  N1 . . . . . . . . . . . . . . . . .	 0004	     DWord
  N10  . . . . . . . . . . . . . . . .	 0008	     DWord
  N100 . . . . . . . . . . . . . . . .	 000C	     DWord
  N1000  . . . . . . . . . . . . . . .	 0010	     DWord
  N1e4 . . . . . . . . . . . . . . . .	 0014	     DWord
  N1e5 . . . . . . . . . . . . . . . .	 0018	     DWord
  N1e6 . . . . . . . . . . . . . . . .	 001C	     DWord
  N1e7 . . . . . . . . . . . . . . . .	 0020	     DWord
  N1e8 . . . . . . . . . . . . . . . .	 0024	     DWord
  N1e9 . . . . . . . . . . . . . . . .	 0028	     DWord
  N1664525 . . . . . . . . . . . . . .	 002C	     DWord
  ExponHi  . . . . . . . . . . . . . .	 0030	     DWord
  ExponLo  . . . . . . . . . . . . . .	 0034	     DWord
  Cseg . . . . . . . . . . . . . . . .	 0038	     Word
  DOS  . . . . . . . . . . . . . . . .	 003A	     DWord
  DosPool  . . . . . . . . . . . . . .	 003E	     Byte
  DqCrLf . . . . . . . . . . . . . . .	 004C	     Byte
  CrLf . . . . . . . . . . . . . . . .	 004D	     Byte
  StackSave  . . . . . . . . . . . . .	 004F	     DWord
Zshape . . . . . . . . . . . . . . . .	 137C
  w  . . . . . . . . . . . . . . . . .	 0000	     Word
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  ProgramCancel  . . . . . . . . . . .	 0002	     DWord
  Program  . . . . . . . . . . . . . .	 0002	     Word
  Cancel . . . . . . . . . . . . . . .	 0004	     Word
  Stack  . . . . . . . . . . . . . . .	 0006	     Word
  ClauseLine . . . . . . . . . . . . .	 0008	     Word
  Middles  . . . . . . . . . . . . . .	 000A	     Word
  Clause . . . . . . . . . . . . . . .	 000C	     Word
  Gen  . . . . . . . . . . . . . . . .	 000E	     Word
  KWMiddle . . . . . . . . . . . . . .	 0010	     Word
  KWFound  . . . . . . . . . . . . . .	 0012	     Word
  Stdout . . . . . . . . . . . . . . .	 0014	     Word
  Stderr . . . . . . . . . . . . . . .	 0016	     Word
  SourceHandle . . . . . . . . . . . .	 0018	     Word
  HowInvoked . . . . . . . . . . . . .	 001A	     Word
  Radix  . . . . . . . . . . . . . . .	 001C	     Byte
  AxAsNum  . . . . . . . . . . . . . .	 001D	     Byte
  Tag  . . . . . . . . . . . . . . . .	 0023	     Byte
  Seed . . . . . . . . . . . . . . . .	 0028	     DWord
  ParseResetSp . . . . . . . . . . . .	 002C	     Word
  XCycleResetSp  . . . . . . . . . . .	 002E	     Word
  Dumper . . . . . . . . . . . . . . .	 0030	     Word
  Stash  . . . . . . . . . . . . . . .	 0032	     Word
  Resolved . . . . . . . . . . . . . .	 0034	     Word
  Cursor . . . . . . . . . . . . . . .	 0036	     Word
  Stream . . . . . . . . . . . . . . .	 0038	     Word
  Queue  . . . . . . . . . . . . . . .	 003A	     Word
  InsSource  . . . . . . . . . . . . .	 003C	     DWord
  SysFile  . . . . . . . . . . . . . .	 003C	     DWord
  File . . . . . . . . . . . . . . . .	 003C	     Word
  SysFiles . . . . . . . . . . . . . .	 003E	     Word
  Consts . . . . . . . . . . . . . . .	 0040	     Word
  Vars . . . . . . . . . . . . . . . .	 0042	     Word
  ProgScope  . . . . . . . . . . . . .	 0044	     Word
  VarScope . . . . . . . . . . . . . .	 0046	     Word
  Symbols  . . . . . . . . . . . . . .	 0048	     Word
  Code . . . . . . . . . . . . . . . .	 004A	     Word
  Zone . . . . . . . . . . . . . . . .	 004C	     Word
  Stem . . . . . . . . . . . . . . . .	 004E	     Word
  PoolPool . . . . . . . . . . . . . .	 0050	     Word
  Level  . . . . . . . . . . . . . . .	 0052	     Word
  Base0  . . . . . . . . . . . . . . .	 0054	     Word
  CurrentDO  . . . . . . . . . . . . .	 0056	     Word
  ResumeP  . . . . . . . . . . . . . .	 0058	     Word
  ResumeDF . . . . . . . . . . . . . .	 005A	     DWord
  ResumeD  . . . . . . . . . . . . . .	 005A	     Word
  ResumeF  . . . . . . . . . . . . . .	 005C	     Word
  ResumeS  . . . . . . . . . . . . . .	 005E	     Byte
  DigitsFuzz . . . . . . . . . . . . .	 005F	     DWord
  Digits . . . . . . . . . . . . . . .	 005F	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0061	     Word
  Ceiling  . . . . . . . . . . . . . .	 0063	     DWord
  DivBreak . . . . . . . . . . . . . .	 0067	     DWord
  TwiceDigits  . . . . . . . . . . . .	 006B	     DWord
  UseGeneral . . . . . . . . . . . . .	 006F	     Word
  InsLine  . . . . . . . . . . . . . .	 0071	     Word
  InsBif . . . . . . . . . . . . . . .	 0073	     Byte
  InsOperator  . . . . . . . . . . . .	 0074	     DWord
  InsUnqual  . . . . . . . . . . . . .	 0078	     Word
  Insert . . . . . . . . . . . . . . .	 007A	      0015
  Inserts  . . . . . . . . . . . . . .	 008F	      0015
  SignM  . . . . . . . . . . . . . . .	 00A4	     Byte
  SignE  . . . . . . . . . . . . . . .	 00A5	     Byte
  MantPos  . . . . . . . . . . . . . .	 00A6	     Word
  MantPosZi  . . . . . . . . . . . . .	 00A8	     Word
  ExpPos . . . . . . . . . . . . . . .	 00AA	     Word
  ExpPosZi . . . . . . . . . . . . . .	 00AC	     Word
  ExpSign  . . . . . . . . . . . . . .	 00AE	     Word
  MantSize . . . . . . . . . . . . . .	 00B0	     Word
  OpIs . . . . . . . . . . . . . . . .	 00B2	     Byte
  Flags  . . . . . . . . . . . . . . .	 00B3	     Byte
  BifParmsHi . . . . . . . . . . . . .	 00B4	     Byte
  BifByte  . . . . . . . . . . . . . .	 00B5	     Byte
  TraceAlign . . . . . . . . . . . . .	 00B6	     DWord
  TraceSource  . . . . . . . . . . . .	 00BA	     DWord
  TraceEnds  . . . . . . . . . . . . .	 00BE	     DWord
  TraceSourceColumn  . . . . . . . . .	 00C2	     Word
  TraceEndsColumn  . . . . . . . . . .	 00C4	     Word
  DualCode . . . . . . . . . . . . . .	 00C6	     Word
  TraceOp  . . . . . . . . . . . . . .	 00C8	     Byte
  Relative . . . . . . . . . . . . . .	 00C9	     DWord
  RelativeNow  . . . . . . . . . . . .	 00CD	     DWord
  Continue . . . . . . . . . . . . . .	 00D1	     Word
  StackX . . . . . . . . . . . . . . .	 00D3	     Word
  TraceLine  . . . . . . . . . . . . .	 00D5	     Word
  InhibitTrace . . . . . . . . . . . .	 00D7	     DWord
  InhibitPauses  . . . . . . . . . . .	 00DB	     DWord
  Target . . . . . . . . . . . . . . .	 00DF	     Word
  Scanp  . . . . . . . . . . . . . . .	 00E1	     Word
  EndUsedBuffer  . . . . . . . . . . .	 00E3	     Word
  NearEnd  . . . . . . . . . . . . . .	 00E5	     Word
  CatOp  . . . . . . . . . . . . . . .	 00E7	     Byte
  RadixBadWhite  . . . . . . . . . . .	 00E8	     Byte
  BackExponent . . . . . . . . . . . .	 00E9	     Word
  LastContent  . . . . . . . . . . . .	 00EB	     Word
  CommaLine  . . . . . . . . . . . . .	 00ED	     Word
  Condition  . . . . . . . . . . . . .	 00EF	     Word
  UntilPlace . . . . . . . . . . . . .	 00F1	     Word
  StemSym  . . . . . . . . . . . . . .	 00F3	     Word
  SoFar  . . . . . . . . . . . . . . .	 00F5	     Word
  PcodePos . . . . . . . . . . . . . .	 00F7	     Word
  TraceOnly  . . . . . . . . . . . . .	 00F9	     Word
  CompareAt  . . . . . . . . . . . . .	 00FB	     Word
  StackHi  . . . . . . . . . . . . . .	 00FD	     Word
  StackLo  . . . . . . . . . . . . . .	 00FF	     Word
  OnSoft . . . . . . . . . . . . . . .	 0101	     Word
  Tail . . . . . . . . . . . . . . . .	 0103	     Word
  TokNum . . . . . . . . . . . . . . .	 0105	     Word
  TokNow . . . . . . . . . . . . . . .	 0107	     Word
  TokWas . . . . . . . . . . . . . . .	 0109	     Word
  TokData  . . . . . . . . . . . . . .	 010B	     Word
  Synch  . . . . . . . . . . . . . . .	 010D	     Word
  Lines  . . . . . . . . . . . . . . .	 010F	     Word
  MsgBegin . . . . . . . . . . . . . .	 0111	     Word
  MsgSoFar . . . . . . . . . . . . . .	 0113	     Word
  PreZi  . . . . . . . . . . . . . . .	 0115	     Word
  TargetMajMin . . . . . . . . . . . .	 0117	     Word
  TargetMinor  . . . . . . . . . . . .	 0117	     Byte
  TargetMajor  . . . . . . . . . . . .	 0118	     Byte
  EnvSeg . . . . . . . . . . . . . . .	 0119	     Word
  ForPSP . . . . . . . . . . . . . . .	 011B	     DWord
  Fcb1 . . . . . . . . . . . . . . . .	 011F	     DWord
  Fcb2 . . . . . . . . . . . . . . . .	 0123	     DWord
  AtPause  . . . . . . . . . . . . . .	 0127	     Word
  ArgsB  . . . . . . . . . . . . . . .	 0129	     Byte
  ArgsB0 . . . . . . . . . . . . . . .	 012A	     Word
  Parsee . . . . . . . . . . . . . . .	 012C	     FWord
  ParseeNum  . . . . . . . . . . . . .	 0132	     Word
  PattLenEtc . . . . . . . . . . . . .	 0134	     Word
  BreakStart . . . . . . . . . . . . .	 0136	     Word
  BreakEnd . . . . . . . . . . . . . .	 0138	     Word
  EnvNow . . . . . . . . . . . . . . .	 013A	     QWord
  CatTotal . . . . . . . . . . . . . .	 0142	     Word
  LastTarget . . . . . . . . . . . . .	 0144	     Word
  NewJshape  . . . . . . . . . . . . .	 0146	     Word
  FromDos  . . . . . . . . . . . . . .	 0148	     Word
  FromDosWas . . . . . . . . . . . . .	 014A	     Word
  FromDosZi  . . . . . . . . . . . . .	 014C	     Word
  MemoryTable  . . . . . . . . . . . .	 014E	     FWord
  MemoryTableZi  . . . . . . . . . . .	 018A	     Byte
  Left . . . . . . . . . . . . . . . .	 018A	     Word
  Right  . . . . . . . . . . . . . . .	 018C	     Word
  AllocBase  . . . . . . . . . . . . .	 018E	     DWord
  DsWas  . . . . . . . . . . . . . . .	 0192	     Word
  DsNew  . . . . . . . . . . . . . . .	 0194	     Word
  EsWas  . . . . . . . . . . . . . . .	 0196	     Word
  EsNew  . . . . . . . . . . . . . . .	 0198	     Word
  FsWas  . . . . . . . . . . . . . . .	 019A	     Word
  FsNew  . . . . . . . . . . . . . . .	 019C	     Word
  GsWas  . . . . . . . . . . . . . . .	 019E	     Word
  GsNew  . . . . . . . . . . . . . . .	 01A0	     Word
  DebugStash . . . . . . . . . . . . .	 01A2	     Word
  DebugD . . . . . . . . . . . . . . .	 01A4	     DWord
  DigitCount . . . . . . . . . . . . .	 01A8	     Word
  SerialNow  . . . . . . . . . . . . .	 01AA	     Byte
  Serial . . . . . . . . . . . . . . .	 01AB	     Byte
  CommandArg . . . . . . . . . . . . .	 1374	     QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

CancelRec  . . . . . . . . . . . . . .	 0010	   0010
  Format5  . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  AssignDO . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ForExpose  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FromIterCV . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  ForBIF . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  TokIsValue . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  ExpRange . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Description  . . . . . . . . . . . .	 0008	   0001	     0100     ?
  Compacted  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  BcodeInterpret . . . . . . . . . . .	 0006	   0001	     0040     ?
  MapOnly  . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ParseUpper . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ParseTrace . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  SourceFiles  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  BoolBefore . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  WasDropped . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ClauseRec  . . . . . . . . . . . . . .	 0010	   0010
  WasUpper . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  OffFlag  . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Condition  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  Append . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Signal . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ClauseSet  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  CVar . . . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Repit  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PosEq  . . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NotAssign  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  WasParse . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  InParse  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  Tailed . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  WasTailed  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PosPlus  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PosMinus . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ConditionRec . . . . . . . . . . . . .	 0008	   0005
  Enabling . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  Delayed  . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PendingNow . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  Instruction  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  CRspare  . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ErrorRec . . . . . . . . . . . . . . .	 0010	   0004
  HasShiftOn . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAloneOn . . . . . . . . . . . .	 000E	   0001	     4000     ?
  MajorField . . . . . . . . . . . . .	 0006	   0008	     3FC0     ?
  MinorField . . . . . . . . . . . . .	 0000	   0006	     003F     ?
FRec . . . . . . . . . . . . . . . . .	 0010	   0009
  Qual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Read . . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Open . . . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  BeenRead . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  BeenWrite  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  WriteMode  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  IsSource . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  BeenCompiled . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FFpad  . . . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
GenRec . . . . . . . . . . . . . . . .	 0010	   0005
  Dual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  DualPending  . . . . . . . . . . . .	 000E	   0001	     4000     ?
  DualGen  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  DualOnly . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  GenSpare . . . . . . . . . . . . . .	 0000	   000C	     0FFF     ?
KeyRec . . . . . . . . . . . . . . . .	 0008	   0003
  KeyFlags . . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  EndList  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KeyLen . . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
LevelRecI  . . . . . . . . . . . . . .	 0010	   0003
  LIPad  . . . . . . . . . . . . . . .	 0002	   000E	     FFFC     ?
  Interactive  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ConditionInstruction . . . . . . . .	 0000	   0001	     0001     ?
LevelRec . . . . . . . . . . . . . . .	 0010	   0007
  Lpad . . . . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  InheritDone  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DigitsSet  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IsProcedure  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IsExternal . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IsFunction . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  Lpad2  . . . . . . . . . . . . . . .	 0000	   0003	     0007     ?
LoopsRec . . . . . . . . . . . . . . .	 0008	   0007
  LoopsPad . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  HasDot . . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  HasDots  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HasTo  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  HasFor . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IsInterp . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ByDown . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MiddleRec  . . . . . . . . . . . . . .	 0010	   0010
  NotLabel . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  SemiAfter  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ValueBefore  . . . . . . . . . . . .	 000D	   0001	     2000     ?
  AbutOK . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  NoBlanks . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ModEquals  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  EndClause  . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  ImplicitValue  . . . . . . . . . . .	 0008	   0001	     0100     ?
  CheckDO  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TargetSymbol . . . . . . . . . . . .	 0006	   0001	     0040     ?
  Function . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  TakenConstant  . . . . . . . . . . .	 0004	   0001	     0010     ?
  LookLabel  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LookBin  . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DotOK  . . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  MRspare  . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OperatorRec  . . . . . . . . . . . . .	 0008	   0006
  InTypes  . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ResultType . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  AppendNum  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  AppendRef  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DownOne  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  EndsClause . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ParmsRec . . . . . . . . . . . . . . .	 0008	   0003
  ParmsMin . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ParmsXtr . . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  NonCheck . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ParserRec  . . . . . . . . . . . . . .	 0010	   0005
  ParserPad  . . . . . . . . . . . . .	 0004	   000C	     FFF0     ?
  DoRep  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DoCV . . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  Forever  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DoDataHost . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ProgramRec . . . . . . . . . . . . . .	 0010	   000B
  API_Enabled  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Repass . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  LabelsBad  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FirstBetween . . . . . . . . . . . .	 000C	   0001	     1000     ?
  EndSource  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  BifCheck . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  RandomSeeded . . . . . . . . . . . .	 0009	   0001	     0200     ?
  NotS9  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  TraceIF  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ShowELSE . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PRSpare  . . . . . . . . . . . . . .	 0000	   0006	     003F     ?
RedRec . . . . . . . . . . . . . . . .	 0010	   0005
  HasShiftOff  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  HasAction  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PruneCt  . . . . . . . . . . . . . .	 000C	   0002	     3000     ?
  Rtype  . . . . . . . . . . . . . . .	 000A	   0002	     0C00     ?
  Rstate . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
ShiftRec . . . . . . . . . . . . . . .	 0010	   0008
  HasShift . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAlone . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  CatFlag  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  HasKeys  . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Reference  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  Direct . . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  Indexb . . . . . . . . . . . . . . .	 0005	   0005	     03E0     ?
  Index  . . . . . . . . . . . . . . .	 0000	   0005	     001F     ?
TokRec . . . . . . . . . . . . . . . .	 0010	   0003
  X02  . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  NdxbT  . . . . . . . . . . . . . . .	 000A	   0005	     7C00     ?
  Aim  . . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
TokVal . . . . . . . . . . . . . . . .	 0008	   0002
  GrpNdx . . . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SubNum . . . . . . . . . . . . . . .	 0000	   0002	     0003     ?


Types:

                N a m e                  Size     Attr

Boolp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
Bool . . . . . . . . . . . . . . . . .	 0001	  Byte 
Handlep  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Handle . . . . . . . . . . . . . . . .	 0002	  Word 
Segp . . . . . . . . . . . . . . . . .	 0002	  Word 
Ulong  . . . . . . . . . . . . . . . .	 0004	  DWord 
Ushortp  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Ushort . . . . . . . . . . . . . . . .	 0002	  Word 
bytep  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
charfp . . . . . . . . . . . . . . . .	 0004	  FarPTR Byte 
charp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
char . . . . . . . . . . . . . . . . .	 0001	  Byte 
shortp . . . . . . . . . . . . . . . .	 0002	  PTR Word 
short  . . . . . . . . . . . . . . . .	 0002	  Word 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
MyGroup  . . . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . . . . .	16 Bit	 23C9	  Word	  Public  'CODE'	
FanSegB  . . . . . . . . . . . . . . .	16 Bit	 004E	  Word	  Public  'CODE'	
BifSeg . . . . . . . . . . . . . . . .	16 Bit	 003C	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

$0 . . . . . . . . . . . . . . . . . .	Number	 0000h	 
$10  . . . . . . . . . . . . . . . . .	Number	 0007h	 
$11  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$12  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$15  . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$16  . . . . . . . . . . . . . . . . .	Number	 0017h	 
$17  . . . . . . . . . . . . . . . . .	Number	 0019h	 
$18  . . . . . . . . . . . . . . . . .	Number	 0018h	 
$19  . . . . . . . . . . . . . . . . .	Number	 001Ah	 
$1 . . . . . . . . . . . . . . . . . .	Number	 0013h	 
$21  . . . . . . . . . . . . . . . . .	Number	 0016h	 
$23  . . . . . . . . . . . . . . . . .	Number	 001Eh	 
$28  . . . . . . . . . . . . . . . . .	Number	 0012h	 
$2 . . . . . . . . . . . . . . . . . .	Number	 0015h	 
$3 . . . . . . . . . . . . . . . . . .	Number	 0004h	 
$5 . . . . . . . . . . . . . . . . . .	Number	 0006h	 
$6 . . . . . . . . . . . . . . . . . .	Number	 0003h	 
$7 . . . . . . . . . . . . . . . . . .	Number	 000Eh	 
$8 . . . . . . . . . . . . . . . . . .	Number	 0014h	 
$9 . . . . . . . . . . . . . . . . . .	Number	 0009h	 
$?BIF  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$?CLAUSELOCAL  . . . . . . . . . . . .	Number	 007Ch	 
$?CLAUSETIME . . . . . . . . . . . . .	Number	 0074h	 
$?Discard  . . . . . . . . . . . . . .	Number	 0010h	 
$?E  . . . . . . . . . . . . . . . . .	Number	 00B4h	 
$?LINEIN_POSITION  . . . . . . . . . .	Number	 006Ch	 
$?MN . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$?MONTHS . . . . . . . . . . . . . . .	Number	 0084h	 
$?Nine . . . . . . . . . . . . . . . .	Number	 009Ch	 
$?Null . . . . . . . . . . . . . . . .	Number	 00ACh	 
$?OUTCOME  . . . . . . . . . . . . . .	Number	 0044h	 
$?Omitted  . . . . . . . . . . . . . .	Number	 0014h	 
$?RCx  . . . . . . . . . . . . . . . .	Number	 0028h	 
$?RC . . . . . . . . . . . . . . . . .	Number	 0034h	 
$?RESPONSE . . . . . . . . . . . . . .	Number	 0064h	 
$?RESULTx  . . . . . . . . . . . . . .	Number	 0020h	 
$?RESULT . . . . . . . . . . . . . . .	Number	 002Ch	 
$?RS . . . . . . . . . . . . . . . . .	Number	 0024h	 
$?SIGLx  . . . . . . . . . . . . . . .	Number	 0030h	 
$?SIGL . . . . . . . . . . . . . . . .	Number	 003Ch	 
$?STARTTIME  . . . . . . . . . . . . .	Number	 0094h	 
$?STREAMSTATE  . . . . . . . . . . . .	Number	 005Ch	 
$?STREAM . . . . . . . . . . . . . . .	Number	 0054h	 
$?SysVars  . . . . . . . . . . . . . .	Number	 0044h	 
$?S  . . . . . . . . . . . . . . . . .	Number	 00BCh	 
$?WEEKDAYS . . . . . . . . . . . . . .	Number	 008Ch	 
$?Zero . . . . . . . . . . . . . . . .	Number	 00A4h	 
$ADDRESS . . . . . . . . . . . . . . .	Number	 008Ch	 
$APPEND  . . . . . . . . . . . . . . .	Number	 0090h	 
$ARG . . . . . . . . . . . . . . . . .	Number	 0088h	 
$Abut  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$And . . . . . . . . . . . . . . . . .	Number	 0018h	 
$Ashapes . . . . . . . . . . . . . . .	Number	 000Ah	 
$Assign  . . . . . . . . . . . . . . .	Number	 0054h	 
$Asterisk  . . . . . . . . . . . . . .	Number	 0011h	 
$AttribAnd . . . . . . . . . . . . . .	Number	 00D8h	 
$AttribComma . . . . . . . . . . . . .	Number	 00DCh	 
$AttribEq  . . . . . . . . . . . . . .	Number	 00EBh	 
$AttribGt  . . . . . . . . . . . . . .	Number	 00F0h	 
$AttribLine  . . . . . . . . . . . . .	Number	 00E7h	 
$AttribLt  . . . . . . . . . . . . . .	Number	 00EDh	 
$AttribMinus . . . . . . . . . . . . .	Number	 00E4h	 
$AttribOr  . . . . . . . . . . . . . .	Number	 00D5h	 
$AttribPlus  . . . . . . . . . . . . .	Number	 00E5h	 
$AttribSlash . . . . . . . . . . . . .	Number	 00D2h	 
$AttribStar  . . . . . . . . . . . . .	Number	 00D1h	 
$AwayString  . . . . . . . . . . . . .	Number	 00C0h	 
$BPcodesCeil . . . . . . . . . . . . .	Number	 005Dh	 
$BY  . . . . . . . . . . . . . . . . .	Number	 006Ch	 
$Bb  . . . . . . . . . . . . . . . . .	Number	 0004h	 
$BcodesBase  . . . . . . . . . . . . .	Number	 00B3h	 
$BifABBREV . . . . . . . . . . . . . .	Number	 0014h	 
$BifABS  . . . . . . . . . . . . . . .	Number	 002Ah	 
$BifADDRESS  . . . . . . . . . . . . .	Number	 0020h	 
$BifARG  . . . . . . . . . . . . . . .	Number	 0021h	 
$BifB2X  . . . . . . . . . . . . . . .	Number	 002Dh	 
$BifBITAND . . . . . . . . . . . . . .	Number	 0034h	 
$BifBITOR  . . . . . . . . . . . . . .	Number	 0035h	 
$BifBITXOR . . . . . . . . . . . . . .	Number	 0036h	 
$BifBase . . . . . . . . . . . . . . .	Number	 FFB9h	 
$BifC2D  . . . . . . . . . . . . . . .	Number	 0031h	 
$BifC2X  . . . . . . . . . . . . . . .	Number	 002Ch	 
$BifCENTER . . . . . . . . . . . . . .	Number	 0015h	 
$BifCENTRE . . . . . . . . . . . . . .	Number	 0016h	 
$BifCHANGESTR  . . . . . . . . . . . .	Number	 0042h	 
$BifCHARIN . . . . . . . . . . . . . .	Number	 0004h	 
$BifCHAROUT  . . . . . . . . . . . . .	Number	 0005h	 
$BifCHARS  . . . . . . . . . . . . . .	Number	 0003h	 
$BifCOMPARE  . . . . . . . . . . . . .	Number	 0017h	 
$BifCONDITION  . . . . . . . . . . . .	Number	 0022h	 
$BifCOPIES . . . . . . . . . . . . . .	Number	 0038h	 
$BifCOUNTSTR . . . . . . . . . . . . .	Number	 0041h	 
$BifD2C  . . . . . . . . . . . . . . .	Number	 0032h	 
$BifD2X  . . . . . . . . . . . . . . .	Number	 0033h	 
$BifDATATYPE . . . . . . . . . . . . .	Number	 001Fh	 
$BifDATE . . . . . . . . . . . . . . .	Number	 0000h	 
$BifDELSTR . . . . . . . . . . . . . .	Number	 0018h	 
$BifDELWORD  . . . . . . . . . . . . .	Number	 0019h	 
$BifDIGITS . . . . . . . . . . . . . .	Number	 0025h	 
$BifERRORTEXT  . . . . . . . . . . . .	Number	 000Eh	 
$BifFORMAT . . . . . . . . . . . . . .	Number	 0011h	 
$BifFORM . . . . . . . . . . . . . . .	Number	 001Eh	 
$BifFUZZ . . . . . . . . . . . . . . .	Number	 0024h	 
$BifINSERT . . . . . . . . . . . . . .	Number	 001Ch	 
$BifLASTPOS  . . . . . . . . . . . . .	Number	 001Bh	 
$BifLEFT . . . . . . . . . . . . . . .	Number	 003Dh	 
$BifLENGTH . . . . . . . . . . . . . .	Number	 0043h	 
$BifLINEIN . . . . . . . . . . . . . .	Number	 0006h	 
$BifLINEOUT  . . . . . . . . . . . . .	Number	 0007h	 
$BifLINES  . . . . . . . . . . . . . .	Number	 0002h	 
$BifMAX  . . . . . . . . . . . . . . .	Number	 0044h	 
$BifMIN  . . . . . . . . . . . . . . .	Number	 0045h	 
$BifOVERLAY  . . . . . . . . . . . . .	Number	 001Dh	 
$BifPOS  . . . . . . . . . . . . . . .	Number	 003Ch	 
$BifQUALIFY  . . . . . . . . . . . . .	Number	 000Bh	 
$BifQUEUED . . . . . . . . . . . . . .	Number	 003Fh	 
$BifRANDOM . . . . . . . . . . . . . .	Number	 0028h	 
$BifREVERSE  . . . . . . . . . . . . .	Number	 0029h	 
$BifRIGHT  . . . . . . . . . . . . . .	Number	 001Ah	 
$BifSIGN . . . . . . . . . . . . . . .	Number	 002Bh	 
$BifSOURCELINE . . . . . . . . . . . .	Number	 0026h	 
$BifSPACE  . . . . . . . . . . . . . .	Number	 000Fh	 
$BifSTREAM . . . . . . . . . . . . . .	Number	 0008h	 
$BifSTRIP  . . . . . . . . . . . . . .	Number	 0009h	 
$BifSUBSTR . . . . . . . . . . . . . .	Number	 003Eh	 
$BifSUBWORD  . . . . . . . . . . . . .	Number	 003Bh	 
$BifSYMBOL . . . . . . . . . . . . . .	Number	 0040h	 
$BifTIME . . . . . . . . . . . . . . .	Number	 0001h	 
$BifTRACE  . . . . . . . . . . . . . .	Number	 0023h	 
$BifTRANSLATE  . . . . . . . . . . . .	Number	 0010h	 
$BifTRUNC  . . . . . . . . . . . . . .	Number	 000Dh	 
$BifTag  . . . . . . . . . . . . . . .	Number	 0080h	 
$BifVALUE  . . . . . . . . . . . . . .	Number	 0037h	 
$BifVERIFY . . . . . . . . . . . . . .	Number	 000Ah	 
$BifWORDINDEX  . . . . . . . . . . . .	Number	 003Ah	 
$BifWORDLENGTH . . . . . . . . . . . .	Number	 0012h	 
$BifWORDPOS  . . . . . . . . . . . . .	Number	 0013h	 
$BifWORDS  . . . . . . . . . . . . . .	Number	 000Ch	 
$BifWORD . . . . . . . . . . . . . . .	Number	 0039h	 
$BifX2B  . . . . . . . . . . . . . . .	Number	 002Eh	 
$BifX2C  . . . . . . . . . . . . . . .	Number	 002Fh	 
$BifX2D  . . . . . . . . . . . . . . .	Number	 0030h	 
$BifXRANGE . . . . . . . . . . . . . .	Number	 0027h	 
$Bin . . . . . . . . . . . . . . . . .	Number	 0024h	 
$CALL  . . . . . . . . . . . . . . . .	Number	 0094h	 
$CONST_SYMBOL  . . . . . . . . . . . .	Number	 0040h	 
$CaseTarget  . . . . . . . . . . . . .	Number	 0006h	 
$Cat . . . . . . . . . . . . . . . . .	Number	 004Dh	 
$Colon . . . . . . . . . . . . . . . .	Number	 000Ah	 
$Comma . . . . . . . . . . . . . . . .	Number	 001Ch	 
$Constant  . . . . . . . . . . . . . .	Number	 008Ah	 
$Cr  . . . . . . . . . . . . . . . . .	Text   	 0dh
$DIGITS  . . . . . . . . . . . . . . .	Number	 00E4h	 
$DO  . . . . . . . . . . . . . . . . .	Number	 0098h	 
$DROP  . . . . . . . . . . . . . . . .	Number	 00B8h	 
$Desc59H . . . . . . . . . . . . . . .	Number	 000Bh	 
$DescArgs  . . . . . . . . . . . . . .	Number	 000Ah	 
$DescFiles . . . . . . . . . . . . . .	Number	 000Ch	 
$DescQueue . . . . . . . . . . . . . .	Number	 000Dh	 
$DescString  . . . . . . . . . . . . .	Number	 0005h	 
$Descriptions  . . . . . . . . . . . .	Number	 0037h	 
$Digit . . . . . . . . . . . . . . . .	Number	 0040h	 
$DosAllocate . . . . . . . . . . . . .	Number	 0048h	 
$DosChmod  . . . . . . . . . . . . . .	Number	 0043h	 
$DosClose  . . . . . . . . . . . . . .	Number	 003Eh	 
$DosCreate . . . . . . . . . . . . . .	Number	 003Ch	 
$DosDate . . . . . . . . . . . . . . .	Number	 002Ah	 
$DosDelete . . . . . . . . . . . . . .	Number	 0041h	 
$DosDisk . . . . . . . . . . . . . . .	Number	 0019h	 
$DosExecute  . . . . . . . . . . . . .	Number	 004Bh	 
$DosExit . . . . . . . . . . . . . . .	Number	 004Ch	 
$DosFree . . . . . . . . . . . . . . .	Number	 0049h	 
$DosGetError . . . . . . . . . . . . .	Number	 0059h	 
$DosModifyAllocated  . . . . . . . . .	Number	 004Ah	 
$DosOpen . . . . . . . . . . . . . . .	Number	 003Dh	 
$DosPSP  . . . . . . . . . . . . . . .	Number	 0062h	 
$DosPath . . . . . . . . . . . . . . .	Number	 0047h	 
$DosRead . . . . . . . . . . . . . . .	Number	 003Fh	 
$DosReturnCode . . . . . . . . . . . .	Number	 004Dh	 
$DosSeek . . . . . . . . . . . . . . .	Number	 0042h	 
$DosTime . . . . . . . . . . . . . . .	Number	 002Ch	 
$DosWrite  . . . . . . . . . . . . . .	Number	 0040h	 
$Dropped . . . . . . . . . . . . . . .	Number	 0040h	 
$ELSE  . . . . . . . . . . . . . . . .	Number	 009Ch	 
$END . . . . . . . . . . . . . . . . .	Number	 005Ch	 
$ENGINEERING . . . . . . . . . . . . .	Number	 00ECh	 
$ERROR . . . . . . . . . . . . . . . .	Number	 00CCh	 
$EXIT  . . . . . . . . . . . . . . . .	Number	 00A8h	 
$EXPOSE  . . . . . . . . . . . . . . .	Number	 00BCh	 
$Ee  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$EndBuffer . . . . . . . . . . . . . .	Number	 000Ah	 
$Eof . . . . . . . . . . . . . . . . .	Text   	 1ah
$Eos . . . . . . . . . . . . . . . . .	Number	 0000h	 
$Eq  . . . . . . . . . . . . . . . . .	Number	 002Bh	 
$Exposed . . . . . . . . . . . . . . .	Number	 0050h	 
$FAILURE . . . . . . . . . . . . . . .	Number	 00C9h	 
$FOREVER . . . . . . . . . . . . . . .	Number	 0118h	 
$FORM  . . . . . . . . . . . . . . . .	Number	 00E8h	 
$FOR . . . . . . . . . . . . . . . . .	Number	 0064h	 
$FUZZ  . . . . . . . . . . . . . . . .	Number	 00E5h	 
$FileBufferSize  . . . . . . . . . . .	Number	 0400h	 
$FragsBase . . . . . . . . . . . . . .	Number	 005Dh	 
$Ge  . . . . . . . . . . . . . . . . .	Number	 002Fh	 
$Group . . . . . . . . . . . . . . . .	Number	 00FCh	 
$Gt  . . . . . . . . . . . . . . . . .	Number	 0030h	 
$HALT  . . . . . . . . . . . . . . . .	Number	 00CAh	 
$Hex . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$IF  . . . . . . . . . . . . . . . . .	Number	 00D4h	 
$INPUT . . . . . . . . . . . . . . . .	Number	 00D8h	 
$INTERPRET . . . . . . . . . . . . . .	Number	 00A4h	 
$ITERATE . . . . . . . . . . . . . . .	Number	 00B5h	 
$InitStackSize . . . . . . . . . . . .	Number	 2000h	 
$Invalid . . . . . . . . . . . . . . .	Number	 0009h	 
$LEAVE . . . . . . . . . . . . . . . .	Number	 00B4h	 
$LINEIN  . . . . . . . . . . . . . . .	Number	 007Ch	 
$LOSTDIGITS  . . . . . . . . . . . . .	Number	 00C5h	 
$Label . . . . . . . . . . . . . . . .	Number	 008Bh	 
$Leeway  . . . . . . . . . . . . . . .	Number	 0003h	 
$Letter  . . . . . . . . . . . . . . .	Number	 0080h	 
$Le  . . . . . . . . . . . . . . . . .	Number	 002Eh	 
$Lf  . . . . . . . . . . . . . . . . .	Text   	 0ah
$Limit_Digits  . . . . . . . . . . . .	Number	 270Fh	 
$Limit_EnvironmentName . . . . . . . .	Number	 000Ah	 
$Limit_ExponentDigits  . . . . . . . .	Number	 0009h	 
$Limit_Insert  . . . . . . . . . . . .	Number	 0032h	 
$Limit_Literal . . . . . . . . . . . .	Number	 00FAh	 
$Limit_Major . . . . . . . . . . . . .	Number	 0036h	 
$Limit_Name  . . . . . . . . . . . . .	Number	 00FAh	 
$Limit_String  . . . . . . . . . . . .	Number	 C350h	 
$LineFeed  . . . . . . . . . . . . . .	Number	 0027h	 
$Locals  . . . . . . . . . . . . . . .	Number	 00AAh	 
$Lowercase . . . . . . . . . . . . . .	Number	 0048h	 
$Lparen  . . . . . . . . . . . . . . .	Number	 000Ch	 
$Lt  . . . . . . . . . . . . . . . . .	Number	 002Dh	 
$M090  . . . . . . . . . . . . . . . .	Number	 0010h	 
$MaxParms  . . . . . . . . . . . . . .	Number	 0064h	 
$MaxPreInsert  . . . . . . . . . . . .	Number	 00AFh	 
$Minus . . . . . . . . . . . . . . . .	Number	 0024h	 
$MsgChunk  . . . . . . . . . . . . . .	Number	 0050h	 
$MsgNum  . . . . . . . . . . . . . . .	Number	 0044h	 
$MsgRoom . . . . . . . . . . . . . . .	Number	 00C8h	 
$NAME  . . . . . . . . . . . . . . . .	Number	 00DCh	 
$NOP . . . . . . . . . . . . . . . . .	Number	 00A0h	 
$NORMAL  . . . . . . . . . . . . . . .	Number	 0114h	 
$NOTREADY  . . . . . . . . . . . . . .	Number	 00C8h	 
$NOVALUE . . . . . . . . . . . . . . .	Number	 00C6h	 
$NUMBER  . . . . . . . . . . . . . . .	Number	 0044h	 
$NUMERIC . . . . . . . . . . . . . . .	Number	 00E0h	 
$Ne  . . . . . . . . . . . . . . . . .	Number	 002Ch	 
$NoMatch . . . . . . . . . . . . . . .	Number	 00FFh	 
$NonUpable . . . . . . . . . . . . . .	Number	 0008h	 
$Not . . . . . . . . . . . . . . . . .	Number	 0020h	 
$NullString  . . . . . . . . . . . . .	Number	 0080h	 
$Num . . . . . . . . . . . . . . . . .	Number	 000Ch	 
$OFF . . . . . . . . . . . . . . . . .	Number	 011Ch	 
$OKb . . . . . . . . . . . . . . . . .	Number	 0020h	 
$OKx . . . . . . . . . . . . . . . . .	Number	 0010h	 
$ON  . . . . . . . . . . . . . . . . .	Number	 0120h	 
$OPTIONS . . . . . . . . . . . . . . .	Number	 00A5h	 
$OTHERWISE . . . . . . . . . . . . . .	Number	 00F0h	 
$OUTPUT  . . . . . . . . . . . . . . .	Number	 00F4h	 
$Omitted . . . . . . . . . . . . . . .	Number	 0088h	 
$Or  . . . . . . . . . . . . . . . . .	Number	 0015h	 
$PARSE . . . . . . . . . . . . . . . .	Number	 00F8h	 
$PROCEDURE . . . . . . . . . . . . . .	Number	 00FCh	 
$PULL  . . . . . . . . . . . . . . . .	Number	 0080h	 
$PUSH  . . . . . . . . . . . . . . . .	Number	 00A9h	 
$Pad . . . . . . . . . . . . . . . . .	Number	 0018h	 
$PcodesBase  . . . . . . . . . . . . .	Number	 0001h	 
$PcodesCeil  . . . . . . . . . . . . .	Number	 00C5h	 
$Percent . . . . . . . . . . . . . . .	Number	 0010h	 
$PjumpBase . . . . . . . . . . . . . .	Number	 0057h	 
$PjumpCeil . . . . . . . . . . . . . .	Number	 0089h	 
$PlusMinus . . . . . . . . . . . . . .	Text   	 $AttribPlus and $Group
$Plus  . . . . . . . . . . . . . . . .	Number	 0025h	 
$Power . . . . . . . . . . . . . . . .	Number	 0050h	 
$QUEUE . . . . . . . . . . . . . . . .	Number	 00AAh	 
$REPLACE . . . . . . . . . . . . . . .	Number	 0108h	 
$RETURN  . . . . . . . . . . . . . . .	Number	 00ABh	 
$Rem . . . . . . . . . . . . . . . . .	Number	 0013h	 
$RoutineBase . . . . . . . . . . . . .	Number	 002Ch	 
$Rparen  . . . . . . . . . . . . . . .	Number	 0038h	 
$SAY . . . . . . . . . . . . . . . . .	Number	 00ACh	 
$SCIENTIFIC  . . . . . . . . . . . . .	Number	 00EDh	 
$SELECT  . . . . . . . . . . . . . . .	Number	 0100h	 
$SIGNAL  . . . . . . . . . . . . . . .	Number	 00C0h	 
$SOURCE  . . . . . . . . . . . . . . .	Number	 007Dh	 
$STEM  . . . . . . . . . . . . . . . .	Number	 010Ch	 
$STREAM  . . . . . . . . . . . . . . .	Number	 0110h	 
$STRING  . . . . . . . . . . . . . . .	Number	 003Ch	 
$SYNTAX  . . . . . . . . . . . . . . .	Number	 00C4h	 
$Semi  . . . . . . . . . . . . . . . .	Number	 0004h	 
$Seq . . . . . . . . . . . . . . . . .	Number	 0031h	 
$SerialCompaction  . . . . . . . . . .	Number	 0002h	 
$SerialInterpret . . . . . . . . . . .	Number	 0003h	 
$SerialNone  . . . . . . . . . . . . .	Number	 0000h	 
$SerialQue . . . . . . . . . . . . . .	Number	 0001h	 
$SerialSource  . . . . . . . . . . . .	Number	 0004h	 
$Sge . . . . . . . . . . . . . . . . .	Number	 0035h	 
$Sgt . . . . . . . . . . . . . . . . .	Number	 0036h	 
$ShiftV  . . . . . . . . . . . . . . .	Number	 0003h	 
$Sigl  . . . . . . . . . . . . . . . .	Number	 0048h	 
$SizeConstsHeader  . . . . . . . . . .	Number	 0014h	 
$Slash . . . . . . . . . . . . . . . .	Number	 0012h	 
$Sle . . . . . . . . . . . . . . . . .	Number	 0034h	 
$Slt . . . . . . . . . . . . . . . . .	Number	 0033h	 
$Sne . . . . . . . . . . . . . . . . .	Number	 0032h	 
$SourceBufferSize  . . . . . . . . . .	Number	 11C8h	 
$Special . . . . . . . . . . . . . . .	Number	 00C0h	 
$Stem  . . . . . . . . . . . . . . . .	Number	 0060h	 
$Stream  . . . . . . . . . . . . . . .	Number	 0020h	 
$StrideA . . . . . . . . . . . . . . .	Number	 0006h	 
$StrideD . . . . . . . . . . . . . . .	Number	 0028h	 
$StrideF . . . . . . . . . . . . . . .	Number	 001Ah	 
$StrideH . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideJ . . . . . . . . . . . . . . .	Number	 000Eh	 
$StrideL . . . . . . . . . . . . . . .	Number	 007Ch	 
$StrideS . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideV . . . . . . . . . . . . . . .	Number	 0008h	 
$Symbol  . . . . . . . . . . . . . . .	Number	 0028h	 
$SysCount  . . . . . . . . . . . . . .	Number	 000Bh	 
$THEN  . . . . . . . . . . . . . . . .	Number	 0060h	 
$TO  . . . . . . . . . . . . . . . . .	Number	 0068h	 
$TRACE . . . . . . . . . . . . . . . .	Number	 00B0h	 
$Test  . . . . . . . . . . . . . . . .	Number	 00C0h	 
$TraceAssign . . . . . . . . . . . . .	Number	 0000h	 
$TraceBY . . . . . . . . . . . . . . .	Number	 0002h	 
$TraceBack . . . . . . . . . . . . . .	Number	 001Ah	 
$TraceClause . . . . . . . . . . . . .	Number	 0004h	 
$TraceCompound . . . . . . . . . . . .	Number	 0006h	 
$TraceDot  . . . . . . . . . . . . . .	Number	 0008h	 
$TraceEndClause  . . . . . . . . . . .	Number	 001Eh	 
$TraceError  . . . . . . . . . . . . .	Number	 000Ah	 
$TraceExpr . . . . . . . . . . . . . .	Number	 000Ch	 
$TraceFailure  . . . . . . . . . . . .	Number	 000Eh	 
$TraceFunction . . . . . . . . . . . .	Number	 0010h	 
$TraceLit  . . . . . . . . . . . . . .	Number	 0016h	 
$TraceOperator . . . . . . . . . . . .	Number	 0012h	 
$TraceParse  . . . . . . . . . . . . .	Number	 001Ch	 
$TracePrefix . . . . . . . . . . . . .	Number	 0014h	 
$TraceVar  . . . . . . . . . . . . . .	Number	 0018h	 
$UNTIL . . . . . . . . . . . . . . . .	Number	 0070h	 
$UPPER . . . . . . . . . . . . . . . .	Number	 00D0h	 
$UnAccept  . . . . . . . . . . . . . .	Number	 0008h	 
$VALUE . . . . . . . . . . . . . . . .	Number	 0058h	 
$VAR_SYMBOL  . . . . . . . . . . . . .	Number	 0048h	 
$VAR . . . . . . . . . . . . . . . . .	Number	 0084h	 
$VERSION . . . . . . . . . . . . . . .	Number	 007Eh	 
$Variable  . . . . . . . . . . . . . .	Number	 0089h	 
$WHEN  . . . . . . . . . . . . . . . .	Number	 0104h	 
$WHILE . . . . . . . . . . . . . . . .	Number	 0074h	 
$WITH  . . . . . . . . . . . . . . . .	Number	 0078h	 
$White . . . . . . . . . . . . . . . .	Number	 0000h	 
$WholeGE . . . . . . . . . . . . . . .	Number	 0004h	 
$WholeGT . . . . . . . . . . . . . . .	Number	 0008h	 
$WholeNum  . . . . . . . . . . . . . .	Number	 0014h	 
$Whole . . . . . . . . . . . . . . . .	Number	 0000h	 
$Xor . . . . . . . . . . . . . . . . .	Number	 0014h	 
$Xx  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$mParseEnd . . . . . . . . . . . . . .	Number	 001Ah	 
$mParseEscape  . . . . . . . . . . . .	Number	 0012h	 
$mPattern  . . . . . . . . . . . . . .	Number	 002Ah	 
$mPosEq  . . . . . . . . . . . . . . .	Number	 0032h	 
$mPosMinus . . . . . . . . . . . . . .	Number	 0042h	 
$mPosPlus  . . . . . . . . . . . . . .	Number	 003Ah	 
$mPosRest  . . . . . . . . . . . . . .	Number	 0022h	 
$mRepTail  . . . . . . . . . . . . . .	Number	 0002h	 
$mTemplateComma  . . . . . . . . . . .	Number	 004Ah	 
$mUpper  . . . . . . . . . . . . . . .	Number	 000Ah	 
$n17p1 . . . . . . . . . . . . . . . .	Number	 0002h	 
$n40p3 . . . . . . . . . . . . . . . .	Number	 0004h	 
$n40p4 . . . . . . . . . . . . . . . .	Number	 0006h	 
$n40p5 . . . . . . . . . . . . . . . .	Number	 0008h	 
$n7p3  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nArg  . . . . . . . . . . . . . . . .	Number	 0004h	 
$nDigits . . . . . . . . . . . . . . .	Number	 0000h	 
$nForm . . . . . . . . . . . . . . . .	Number	 0004h	 
$nFuzz . . . . . . . . . . . . . . . .	Number	 0002h	 
$nLineIn . . . . . . . . . . . . . . .	Number	 0006h	 
$nNormal . . . . . . . . . . . . . . .	Number	 0040h	 
$nPull . . . . . . . . . . . . . . . .	Number	 0008h	 
$nSource . . . . . . . . . . . . . . .	Number	 000Ah	 
$nStem . . . . . . . . . . . . . . . .	Number	 0000h	 
$nStream . . . . . . . . . . . . . . .	Number	 0020h	 
$nVar  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nVersion  . . . . . . . . . . . . . .	Number	 000Ch	 
$nWith . . . . . . . . . . . . . . . .	Number	 0002h	 
$pAbut . . . . . . . . . . . . . . . .	Number	 0001h	 
$pAddress  . . . . . . . . . . . . . .	Number	 00A5h	 
$pAdd  . . . . . . . . . . . . . . . .	Number	 003Fh	 
$pAnd  . . . . . . . . . . . . . . . .	Number	 0035h	 
$pAssignConst  . . . . . . . . . . . .	Number	 0099h	 
$pAssignDotsP  . . . . . . . . . . . .	Number	 0007h	 
$pAssignDots . . . . . . . . . . . . .	Number	 0097h	 
$pAssignStem . . . . . . . . . . . . .	Number	 0095h	 
$pAssign . . . . . . . . . . . . . . .	Number	 0093h	 
$pBifGroup . . . . . . . . . . . . . .	Number	 00ADh	 
$pBifq . . . . . . . . . . . . . . . .	Number	 002Bh	 
$pBif  . . . . . . . . . . . . . . . .	Number	 00ABh	 
$pBool . . . . . . . . . . . . . . . .	Number	 00A1h	 
$pBy . . . . . . . . . . . . . . . . .	Number	 0011h	 
$pCallOn . . . . . . . . . . . . . . .	Number	 008Fh	 
$pCall . . . . . . . . . . . . . . . .	Number	 0055h	 
$pCat  . . . . . . . . . . . . . . . .	Number	 0003h	 
$pCeq  . . . . . . . . . . . . . . . .	Number	 007Dh	 
$pCge  . . . . . . . . . . . . . . . .	Number	 0085h	 
$pCgt  . . . . . . . . . . . . . . . .	Number	 0087h	 
$pCle  . . . . . . . . . . . . . . . .	Number	 0083h	 
$pClt  . . . . . . . . . . . . . . . .	Number	 0081h	 
$pCne  . . . . . . . . . . . . . . . .	Number	 007Fh	 
$pCommandEnv . . . . . . . . . . . . .	Number	 00A7h	 
$pCommand  . . . . . . . . . . . . . .	Number	 004Dh	 
$pControlVar . . . . . . . . . . . . .	Number	 005Bh	 
$pDivide . . . . . . . . . . . . . . .	Number	 0045h	 
$pDotControlVar  . . . . . . . . . . .	Number	 005Dh	 
$pDots . . . . . . . . . . . . . . . .	Number	 0091h	 
$pDropList . . . . . . . . . . . . . .	Number	 00B7h	 
$pDrop . . . . . . . . . . . . . . . .	Number	 009Dh	 
$pEnvName  . . . . . . . . . . . . . .	Number	 00A9h	 
$pEq . . . . . . . . . . . . . . . . .	Number	 0065h	 
$pExit . . . . . . . . . . . . . . . .	Number	 0027h	 
$pExposeList . . . . . . . . . . . . .	Number	 00B9h	 
$pExpose . . . . . . . . . . . . . . .	Number	 009Fh	 
$pFor  . . . . . . . . . . . . . . . .	Number	 0013h	 
$pGe . . . . . . . . . . . . . . . . .	Number	 006Dh	 
$pGt . . . . . . . . . . . . . . . . .	Number	 006Fh	 
$pIntDivide  . . . . . . . . . . . . .	Number	 0047h	 
$pInterpEnd  . . . . . . . . . . . . .	Number	 0089h	 
$pInterpret  . . . . . . . . . . . . .	Number	 004Fh	 
$pInvoke . . . . . . . . . . . . . . .	Number	 0053h	 
$pIterCV . . . . . . . . . . . . . . .	Number	 00A3h	 
$pIterRep  . . . . . . . . . . . . . .	Number	 0019h	 
$pIterate  . . . . . . . . . . . . . .	Number	 001Bh	 
$pJump . . . . . . . . . . . . . . . .	Number	 0063h	 
$pLeave  . . . . . . . . . . . . . . .	Number	 001Dh	 
$pLength . . . . . . . . . . . . . . .	Number	 002Dh	 
$pLe . . . . . . . . . . . . . . . . .	Number	 006Bh	 
$pLt . . . . . . . . . . . . . . . . .	Number	 0069h	 
$pMax  . . . . . . . . . . . . . . . .	Number	 002Fh	 
$pMin  . . . . . . . . . . . . . . . .	Number	 0031h	 
$pMultiply . . . . . . . . . . . . . .	Number	 0043h	 
$pNegate . . . . . . . . . . . . . . .	Number	 003Dh	 
$pNe . . . . . . . . . . . . . . . . .	Number	 0067h	 
$pNop  . . . . . . . . . . . . . . . .	Number	 0005h	 
$pNot  . . . . . . . . . . . . . . . .	Number	 0033h	 
$pNumber . . . . . . . . . . . . . . .	Number	 000Dh	 
$pNumeric  . . . . . . . . . . . . . .	Number	 0051h	 
$pOptions  . . . . . . . . . . . . . .	Number	 00C3h	 
$pOr . . . . . . . . . . . . . . . . .	Number	 0037h	 
$pParse  . . . . . . . . . . . . . . .	Number	 0009h	 
$pPositive . . . . . . . . . . . . . .	Number	 003Bh	 
$pPower  . . . . . . . . . . . . . . .	Number	 004Bh	 
$pPush . . . . . . . . . . . . . . . .	Number	 00BBh	 
$pQueue  . . . . . . . . . . . . . . .	Number	 00BDh	 
$pRaise  . . . . . . . . . . . . . . .	Number	 00AFh	 
$pRemainder  . . . . . . . . . . . . .	Number	 0049h	 
$pRepEver  . . . . . . . . . . . . . .	Number	 0059h	 
$pRep  . . . . . . . . . . . . . . . .	Number	 0057h	 
$pResult . . . . . . . . . . . . . . .	Number	 0021h	 
$pResumeParse  . . . . . . . . . . . .	Number	 000Bh	 
$pReturns  . . . . . . . . . . . . . .	Number	 0025h	 
$pReturn . . . . . . . . . . . . . . .	Number	 0023h	 
$pSay  . . . . . . . . . . . . . . . .	Number	 0029h	 
$pSeq  . . . . . . . . . . . . . . . .	Number	 0071h	 
$pSge  . . . . . . . . . . . . . . . .	Number	 0079h	 
$pSgt  . . . . . . . . . . . . . . . .	Number	 007Bh	 
$pSignalOff  . . . . . . . . . . . . .	Number	 00B1h	 
$pSignalOn . . . . . . . . . . . . . .	Number	 008Dh	 
$pSignalV  . . . . . . . . . . . . . .	Number	 00B3h	 
$pSignal . . . . . . . . . . . . . . .	Number	 008Bh	 
$pSle  . . . . . . . . . . . . . . . .	Number	 0077h	 
$pSlt  . . . . . . . . . . . . . . . .	Number	 0075h	 
$pSne  . . . . . . . . . . . . . . . .	Number	 0073h	 
$pSubtract . . . . . . . . . . . . . .	Number	 0041h	 
$pSysVar . . . . . . . . . . . . . . .	Number	 00B5h	 
$pThen . . . . . . . . . . . . . . . .	Number	 005Fh	 
$pTo . . . . . . . . . . . . . . . . .	Number	 000Fh	 
$pTraceEvent . . . . . . . . . . . . .	Number	 00C1h	 
$pTrace  . . . . . . . . . . . . . . .	Number	 00BFh	 
$pUnDo . . . . . . . . . . . . . . . .	Number	 001Fh	 
$pUnstore  . . . . . . . . . . . . . .	Number	 009Bh	 
$pUntil  . . . . . . . . . . . . . . .	Number	 0017h	 
$pWhen . . . . . . . . . . . . . . . .	Number	 0061h	 
$pWhile  . . . . . . . . . . . . . . .	Number	 0015h	 
$pXor  . . . . . . . . . . . . . . . .	Number	 0039h	 
$ret . . . . . . . . . . . . . . . . .	Number	 00C3h	 
$sAddress  . . . . . . . . . . . . . .	Number	 002Dh	 
$sDigits . . . . . . . . . . . . . . .	Number	 0027h	 
$sDropList . . . . . . . . . . . . . .	Number	 000Bh	 
$sDrop . . . . . . . . . . . . . . . .	Number	 0006h	 
$sEq . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$sExit . . . . . . . . . . . . . . . .	Number	 0032h	 
$sForm . . . . . . . . . . . . . . . .	Number	 002Bh	 
$sIterate  . . . . . . . . . . . . . .	Number	 003Fh	 
$sLeave  . . . . . . . . . . . . . . .	Number	 003Eh	 
$sLength . . . . . . . . . . . . . . .	Number	 0017h	 
$sMinus  . . . . . . . . . . . . . . .	Number	 0014h	 
$sNegate . . . . . . . . . . . . . . .	Number	 0030h	 
$sNop  . . . . . . . . . . . . . . . .	Number	 002Ah	 
$sNumber . . . . . . . . . . . . . . .	Number	 0037h	 
$sPercent  . . . . . . . . . . . . . .	Number	 0000h	 
$sPositive . . . . . . . . . . . . . .	Number	 0031h	 
$sRaise  . . . . . . . . . . . . . . .	Number	 0039h	 
$sReturns  . . . . . . . . . . . . . .	Number	 0035h	 
$sSeq  . . . . . . . . . . . . . . . .	Number	 0021h	 
$sStem . . . . . . . . . . . . . . . .	Number	 0009h	 
$sWith . . . . . . . . . . . . . . . .	Number	 000Ah	 
$tBinary . . . . . . . . . . . . . . .	Number	 00FDh	 
$tChar . . . . . . . . . . . . . . . .	Number	 00FFh	 
$tLabel  . . . . . . . . . . . . . . .	Number	 00FEh	 
??0000 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0001 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0002 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0003 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0004 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0005 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0006 . . . . . . . . . . . . . . . .	Number	 0400h	 
??0007 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0008 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0009 . . . . . . . . . . . . . . . .	Number	 0200h	 
??000A . . . . . . . . . . . . . . . .	Number	 0200h	 
??000B . . . . . . . . . . . . . . . .	Number	 8000h	 
?BIF . . . . . . . . . . . . . . . . .	Number	 0002h	 
?CLAUSELOCAL . . . . . . . . . . . . .	Number	 000Eh	 
?CLAUSETIME  . . . . . . . . . . . . .	Number	 000Ch	 
?LINEIN_POSITION . . . . . . . . . . .	Number	 000Ah	 
?MONTHS  . . . . . . . . . . . . . . .	Number	 0010h	 
?OUTCOME . . . . . . . . . . . . . . .	Number	 0000h	 
?RESPONSE  . . . . . . . . . . . . . .	Number	 0008h	 
?STARTTIME . . . . . . . . . . . . . .	Number	 0014h	 
?STREAMSTATE . . . . . . . . . . . . .	Number	 0006h	 
?STREAM  . . . . . . . . . . . . . . .	Number	 0004h	 
?WEEKDAYS  . . . . . . . . . . . . . .	Number	 0012h	 
@CodeSize  . . . . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . . . . .	Text   	 DGROUP
AA . . . . . . . . . . . . . . . . . .	Number	 -0026h	  
AFTERS . . . . . . . . . . . . . . . .	Number	 -0020h	  
AFTER  . . . . . . . . . . . . . . . .	Number	 -000Eh	  
AFTE . . . . . . . . . . . . . . . . .	Number	 -001Ch	  
ALIGN1 . . . . . . . . . . . . . . . .	Number	 -0022h	  
ALIGN2 . . . . . . . . . . . . . . . .	Number	 -0024h	  
ARITHOP$$  . . . . . . . . . . . . . .	Byte	 1808	  _TEXT	Public
ARITHOP  . . . . . . . . . . . . . . .	Text   	 $RoutineBase+0
A_X  . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
A_Y  . . . . . . . . . . . . . . . . .	Number	 -001Ch	  
AddRegs  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AllocateCx_EsAx  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Arg1 . . . . . . . . . . . . . . . . .	Number	 0002h	 
Arg2 . . . . . . . . . . . . . . . . .	Number	 0004h	 
Arg3 . . . . . . . . . . . . . . . . .	Number	 0006h	 
Arg4 . . . . . . . . . . . . . . . . .	Number	 0008h	 
Arg5 . . . . . . . . . . . . . . . . .	Number	 000Ah	 
ArrayBx  . . . . . . . . . . . . . . .	Text   	 bx
ArraySi  . . . . . . . . . . . . . . .	Text   	 si
Assert . . . . . . . . . . . . . . . .	Text   	 .erre
AssignExposed  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AssureSiPlus . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AttribAl . . . . . . . . . . . . . . .	Text   	 al
Attributes . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AwayEsAxCx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Away . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ax2DsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
A  . . . . . . . . . . . . . . . . . .	Text   	 (Ashape ptr[bp+si])
B1 . . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
B2Cloop  . . . . . . . . . . . . . . .	L Near	 1209	  _TEXT	
B2 . . . . . . . . . . . . . . . . . .	Number	 -000Ch	  
B4DROP . . . . . . . . . . . . . . . .	Byte	 0DF5	  _TEXT	Public
B4EXPOSE . . . . . . . . . . . . . . .	Byte	 0E00	  _TEXT	Public
B4VALUE1 . . . . . . . . . . . . . . .	Byte	 0DD7	  _TEXT	Public
B4VALUE2 . . . . . . . . . . . . . . .	Byte	 0DDB	  _TEXT	Public
B4V  . . . . . . . . . . . . . . . . .	Number	 -0002h	  
BASEDAYS . . . . . . . . . . . . . . .	Number	 -0008h	  
BCycle . . . . . . . . . . . . . . . .	L Near	 1FBA	  _TEXT	
BEFORE . . . . . . . . . . . . . . . .	Number	 -000Ch	  
BEFO . . . . . . . . . . . . . . . . .	Number	 -001Ah	  
BEGINRIGHT . . . . . . . . . . . . . .	Number	 -0004h	  
BIFABBREV  . . . . . . . . . . . . . .	Byte	 007D	  _TEXT	
BIFB2X . . . . . . . . . . . . . . . .	Byte	 07AF	  _TEXT	
BIFBITAND  . . . . . . . . . . . . . .	Byte	 07BF	  _TEXT	
BIFC2D . . . . . . . . . . . . . . . .	Byte	 0855	  _TEXT	
BIFC2X . . . . . . . . . . . . . . . .	Byte	 0922	  _TEXT	
BIFCENTER  . . . . . . . . . . . . . .	Byte	 00A9	  _TEXT	
BIFCHANGESTR . . . . . . . . . . . . .	Byte	 00C8	  _TEXT	
BIFCHARS . . . . . . . . . . . . . . .	Byte	 0A8C	  _TEXT	
BIFCOMPARE . . . . . . . . . . . . . .	Byte	 00F6	  _TEXT	
BIFCOUNTSTR  . . . . . . . . . . . . .	Byte	 0136	  _TEXT	
BIFD2C . . . . . . . . . . . . . . . .	Byte	 08BF	  _TEXT	
BIFD2X . . . . . . . . . . . . . . . .	Byte	 0937	  _TEXT	
BIFDATE  . . . . . . . . . . . . . . .	Byte	 0169	  _TEXT	
BIFDELSTR  . . . . . . . . . . . . . .	Byte	 03F5	  _TEXT	
BIFDELWORD . . . . . . . . . . . . . .	Byte	 0424	  _TEXT	
BIFERRORTEXT . . . . . . . . . . . . .	Byte	 045C	  _TEXT	
BIFFORMAT  . . . . . . . . . . . . . .	Byte	 04AF	  _TEXT	
BIFINSERT  . . . . . . . . . . . . . .	Byte	 0734	  _TEXT	
BIFLASTPOS . . . . . . . . . . . . . .	Byte	 0753	  _TEXT	
BIFLINEIN  . . . . . . . . . . . . . .	Byte	 0A0D	  _TEXT	
BIFLINEOUT . . . . . . . . . . . . . .	Byte	 0A7F	  _TEXT	
BIFLINES . . . . . . . . . . . . . . .	Byte	 0A9D	  _TEXT	
BIFMAX . . . . . . . . . . . . . . . .	Byte	 0068	  _TEXT	
BIFMIN . . . . . . . . . . . . . . . .	Byte	 0054	  _TEXT	
BIFOVERLAY . . . . . . . . . . . . . .	Byte	 078E	  _TEXT	
BIFQUALIFY . . . . . . . . . . . . . .	Byte	 0AAB	  _TEXT	
BIFRIGHT . . . . . . . . . . . . . . .	Byte	 0ABD	  _TEXT	
BIFSPACE . . . . . . . . . . . . . . .	Byte	 0AD3	  _TEXT	
BIFSTRIP . . . . . . . . . . . . . . .	Byte	 0B12	  _TEXT	
BIFTIME  . . . . . . . . . . . . . . .	Byte	 0B94	  _TEXT	
BIFTRANSLATE . . . . . . . . . . . . .	Byte	 0FE2	  _TEXT	
BIFTRUNC . . . . . . . . . . . . . . .	Byte	 1045	  _TEXT	
BIFVERIFY  . . . . . . . . . . . . . .	Byte	 1081	  _TEXT	
BIFWORDLENGTH  . . . . . . . . . . . .	Byte	 10D8	  _TEXT	
BIFWORDPOS . . . . . . . . . . . . . .	Byte	 10E2	  _TEXT	
BIFWORDS . . . . . . . . . . . . . . .	Byte	 1113	  _TEXT	
BIFX2B . . . . . . . . . . . . . . . .	Byte	 097E	  _TEXT	
BIFX2C . . . . . . . . . . . . . . . .	Byte	 098A	  _TEXT	
BIFX2D . . . . . . . . . . . . . . . .	Byte	 09AA	  _TEXT	
B_J  . . . . . . . . . . . . . . . . .	Number	 -0008h	  
B_R  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
B_STRING . . . . . . . . . . . . . . .	Number	 -0002h	  
B_T  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
Bassign  . . . . . . . . . . . . . . .	L Near	 206B	  _TEXT	Public
Bbp  . . . . . . . . . . . . . . . . .	L Near	 1FCE	  _TEXT	
BcodeEntry . . . . . . . . . . . . . .	L Near	 1F86	  _TEXT	
BcodeRoutine . . . . . . . . . . . . .	L Near	 1F80	  _TEXT	
BcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  FanSegB	
Bfetch . . . . . . . . . . . . . . . .	L Near	 1FFE	  _TEXT	
BifABBREV  . . . . . . . . . . . . . .	L Near	 007D	  _TEXT	
BifB2X . . . . . . . . . . . . . . . .	L Near	 07AF	  _TEXT	Public
BifBITAND  . . . . . . . . . . . . . .	L Near	 07BF	  _TEXT	Public
BifBITOR . . . . . . . . . . . . . . .	L Near	 07BF	  _TEXT	Public
BifBITXOR  . . . . . . . . . . . . . .	L Near	 07BF	  _TEXT	Public
BifBound . . . . . . . . . . . . . . .	L Near	 112C	  _TEXT	Public
BifC2D . . . . . . . . . . . . . . . .	L Near	 0855	  _TEXT	Public
BifC2X . . . . . . . . . . . . . . . .	L Near	 0922	  _TEXT	Public
BifCENTER  . . . . . . . . . . . . . .	L Near	 00A9	  _TEXT	
BifCENTRE  . . . . . . . . . . . . . .	L Near	 00A9	  _TEXT	
BifCHANGESTR . . . . . . . . . . . . .	L Near	 00C8	  _TEXT	Public
BifCHARIN  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifCHAROUT . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifCHARS . . . . . . . . . . . . . . .	L Near	 0A8C	  _TEXT	
BifCOMPARE . . . . . . . . . . . . . .	L Near	 00F6	  _TEXT	
BifCOUNTSTR  . . . . . . . . . . . . .	L Near	 0136	  _TEXT	Public
BifD2C . . . . . . . . . . . . . . . .	L Near	 08BF	  _TEXT	Public
BifD2X . . . . . . . . . . . . . . . .	L Near	 0937	  _TEXT	Public
BifDATE  . . . . . . . . . . . . . . .	L Near	 0169	  _TEXT	
BifDELSTR  . . . . . . . . . . . . . .	L Near	 03F5	  _TEXT	
BifDELWORD . . . . . . . . . . . . . .	L Near	 0424	  _TEXT	
BifERRORTEXT . . . . . . . . . . . . .	L Near	 045C	  _TEXT	
BifFORMAT  . . . . . . . . . . . . . .	L Near	 04AF	  _TEXT	
BifINSERT  . . . . . . . . . . . . . .	L Near	 0734	  _TEXT	
BifLASTPOS . . . . . . . . . . . . . .	L Near	 0753	  _TEXT	
BifLINEIN  . . . . . . . . . . . . . .	L Near	 0A0D	  _TEXT	
BifLINEOUT . . . . . . . . . . . . . .	L Near	 0A7F	  _TEXT	
BifLINES . . . . . . . . . . . . . . .	L Near	 0A9D	  _TEXT	
BifMAX . . . . . . . . . . . . . . . .	L Near	 0068	  _TEXT	Public
BifMIN . . . . . . . . . . . . . . . .	L Near	 0054	  _TEXT	Public
BifOVERLAY . . . . . . . . . . . . . .	L Near	 078E	  _TEXT	
BifQUALIFY . . . . . . . . . . . . . .	L Near	 0AAB	  _TEXT	
BifRIGHT . . . . . . . . . . . . . . .	L Near	 0ABD	  _TEXT	
BifSPACE . . . . . . . . . . . . . . .	L Near	 0AD3	  _TEXT	
BifSTREAM  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifSTRIP . . . . . . . . . . . . . . .	L Near	 0B12	  _TEXT	
BifTIME  . . . . . . . . . . . . . . .	L Near	 0B94	  _TEXT	
BifTRANSLATE . . . . . . . . . . . . .	L Near	 0FE2	  _TEXT	
BifTRUNC . . . . . . . . . . . . . . .	L Near	 1045	  _TEXT	
BifVERIFY  . . . . . . . . . . . . . .	L Near	 1081	  _TEXT	
BifWORDLENGTH  . . . . . . . . . . . .	L Near	 10D8	  _TEXT	
BifWORDPOS . . . . . . . . . . . . . .	L Near	 10E2	  _TEXT	
BifWORDS . . . . . . . . . . . . . . .	L Near	 1113	  _TEXT	
BifX2B . . . . . . . . . . . . . . . .	L Near	 097E	  _TEXT	Public
BifX2C . . . . . . . . . . . . . . . .	L Near	 098A	  _TEXT	Public
BifX2D . . . . . . . . . . . . . . . .	L Near	 09AA	  _TEXT	Public
BooleryRejumps . . . . . . . . . . . .	Number	 0000h	 External
Boolery  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bptr . . . . . . . . . . . . . . . . .	Text   	 byte ptr
Bswitch  . . . . . . . . . . . . . . .	L Near	 0000	  BifSeg	Public
C2Bloop  . . . . . . . . . . . . . . .	L Near	 11C1	  _TEXT	
C2Bret . . . . . . . . . . . . . . . .	L Near	 11D9	  _TEXT	
CAaddloop  . . . . . . . . . . . . . .	L Near	 2357	  _TEXT	
CAsubloop  . . . . . . . . . . . . . .	L Near	 237D	  _TEXT	
CD . . . . . . . . . . . . . . . . . .	Number	 0000h	 
COMMANDWRAP  . . . . . . . . . . . . .	Byte	 0F73	  _TEXT	Public
COND1  . . . . . . . . . . . . . . . .	Number	 -0004h	  
COND2  . . . . . . . . . . . . . . . .	Number	 -0006h	  
COND3  . . . . . . . . . . . . . . . .	Number	 -0008h	  
CONFIG_ARITH$$ . . . . . . . . . . . .	L Near	 230B	  _TEXT	
CONFIG_ARITH . . . . . . . . . . . . .	Number	 00FFh	 
CONFIG_B2C$$ . . . . . . . . . . . . .	L Near	 11F2	  _TEXT	
CONFIG_B2C . . . . . . . . . . . . . .	Number	 00E9h	 
CONFIG_C2B$$ . . . . . . . . . . . . .	L Near	 11A8	  _TEXT	
CONFIG_C2B . . . . . . . . . . . . . .	Number	 00E7h	 
CONFIG_MSG$$ . . . . . . . . . . . . .	L Near	 1166	  _TEXT	
CONFIG_MSG . . . . . . . . . . . . . .	Number	 00E5h	 
CONFIG_RAISE$$ . . . . . . . . . . . .	L Near	 2397	  _TEXT	
CONFIG_RAISE40$$ . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_RAISE40 . . . . . . . . . . . .	Number	 00E1h	 
CONFIG_RAISE . . . . . . . . . . . . .	Number	 00DFh	 
CONFIG_STREAM_CHARIN$$ . . . . . . . .	L Near	 137A	  _TEXT	
CONFIG_STREAM_CHARIN . . . . . . . . .	Number	 00EDh	 
CONFIG_STREAM_CHAROUT$$  . . . . . . .	L Near	 146D	  _TEXT	
CONFIG_STREAM_CHAROUT  . . . . . . . .	Number	 00F3h	 
CONFIG_STREAM_CLOSE$$  . . . . . . . .	L Near	 1453	  _TEXT	
CONFIG_STREAM_CLOSE  . . . . . . . . .	Number	 00F1h	 
CONFIG_STREAM_COMMAND$$  . . . . . . .	L Near	 15DF	  _TEXT	
CONFIG_STREAM_COMMAND  . . . . . . . .	Number	 00F9h	 
CONFIG_STREAM_COUNT$$  . . . . . . . .	L Near	 149A	  _TEXT	
CONFIG_STREAM_COUNT  . . . . . . . . .	Number	 00F5h	 
CONFIG_STREAM_POSITION$$ . . . . . . .	L Near	 1222	  _TEXT	
CONFIG_STREAM_POSITION . . . . . . . .	Number	 00EBh	 
CONFIG_STREAM_QUALIFIED$$  . . . . . .	L Near	 1550	  _TEXT	
CONFIG_STREAM_QUALIFIED  . . . . . . .	Number	 00F7h	 
CONFIG_STREAM_QUERY$$  . . . . . . . .	L Near	 1451	  _TEXT	
CONFIG_STREAM_QUERY  . . . . . . . . .	Number	 00EFh	 
CONFIG_STREAM_STATE$$  . . . . . . . .	L Near	 15E1	  _TEXT	
CONFIG_STREAM_STATE  . . . . . . . . .	Number	 00FBh	 
CONFIG_TIME$$  . . . . . . . . . . . .	L Near	 15E3	  _TEXT	
CONFIG_TIME  . . . . . . . . . . . . .	Number	 00FDh	 
CONFIG_UPPER$$ . . . . . . . . . . . .	L Near	 112C	  _TEXT	Public
CONFIG_UPPER . . . . . . . . . . . . .	Number	 00E3h	 
COUNT  . . . . . . . . . . . . . . . .	Number	 -0004h	  
CO_LENGTH  . . . . . . . . . . . . . .	Number	 -0004h	  
CR42 . . . . . . . . . . . . . . . . .	L Near	 23BF	  _TEXT	
CSCret . . . . . . . . . . . . . . . .	L Near	 14ED	  _TEXT	
CSPinc . . . . . . . . . . . . . . . .	L Near	 1243	  _TEXT	
CSPoutc  . . . . . . . . . . . . . . .	L Near	 1256	  _TEXT	
CSPout . . . . . . . . . . . . . . . .	L Near	 1245	  _TEXT	
CSPret . . . . . . . . . . . . . . . .	L Near	 1256	  _TEXT	
CSQ0 . . . . . . . . . . . . . . . . .	L Near	 1537	  _TEXT	
CURSOR . . . . . . . . . . . . . . . .	Number	 -000Ah	  
CW_T . . . . . . . . . . . . . . . . .	Number	 -0002h	  
C_COUNT  . . . . . . . . . . . . . . .	Number	 -0002h	  
C_I  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
C_LENGTH . . . . . . . . . . . . . . .	Number	 -000Ch	  
C_MAX  . . . . . . . . . . . . . . . .	Number	 -0002h	  
C_OUTPUT . . . . . . . . . . . . . . .	Number	 -0002h	  
C_PAD  . . . . . . . . . . . . . . . .	Number	 -0002h	  
C_POSITION . . . . . . . . . . . . . .	Number	 -0004h	  
C_R  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
C_SIGN . . . . . . . . . . . . . . . .	Number	 -0008h	  
C_STRING . . . . . . . . . . . . . . .	Number	 -0002h	  
C_T  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
ClauseSourceEnd  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CloseBx  . . . . . . . . . . . . . . .	L Near	 1456	  _TEXT	Public
Command  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CompareTO  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiler . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiling  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Consist  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValueX  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValue . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Create4Dump  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CursorBx . . . . . . . . . . . . . . .	Text   	 bx
CursorSi . . . . . . . . . . . . . . .	Text   	 si
D1 . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD])
DATEFORMAT$$ . . . . . . . . . . . . .	Byte	 0335	  _TEXT	
DATEFORMAT . . . . . . . . . . . . . .	Text   	 $RoutineBase+26
DAYS . . . . . . . . . . . . . . . . .	Number	 -0006h	  
DAY  . . . . . . . . . . . . . . . . .	Number	 -0010h	  
DC_OUTPUT  . . . . . . . . . . . . . .	Number	 -0008h	  
DIGITS . . . . . . . . . . . . . . . .	Number	 -0034h	  
DIGIT  . . . . . . . . . . . . . . . .	Number	 -0024h	  
DOS_TIME$$ . . . . . . . . . . . . . .	Byte	 0D37	  _TEXT	
DOS_TIME . . . . . . . . . . . . . . .	Text   	 $RoutineBase+24
DT_BASEDAYS  . . . . . . . . . . . . .	Number	 -0008h	  
DT_DAYS  . . . . . . . . . . . . . . .	Number	 -0006h	  
DT_DAY . . . . . . . . . . . . . . . .	Number	 -0010h	  
DT_MONTH . . . . . . . . . . . . . . .	Number	 -000Eh	  
DT_YEAR  . . . . . . . . . . . . . . .	Number	 -0004h	  
DW_LEN . . . . . . . . . . . . . . . .	Number	 -0002h	  
DW_NUM . . . . . . . . . . . . . . . .	Number	 -0010h	  
DW_OUTPUT  . . . . . . . . . . . . . .	Number	 -0008h	  
DW_STRING  . . . . . . . . . . . . . .	Number	 -0012h	  
D_BASE . . . . . . . . . . . . . . . .	Number	 -0010h	  
D_DAYS . . . . . . . . . . . . . . . .	Number	 -0012h	  
D_DAY  . . . . . . . . . . . . . . . .	Number	 -0004h	  
D_HOUR . . . . . . . . . . . . . . . .	Number	 -0008h	  
D_LENGTH . . . . . . . . . . . . . . .	Number	 -0006h	  
D_MICROSECOND  . . . . . . . . . . . .	Number	 -000Eh	  
D_MINUTE . . . . . . . . . . . . . . .	Number	 -000Ah	  
D_MONTH  . . . . . . . . . . . . . . .	Number	 -0002h	  
D_OPTION . . . . . . . . . . . . . . .	Number	 -0002h	  
D_OUTPUT . . . . . . . . . . . . . . .	Number	 -0004h	  
D_R  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
D_SECOND . . . . . . . . . . . . . . .	Number	 -000Ch	  
D_STRING . . . . . . . . . . . . . . .	Number	 -0012h	  
D_SUBJECT  . . . . . . . . . . . . . .	Number	 -0002h	  
D_YEAR . . . . . . . . . . . . . . . .	Number	 -0006h	  
Debug  . . . . . . . . . . . . . . . .	Number	 0001h	 
DepthBl  . . . . . . . . . . . . . . .	Text   	 bl
DepthBx  . . . . . . . . . . . . . . .	Text   	 bx
DigitsChange . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DosMemCheck  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsExposed  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSiX  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSi . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dptr . . . . . . . . . . . . . . . . .	Text   	 dword ptr
DualSwitch . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dumper . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
D  . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD+$StrideV])
ENDLEFT  . . . . . . . . . . . . . . .	Number	 -0006h	  
END_ . . . . . . . . . . . . . . . . .	Number	 -0004h	  
EXPART . . . . . . . . . . . . . . . .	Number	 -0026h	  
EXPONENT1  . . . . . . . . . . . . . .	Number	 -0010h	  
EXPONENT2  . . . . . . . . . . . . . .	Number	 -0016h	  
EXPONENT3  . . . . . . . . . . . . . .	Number	 -0008h	  
EXPONENT . . . . . . . . . . . . . . .	Number	 -0008h	  
EXPP . . . . . . . . . . . . . . . . .	Number	 -0010h	  
EXPT . . . . . . . . . . . . . . . . .	Number	 -0012h	  
E_OPTION . . . . . . . . . . . . . . .	Number	 -000Ch	  
EndFile  . . . . . . . . . . . . . . .	L Near	 1438	  _TEXT	
EndNull  . . . . . . . . . . . . . . .	L Near	 143A	  _TEXT	
Error49Bp  . . . . . . . . . . . . . .	Text   	 call bp
ExposedFs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
FOUNDPOS . . . . . . . . . . . . . . .	Number	 -0006h	  
F_EXPONENT . . . . . . . . . . . . . .	Number	 -0008h	  
F_MANTISSA . . . . . . . . . . . . . .	Number	 -0002h	  
F_NUMBER . . . . . . . . . . . . . . .	Number	 -0016h	  
F_R  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
F_SIGN . . . . . . . . . . . . . . . .	Number	 -0018h	  
F_Z  . . . . . . . . . . . . . . . . .	Number	 -0014h	  
FileBx . . . . . . . . . . . . . . . .	Text   	 bx
FileErrorPop . . . . . . . . . . . . .	L Near	 1444	  _TEXT	
FileError  . . . . . . . . . . . . . .	L Near	 1446	  _TEXT	
FillBuffer . . . . . . . . . . . . . .	L Near	 1300	  _TEXT	
FindLine . . . . . . . . . . . . . . .	L Near	 138B	  _TEXT	
ForBcode . . . . . . . . . . . . . . .	Number	 0000h	 
ForBig . . . . . . . . . . . . . . . .	Number	 0000h	 
Frag1$$  . . . . . . . . . . . . . . .	Byte	 160B	  _TEXT	
Frag10$$ . . . . . . . . . . . . . . .	Byte	 1687	  _TEXT	
Frag10 . . . . . . . . . . . . . . . .	Number	 006Fh	 
Frag11$$ . . . . . . . . . . . . . . .	Byte	 1696	  _TEXT	
Frag11 . . . . . . . . . . . . . . . .	Number	 0071h	 
Frag12$$ . . . . . . . . . . . . . . .	Byte	 16A5	  _TEXT	
Frag12 . . . . . . . . . . . . . . . .	Number	 0073h	 
Frag13$$ . . . . . . . . . . . . . . .	Byte	 16B2	  _TEXT	
Frag13 . . . . . . . . . . . . . . . .	Number	 0075h	 
Frag14$$ . . . . . . . . . . . . . . .	Byte	 16BE	  _TEXT	
Frag14 . . . . . . . . . . . . . . . .	Number	 0077h	 
Frag15$$ . . . . . . . . . . . . . . .	Byte	 16CA	  _TEXT	
Frag15 . . . . . . . . . . . . . . . .	Number	 0079h	 
Frag16$$ . . . . . . . . . . . . . . .	Byte	 16DA	  _TEXT	
Frag16 . . . . . . . . . . . . . . . .	Number	 007Bh	 
Frag17$$ . . . . . . . . . . . . . . .	Byte	 16E7	  _TEXT	
Frag17 . . . . . . . . . . . . . . . .	Number	 007Dh	 
Frag18$$ . . . . . . . . . . . . . . .	Byte	 16F6	  _TEXT	
Frag18 . . . . . . . . . . . . . . . .	Number	 007Fh	 
Frag19$$ . . . . . . . . . . . . . . .	Byte	 170B	  _TEXT	
Frag19 . . . . . . . . . . . . . . . .	Number	 0081h	 
Frag1  . . . . . . . . . . . . . . . .	Number	 005Dh	 
Frag2$$  . . . . . . . . . . . . . . .	Byte	 1619	  _TEXT	
Frag20$$ . . . . . . . . . . . . . . .	Byte	 1718	  _TEXT	
Frag20 . . . . . . . . . . . . . . . .	Number	 0083h	 
Frag21$$ . . . . . . . . . . . . . . .	Byte	 1726	  _TEXT	
Frag21 . . . . . . . . . . . . . . . .	Number	 0085h	 
Frag22$$ . . . . . . . . . . . . . . .	Byte	 1749	  _TEXT	
Frag22 . . . . . . . . . . . . . . . .	Number	 0087h	 
Frag23$$ . . . . . . . . . . . . . . .	Byte	 175C	  _TEXT	
Frag23 . . . . . . . . . . . . . . . .	Number	 0089h	 
Frag24$$ . . . . . . . . . . . . . . .	Byte	 1770	  _TEXT	
Frag24 . . . . . . . . . . . . . . . .	Number	 008Bh	 
Frag25$$ . . . . . . . . . . . . . . .	Byte	 1786	  _TEXT	
Frag25 . . . . . . . . . . . . . . . .	Number	 008Dh	 
Frag26$$ . . . . . . . . . . . . . . .	Byte	 17AE	  _TEXT	
Frag26 . . . . . . . . . . . . . . . .	Number	 008Fh	 
Frag27$$ . . . . . . . . . . . . . . .	Byte	 17C9	  _TEXT	
Frag27 . . . . . . . . . . . . . . . .	Number	 0091h	 
Frag28$$ . . . . . . . . . . . . . . .	Byte	 17E2	  _TEXT	
Frag28 . . . . . . . . . . . . . . . .	Number	 0093h	 
Frag2  . . . . . . . . . . . . . . . .	Number	 005Fh	 
Frag3$$  . . . . . . . . . . . . . . .	Byte	 1625	  _TEXT	
Frag3  . . . . . . . . . . . . . . . .	Number	 0061h	 
Frag4$$  . . . . . . . . . . . . . . .	Byte	 1633	  _TEXT	
Frag4  . . . . . . . . . . . . . . . .	Number	 0063h	 
Frag5$$  . . . . . . . . . . . . . . .	Byte	 1641	  _TEXT	
Frag5  . . . . . . . . . . . . . . . .	Number	 0065h	 
Frag6$$  . . . . . . . . . . . . . . .	Byte	 164F	  _TEXT	
Frag6  . . . . . . . . . . . . . . . .	Number	 0067h	 
Frag7$$  . . . . . . . . . . . . . . .	Byte	 165D	  _TEXT	
Frag7  . . . . . . . . . . . . . . . .	Number	 0069h	 
Frag8$$  . . . . . . . . . . . . . . .	Byte	 166B	  _TEXT	
Frag8  . . . . . . . . . . . . . . . .	Number	 006Bh	 
Frag9$$  . . . . . . . . . . . . . . .	Byte	 1679	  _TEXT	
Frag9  . . . . . . . . . . . . . . . .	Number	 006Dh	 
FragsBase$ . . . . . . . . . . . . . .	Number	 0FA8h	 
F  . . . . . . . . . . . . . . . . . .	Text   	 (Fshape ptr[bx-$StrideF])
GiveDosMem . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
HAYSTACK . . . . . . . . . . . . . . .	Number	 -000Eh	  
HH . . . . . . . . . . . . . . . . . .	Number	 -0006h	  
HOURADJUST . . . . . . . . . . . . . .	Number	 -0008h	  
H_OPTION . . . . . . . . . . . . . . .	Number	 -0002h	  
Hang . . . . . . . . . . . . . . . . .	Text   	 jmp $
HaveBuffer . . . . . . . . . . . . . .	L Near	 132A	  _TEXT	
HaveHandle . . . . . . . . . . . . . .	L Near	 12F7	  _TEXT	
Hd . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr ds:[0])
HeritageDi . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
He . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr es:[bp])
Hf . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr fs:[bp])
Hg . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr gs:[bp])
HighDi . . . . . . . . . . . . . . . .	Text   	 di
H  . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr[si])
II . . . . . . . . . . . . . . . . . .	Number	 -0006h	  
INOPTION . . . . . . . . . . . . . . .	Number	 -000Ch	  
INTDIGITS  . . . . . . . . . . . . . .	Number	 -0028h	  
INVALUE  . . . . . . . . . . . . . . .	Number	 -000Ah	  
I_LENGTH . . . . . . . . . . . . . . .	Number	 -0002h	  
I_M  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
I_NUM  . . . . . . . . . . . . . . . .	Number	 -0006h	  
I_N  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
I_PAD  . . . . . . . . . . . . . . . .	Number	 -0004h	  
IncrIt . . . . . . . . . . . . . . . .	L Near	 224E	  _TEXT	
InitMemory . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InitSegDs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Int21DsBx  . . . . . . . . . . . . . .	L Near	 12A6	  _TEXT	
IsEven . . . . . . . . . . . . . . . .	L Near	 1FF8	  _TEXT	
JJ . . . . . . . . . . . . . . . . . .	Number	 -000Ch	  
Jbx  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[bx])
Jdi  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[di])
J  . . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[si])
KK . . . . . . . . . . . . . . . . . .	Number	 -000Eh	  
KeyListCx  . . . . . . . . . . . . . .	Text   	 cx
KeysBase . . . . . . . . . . . . . . .	Number	 0028h	 
KeywordOffsetCx  . . . . . . . . . . .	Text   	 cx
LAST . . . . . . . . . . . . . . . . .	Number	 -0004h	  
LEAP$$ . . . . . . . . . . . . . . . .	Byte	 1EB8	  _TEXT	
LEAP . . . . . . . . . . . . . . . . .	Text   	 $RoutineBase+20
LENGTH_  . . . . . . . . . . . . . . .	Number	 -0002h	  
LEN  . . . . . . . . . . . . . . . . .	Number	 -0002h	  
LINESPLIT  . . . . . . . . . . . . . .	Byte	 0F65	  _TEXT	Public
LOGIC  . . . . . . . . . . . . . . . .	Number	 -0014h	  
LS_N . . . . . . . . . . . . . . . . .	Number	 -0002h	  
LS_P . . . . . . . . . . . . . . . . .	Number	 -0004h	  
LS_T . . . . . . . . . . . . . . . . .	Number	 -0008h	  
L_COUNT  . . . . . . . . . . . . . . .	Number	 -0002h	  
Lbx  . . . . . . . . . . . . . . . . .	Text   	 ss:(Lshape ptr[bx-$StrideL+$StrideV])
LengthAtBx . . . . . . . . . . . . . .	Text   	 bx
LevelDi  . . . . . . . . . . . . . . .	Text   	 di
LevelSi  . . . . . . . . . . . . . . .	Text   	 si
LinesExact . . . . . . . . . . . . . .	L Near	 1511	  _TEXT	
LinkBcodeX . . . . . . . . . . . . . .	L Near	 21CE	  _TEXT	Public
LinkBcode  . . . . . . . . . . . . . .	L Near	 21CB	  _TEXT	Public
LookFileDsBx . . . . . . . . . . . . .	L Near	 125E	  _TEXT	Public
LookupSi . . . . . . . . . . . . . . .	Text   	 si
Lookup . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LowPartLenCl . . . . . . . . . . . . .	Text   	 cl
LowSi  . . . . . . . . . . . . . . . .	Text   	 si
Lsi  . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+si-$StrideL+$StrideV])
L  . . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+di-$StrideL+$StrideV])
MAJOR  . . . . . . . . . . . . . . . .	Number	 -0004h	  
MANTISSA1  . . . . . . . . . . . . . .	Number	 -0004h	  
MANTISSA2  . . . . . . . . . . . . . .	Number	 -0014h	  
MANTISSA3  . . . . . . . . . . . . . .	Number	 -001Ah	  
MANTISSA . . . . . . . . . . . . . . .	Number	 -0002h	  
MANTLEN  . . . . . . . . . . . . . . .	Number	 -0022h	  
MAX  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
MICRO  . . . . . . . . . . . . . . . .	Number	 -0012h	  
MINOR  . . . . . . . . . . . . . . . .	Number	 -0006h	  
MIN  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
MM . . . . . . . . . . . . . . . . . .	Number	 -0010h	  
MODE . . . . . . . . . . . . . . . . .	Number	 -0004h	  
MONTHIS  . . . . . . . . . . . . . . .	Number	 -0016h	  
MONTH  . . . . . . . . . . . . . . . .	Number	 -000Eh	  
MSGCODE  . . . . . . . . . . . . . . .	Number	 -0002h	  
MajMinDx . . . . . . . . . . . . . . .	Text   	 dx
MajorDh  . . . . . . . . . . . . . . .	Text   	 dh
MemCheck . . . . . . . . . . . . . . .	Number	 0001h	 
MidNight . . . . . . . . . . . . . . .	L Near	 15EA	  _TEXT	
MinorDl  . . . . . . . . . . . . . . .	Text   	 dl
MinorDx  . . . . . . . . . . . . . . .	Text   	 dx
MoreSpaceEs  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NEEDLELENGTH . . . . . . . . . . . . .	Number	 -0004h	  
NEEDLE . . . . . . . . . . . . . . . .	Number	 -0010h	  
NEW  . . . . . . . . . . . . . . . . .	Number	 -0014h	  
NEXT . . . . . . . . . . . . . . . . .	Number	 -0002h	  
NOWDIGITS  . . . . . . . . . . . . . .	Number	 -0020h	  
NUMBER1  . . . . . . . . . . . . . . .	Number	 -003Ah	  
NUMBER2  . . . . . . . . . . . . . . .	Number	 -0038h	  
NUMBER3  . . . . . . . . . . . . . . .	Number	 -0018h	  
NUMBER . . . . . . . . . . . . . . . .	Number	 -0016h	  
NUM  . . . . . . . . . . . . . . . . .	Number	 -0010h	  
N_OPTION . . . . . . . . . . . . . . .	Number	 -0002h	  
Name2File  . . . . . . . . . . . . . .	L Near	 217B	  _TEXT	Public
Name2Old . . . . . . . . . . . . . . .	L Near	 21BB	  _TEXT	
NotBcode . . . . . . . . . . . . . . .	L Near	 1FE7	  _TEXT	
NotCSQ1  . . . . . . . . . . . . . . .	L Near	 156B	  _TEXT	
NotCSQ2  . . . . . . . . . . . . . . .	L Near	 1597	  _TEXT	
NotCSQ3  . . . . . . . . . . . . . . .	L Near	 15BF	  _TEXT	
NotCharin  . . . . . . . . . . . . . .	L Near	 144F	  _TEXT	
NotChars . . . . . . . . . . . . . . .	L Near	 14F5	  _TEXT	
NotEol . . . . . . . . . . . . . . . .	L Near	 13A0	  _TEXT	
NotLinein  . . . . . . . . . . . . . .	L Near	 144A	  _TEXT	
NotLocalFetch  . . . . . . . . . . . .	L Near	 2062	  _TEXT	
NotLocalPut  . . . . . . . . . . . . .	L Near	 20C1	  _TEXT	
NotPcode . . . . . . . . . . . . . . .	L Near	 1FF0	  _TEXT	
NotPresent . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NotRead  . . . . . . . . . . . . . . .	L Near	 133A	  _TEXT	
NotSyntax  . . . . . . . . . . . . . .	L Near	 23C7	  _TEXT	
NotWrite . . . . . . . . . . . . . . .	L Near	 135C	  _TEXT	
Null$$ . . . . . . . . . . . . . . . .	L Near	 2252	  _TEXT	
Null . . . . . . . . . . . . . . . . .	Number	 00B7h	 
NumDxBx  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OPERATION  . . . . . . . . . . . . . .	Number	 -0002h	  
OPERATOR . . . . . . . . . . . . . . .	Number	 -0036h	  
OPTION_  . . . . . . . . . . . . . . .	Number	 -0002h	  
OUTPUT . . . . . . . . . . . . . . . .	Number	 -0002h	  
O_HAYSTACK . . . . . . . . . . . . . .	Number	 -0006h	  
O_LENGTH . . . . . . . . . . . . . . .	Number	 -0002h	  
O_MODE . . . . . . . . . . . . . . . .	Number	 -0004h	  
O_NEW  . . . . . . . . . . . . . . . .	Number	 -0014h	  
O_NUM  . . . . . . . . . . . . . . . .	Number	 -0006h	  
O_PAD  . . . . . . . . . . . . . . . .	Number	 -0004h	  
O_TARGET . . . . . . . . . . . . . . .	Number	 -0012h	  
Om . . . . . . . . . . . . . . . . . .	L Near	 205A	  _TEXT	
One$$  . . . . . . . . . . . . . . . .	L Near	 224B	  _TEXT	Public
One  . . . . . . . . . . . . . . . . .	Number	 00B5h	 
OpAppendCl . . . . . . . . . . . . . .	Text   	 cl
OpAppendCx . . . . . . . . . . . . . .	Text   	 cx
OpFlags  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OpenQ  . . . . . . . . . . . . . . . .	L Near	 12B6	  _TEXT	
OpenR  . . . . . . . . . . . . . . . .	L Near	 12B8	  _TEXT	
OpenW  . . . . . . . . . . . . . . . .	L Near	 12B7	  _TEXT	
OperandBl  . . . . . . . . . . . . . .	Text   	 bl
OperandBx  . . . . . . . . . . . . . .	Text   	 bx
Overlay  . . . . . . . . . . . . . . .	Text   	 0 dup(?)
PADDING  . . . . . . . . . . . . . . .	Number	 -0006h	  
PAD  . . . . . . . . . . . . . . . . .	Number	 -0002h	  
PATHQUALIFY  . . . . . . . . . . . . .	Byte	 0E5F	  _TEXT	Public
PHRASEWORDS  . . . . . . . . . . . . .	Number	 -0004h	  
PHRASE . . . . . . . . . . . . . . . .	Number	 -0012h	  
PIECE  . . . . . . . . . . . . . . . .	Number	 -000Ch	  
POINT  . . . . . . . . . . . . . . . .	Number	 -000Ah	  
POSITION . . . . . . . . . . . . . . .	Number	 -0004h	  
PQ_DIR . . . . . . . . . . . . . . . .	Number	 -0016h	  
PQ_DRIVE . . . . . . . . . . . . . . .	Number	 -000Ah	  
PQ_EXISTS  . . . . . . . . . . . . . .	Number	 -0010h	  
PQ_EXTEN . . . . . . . . . . . . . . .	Number	 -000Eh	  
PQ_HAVEENV . . . . . . . . . . . . . .	Number	 -000Ch	  
PQ_J . . . . . . . . . . . . . . . . .	Number	 -0004h	  
PQ_LETTER  . . . . . . . . . . . . . .	Number	 -0012h	  
PQ_NAME  . . . . . . . . . . . . . . .	Number	 -0006h	  
PQ_PATH  . . . . . . . . . . . . . . .	Number	 -0008h	  
PQ_PREFIX  . . . . . . . . . . . . . .	Number	 -0014h	  
PQ_REST  . . . . . . . . . . . . . . .	Number	 -001Ah	  
PQ_R . . . . . . . . . . . . . . . . .	Number	 -0018h	  
PQ_T . . . . . . . . . . . . . . . . .	Number	 -0002h	  
PREPARE$$  . . . . . . . . . . . . . .	Byte	 184F	  _TEXT	
PREPARE  . . . . . . . . . . . . . . .	Text   	 $RoutineBase+2
P_DIGITS . . . . . . . . . . . . . . .	Number	 -0014h	  
P_HAYSTACK . . . . . . . . . . . . . .	Number	 -0010h	  
P_I  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
P_NEEDLE . . . . . . . . . . . . . . .	Number	 -0012h	  
P_P  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
P_Q  . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
P_START  . . . . . . . . . . . . . . .	Number	 -0002h	  
P_T  . . . . . . . . . . . . . . . . .	Number	 -000Eh	  
ParaAllocAx  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ParmsCl  . . . . . . . . . . . . . . .	Text   	 cl
ParmsCx  . . . . . . . . . . . . . . .	Text   	 cx
ParseDot . . . . . . . . . . . . . . .	Number	 00FEh	 
ParseDx  . . . . . . . . . . . . . . .	Text   	 dx
ParseSi  . . . . . . . . . . . . . . .	Text   	 si
PartLenCx  . . . . . . . . . . . . . .	Text   	 cx
Pcode1 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Pcode2 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeArg . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeGapBx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeOp  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ProbeBx  . . . . . . . . . . . . . . .	Text   	 bx
ProgEs . . . . . . . . . . . . . . . .	Text   	 es
Q_DRIVE  . . . . . . . . . . . . . . .	Number	 -000Ah	  
Q_J  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
Q_NAME . . . . . . . . . . . . . . . .	Number	 -0006h	  
Q_PATH . . . . . . . . . . . . . . . .	Number	 -0008h	  
Q_T  . . . . . . . . . . . . . . . . .	Number	 -0002h	  
REFERENCE  . . . . . . . . . . . . . .	Number	 -001Eh	  
RERADIX$$  . . . . . . . . . . . . . .	Byte	 1ED7	  _TEXT	
RERADIX  . . . . . . . . . . . . . . .	Text   	 $RoutineBase+22
RESIDUE  . . . . . . . . . . . . . . .	Number	 -0008h	  
RHS  . . . . . . . . . . . . . . . . .	Number	 -002Ah	  
RR_FROMRADIX . . . . . . . . . . . . .	Number	 -0008h	  
RR_INTEGER . . . . . . . . . . . . . .	Number	 -0006h	  
RR_J . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
RR_R . . . . . . . . . . . . . . . . .	Number	 -000Ch	  
RR_SUBJECT . . . . . . . . . . . . . .	Number	 -0002h	  
RR_TORADIX . . . . . . . . . . . . . .	Number	 -0004h	  
R_LENGTH . . . . . . . . . . . . . . .	Number	 -000Ch	  
R_PAD  . . . . . . . . . . . . . . . .	Number	 -0002h	  
R_START  . . . . . . . . . . . . . . .	Number	 -0002h	  
R_STRING . . . . . . . . . . . . . . .	Number	 -000Eh	  
R_TRIM . . . . . . . . . . . . . . . .	Number	 -0004h	  
RadixTypeDl  . . . . . . . . . . . . .	Text   	 dl
Raise49  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1d  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RawCharAh  . . . . . . . . . . . . . .	Text   	 ah
RawCharAl  . . . . . . . . . . . . . .	Text   	 al
RawChar  . . . . . . . . . . . . . . .	Text   	 byte ptr ss:[si+bp]
Rejumps  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Respond  . . . . . . . . . . . . . . .	L Near	 141C	  _TEXT	
ResultSpace  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResumeP$ . . . . . . . . . . . . . . .	L Near	 2203	  _TEXT	Public
ResumePret . . . . . . . . . . . . . .	L Near	 221F	  _TEXT	
RetEsSi  . . . . . . . . . . . . . . .	L Near	 1161	  _TEXT	Public
RoutineBase$ . . . . . . . . . . . . .	Number	 0F8Ah	 
Routx  . . . . . . . . . . . . . . . .	L Near	 1FA1	  _TEXT	
RtypeAh  . . . . . . . . . . . . . . .	Text   	 ah
R  . . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	
S1 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+$StrideS])
S2 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+2*$StrideS])
SHOWEXP  . . . . . . . . . . . . . . .	Number	 -001Eh	  
SIGDIGITS  . . . . . . . . . . . . . .	Number	 -0006h	  
SIGN1  . . . . . . . . . . . . . . . .	Number	 -000Eh	  
SIGN2  . . . . . . . . . . . . . . . .	Number	 -0012h	  
SIGN3  . . . . . . . . . . . . . . . .	Number	 -001Eh	  
SIGNBIT  . . . . . . . . . . . . . . .	Number	 -0008h	  
SIGNEXP  . . . . . . . . . . . . . . .	Number	 -0028h	  
SIGN . . . . . . . . . . . . . . . . .	Number	 -0004h	  
SIZE_  . . . . . . . . . . . . . . . .	Number	 -0006h	  
SS_  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
START  . . . . . . . . . . . . . . . .	Number	 -0002h	  
STR1 . . . . . . . . . . . . . . . . .	Number	 -0012h	  
STR2 . . . . . . . . . . . . . . . . .	Number	 -0010h	  
STREAMQUALIFY  . . . . . . . . . . . .	Byte	 0E17	  _TEXT	
STRIDE . . . . . . . . . . . . . . . .	Number	 -0006h	  
STRING1  . . . . . . . . . . . . . . .	Number	 -0018h	  
STRING2  . . . . . . . . . . . . . . .	Number	 -0002h	  
STRINGWORDS  . . . . . . . . . . . . .	Number	 -0006h	  
STRING . . . . . . . . . . . . . . . .	Number	 -000Eh	  
ST_STRING  . . . . . . . . . . . . . .	Number	 -000Ch	  
SUBJECT  . . . . . . . . . . . . . . .	Number	 -0012h	  
SUBJ . . . . . . . . . . . . . . . . .	Number	 -0010h	  
SW_NUM . . . . . . . . . . . . . . . .	Number	 -0010h	  
SW_OUTPUT  . . . . . . . . . . . . . .	Number	 -0008h	  
SW_STRING  . . . . . . . . . . . . . .	Number	 -0012h	  
S_COUNT  . . . . . . . . . . . . . . .	Number	 -0002h	  
S_I  . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
S_LENGTH . . . . . . . . . . . . . . .	Number	 -0002h	  
S_NUM  . . . . . . . . . . . . . . . .	Number	 -0004h	  
S_OUTPUT . . . . . . . . . . . . . . .	Number	 -0008h	  
S_PAD  . . . . . . . . . . . . . . . .	Number	 -0002h	  
S_PART . . . . . . . . . . . . . . . .	Number	 -0006h	  
S_START  . . . . . . . . . . . . . . .	Number	 -0006h	  
S_STRING . . . . . . . . . . . . . . .	Number	 -0012h	  
Say$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ScanSi . . . . . . . . . . . . . . . .	Text   	 si
ScannerSi  . . . . . . . . . . . . . .	Text   	 si
Scode  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SegOffDi . . . . . . . . . . . . . . .	Text   	 di
Serialize  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetInherit . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetS9  . . . . . . . . . . . . . . . .	L Near	 222C	  _TEXT	
SetStack . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetSymLenJa  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Solid  . . . . . . . . . . . . . . . .	Number	 0001h	 
SortSpaceSS  . . . . . . . . . . . . .	Number	 0001h	 
StackDi  . . . . . . . . . . . . . . .	Text   	 di
StackDx  . . . . . . . . . . . . . . .	Text   	 dx
StackSafe  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StackSi  . . . . . . . . . . . . . . .	Text   	 si
StartExecutionY  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StartExecution . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StateBx  . . . . . . . . . . . . . . .	Text   	 bx
StateDi  . . . . . . . . . . . . . . .	Text   	 di
StateSi  . . . . . . . . . . . . . . .	Text   	 si
StemBx . . . . . . . . . . . . . . . .	Text   	 bx
StemEs . . . . . . . . . . . . . . . .	Text   	 es
String$$ . . . . . . . . . . . . . . .	L Near	 2272	  _TEXT	
String1$$  . . . . . . . . . . . . . .	L Near	 225A	  _TEXT	Public
String1  . . . . . . . . . . . . . . .	Number	 00BBh	 
String2$$  . . . . . . . . . . . . . .	L Near	 2266	  _TEXT	
String2  . . . . . . . . . . . . . . .	Number	 00BDh	 
String . . . . . . . . . . . . . . . .	Number	 00B9h	 
SwopReadWrite  . . . . . . . . . . . .	L Near	 135D	  _TEXT	
SymbolLook . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymbolsEs  . . . . . . . . . . . . . .	Text   	 es
SymbolsSafe  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymsZiDx . . . . . . . . . . . . . . .	Text   	 dx
SysTgt . . . . . . . . . . . . . . . .	L Near	 2122	  _TEXT	
S  . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si])
TABLEI . . . . . . . . . . . . . . . .	Number	 -0004h	  
TABLEO . . . . . . . . . . . . . . . .	Number	 -0002h	  
TARGET . . . . . . . . . . . . . . . .	Number	 -0012h	  
TF_OUTPUT  . . . . . . . . . . . . . .	Number	 -000Ah	  
TIME2DATE$$  . . . . . . . . . . . . .	Byte	 1DA6	  _TEXT	
TIME2DATE2$$ . . . . . . . . . . . . .	Byte	 1DCF	  _TEXT	
TIME2DATE2 . . . . . . . . . . . . . .	Text   	 $RoutineBase+18
TIME2DATE  . . . . . . . . . . . . . .	Text   	 $RoutineBase+16
TIMEFORMAT$$ . . . . . . . . . . . . .	Byte	 0C64	  _TEXT	
TIMEFORMAT . . . . . . . . . . . . . .	Text   	 $RoutineBase+28
TRIGGERED  . . . . . . . . . . . . . .	Number	 -0006h	  
TRIM . . . . . . . . . . . . . . . . .	Number	 -0004h	  
TT . . . . . . . . . . . . . . . . . .	Number	 -000Ch	  
TV . . . . . . . . . . . . . . . . . .	Number	 -0012h	  
T_C  . . . . . . . . . . . . . . . . .	Number	 -000Ch	  
T_HOUR . . . . . . . . . . . . . . . .	Number	 -0006h	  
T_INOPTION . . . . . . . . . . . . . .	Number	 -000Ch	  
T_INTEGER  . . . . . . . . . . . . . .	Number	 -0004h	  
T_J  . . . . . . . . . . . . . . . . .	Number	 -000Ah	  
T_MICROSECOND  . . . . . . . . . . . .	Number	 -0008h	  
T_MICRO  . . . . . . . . . . . . . . .	Number	 -0012h	  
T_MINUTE . . . . . . . . . . . . . . .	Number	 -0002h	  
T_NUMBER . . . . . . . . . . . . . . .	Number	 -000Ch	  
T_NUM  . . . . . . . . . . . . . . . .	Number	 -0002h	  
T_OPTION . . . . . . . . . . . . . . .	Number	 -0002h	  
T_OUTPUT . . . . . . . . . . . . . . .	Number	 -0008h	  
T_PAD  . . . . . . . . . . . . . . . .	Number	 -0006h	  
T_SECOND . . . . . . . . . . . . . . .	Number	 -0004h	  
T_STRING . . . . . . . . . . . . . . .	Number	 -0018h	  
T_T  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
TailSi . . . . . . . . . . . . . . . .	Text   	 si
TargetMsg  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Terminate  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TestEol  . . . . . . . . . . . . . . .	L Near	 13EB	  _TEXT	
Tgts . . . . . . . . . . . . . . . . .	Number	 0016h	 
Tgt  . . . . . . . . . . . . . . . . .	Number	 0056h	 
TheMsgBh . . . . . . . . . . . . . . .	Text   	 bh
Then$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToDsSiCx . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToFindDx . . . . . . . . . . . . . . .	Text   	 dx
ToFindLenAx  . . . . . . . . . . . . .	Text   	 ax
ToWholeEbx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TokNowCh . . . . . . . . . . . . . . .	Text   	 ch
TokNumAh . . . . . . . . . . . . . . .	Text   	 ah
Trial  . . . . . . . . . . . . . . . .	Number	 0000h	 
TryLonger  . . . . . . . . . . . . . .	L Near	 13A3	  _TEXT	
UNWANTED . . . . . . . . . . . . . . .	Number	 -0004h	  
UpStack  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperFirstAh . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperLoop  . . . . . . . . . . . . . .	L Near	 1144	  _TEXT	
UpperRet . . . . . . . . . . . . . . .	L Near	 1164	  _TEXT	
V00  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-2*$StrideV])
V0 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-$StrideV])
V2 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+$StrideV])
V3 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+2*$StrideV])
V4 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+3*$StrideV])
VALUE  . . . . . . . . . . . . . . . .	Number	 -000Ah	  
V_I  . . . . . . . . . . . . . . . . .	Number	 -0006h	  
V_OPTION . . . . . . . . . . . . . . .	Number	 -000Ch	  
V_START  . . . . . . . . . . . . . . .	Number	 -0002h	  
V_STRING . . . . . . . . . . . . . . .	Number	 -0020h	  
V_T  . . . . . . . . . . . . . . . . .	Number	 -0008h	  
VasDsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Vbxe . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bx])
Vbxf2  . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx+$StrideV])
Vbxf . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx])
Vbxs . . . . . . . . . . . . . . . . .	Text   	 ss:(Vshape ptr[bx])
Vbxt . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx-$CaseTarget])
Vbx  . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[bx])
Vdid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[di])
Ve . . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bp])
Vf . . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bp])
Vsid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[si])
Vsif . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[si])
Vsi  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+si])
V  . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di])
WORDNUMBER . . . . . . . . . . . . . .	Number	 -0008h	  
WP_STRING  . . . . . . . . . . . . . .	Number	 -0010h	  
W_NUM  . . . . . . . . . . . . . . . .	Number	 -000Ah	  
W_START  . . . . . . . . . . . . . . .	Number	 -0002h	  
W_STRING . . . . . . . . . . . . . . .	Number	 -000Ch	  
WasCrLf  . . . . . . . . . . . . . . .	L Near	 13F7	  _TEXT	
WasCr  . . . . . . . . . . . . . . . .	L Near	 1425	  _TEXT	
WasEol . . . . . . . . . . . . . . . .	L Near	 13F5	  _TEXT	
Wptr . . . . . . . . . . . . . . . . .	Text   	 word ptr
XB_SUBJECT . . . . . . . . . . . . . .	Number	 -0008h	  
XC_LENGTH  . . . . . . . . . . . . . .	Number	 -0004h	  
XC_R . . . . . . . . . . . . . . . . .	Number	 -0002h	  
XC_SUBJECT . . . . . . . . . . . . . .	Number	 -0008h	  
XCycle . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
XD_MAX . . . . . . . . . . . . . . . .	Number	 -0002h	  
XD_R . . . . . . . . . . . . . . . . .	Number	 -0006h	  
XD_SUBJECT . . . . . . . . . . . . . .	Number	 -0004h	  
XX . . . . . . . . . . . . . . . . . .	Number	 -000Eh	  
X_R  . . . . . . . . . . . . . . . . .	Number	 -0004h	  
X_SUBJECT  . . . . . . . . . . . . . .	Number	 -0002h	  
YEARNOW  . . . . . . . . . . . . . . .	Number	 -001Ah	  
YEAR . . . . . . . . . . . . . . . . .	Number	 -0004h	  
YY . . . . . . . . . . . . . . . . . .	Number	 -0018h	  
Y_BASEDAYS . . . . . . . . . . . . . .	Number	 -000Ch	  
Y_DAYS . . . . . . . . . . . . . . . .	Number	 -0012h	  
Y_DAY  . . . . . . . . . . . . . . . .	Number	 -000Ah	  
Y_HOUR . . . . . . . . . . . . . . . .	Number	 -0008h	  
Y_MICROSECOND  . . . . . . . . . . . .	Number	 -0004h	  
Y_MINUTE . . . . . . . . . . . . . . .	Number	 -0006h	  
Y_MONTH  . . . . . . . . . . . . . . .	Number	 -0014h	  
Y_SECOND . . . . . . . . . . . . . . .	Number	 -0002h	  
Y_THISMONTH  . . . . . . . . . . . . .	Number	 -0016h	  
Y_TIME . . . . . . . . . . . . . . . .	Number	 -001Ah	  
Y_YEARDAYS . . . . . . . . . . . . . .	Number	 -0010h	  
Y_YEAR . . . . . . . . . . . . . . . .	Number	 -000Eh	  
Ycx2 . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[2*ecx+ebp])
Ysi  . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[si])
Y  . . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[bp])
ZZ . . . . . . . . . . . . . . . . . .	Number	 -0002h	  
Zero$$ . . . . . . . . . . . . . . . .	L Near	 2240	  _TEXT	Public
ZeroBp . . . . . . . . . . . . . . . .	Text   	 bp
ZeroIt . . . . . . . . . . . . . . . .	L Near	 2243	  _TEXT	
Zero . . . . . . . . . . . . . . . . .	Number	 00B3h	 
ZoneNumerics . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZoneToLevel  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Z  . . . . . . . . . . . . . . . . . .	Text   	 (Zshape ptr[bp])
_ADDSUBCOMP$$  . . . . . . . . . . . .	Byte	 1A72	  _TEXT	
_ADDSUBCOMP  . . . . . . . . . . . . .	Text   	 $RoutineBase+10
_DIVTYPE$$ . . . . . . . . . . . . . .	Byte	 1BF5	  _TEXT	
_DIVTYPE . . . . . . . . . . . . . . .	Text   	 $RoutineBase+6
_Eq$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Eq  . . . . . . . . . . . . . . . . .	Number	 00CDh	 
_Exists$$  . . . . . . . . . . . . . .	L Near	 22C2	  _TEXT	
_Exists  . . . . . . . . . . . . . . .	Number	 00C7h	 
_FLOATING$$  . . . . . . . . . . . . .	Byte	 1A57	  _TEXT	
_FLOATING  . . . . . . . . . . . . . .	Text   	 $RoutineBase+14
_Ge$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Ge  . . . . . . . . . . . . . . . . .	Number	 00D5h	 
_Gt$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Gt  . . . . . . . . . . . . . . . . .	Number	 00D7h	 
_IterCV$$  . . . . . . . . . . . . . .	L Near	 22CD	  _TEXT	
_IterCV  . . . . . . . . . . . . . . .	Number	 00C5h	 
_Jump$$  . . . . . . . . . . . . . . .	L Near	 2304	  _TEXT	
_Jump  . . . . . . . . . . . . . . . .	Number	 00CBh	 
_Le$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Le  . . . . . . . . . . . . . . . . .	Number	 00D3h	 
_Lt$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Lt  . . . . . . . . . . . . . . . . .	Number	 00D1h	 
_MULTIPLY$$  . . . . . . . . . . . . .	Byte	 1B93	  _TEXT	
_MULTIPLY  . . . . . . . . . . . . . .	Text   	 $RoutineBase+4
_NEXT  . . . . . . . . . . . . . . . .	Number	 -0002h	  
_Ne$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Ne  . . . . . . . . . . . . . . . . .	Number	 00CFh	 
_POSTOP$$  . . . . . . . . . . . . . .	Byte	 1912	  _TEXT	
_POSTOP  . . . . . . . . . . . . . . .	Text   	 $RoutineBase+12
_POWER$$ . . . . . . . . . . . . . . .	Byte	 1D1E	  _TEXT	
_POWER . . . . . . . . . . . . . . . .	Text   	 $RoutineBase+8
_RetB$$  . . . . . . . . . . . . . . .	L Near	 22A8	  _TEXT	
_RetBc$$ . . . . . . . . . . . . . . .	L Near	 22A4	  _TEXT	
_RetBc . . . . . . . . . . . . . . . .	Number	 00BFh	 
_RetB  . . . . . . . . . . . . . . . .	Number	 00C1h	 
_RetF$$  . . . . . . . . . . . . . . .	L Near	 22BF	  _TEXT	
_RetF  . . . . . . . . . . . . . . . .	Number	 00C3h	 
_Seq$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Seq . . . . . . . . . . . . . . . . .	Number	 00D9h	 
_Slt$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Slt . . . . . . . . . . . . . . . . .	Number	 00DDh	 
_Sne$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
_Sne . . . . . . . . . . . . . . . . .	Number	 00DBh	 
_Then$$  . . . . . . . . . . . . . . .	L Near	 22F1	  _TEXT	
_Then  . . . . . . . . . . . . . . . .	Number	 00C9h	 
is . . . . . . . . . . . . . . . . . .	Text   	 textequ

	   0 Warnings
	   0 Errors
