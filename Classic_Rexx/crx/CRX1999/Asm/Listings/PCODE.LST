Microsoft (R) Macro Assembler Version 6.11		    01/27/12 18:24:09
pcode.asm						     Page 1 - 1


				     ; Copyright Formcroft Ltd 1997-1999
				      .model small
				      .486
 0000				      .code
				     ;------------------------------------------------------------------------------
				     ; Literal and numeric replacements
				     ;------------------------------------------------------------------------------
 = textequ			     is textequ <textequ>
 = byte ptr			     Bptr  is <byte ptr>
 = word ptr			     Wptr  is <word ptr>
 = dword ptr			     Dptr  is <dword ptr>
 = jmp $			     Hang  is <jmp $>
 = 0dh				     $Cr   is <0dh>
 = 0ah				     $Lf   is <0ah>
 = 1ah				     $Eof  is <1ah>
 = 0 dup(?)			     Overlay is <0 dup(?)>
 = .erre			     Assert is <.erre>
				     ;------------------------------------------------------------------------------
				     ; Typedefs. MASMs pointers are offsets in a segment.
				     ; Some of this is to indicate the purpose to the reader rather than MASM,
				     ; ie CHAR v BYTE since both are unsigned 8 bits.
				     ; However, pointerness is worth saying for words containing offsets since
				     ; debugger will take note.
				     ; WORD will tend not to get used since a word is either an integer (USHORT)
				     ; or an offset.
				     ; I haven't yet found the penalty in giving up SHORT as a keyword so as to
				     ; use it in the 'C' sense.
				     ;------------------------------------------------------------------------------
				       option nokeyword:<short>
				       option nokeyword:<C>
				     ; One byte target:
				     char   typedef byte
				     Bool   typedef byte
				     bytep  typedef ptr byte
				     charp  typedef ptr byte
				     charfp  typedef far ptr byte
				     Boolp  typedef ptr byte
				     ; Two byte
				     Ushort typedef word
				     Ushortp typedef ptr word
				     short typedef sword
				     shortp typedef ptr sword
				     Handle typedef word
				     Handlep typedef ptr word
				     Segp typedef word; Slightly different sense.
				     ; Four byte
				     Ulong typedef dword
 0004				     Farp struc; For les,lds
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
				     Farp ends

				     ;------------------------------------------------------------------------------
				     ; Macros
				     ;------------------------------------------------------------------------------

				     MkMajMin macro Maj:req, Min:req
				      
; Makes parts of msg number into one number.
				      exitm %(256*Maj+Min)
				     endm

				     StringOrder macro a:req, b:req, c, d
				      
; Load so that a store puts them in the written order.
				      ifnb <d>
				       exitm %(256*256*256*(d)+256*256*(c)+256*(b)+(a))
				      endif
				      exitm %(256*(b)+(a))
				     endm

				     ; Splat makes a visual 'noise' on the output.
				     Splat macro It:=<'*'>
				      mov dl,It
				      mov ah,02h
				      int 21h
				     endm

				     LoopQ macro tgt:req
				     
; Faster than single loop instruction
				       dec cx
				       jnz tgt
				     endm

				     JcxzQ macro tgt:req
				     
; jcxz is written only where retaining flags matters, else JcxzQ
				     
; JcxzQ can be rendered in way that can do long jump. (And maybe faster)
				       test cx,cx
				       je tgt
				     endm

				     Pos macro Needle:req, Hay:req
				      exitm % @InStr(1,Hay,Needle)
				     endm

				     ; As provided in MASM readme, plus fixing:
				      la macro Dest:req, Symbol:req
				     ; This can go wrong because replacement in operand occurs later.
				     ; Page 583 of Waite suggests we can test this but...
				      if (opattr(Symbol)) and 20h
				        if (opattr(Symbol)) and 08h
				          mov Dest, offset Symbol
				        else
				          lea Dest, Symbol
				        endif
				      else
				        ; Assume MOV if errors
				        mov Dest, offset Symbol
				      endif
				      endm

				     ; Having bp=0 makes a difference to zeroing.
				     ; XOR is no better than MOV of 0, and disturbs flags so this is just shorthand.
				     ; XOR faster than MOV of 0 on some machines?
				     ; Actually XOR is better for accum, but macro can't distinquish accum.
				     ; If Ax is positive CWD is better for DX, but macro doesn't do that.
				      z macro Dest:req
				     ; Drop this bit because XOR never better than register move.
				          if (type Dest) eq 1
				            mov Dest,0
				          else
				            if (type Dest) eq 2
				              mov Dest,bp
				            else
				              if (type Dest) eq 4
				                mov Dest,ebp
				              else
				                Whoops
				              endif
				            endif
				          endif
				      endm

				     ; Illuminate special use of test to set flags.
				     TestReg macro arg:req
				            test arg,arg
				     endm

				     ; Illuminate pop that discards.
				     PopJunk  macro arg:req
				       pop arg
				     endm

				     ; Setting bits in records.
				     ; I'm having trouble with MASM. If arg is complicated, it uses two byte
				     ; offsets where one would do. (Cured by overlay of word on record)
				     ; I cannot get MASM to put what I want on the listing. I would like the
				     ; values computed to show in the listed expansion but MASM will only show
				     ; the macro variable names there.  A % at the beginning of the line returned
				     ; by the macro does nothing. A % before the macro variable name in it is seen
				     ; as a syntax error. Short of conditional generation returning lines with
				     ; only the macro arguments in (these do get replaced on the listing), I don't
				     ; see a solution.

				     On      macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             or  arg,masksum
				       else
				         if masksum gt 255
				             or  Bptr(arg+1), high masksum
				         else
				             or  Bptr(arg), low masksum
				         endif
				       endif
				     endm
				     Off     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             and arg, not masksum
				       else
				         if masksum gt 255
				             and Bptr(arg+1), high not masksum
				         else
				             and Bptr(arg), low not masksum
				         endif
				       endif
				     endm
				     Qry     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             test arg, masksum
				       else
				         if masksum gt 255
				           if @SizeStr("&arg") gt 4
				             test Bptr(arg+1), high masksum
				           else
				             if "cx" ne "&arg"
				               test Bptr(arg+1), high masksum
				             else
				               test ch, high masksum
				             endif
				           endif
				         else
				             test Bptr(arg), low masksum
				         endif
				       endif
				     endm

				     mv   macro To:req,From:req
				     ; Used for segment moves
				      push From
				      pop To
				     endm

				     xax macro To:req
				     ; Used for ax moves when xchg saves a byte. (At expense of cycles)
				     ; Don't use xax form if exchange is "real" exchange.
				      if (type To) eq 2
				        xchg ax,To
				      else
				        xchg eax,To
				      endif
				     endm

				     inc2 macro Subj:req
				     ; Shorter than add Subj,2 when non-acc 16 bit reg.
				      inc Subj
				      inc Subj
				     endm

				     dec2 macro Subj:req
				     ; Shorter than dec Subj,2 when non-acc 16 bit reg.
				      dec Subj
				      dec Subj
				     endm

				     top macro To:req
				     ; Top element of hardware stack without disturbing it.
				      pop To
				      push To
				     endm

				     move macro To:req,From:req,Via
				     ; Memory to memory with arguments in same order as a mov.
				      ifb <Via>
				       if (type To) eq 2
				         mov ax,From
				         mov To,ax
				       elseif (type To) eq 1
				         mov al,From
				         mov To,al
				       else
				         mov eax,From
				         mov To,eax
				       endif
				      else
				       mov Via,From
				       mov To,Via
				      endif
				     endm

				     ;------------------------------------------------------------------------------
				     ; Shapes of structures for based addressing.
				     ;------------------------------------------------------------------------------
				     ; If we PUSHA and then copy SP to BP the caller's
				     ; registers have become locals accessible on [BP].
				     ; Structure PushShape holds the shape for this.
 0010				     PushShape struct
 0000  0000			      di_ word ?
 0002  0000			      si_ word ?
 0004  0000			      bp_ word ?
 0006  0000			      sp_ word ?
 0008	    0000 [		      bx_ word Overlay
	     0000
	    ]
 0008  00			      bl_ byte ?
 0009  00			      bh_ byte ?
 000A	    0000 [		      dx_ word Overlay
	     0000
	    ]
 000A  00			      dl_ byte ?
 000B  00			      dh_ byte ?
 000C	    0000 [		      cx_ word Overlay
	     0000
	    ]
 000C  00			      cl_ byte ?
 000D  00			      ch_ byte ?
 000E	    0000 [		      ax_ word Overlay
	     0000
	    ]
 000E  00			      al_ byte ?
 000F  00			      ah_ byte ?
				     PushShape ends
				     ; Build characteristics:
 = 0000				      CD equ 0; On when dump of compaction activity needed. See CD.REXX
 = 0001				      Debug equ 1; On for normal checks detecting internal flaws early.
 = 0001				      MemCheck equ 1; On for DOS memory checks.
 = 0000				      ForBcode equ 0; When making code that will be turned to BCode.
 = 0000				      ForBig equ 0; When making code that will be turned into one big assembly.
 = 0001				      SortSpaceSS equ 1; Design has compaction list under SS.
 = 0000				      Trial equ 0; Design change experiment.
 = 0001				      Solid equ 1; Always 1, used to mark sensitive areas for ForBig technology.
				     ;(Solid section with following label is assumed not to fall through.)
				     if ForBig
				      endif
				     if Debug
				     CheckType macro
				      test V.Dtype,$Test
				      jz @F
				      cmp V.Dtype,$AwayString
				      je @F
				      cmp V.Dtype,$NullString
				      je @F
				      cmp V.Dtype,$NullString+1
				      je @F
				      cmp V.Dtype,$NullString+2
				      je @F
				      cmp V.Dtype,$NullString+3
				      je @F
				      cmp V.Dtype,$NullString+4
				      je @F
				      cmp V.Dtype,$NullString+5
				      je @F
				      cmp V.Dtype,$NullString+6
				      je @F
				      cmp V.Dtype,$NullString+7
				      je @F
				     endm
				     endif
				      EXTERNDEF ToWholeEbx:near; Converts from Rexx variable to integer in EBX.
				      EXTERNDEF Zero$$:near; Puts zero on the stack.
				      EXTERNDEF Then$$:near; Execution of THEN
				      EXTERNDEF DigitsChange:near; Called at places where Digits() setting may change.
				      EXTERNDEF ZoneNumerics:near; Updates Zone for fast access to numeric settings.
				      EXTERNDEF SetInherit:near; Inherit, for an external routine.
				      EXTERNDEF Compiling:near; To start compiling something.
				      EXTERNDEF Compiler:near; To start compiling something.
				      EXTERNDEF StartExecution:near; To start executing made Pcode.
				      EXTERNDEF StartExecutionY:near; To start executing made Pcode.
				      EXTERNDEF ResumeP$:near; To start executing Pcode after Bcode.
				      EXTERNDEF Command:near; To start compiling source named on a command.
				      EXTERNDEF AssureSiPlus:near
				      EXTERNDEF AssignExposed:near
				      EXTERNDEF Name2File:near
				      EXTERNDEF ZoneToLevel:near
				      EXTERNDEF BifBound:near; A place separating code on basis of address
				      EXTERNDEF ConstValue:near
				      EXTERNDEF ConstValueX:near
				      EXTERNDEF Terminate:near
				      EXTERNDEF UpperFirstAh:near
				      EXTERNDEF NotPresent:near
				      EXTERNDEF Consist:near
				      EXTERNDEF Serialize:near
				      EXTERNDEF RetEsSi:near
				      EXTERNDEF ExposedFs:near, DotsExposed:near
				     ; Make the memory services available to all modules.
				      EXTERNDEF InitMemory:near, AllocateCx_EsAx:near, InitSegDs:near
				      EXTERNDEF MoreSpaceEs:near,GiveDosMem:near
				      EXTERNDEF ParaAllocAx:near, Raise5p1:near, Raise5p1d:near
				      EXTERNDEF StackSafe:near, SetStack:near, UpStack:near
				     ; Most modules need to load values from Rexx variables to registers.
				      EXTERNDEF ToDsSiCx:near, NumDxBx:near
				     ; Many modules create pseudo-code, test operator attributes..
				      EXTERNDEF Scode:near, Pcode1:near, Pcode2:near, PcodeArg:near
				      EXTERNDEF PcodeGapBx:near, PcodeOp:near, OpFlags:near
				     ; Lookup things may be needed in execution, eg for DROP (abc)
				      EXTERNDEF Lookup:near,SymbolsSafe:near,SetSymLenJa:near,SymbolLook:near
				      EXTERNDEF VasDsSiCx:near
				     ; And a few more in common use.
				      EXTERNDEF Ax2DsSiCx:near,HeritageDi:near, Raise:near
				      EXTERNDEF Attributes:near; Table for uppercasing, etc.
				      EXTERNDEF ResultSpace:near, AwayEsAxCx:near
				      EXTERNDEF LinkBcode:near, LinkBcodeX:near
				      EXTERNDEF CONFIG_UPPER$$:near
				      EXTERNDEF CONFIG_RAISE40$$:near
				      EXTERNDEF PcodesBase$:near
				      EXTERNDEF DotsFsBxDsSi:near
				      EXTERNDEF DotsFsBxDsSiX:near
				      EXTERNDEF XCycle:near,Rejumps:near,Boolery:near,BooleryRejumps:abs
				      EXTERNDEF LookFileDsBx:near
				      EXTERNDEF Away:near
				      EXTERNDEF ClauseSourceEnd:near
				      EXTERNDEF DualSwitch:near
				     if Debug
				      EXTERNDEF Say$$:near ; only for Consist debug
				      EXTERNDEF DosMemCheck:near
				      EXTERNDEF Create4Dump:near
				      EXTERNDEF Dumper:near
				     endif

 = 0001				     $PcodesBase equ 01h
 = 005D				     $BPcodesCeil equ 05Dh
 = 00C5				     $PcodesCeil equ 0C5h
 = 0057				     $PjumpBase equ 057h
 = 0089				     $PjumpCeil equ 089h
 = 0001				     $pAbut equ 01h
 = 0003				     $pCat equ 03h
 = 0005				     $pNop equ 05h
 = 0007				     $pAssignDotsP equ 07h
 = 0009				     $pParse equ 09h
 = 000B				     $pResumeParse equ 0Bh
 = 000D				     $pNumber equ 0Dh
 = 000F				     $pTo equ 0Fh
 = 0011				     $pBy equ 011h
 = 0013				     $pFor equ 013h
 = 0015				     $pWhile equ 015h
 = 0017				     $pUntil equ 017h
 = 0019				     $pIterRep equ 019h
 = 001B				     $pIterate equ 01Bh
 = 001D				     $pLeave equ 01Dh
 = 001F				     $pUnDo equ 01Fh
 = 0021				     $pResult equ 021h
 = 0023				     $pReturn equ 023h
 = 0025				     $pReturns equ 025h
 = 0027				     $pExit equ 027h
 = 0029				     $pSay equ 029h
 = 002B				     $pBifq equ 02Bh
 = 002D				     $pLength equ 02Dh
 = 002F				     $pMax equ 02Fh
 = 0031				     $pMin equ 031h
 = 0033				     $pNot equ 033h
 = 0035				     $pAnd equ 035h
 = 0037				     $pOr equ 037h
 = 0039				     $pXor equ 039h
 = 003B				     $pPositive equ 03Bh
 = 003D				     $pNegate equ 03Dh
 = 003F				     $pAdd equ 03Fh
 = 0041				     $pSubtract equ 041h
 = 0043				     $pMultiply equ 043h
 = 0045				     $pDivide equ 045h
 = 0047				     $pIntDivide equ 047h
 = 0049				     $pRemainder equ 049h
 = 004B				     $pPower equ 04Bh
 = 004D				     $pCommand equ 04Dh
 = 004F				     $pInterpret equ 04Fh
 = 0051				     $pNumeric equ 051h
 = 0053				     $pInvoke equ 053h
 = 0055				     $pCall equ 055h
 = 0057				     $pRep equ 057h
 = 0059				     $pRepEver equ 059h
 = 005B				     $pControlVar equ 05Bh
 = 005D				     $pDotControlVar equ 05Dh
 = 005F				     $pThen equ 05Fh
 = 0061				     $pWhen equ 061h
 = 0063				     $pJump equ 063h
 = 0065				     $pEq equ 065h
 = 0067				     $pNe equ 067h
 = 0069				     $pLt equ 069h
 = 006B				     $pLe equ 06Bh
 = 006D				     $pGe equ 06Dh
 = 006F				     $pGt equ 06Fh
 = 0071				     $pSeq equ 071h
 = 0073				     $pSne equ 073h
 = 0075				     $pSlt equ 075h
 = 0077				     $pSle equ 077h
 = 0079				     $pSge equ 079h
 = 007B				     $pSgt equ 07Bh
 = 007D				     $pCeq equ 07Dh
 = 007F				     $pCne equ 07Fh
 = 0081				     $pClt equ 081h
 = 0083				     $pCle equ 083h
 = 0085				     $pCge equ 085h
 = 0087				     $pCgt equ 087h
 = 0089				     $pInterpEnd equ 089h
 = 008B				     $pSignal equ 08Bh
 = 008D				     $pSignalOn equ 08Dh
 = 008F				     $pCallOn equ 08Fh
 = 0091				     $pDots equ 091h
 = 0093				     $pAssign equ 093h
 = 0095				     $pAssignStem equ 095h
 = 0097				     $pAssignDots equ 097h
 = 0099				     $pAssignConst equ 099h
 = 009B				     $pUnstore equ 09Bh
 = 009D				     $pDrop equ 09Dh
 = 009F				     $pExpose equ 09Fh
 = 00A1				     $pBool equ 0A1h
 = 00A3				     $pIterCV equ 0A3h
 = 00A5				     $pAddress equ 0A5h
 = 00A7				     $pCommandEnv equ 0A7h
 = 00A9				     $pEnvName equ 0A9h
 = 00AB				     $pBif equ 0ABh
 = 00AD				     $pBifGroup equ 0ADh
 = 00AF				     $pRaise equ 0AFh
 = 00B1				     $pSignalOff equ 0B1h
 = 00B3				     $pSignalV equ 0B3h
 = 00B5				     $pSysVar equ 0B5h
 = 00B7				     $pDropList equ 0B7h
 = 00B9				     $pExposeList equ 0B9h
 = 00BB				     $pPush equ 0BBh
 = 00BD				     $pQueue equ 0BDh
 = 00BF				     $pTrace equ 0BFh
 = 00C1				     $pTraceEvent equ 0C1h
 = 00C3				     $pOptions equ 0C3h
 = 0000				     $BifDATE equ 0
 = 0001				     $BifTIME equ 1
 = 0002				     $BifLINES equ 2
 = 0003				     $BifCHARS equ 3
 = 0004				     $BifCHARIN equ 4
 = 0005				     $BifCHAROUT equ 5
 = 0006				     $BifLINEIN equ 6
 = 0007				     $BifLINEOUT equ 7
 = 0008				     $BifSTREAM equ 8
 = 0009				     $BifSTRIP equ 9
 = 000A				     $BifVERIFY equ 10
 = 000B				     $BifQUALIFY equ 11
 = 000C				     $BifWORDS equ 12
 = 000D				     $BifTRUNC equ 13
 = 000E				     $BifERRORTEXT equ 14
 = 000F				     $BifSPACE equ 15
 = 0010				     $BifTRANSLATE equ 16
 = 0011				     $BifFORMAT equ 17
 = 0012				     $BifWORDLENGTH equ 18
 = 0013				     $BifWORDPOS equ 19
 = 0014				     $BifABBREV equ 20
 = 0015				     $BifCENTER equ 21
 = 0016				     $BifCENTRE equ 22
 = 0017				     $BifCOMPARE equ 23
 = 0018				     $BifDELSTR equ 24
 = 0019				     $BifDELWORD equ 25
 = 001A				     $BifRIGHT equ 26
 = 001B				     $BifLASTPOS equ 27
 = 001C				     $BifINSERT equ 28
 = 001D				     $BifOVERLAY equ 29
 = 001E				     $BifFORM equ 30
 = 001F				     $BifDATATYPE equ 31
 = 0020				     $BifADDRESS equ 32
 = 0021				     $BifARG equ 33
 = 0022				     $BifCONDITION equ 34
 = 0023				     $BifTRACE equ 35
 = 0024				     $BifFUZZ equ 36
 = 0025				     $BifDIGITS equ 37
 = 0026				     $BifSOURCELINE equ 38
 = 0027				     $BifXRANGE equ 39
 = 0028				     $BifRANDOM equ 40
 = 0029				     $BifREVERSE equ 41
 = 002A				     $BifABS equ 42
 = 002B				     $BifSIGN equ 43
 = 002C				     $BifC2X equ 44
 = 002D				     $BifB2X equ 45
 = 002E				     $BifX2B equ 46
 = 002F				     $BifX2C equ 47
 = 0030				     $BifX2D equ 48
 = 0031				     $BifC2D equ 49
 = 0032				     $BifD2C equ 50
 = 0033				     $BifD2X equ 51
 = 0034				     $BifBITAND equ 52
 = 0035				     $BifBITOR equ 53
 = 0036				     $BifBITXOR equ 54
 = 0037				     $BifVALUE equ 55
 = 0038				     $BifCOPIES equ 56
 = 0039				     $BifWORD equ 57
 = 003A				     $BifWORDINDEX equ 58
 = 003B				     $BifSUBWORD equ 59
 = 003C				     $BifPOS equ 60
 = 003D				     $BifLEFT equ 61
 = 003E				     $BifSUBSTR equ 62
 = 003F				     $BifQUEUED equ 63
 = 0040				     $BifSYMBOL equ 64
 = 0041				     $BifCOUNTSTR equ 65
 = 0042				     $BifCHANGESTR equ 66
 = 0043				     $BifLENGTH equ 67
 = 0044				     $BifMAX equ 68
 = 0045				     $BifMIN equ 69
 = 00B3				     $BcodesBase equ 0B3h
 = 00B3				     Zero equ 0B3h
 = 00B5				     One equ 0B5h
 = 00B7				     Null equ 0B7h
 = 00B9				     String equ 0B9h
 = 00BB				     String1 equ 0BBh
 = 00BD				     String2 equ 0BDh
 = 00BF				     _RetBc equ 0BFh
 = 00C1				     _RetB equ 0C1h
 = 00C3				     _RetF equ 0C3h
 = 00C5				     _IterCV equ 0C5h
 = 00C7				     _Exists equ 0C7h
 = 00C9				     _Then equ 0C9h
 = 00CB				     _Jump equ 0CBh
 = 00CD				     _Eq equ 0CDh
 = 00CF				     _Ne equ 0CFh
 = 00D1				     _Lt equ 0D1h
 = 00D3				     _Le equ 0D3h
 = 00D5				     _Ge equ 0D5h
 = 00D7				     _Gt equ 0D7h
 = 00D9				     _Seq equ 0D9h
 = 00DB				     _Sne equ 0DBh
 = 00DD				     _Slt equ 0DDh
 = 00DF				     CONFIG_RAISE equ 0DFh
 = 00E1				     CONFIG_RAISE40 equ 0E1h
 = 00E3				     CONFIG_UPPER equ 0E3h
 = 00E5				     CONFIG_MSG equ 0E5h
 = 00E7				     CONFIG_C2B equ 0E7h
 = 00E9				     CONFIG_B2C equ 0E9h
 = 00EB				     CONFIG_STREAM_POSITION equ 0EBh
 = 00ED				     CONFIG_STREAM_CHARIN equ 0EDh
 = 00EF				     CONFIG_STREAM_QUERY equ 0EFh
 = 00F1				     CONFIG_STREAM_CLOSE equ 0F1h
 = 00F3				     CONFIG_STREAM_CHAROUT equ 0F3h
 = 00F5				     CONFIG_STREAM_COUNT equ 0F5h
 = 00F7				     CONFIG_STREAM_QUALIFIED equ 0F7h
 = 00F9				     CONFIG_STREAM_COMMAND equ 0F9h
 = 00FB				     CONFIG_STREAM_STATE equ 0FBh
 = 00FD				     CONFIG_TIME equ 0FDh
 = 00FF				     CONFIG_ARITH equ 0FFh
 = 0000				     $0 equ 0
 = 0000				     $Eos equ 0*4
 = 0001				     $12 equ 1
 = 0004				     $Semi equ 1*4
 = 0002				     $11 equ 2
 = 0008				     $UnAccept equ 2*4
 = 0003				     $6 equ 3
 = 000C				     $Lparen equ 3*4
 = 0004				     $3 equ 4
 = 0010				     $Percent equ 4*4
 = 0011				     $Asterisk equ 4*(5-1) + 1
 = 0012				     $Slash equ 4*(5-1) + 2
 = 0013				     $Rem equ 4*(5-1) + 3
 = 0014				     $Xor equ 5*4
 = 0015				     $Or equ 4*(6-1) + 1
 = 0006				     $5 equ 6
 = 0018				     $And equ 6*4
 = 0007				     $10 equ 7
 = 001C				     $Comma equ 7*4
 = 0020				     $Not equ 8*4
 = 0009				     $9 equ 9
 = 0024				     $Minus equ 9*4
 = 0025				     $Plus equ 4*(10-1) + 1
 = 002B				     $Eq equ 10*4+3
 = 002C				     $Ne equ 11*4
 = 002D				     $Lt equ 4*(12-1) + 1
 = 002E				     $Le equ 4*(12-1) + 2
 = 002F				     $Ge equ 4*(12-1) + 3
 = 0030				     $Gt equ 12*4
 = 0031				     $Seq equ 4*(13-1) + 1
 = 0032				     $Sne equ 4*(13-1) + 2
 = 0033				     $Slt equ 4*(13-1) + 3
 = 0034				     $Sle equ 13*4
 = 0035				     $Sge equ 4*(14-1) + 1
 = 0036				     $Sgt equ 4*(14-1) + 2
 = 000E				     $7 equ 14
 = 0038				     $Rparen equ 14*4
 = 003C				     $STRING equ 15*4
 = 0040				     $CONST_SYMBOL equ 16*4
 = 0044				     $NUMBER equ 17*4
 = 0012				     $28 equ 18
 = 0048				     $VAR_SYMBOL equ 18*4
 = 0013				     $1 equ 19
 = 004C				     $Abut equ 19*4
 = 004D				     $Cat equ 4*(20-1) + 1
 = 0014				     $8 equ 20
 = 0050				     $Power equ 20*4
 = 0015				     $2 equ 21
 = 0054				     $Assign equ 21*4
 = 0016				     $21 equ 22
 = 0058				     $VALUE equ 22*4
 = 0017				     $16 equ 23
 = 005C				     $END equ 23*4
 = 0018				     $18 equ 24
 = 0060				     $THEN equ 24*4
 = 0019				     $17 equ 25
 = 0064				     $FOR equ 25*4
 = 001A				     $19 equ 26
 = 0068				     $TO equ 26*4
 = 001B				     $15 equ 27
 = 006C				     $BY equ 27*4
 = 0070				     $UNTIL equ 28*4
 = 0074				     $WHILE equ 29*4
 = 001E				     $23 equ 30
 = 0078				     $WITH equ 30*4
 = 007C				     $LINEIN equ 31*4
 = 007D				     $SOURCE equ 4*(32-1) + 1
 = 007E				     $VERSION equ 4*(32-1) + 2
 = 0080				     $PULL equ 32*4
 = 0084				     $VAR equ 33*4
 = 0088				     $ARG equ 34*4
 = 008C				     $ADDRESS equ 35*4
 = 0090				     $APPEND equ 36*4
 = 0094				     $CALL equ 37*4
 = 0098				     $DO equ 38*4
 = 009C				     $ELSE equ 39*4
 = 00A0				     $NOP equ 40*4
 = 00A4				     $INTERPRET equ 41*4
 = 00A5				     $OPTIONS equ 4*(42-1) + 1
 = 00A8				     $EXIT equ 42*4
 = 00A9				     $PUSH equ 4*(43-1) + 1
 = 00AA				     $QUEUE equ 4*(43-1) + 2
 = 00AB				     $RETURN equ 4*(43-1) + 3
 = 00AC				     $SAY equ 43*4
 = 00B0				     $TRACE equ 44*4
 = 00B4				     $LEAVE equ 45*4
 = 00B5				     $ITERATE equ 4*(46-1) + 1
 = 00B8				     $DROP equ 46*4
 = 00BC				     $EXPOSE equ 47*4
 = 00C0				     $SIGNAL equ 48*4
 = 00C4				     $SYNTAX equ 49*4
 = 00C5				     $LOSTDIGITS equ 4*(50-1) + 1
 = 00C6				     $NOVALUE equ 4*(50-1) + 2
 = 00C8				     $NOTREADY equ 50*4
 = 00C9				     $FAILURE equ 4*(51-1) + 1
 = 00CA				     $HALT equ 4*(51-1) + 2
 = 00CC				     $ERROR equ 51*4
 = 00D0				     $UPPER equ 52*4
 = 00D4				     $IF equ 53*4
 = 00D8				     $INPUT equ 54*4
 = 00DC				     $NAME equ 55*4
 = 00E0				     $NUMERIC equ 56*4
 = 00E4				     $DIGITS equ 57*4
 = 00E5				     $FUZZ equ 4*(58-1) + 1
 = 00E8				     $FORM equ 58*4
 = 00EC				     $ENGINEERING equ 59*4
 = 00ED				     $SCIENTIFIC equ 4*(60-1) + 1
 = 00F0				     $OTHERWISE equ 60*4
 = 00F4				     $OUTPUT equ 61*4
 = 00F8				     $PARSE equ 62*4
 = 00FC				     $PROCEDURE equ 63*4
 = 0100				     $SELECT equ 64*4
 = 0104				     $WHEN equ 65*4
 = 0108				     $REPLACE equ 66*4
 = 010C				     $STEM equ 67*4
 = 0110				     $STREAM equ 68*4
 = 0114				     $NORMAL equ 69*4
 = 0118				     $FOREVER equ 70*4
 = 011C				     $OFF equ 71*4
 = 0120				     $ON equ 72*4
 = 0000				     $sPercent equ 0
 = 0006				     $sDrop equ 6
 = 0009				     $sStem equ 9
 = 000A				     $sWith equ 10
 = 000B				     $sDropList equ 11
 = 0014				     $sMinus equ 20
 = 0017				     $sLength equ 23
 = 001B				     $sEq equ 27
 = 0021				     $sSeq equ 33
 = 0027				     $sDigits equ 39
 = 002A				     $sNop equ 42
 = 002B				     $sForm equ 43
 = 002D				     $sAddress equ 45
 = 0030				     $sNegate equ 48
 = 0031				     $sPositive equ 49
 = 0032				     $sExit equ 50
 = 0035				     $sReturns equ 53
 = 0037				     $sNumber equ 55
 = 0039				     $sRaise equ 57
 = 003E				     $sLeave equ 62
 = 003F				     $sIterate equ 63
 = 00FE				     ParseDot equ 254; A non-operator Bcode value otherwise unused.
 = 0028				     KeysBase equ 4*10; Manual
				     ; Here are some symbolic names of registers, used for readability of this code.
 = bp				     ZeroBp is <bp>
 = di				     StackDi is <di>      ; The soft stack pointer.
 = si				     StackSi is <si>      ; Another soft stack pointer.
 = dx				     StackDx is <dx>      ; Limit of range on soft stack.
 = bx				     ArrayBx is <bx>      ; To an element of Vshape.
 = bx				     StemBx is <bx>       ; When the subject is a stem.
 = si				     TailSi is <si>       ; When the subject is a tailed variable.
 = bx				     FileBx is <bx>       ; To an element of Fshape.
 = si				     ArraySi is <si>      ; To an element of Vshape.
 = bx				     OperandBx is <bx>    ; A pointer to an operand in one of the arrays of Vshapes.
 = bl				     OperandBl is <bl>    ;
 = bx				     ProbeBx is <bx>      ; Used when searching a binary tree for a stemmed variable.
 = si				     LowSi is <si>        ; Used when searching a binary tree.
 = di				     HighDi is <di>       ; Used when searching a binary tree.
 = ax				     ToFindLenAx is <ax>  ; Used when searching a binary tree.
 = dx				     ToFindDx is <dx>     ; Used when searching a binary tree.
 = cx				     KeyListCx is <cx>;   ; Parameter to keyword lookup.
 = ch				     TokNowCh is <ch>;    ; One of the places numbers for tokens are held.
 = si				     StateSi is <si>      ; The state in parsing.
 = si				     ParseSi is <si>      ; Parse state pushed on hard stack.
 = di				     StateDi is <di>      ; Address first word of the state.
 = bx				     StateBx is <bx>      ; Often distance from StateOrig to some state data.
 = dx				     ParseDx is <dx>      ; Token data in form the parser uses.
 = ah				     RtypeAh is <ah>      ; Type of reduction done in Cycle.
 = ah				     TokNumAh is <ah>     ; Where next token is returned, becoming TokNum.
 = si				     LookupSi is <si>     ; Where Lookup finds unresolved compound symbol.
 = si				     LevelSi is <si>      ; To block for this invocation level.
 = di				     LevelDi is <di>
 = si				     CursorSi is <si>     ; Offset in Pcode.
 = bx				     CursorBx is <bx>     ; Offset in Pcode.
 = cx				     OpAppendCx is <cx>   ; Numeric argument to PcodeOp routine.
 = si				     ScanSi is <si>       ; Scanning the user's source program.
 = cl				     OpAppendCl is <cl>
 = al				     RawCharAl is <al>
 = ah				     RawCharAh is <ah>
 = al				     AttribAl is <al>
 = dl				     RadixTypeDl is <dl>
 = cx				     ParmsCx is <cx>
 = cl				     ParmsCl is <cl>
 = bx				     LengthAtBx is <bx>
 = dx				     SymsZiDx is <dx>
 = di				     SegOffDi is <di> ; Offset in Zone of a segment pointer.
				     ; Special use of bp for two-byte call.
 = call bp			     Error49Bp is <call bp>
				     ; Shorthand for current byte of input.
 = byte ptr ss:[si+bp]		     RawChar is <byte ptr ss:[si+bp]>
				     ; These for making messages.
 = bl				     DepthBl is <bl>; of recursion.
 = bx				     DepthBx is <bx>; Bug if inc/dec affects bh.
 = bh				     TheMsgBh is <bh>; on when scanning the target.
 = cx				     PartLenCx is <cx>; Amount of compressed to expand.
 = cl				     LowPartLenCl is <cl>
 = cx				     KeywordOffsetCx is <cx>
 = dx				     MajMinDx is <dx>
 = dh				     MajorDh is <dh>
 = dl				     MinorDl is <dl>
 = dx				     MinorDx is <dx>; inc/dec
 = si				     ScannerSi is <si>; SI the address in table. (LODS used)
				     ; For segment registers.
				     ; ES has some transient uses (particularly because it cannot be overridden
				     ; in movsb) but mainly it is set to the symbols segment during compilation
				     ; and the program scope segment during execution.  Tailed variable references
				     ; also use it (transiently) because each stem variable has it's own segment.
 = es				     SymbolsEs is <es>
 = es				     ProgEs is <es>
 = es				     StemEs is <es>

 = 0019				     $DosDisk equ 19h
 = 002A				     $DosDate equ 2Ah
 = 002C				     $DosTime equ 2Ch
 = 003C				     $DosCreate equ 3Ch
 = 003D				     $DosOpen equ 3Dh
 = 003E				     $DosClose equ 3Eh
 = 003F				     $DosRead equ 3Fh
 = 0040				     $DosWrite equ 40h
 = 0041				     $DosDelete equ 41h
 = 0042				     $DosSeek equ 42h
 = 0043				     $DosChmod equ 43h
 = 0047				     $DosPath equ 47h
 = 0048				     $DosAllocate equ 48h
 = 0049				     $DosFree equ 49h
 = 004A				     $DosModifyAllocated equ 4Ah
 = 004B				     $DosExecute equ 4Bh
 = 004C				     $DosExit equ 4Ch
 = 004D				     $DosReturnCode equ 4Dh
 = 0059				     $DosGetError equ 59h
 = 0062				     $DosPSP equ 62h
				     ; As allowed by the Standard:
 = 000A				     $Limit_EnvironmentName equ 10
 = C350				     $Limit_String equ 50000
 = 00FA				     $Limit_Literal equ 250
 = 00FA				     $Limit_Name equ 250
 = 270F				     $Limit_Digits equ 9999; Note Msg33.2 must be generated to match.
 = 0009				     $Limit_ExponentDigits equ 9
 = 0032				     $Limit_Insert equ 50; Longest insert.
				     ; Ours
 = 0036				     $Limit_Major equ 54; Highest message user sees.
 = 0037				     $Descriptions equ 55; A place in the message numbering for oddment prose.
 = 00C8				     $MsgRoom equ 4*$Limit_Insert
 = 00AF				     $MaxPreInsert equ 175; Chars in message.
 = 0050				     $MsgChunk equ 80; Strictly, ANSI says leave chunking to system.
 = 0064				     $MaxParms equ 100; Per invokation. (Or temporary results within an expression)
 = 0400				     $FileBufferSize equ 1024
 = 0003				     $Leeway equ 3
				     ; Data types within symbols segment:
 = 00FF				     $tChar equ 0FFh
 = 00FE				     $tLabel equ 0FEh
 = 00FD				     $tBinary equ 0FDh
				     ; Minor bits on an operand reference.
 = 0006				     $CaseTarget equ 6
				     ; Subcodes to Pcodes.
				     ; These are used by the utility. Avoid putting semicolon abutting the "h".
				     ; These markers share values with Sysvar references in Bcode but we don't
				     ; parse into sysvars in our Bcode.
				     ; If we want to detect presence/absence of these they need to be 2 modulo 8.
				     ; However if they always follow something known, any value will do.
				     ; In practice we sometimes use the modulo 8 approach (even at the expense of
				     ; a shift when they are used) so as to make scanning of Pcode simpler.
 = 0002				     $mRepTail equ 02h        ; Used when $pDotControlVar addresses tails.
 = 000A				     $mUpper equ 0Ah          ; Modifier on parse source.
 = 0012				     $mParseEscape equ 12h    ; Parse part too complex to handle as single action.
 = 001A				     $mParseEnd equ 1Ah       ; Parse ends.
 = 0022				     $mPosRest equ 22h        ; Parse trigger
 = 002A				     $mPattern equ 2Ah        ; Parse trigger after operand
 = 0032				     $mPosEq equ 32h          ; Parse trigger after operand
 = 003A				     $mPosPlus equ 3Ah        ; Parse trigger after operand
 = 0042				     $mPosMinus equ 42h       ; Parse trigger after operand
 = 004A				     $mTemplateComma equ 4Ah  ; Parse trigger
				     ; These in number field of $pParse:
 = 0000				     $nVar equ 0              ; These
 = 0002				     $nWith equ 2             ;       two lowest of parse sources.
 = 0004				     $nArg equ 4
 = 0006				     $nLineIn equ 6
 = 0008				     $nPull equ 8
 = 000A				     $nSource equ 10
 = 000C				     $nVersion equ 12
				     ; These in number field of $pCommandEnv
 = 0000				     $nStem equ 00h
 = 0020				     $nStream equ 20h
 = 0040				     $nNormal equ 40h
				     ; These in number field of $pNumeric
 = 0000				     $nDigits equ 00h
 = 0002				     $nFuzz equ 02h
 = 0004				     $nForm equ 04h
				     ; These in number field of $pRaise
 = 0000				     $n7p3 equ 0
 = 0002				     $n17p1 equ 2
 = 0004				     $n40p3 equ 4
 = 0006				     $n40p4 equ 6
 = 0008				     $n40p5 equ 8
				     ; Types for things in Z.Serial
				     ; $SerialNone is also used for message building.
				     ; $SerialSource is qualified by Z.RelativeNow - what part of source file.
				     ; These are modals except for $SerialCompaction which saves/restores previous.
 = 0000				     $SerialNone equ 0
 = 0001				     $SerialQue equ 1
 = 0002				     $SerialCompaction equ 2
 = 0003				     $SerialInterpret equ 3
 = 0004				     $SerialSource equ 4
				     ; Trace events. (Order unexploited except for highest.)
 = 0000				     $TraceAssign equ 0
 = 0002				     $TraceBY equ 1*2
 = 0004				     $TraceClause equ 2*2
 = 0006				     $TraceCompound equ 3*2
 = 0008				     $TraceDot equ 4*2
 = 000A				     $TraceError equ 5*2
 = 000C				     $TraceExpr equ 6*2
 = 000E				     $TraceFailure equ 7*2
 = 0010				     $TraceFunction equ 8*2
 = 0012				     $TraceOperator equ 9*2
 = 0014				     $TracePrefix equ 10*2
 = 0016				     $TraceLit equ 11*2
 = 0018				     $TraceVar equ 12*2
 = 001A				     $TraceBack equ 13*2; Highest for $TrEv.
 = 001C				     $TraceParse equ 14*2; Only sets flag.
 = 001E				     $TraceEndClause equ 15*2; Compiled at end of a traced clause.
				     ; Descriptions on messages.    See OverfullMem for some.
				     Assert Zshape.SysFiles-Zshape.SysFiles eq 2*1-2
				     Assert Zshape.Consts-Zshape.SysFiles eq 2*2-2
				     Assert Zshape.Vars-Zshape.SysFiles eq 2*3-2
				     Assert Zshape.ProgScope-Zshape.SysFiles eq 2*4-2 ; Used for 'memory' msg.
				     Assert Zshape.VarScope-Zshape.SysFiles eq 2*5-2 ; Used for 'string length'
				     Assert Zshape.Symbols-Zshape.SysFiles eq 2*6-2
				     Assert Zshape.Code-Zshape.SysFiles eq 2*7-2
				     Assert Zshape.Zone-Zshape.SysFiles eq 2*8-2
				     Assert Zshape.Stem-Zshape.SysFiles eq 2*9-2
 = 0005				     $DescString equ 5
 = 000A				     $DescArgs   equ 10
 = 000B				     $Desc59H    equ 11
 = 000C				     $DescFiles  equ 12
 = 000D				     $DescQueue  equ 13
 = 0080				     $BifTag equ 80h; Helps with reverse lookup
				     ; As well as source coming from a file, there are the cases of INTERPRET,
				     ; VALUE, and SYMBOL where some compiling is needed.  Also VarPool cases.
				     ; Even if only Lookup is needed, it can be simplest to compile and pick
				     ; the answer up from the generated code.
 = 11C8				     $SourceBufferSize equ 4552; Allows for long bit literal.
 = 2000				     $InitStackSize equ 8192
 = 0000				      $White equ 0
 = 0040				      $Digit equ 64
 = 0080				      $Letter equ 128
 = 00C0				      $Special equ 192
 = 0008				      $NonUpable equ 8
 = 0004				      $Bb equ 4
 = 0002				      $Xx equ 2
 = 0001				      $Ee equ 1
 = 0048				      $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; Constants for Bifs.
 = FFB9				     $BifBase equ 65535-70; 68 bifs at high numbers.
				     ; The equates for pseudo code operations are with the P switch.
				     ; (See also $Reserved)
 = 00C0				     $Test       equ 11000000b; To test the most vital bits.
 = 0080				     $NullString equ 10000000b; 01000nnn for 0-7 length strings.
 = 0088				     $Omitted    equ 10001000b; Value of omitted is null string.
 = 0089				     $Variable   equ 10001001b; Only used at compile time.
 = 008A				     $Constant   equ 10001010b; Only used at compile time. (Untyped constant.)
 = 008B				     $Label      equ 10001011b;
 = 00C0				     $AwayString equ 11000000b;
				     ; NYI $AwayNumber equ 11110000b;
				     ; The 01 tags don't reach the runtime stack.
				     ; (That avoids a test when type checking operands now and allows future use.)
 = 0040				     $Dropped    equ 01000000b;
 = 0050				     $Exposed    equ 01010000b;
 = 0060				     $Stem       equ 01100000b;
 = 0044				     $MsgNum     equ 01000100b; Msg number in Major/Minor form.
 = 0048				     $Sigl       equ 01001000b; Jump point still as code offset.
				     ; Not to be confused with the bits from the table of characters:
				     XlatBDLS macro ;; 0=Blanks 1=Digits 2=Letters 3=Special
				      
; Picks up attributes of current char and sets flags.
				      xlat Bptr cs:[bx]
				      test al,0C0h
				     endm
				     Down macro
				      sub StackDi,$StrideV
				     endm
				     Up macro
				      add StackDi,$StrideV
				     endm
				     DownCare macro
				      lea StackDi,(-$StrideV)[StackDi]
				     endm
				     UpCare macro
				      lea StackDi,$StrideV[StackDi]
				     endm
				     ; Hard & soft cursors return.
				     RetSi macro
				      pop CursorSi
				      ret
				     endm
				     ; Macros for some common idioms in Pcode making.
				     OpAl macro $p
				       mov al,$p
				       call PcodeOp
				     endm
				     OpRet macro $p
				       mov al,$p
				       jmp PcodeOp
				     endm
				     EvAh macro $p
				       mov ah,$p
				       call TraceEvent
				     endm
				     EvRet macro $p
				       mov ah,$p
				       jmp TraceEvent
				     endm

				     ; Macros are used to make that clear where code is run out of the interpreter
				     ; loop, and to allow experiments in how the return is made.
				     ; These experiments never worked out because of the difficulty in having some
				     ; operations that needed to be routines (eg Assign as part of ControlVar) and
				     ; some that didn't.  Changing code to achieve sometimes-routine is a speed
				     ; killer.

				     Back macro
				     jmp XCycle
				     endm
				     BackRet macro
				     ret
				     endm

				     ; When all the operations end with a jump to XCycle we can turn them into
				     ; callable routines by sticking a ret instruction the code at XCycle.
				     ; Performance killer so rarely used.
 = 00C3				     $ret equ 0C3h
				     CodeModeR macro
				      push Wptr cs:XCycle
				      mov Bptr cs:XCycle,$ret
				     endm
				     UnCodeMode macro
				      pop Wptr cs:XCycle
				     endm

				     Repmovsb macro
				     local IsEven
				     if 1
				      rep movsb
				     endif
				     if 0
				     ; This ought to be faster but didn't seem to be. Perhaps jnc high cost.
				      shr cx,1
				      rep movsw
				      jnc IsEven
				      movsb
				      IsEven:
				     endif
				     endm

				     ; There is a "mv" macro that moves registers by push & pop.
				     ; There is a "move" that saves typing when memory-to-memory.
				     ; Here is "Mv" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by push & pop.
				     ; Here is "Move" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by shuffling through general registers.
				     Mv macro To,From
				     ; "Move" is faster than "Mv" and no bigger, if there is a spare register.
				        pushd From.OverExpo
				        pop To.OverExpo
				        pushd From.OverMant
				        pop To.OverMant
				     endm

				     Move macro To,From,Via
				     ; Move of a Rexx value. Convention is to use ecx:eax
				      ifb <To>
				     ; No target means load usual registers.
				        mov ecx,From.OverExpo
				        mov eax,From.OverMant
				      elseifb <From>
				     ; No source means store from usual registers.
				        mov To.OverExpo,ecx
				        mov To.OverMant,eax
				      elseifb <Via>
				     ; Copy via usual registers.
				        mov ecx,From.OverExpo
				        mov To.OverExpo,ecx
				        mov eax,From.OverMant
				        mov To.OverMant,eax
				      else
				     ; Copy via specified register.
				       mov Via,From.OverExpo
				       mov To.OverExpo,Via
				       mov Via,From.OverMant
				       mov To.OverMant,Via
				      endif
				     endm

 0006				     FarpX struc
 0000	    0000 [		      Fr dword Overlay
	     00000000
	    ]
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
 0004	    0000 [		      Limit word Overlay
	     0000
	    ]
 0004  0000			      Len word 0
				     FarpX ends


 0008				     Vshape union
				      struc; When containing a short string.
 0000	    0007 [		       String db 7 dup(?)
	     00
	    ]
 0007  00			       Dtype db ?                        ; Whether string or not and used length.
				      ends
				      struc; When binary number
				       Sign byte Overlay     ; Odd means negative mantissa.
				       ExpAnd dword Overlay  ; Exponent and sign of mantissa.
				        ExpoUses db 3 dup(?)
				        ExpoSign db ?        ; Sign of exponent.
				       Mantissa dword Overlay
				        MantLow word ?
				        MantHigh word ?
				      ends
				      struc; When treated as just bytes.
				       OverExpo dword ?
				       OverMant dword ?
				      ends
				      struc; When referencing a long string.
				       FarpX <>
				       dw ?                              ; Covers Dtype.
				      ends
				      struc; When referencing label information
				       LabelValue word ?                 ; Offset in Pcode.
				       dword ?
				       LabelType word Overlay
				       byte ?                            ; 0 = normal, 1 = TraceOnly
				       db ?                              ; Covers Dtype. Will be $Label.
				      ends
				      struc; When compile time stack item for a constant.
				       WhichCon word ?                  ; Offset under ProgScope.
				       PcodePos word ?                  ; Where it will be in Pcode.
				       db 4 dup(?)                       ; Covers Dtype. Will be $Constant.
				      ends
				      struc; When compile time stack item for a resolved target.
				       HeldOver word ?                   ; To go in Pcode eventually.
				       db 6 dup(?)                       ; Covers Dtype. Will be $NullString
				      ends
				      struc ; When used to look up symbols.  Dtype not relevant then.
				     ; Moot whether this is really a Vshape but pretending it is allows use of Vbx.
				       Pair dd 0 dup(?)                  ; Next two together.
				        Lower Ushortp ?                  ; a subtree.
				        Higher Ushortp ?                 ; a subtree
				       Here charp ?                      ; to the symbol.
				      ends
				     Vshape ends
				     ; V. is for Vshape objects addressed by [di+bp]; eg variables on the stack.
 = (Vshape ptr[bp+di])		     V is <(Vshape ptr[bp+di])>
				     ; 1-origin numbers for the parameters of bif, but V is used for V1 (and result).
				     ; So lhs and rhs of binary operation are V and V2, result overlays V.
				     ; Of course, changing di by $StrideV is an alternative to using different Vn.
 = 0008				     $StrideV equ size Vshape
 = 0003				     $ShiftV equ 3
 = (Vshape ptr[bp+di-$StrideV])	     V0 is <(Vshape ptr[bp+di-$StrideV])>
 = (Vshape ptr[bp+di-2*$StrideV]     V00 is <(Vshape ptr[bp+di-2*$StrideV])>
   )
 = (Vshape ptr[bp+di+$StrideV])	     V2 is <(Vshape ptr[bp+di+$StrideV])>
 = (Vshape ptr[bp+di+2*$StrideV]     V3 is <(Vshape ptr[bp+di+2*$StrideV])>
   )
 = (Vshape ptr[bp+di+3*$StrideV]     V4 is <(Vshape ptr[bp+di+3*$StrideV])>
   )
				     ; Vsi. is for Vshape objects addressed by [si+bp]; variables on the stack.
 = (Vshape ptr[bp+si])		     Vsi is <(Vshape ptr[bp+si])>
				     ;Vsif. is for Vshape objects addressed by fs:[si]; Variables of procedure.
 = fs:(Vshape ptr[si])		     Vsif is <fs:(Vshape ptr[si])>
				     ; Vdid. is for Vshape objects addressed by ds:[di]
 = ds:(Vshape ptr[di])		     Vdid is <ds:(Vshape ptr[di])>
				     ; Vsid. is for Vshape objects addressed by ds:[si]
 = ds:(Vshape ptr[si])		     Vsid is <ds:(Vshape ptr[si])>
				     ;Vbx. is for Vshape objects addressed by ds:[bx]
 = ds:(Vshape ptr[bx])		     Vbx is <ds:(Vshape ptr[bx])>
				     ;Vbxf. is for Vshape objects addressed by fs:[bx]; Variables of procedure.
 = fs:(Vshape ptr[bx])		     Vbxf is <fs:(Vshape ptr[bx])>
 = fs:(Vshape ptr[bx-$CaseTarget     Vbxt is <fs:(Vshape ptr[bx-$CaseTarget])>
   ])
 = fs:(Vshape ptr[bx+$StrideV])	     Vbxf2 is <fs:(Vshape ptr[bx+$StrideV])>
				     ;Vbxs. is for Vshape objects addressed by ss:[bx]; Variables on the stack.
 = ss:(Vshape ptr[bx])		     Vbxs is <ss:(Vshape ptr[bx])>
				     ;Ve. is for Vshape objects addressed by es:[bp]; (Saves a byte sometimes)
 = es:(Vshape ptr[bp])		     Ve is <es:(Vshape ptr[bp])>
 = fs:(Vshape ptr[bp])		     Vf is <fs:(Vshape ptr[bp])>
				     ;Vbxe. is for Vshape objects addressed by es:[bx]
 = es:(Vshape ptr[bx])		     Vbxe is <es:(Vshape ptr[bx])>
				     if 0
				     endif
 0028				     Dshape struc; The elements of soft stack for DO loops.    (And INTERPRET)
				     ; Here the n of "DO n;" will wind up.
				     ; Also x of DO j=x...  We don't need to retain that through the DO-END, but
				     ; harmless to do so. (Overlaid when DO A.K=....)
 0000	    0000 [		      TailsAt word Overlay; Where the pcode to reload tails is.
	     0000
	    ]
 0000	    0000 [		      Subject Vshape 0 dup(<>); When block is for an INTERPRET.
	     0007 [
	      00 00
	     ]
 0000	     0000 [		      CVinit Vshape 0 dup(<>)
	      0007 [
	       00 00
	      ]
 0000	      0007 [		      Reps Vshape <>
	       00
	      ] 00
 0008	      0007 [		      To Vshape <>
	       00
	      ] 00
 0010	      0007 [		      By Vshape <>
	       00
	      ] 00
 0018	      0007 [		      ForCount Vshape <>
	       00
	      ] 00
				     ; The rest is made similar to a Vshape so that Bcode can overlay Dshape as
				     ; variables.
 0020	      0000 [		      PcodePos charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0020  0000			      Iteration charp ?; Where to branch on ITERATE
 0022  0000			      Leaving charp ?  ; Where to branch on LEAVE
 0024	      0000 [		      UpDO charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0024  0000			      CV charp ?; Offset of the control variable.
 0026  00			      byte ?
 0027  00			      Rec byte ?;  MASM confused when LoopsRec<> used.
				     Dshape ends
 = 0028				     $StrideD equ size Dshape
				     ; D. is for Dshape objects addressed by [di+bp]; the DO nesting.
				     ; These objects are addressed from partway through them.  This is because the
				     ; XCycle loop benefits from moving StackDi over the "previous operand" when
				     ; loading the latest operand. But the "previous operand" may actually have
				     ; been one of these DO control blocks.
				     ; Use D1 to address the DO block when StackDi has been upped to indicate
				     ; there is a value stacked later than the DO block.
 = (Dshape ptr[bp+di-$StrideD+$S     D is <(Dshape ptr[bp+di-$StrideD+$StrideV])>
   trideV])
 = (Dshape ptr[bp+di-$StrideD])	     D1 is <(Dshape ptr[bp+di-$StrideD])>

				      FRec record Qual:1,Read:1,Open:1,BeenRead:1,BeenWrite:1,
				                  WriteMode:1,IsSource:1,BeenCompiled:1,FFpad:8
 001A				     Fshape struct ; Data for a file, the key is the file name.
 0000  0000			       Flags FRec <>
 0002  0000			       ToQual word ? ; To item for fully qualified name.
 0004  00000000			       Lines Ulong ?
 0008  0000			       Hand Handle ?
 000A  00000000			       Other_Position Ulong ? ; A position on the file, provided by DOS.
 000E  00			       Exten byte ?; 1=REX/CMD 2=COM 3=EXE 4=BAT
 000F  00			       TraceWidth byte ?; How many chars in a clause identifier.
 0010  0000			       Symbols Segp ? ; Saved from Zone when file inactive.
 0012  0000			       Code Segp ?
 0014  0000			       Vars Segp ?
 0016  0000			       Consts Segp ?
 0018  0000			       ProgScope Segp ?
				     Fshape ends
 = 001A				     $StrideF equ size Fshape
				     ; F. is for Fshape objects addressed by [bx]; a file.
				     ; An Fshape is put ahead of a Jshape.
 = (Fshape ptr[bx-$StrideF])	     F is <(Fshape ptr[bx-$StrideF])>

 0008				     EnvBlock struc 2
 0000  0000			      EnvNumber    word ?
 0002  0000			      EnvResourceI word ?
 0004  0000			      EnvResourceO word ?
 0006  0000			      EnvResourceE word ?
				     EnvBlock ends
				     if 1; Private to memory object
 0006				     Ashape struc; Describe pieces of memory got from Dos, and part of them used.
 0000  0000 0000		      Fr Farp <>
 0004  0000			      Amount Ushort 0
				     Ashape ends
				     ; A. is for Ashape objects addressed by [si+bp]; For memory allocation.
 = (Ashape ptr[bp+si])		     A is <(Ashape ptr[bp+si])>
 = 0006				     $StrideA equ size Ashape
				     endif
 0015				     InsBlock struc;  Used by issuing of messages, to deduce inserts.
 0000	      0000 [		      MajMin word Overlay    ; This is an error detected.
	       0000
	      ]
 0000  00			       Minor byte ?
 0001  00			       Major byte ?
 0002  0000			      Value word ?           ; Soft stack offset of value.
 0004	      0000 [		      Named Ushort Overlay
	       0000
	      ]
 0004  0000			      Position Ushort ?
 0006  0000			      KeysList charp ?       ; Yields keyword list
 0008  00			      ArgNum byte ?
 0009  00			      Desc byte ?            ; To find text of <Description>
 000A	      0000 [		      Hex byte Overlay
	       00
	      ]
 000A  00			      Char byte ?
 000B  0000			      Options charp ?        ; Msg 40.28
 000D  0000			      OptsHi charp ?         ; Msg 40.28
 000F  0000			      Digits word ?          ; Msgs 26.1 and 33.1  Don't overlay, zero meaningful.
 0011  0000			      TokPos charp ?         ; Position of token within segment holding source.
 0013  0000			      TokLen Ushort ?        ; Ushort although inserts have low limit length.
				     InsBlock ends

				     ; "Interacting" is a bug for "Interactive" ?. Pad 8 makes byte offset zero.
				     LevelRec record Lpad:8,InheritDone:1,DigitsSet:1,IsProcedure:1,IsExternal:1,
				         IsFunction:1,Lpad2:3

				     LevelRecI record LIPad:14,Interactive:1,ConditionInstruction:1
				     ; Instruction.Condition and ConditionInstruction are the same value.

				     ConditionRec record Enabling:1,Delayed:1,PendingNow:1,Instruction:1,CRspare:4

 007C				     Lshape struc; The elements of soft stack for invocations.
				     ; The part inherited from the level above. (When there is one.)
				      align 4; We move the inherited bit using doublewords.
 0000	      0000 [		       DigitsFuzz dword Overlay
	       00000000
	      ]
 0000  0000			       Digits Ushort ?
 0002  0000			       Fuzz Ushort ?
 0004  00			       Form char ?
 0005  0000000000000000		       StartTime qword ?
 000D	      0000 [		       TraceLetter char Overlay
	       00
	      ]
 000D  0000			       TraceWord word ?; LevelRecI <>.
 000F  0000 0000 0000 0000	       Active EnvBlock <>
 0017  0000 0000 0000 0000	       Alternate EnvBlock <>
 001F  00			       Syntax ConditionRec <>
 0020  00			       LostDigits ConditionRec <>
 0021  00			       NoValue ConditionRec <>
 0022  00			       NotReady ConditionRec <>
 0023  00			       Error ConditionRec <>
 0024  00			       Failure ConditionRec <>
 0025  00			       Halt ConditionRec <>
 0026	      0007 [		       TrapName word 7 dup(?)
	       0000
	      ]
 0034  0000			       EventLevel word ?   ; Only used for Halt.
 0036  0000			       Condition word ?    ; As CONDITION bif result(C)
 0038	      0007 [		       ConditionDescription Vshape <>; As CONDITION bif result(D)
	       00
	      ] 00
 0040	      0007 [		       ConditionExtra Vshape <>; As CONDITION bif result(E)
	       00
	      ] 00
				      align 4; We move the inherited bit using doublewords.
 0048	      0000 [		       Inherit char Overlay; End of inherited.
	       00
	      ]
 0048  0000000000000000		      ClauseTime qword ?
 0050  0000000000000000		      ClauseLocal qword ?
 0058  0000000000000000		      PendingDescription qword ?
 0060  0000000000000000		      PendingExtra qword ?
 0068  0000			      LevelDO charp ?;  Level's CurrentDO held over call.
 006A  0000 0000		      StackSave Farp <>; To make save over DosExecute recursive.
 006E  0000			      File charp ?     ; Save which external file is source when external call made.
 0070  0000			      ProgScope Segp ? ; Saved values of constants, when external call.
 0072  0000			      VarScope Segp ?  ; Saved values of variables, when external call.
				      align 4
				     ;The Lshape is normally addressed a few bytes ($StrideV) down from its high end.
 0074	      0000 [		      Access word Overlay; MASM gets confused if this is attached to the LevelRec.
	       0000
	      ]
 0074  0000			      Flags LevelRec <>
 0076  0000			      UpLevel charp ?; Invoker's block.
 0078  0000			      Resume charp ? ; On return from invoke from here.
 007A  0000			      Arg0 charp ?   ; Parameters to this invoke.
				     Lshape ends
 = 007C				      $StrideL equ size Lshape
				     ; L. is for Lshape objects addressed by ss:[di+bp]; the level of the execution.
 = (Lshape ptr[bp+di-$StrideL+$S     L is <(Lshape ptr[bp+di-$StrideL+$StrideV])>
   trideV])
				     ; Lsi. is for Lshape objects addressed by ss:[si+bp]
 = (Lshape ptr[bp+si-$StrideL+$S     Lsi is <(Lshape ptr[bp+si-$StrideL+$StrideV])>
   trideV])
				     ; Lbx. is for Lshape objects addressed by ss:[bx]; the level of the execution.
 = ss:(Lshape ptr[bx-$StrideL+$S     Lbx is <ss:(Lshape ptr[bx-$StrideL+$StrideV])>
   trideV])

				     ; LoopsRec is used only in Dshape.
				     ;HasDot:1,      ; When DO X.=
				     ;HasDots:1,     ; When DO X.Y =
				     ;HasTo:1,
				     ;HasFor:1,
				     ;ByDown:1,      ; When control variable values are going down.
				     ;IsInterp:1     ; When block is for INTERPRET, not DO.
				     LoopsRec record LoopsPad:2,HasDot:1,HasDots:1,HasTo:1,HasFor:1,IsInterp:1,
				                     ByDown:1; ByDown last - see use in CompareTo

				     ; API_Enabled:1,   Controls "Variable Pool" interface.
				     ; NoSource:1,      $5.10.11, but no need to implement.
				     ; RandomSeeded:1,  Has the seed been initialized?
				     ; NotS9:1,         Off if numerics are 9 digit SCIENTIFIC.
				     ; The following are to do with compiling - they are off in execution.
				     ; LabelsBad:1,     On when the compile is of text from INTERPRET.
				     ; Repass:1,        When user overides Bif name.
				     ; FirstBetween:1,  On when parsing should start with a Between call.
				     ; EndSource:1,     Helps parser detect end-of-source.
				     ; BifCheck:1,      Tells whether Bif check failed, for compile time .
				     ; TraceIF:1,       Controls trace output.
				     ; ShowELSE:1,      Controls trace output.
				     ProgramRec record API_Enabled:1,
				        Repass:1,
				        LabelsBad:1,
				        FirstBetween:1,
				        EndSource:1,
				        BifCheck:1,RandomSeeded:1,NotS9:1,TraceIF:1,ShowELSE:1,PRSpare:6

				     ; InTypes:2     What are the types of the input operand(s)?
				     ; ResultType:2  Mark result on stack with its type.
				     ; AppendNum:1   When opcode is followed by a number.
				     ; AppendRef:1   When opcode (plus maybe number) is followed by a reference.
				     ; DownOne:1     On if operator leaves stack down one on when it started.
				     ; EndsClause:1  On if operator ends a clause. (Only for internal checks)
				     OperatorRec record InTypes:2,ResultType:2,AppendNum:1,AppendRef:1,DownOne:1,
				                        EndsClause:1

				     ; The Dtype byte is too complex to describe as individual flags. See equates.

 000E				     Jshape struc
 0000	      0007 [		      Valued Vshape <>                  ; Will be addressable Vsid. and J.
	       00
	      ] 00
 0008	      0000 [		      Pair dd 0 dup(?)                  ; Next two together.
	       00000000
	      ]
 0008  0000			      Lower Ushortp ?                   ; a subtree.
 000A  0000			      Higher Ushortp ?                  ; a subtree
 000C  0000			      KeyLen word ?                     ; Always a word of length. Chars may follow.
 000E	      0000 [		      Key char 0 dup(?)
	       00
	      ]
				     Jshape ends
 = 000E				     $StrideJ equ size Jshape
				     ; J. is for Jshape objects addressed by [si]; To look up tails.
 = (Jshape ptr[si])		     J is <(Jshape ptr[si])>
				     ; Jbx. is for Jshape objects addressed by [bx]; To look up tails.
 = (Jshape ptr[bx])		     Jbx is <(Jshape ptr[bx])>
				     ; Jdi. is for Jshape objects addressed by [di]; To look up tails.
 = (Jshape ptr[di])		     Jdi is <(Jshape ptr[di])>

				     TokVal record  GrpNdx:6,SubNum:2; Shape of $name
				     TokRec record X02:1, NdxbT:5, Aim:10
				     KeyRec record KeyFlags:3,EndList:1, KeyLen:4
				     ; Shapes for interpreting syntax tables. Ensure match with table generator.
				     ShiftRec record HasShift:1, ErrorAlone:1, CatFlag:1, HasKeys:1, Reference:1,
				                     Direct:1,Indexb:5, Index:5
				     ErrorRec record HasShiftOn:1, ErrorAloneOn:1, MajorField:8, MinorField:6
				     RedRec record HasShiftOff:1, HasAction:1, PruneCt:2, Rtype:2, Rstate:10
				     ; Every element on the parser stack will have the same size but the contents
				     ; are not always the same, except for State which is the reference state
				     ; needed by the parser mechanism.  The other fields are used for error
				     ; message data, and code generation.
				     ; Field order of Sshape is sensitive, matched to pushes that create an item.
				     ParserRec record ParserPad:12,DoRep:1,DoCV:1,Forever:1,DoDataHost:1
 0010				     Sshape struc
 0000  0000			      State word ?
 0002	      0000 [		      Parser word Overlay
	       0000
	      ]
 0002  0000			      ParserRec <>
				     ; Some of these fields could logically be overlaid but they are not, so that
				     ; logic is avoided in deciding what to push. (They are all pushed)
				     ; Actually that applies to just ClauseWas.
 0004  0000			      ClauseWas  word ?; Line number for message 10.n and 7.n
				      union
				       struct; This one for an operation. Element is made on basis that it is this.
 0006  0000			        Token Ushort ?; Numeric coding of the operation.
 0008  00000000			        Operation dword ?; ASCII coding with length ahead, eg 3,">>=".
 000C  0000			        Caller word ?; Resolved reference to what is to be invoked.
 000E  0000			        Parms Ushort ?; To compute how many arguments there are.
				       ends
				       struct; This overlay for info on a SELECT structure. (Also IF & DO)
				        JumpSite word ?; Records how Pcode jumps from WHEN test to WHEN test.
				                       ; (Also used by IF-ELSE)
				        SoFar charp Overlay; For TraceOnly
				        WhatCV charp Overlay; Control variable identification.
				        SelectSite word ?; Records how Pcode jumps from end of WHENs to end SELECT.
				       ends
				      ends
				     Sshape ends
				     ; S. is for Sshape objects addressed by [si+bp]; the parser stack.
 = (Sshape ptr[bp+si])		     S is <(Sshape ptr[bp+si])>
 = 0010				     $StrideS equ size Sshape
 = (Sshape ptr[bp+si+$StrideS])	     S1 is <(Sshape ptr[bp+si+$StrideS])>
 = (Sshape ptr[bp+si+2*$StrideS]     S2 is <(Sshape ptr[bp+si+2*$StrideS])>
   )
				     ParmsRec record ParmsMin:2,ParmsXtr:2,NonCheck:4
				     MiddleRec record NotLabel:1,SemiAfter:1,ValueBefore:1,
				       AbutOK:1,NoBlanks:1,ModEquals:1,EndClause:1,ImplicitValue:1,
				       CheckDO:1,TargetSymbol:1,Function:1,TakenConstant:1,LookLabel:1,
				       LookBin:1,DotOK:1,MRspare:1

				     ; More flags for clause level.
				     ; NotAssign:1,     Off includes DO j=
				     ; ClauseSet:1,     On when ClauseLine set.
				     ; Tailed:1,        Tells Lookup that compound name is on stack.
				     ; WasTailed:1,     Last Lookup was of tailed.
				     ; WasUpper:1,      Remembers UPPER option on PARSE.
				     ; OffFlag:1,       Remembers OFF of CALL OFF.
				     ; Condition:1,     Remembers there was a condition on CALL ON or SIGNAL ON.
				     ; Append:1,        Remembers there is APPEND during ADDRESS.
				     ; Signal:1,        Remembers when the verb was SIGNAL
				     ; CVar:1,          Remembers when there is a control variable on DO.
				     ; Repit:1,         Remembers when there is repetition part in DO.
				     ; PosEq:1,         Grouped with PosPlus & PosMinus - triggers in PARSE.
				     ; InParse:1,       On during Parse instruction. (Off when escape)
				     ; WasParse:1,      On during Parse instruction.
				       ClauseRec record WasUpper:1,OffFlag:1,Condition:1,Append:1,Signal:1,
				       ClauseSet:1,CVar:1,Repit:1,PosEq:1,NotAssign:1,
				       WasParse:1,InParse:1,Tailed:1,WasTailed:1,
				       PosPlus:1,PosMinus:1; Using 5-gap of PosEq and PosPlus.

				     ; Format5:1,       On for FORMAT bif with five args.
				     ; AssignDO:1,      On when assignment is for DO.
				     ; ForExpose:1,     On while executing EXPOSE.
				     ; FromIterCV:1,    Used when DO loop execution has dotted control variable.
				     ; ForBIF:1,        TargetMsg without expanding inserts. Needed for ERRORTEXT.
				     ; TokIsValue:1     Conditions error message insert.
				     ; ExpRange:1,      Number failure due to exponent oversize.
				     ; Description:1,   Used in msg production.
				     ; Compacted:1,     Used to detect a loop within Compaction.
				     ; BcodeInterpret:1, On when INTERPRET executing on behalf of Bcode.
				     ; MapOnly:1,       Used by Debug for when to fill allocations.
				     ; ParseUpper:1,    On when PARSE has UPPER, in execution.
				     ; ParseTrace:1,    On when PARSE tracing, in execution.
				     ; SourceFiles:1, On when source files rather than ordinary data files relevant.
				     ; BoolBefore:1,    On to prevent code generated for trace making undue prefix.
				     ; WasDropped:1     On to tell us that last load of variable found it dropped.
				     CancelRec record Format5:1,AssignDO:1,ForExpose:1,FromIterCV:1,
				      ForBIF:1,TokIsValue:1, ExpRange:1, Description:1, Compacted:1,
				      BcodeInterpret:1, MapOnly:1, ParseUpper:1, ParseTrace:1, SourceFiles:1,
				      BoolBefore:1, WasDropped:1

				     ; Dual:1,          On when the purpose of compiling is clause by clause run.
				     ; DualPending:1,   On when DualGen is to be set later.
				     ; DualGen:1,       On when Pcode for trace events is being made.
				     ; DualOnly:1,      On when Pcode for Dual differs from original.
				     GenRec record Dual:1,DualPending:1,DualGen:1,DualOnly:1,
				      GenSpare:12

				     ; Experience may show how many allocations the Dos space will be in.
 = 000A				     $Ashapes equ 10
				     ; Shortest code for addressing Header fields is varied. If mov with ax, then
				     ; 2-byte offset is reasonable because there are dedicated opcodes. Else it
				     ; will usually pay to specify indexing with a zero-value index because that
				     ; uses a one byte offset. The index can be bp when there is segment override.
				     ; Otherwise it may pay to zero si especially for the purpose.
 0010				     Hshape struct
 0000	      0000 [		      Hdw0 dword Overlay; This and next dword used when making a copy of a segment.
	       00000000
	      ]
 0000  0000			      SegSize Ushort ?  ; Bytes including our header.
				     ; The segments for different purposes need different subsets of these fields.
				     ; They all need SegSize because Compaction uses it.
				     ; The stack segment needs only SegSize because it has its own routine for
				     ; expansion on demand.
				     ; The pool-type segments only need SegSize&Bump; their size changes only when
				     ; the relevant Vars or Consts segment changes size.
 0002  0000			      Bump Ushort ?   ; Number of new bytes added each expansion
				     ; Things that grow independently (Symbols, Vars, Consts, SysFiles, and each
				     ; compound variable) need Avail and Trigger.
 0004  0000			      Avail Ushort ?  ; Place, below Trigger, for new-stuff-at-end.
 0006  0000			      Trigger Ushort ?; Limit before extension.
				     ; Link identifies the type of segment and allows Zone updates.
 0008  0000			      Link Ushort ?   ; To find slot in Zone that addresses this segment.
 000A	      0000 [		      TreeBin Ushort Overlay ; Field reused in the constants lookup segment.
	       0000
	      ]
 000A	      0000 [		      Original Ushort Overlay ; Field reused in the Pcode segment.
	       0000
	      ]
				                              ; (End of original Pcode.)
 000A  0000			      UpPool Segp ?   ; When segment is a pool. (Also used as chain of free ones)
 000C  0000			      Probe Ushort ?  ; Place to start search if this is a lookup type segment.
 000E	      0000 [		      TreeProg Ushort Overlay ; Field reused as root for source file names lookup.
	       0000
	      ]
 000E  0000			      Labels Ushort ? ; Alternative needed since label and constant trees same seg.
				     Hshape ends
 = 0010				     $StrideH equ size Hshape
				     ; H. is for Hshape objects addressed by [si]; Headers on segments (si=0).
 = (Hshape ptr[si])		     H is <(Hshape ptr[si])>
				     ; Hd. is for Hshape objects addressed by ds:; Headers on segments.
 = (Hshape ptr ds:[0])		     Hd is <(Hshape ptr ds:[0])>
				     ; He. is for Hshape objects addressed by es:[bp]; Headers on segments.
 = (Hshape ptr es:[bp])		     He is <(Hshape ptr es:[bp])>
				     ; Hf. is for Hshape objects addressed by fs:[bp]; Headers on segments.
 = (Hshape ptr fs:[bp])		     Hf is <(Hshape ptr fs:[bp])>
				     ; Hg. is for Hshape objects addressed by gs:[bp]; Headers on segments.
 = (Hshape ptr gs:[bp])		     Hg is <(Hshape ptr gs:[bp])>

				     ; Zshape is resized by StackSafe, not by MoreSpaceEs, so doesn't need all
				     ; the Hshape header. It does need SegSize in correct location though because
				     ; Compaction treats it like a headed segment.
 137C				     Zshape struc
 0000	      0000 [		      w word Overlay       ; Not used in this position - always used like Z.w[index]
	       0000
	      ]
 0000  0000			      SegSize word ?       ; Bytes.
 0002	      0000 [		      ProgramCancel dword Overlay; Used for zeroing.
	       00000000
	      ]
 0002  0000			      Program ProgramRec <>; Program flags
 0004  0000			      Cancel CancelRec <>  ; Flags for transient logic.
 0006  0000			      Stack word ? ; Current variable for Compaction. (Top of soft stack-$StrideV)
 0008  0000			      ClauseLine Ushort ?  ; Line this clause starts on. (First token)
 000A  0000			      Middles MiddleRec <> ; Extension of Clause. Keep with Clause for zeroing.
 000C  0000			      Clause ClauseRec <>  ; Compile time clause flags
 000E  0000			      Gen GenRec <>        ; Flags for control of what gets compiled.
 0010  0000			      KWMiddle charp ?     ; List of search keywords.
 0012  0000			      KWFound Ushort ?     ; Latest keyword found.
 0014  0000			      Stdout Handle ?      ; A constant but potential redirection.
 0016  0000			      Stderr Handle ?      ; A constant but potential redirection.
 0018  0000			      SourceHandle Handle ?
 001A  0000			      HowInvoked Ushort ?  ; Length of COMMAND/FUNCTION/SUBROUTINE.
 001C  00			      Radix byte ?         ; Normally has value 10.
 001D	      0006 [		      AxAsNum char 6 dup(?); For result of Ax2DsSiCx
	       00
	      ]
 0023	      0005 [		      Tag char 5 dup(?)    ; For trace. Joined to AxAsNum
	       00
	      ]
 0028  00000000			      Seed dword ?         ; For Random bif.
 002C  0000			      ParseResetSp charp ? ; Where the parser started work on the hard stack.
 002E  0000			      XCycleResetSp charp ?; Where the execution started work on the hard stack.
 0030  0000			      Dumper word ?        ; Handle when we are writing Pcode to disk.
 0032  0000			      Stash word ?         ; Various
 0034  0000			      Resolved charp ?     ; Result of Lookup.
 0036  0000			      Cursor charp ?       ; Offset into code. (Compile time)
 0038  0000			      Stream charp ?       ; The current stream.  In SysFiles segment.
 003A  0000			      Queue  charp ?       ; The FileBx for CRXREXX.QUE in SysFiles segment.
				     ; Compaction exploits these Segp things being adjacent.
 003C	      0000 [		      InsSource dword Overlay
	       00000000
	      ]
 003C	      0000 [		      SysFile dword Overlay
	       00000000
	      ]
 003C  0000			      File charp ?         ; Current external file of source.
 003E  0000			      SysFiles Segp ?      ; DOS interface
 0040  0000			      Consts Segp ?        ; To an array, fixed size per constant.
 0042  0000			      Vars Segp ?          ; To an array, fixed size per variable.
 0044  0000			      ProgScope Segp ?     ; Shadow of Consts. Order is exploited, see MoreSpaceEs.
 0046  0000			      VarScope Segp ?      ; Shadow of Vars.
 0048  0000			      Symbols Segp ?       ; To a write-once for names and constants.
 004A  0000			      Code Segp ?          ; To the internal code.
 004C  0000			      Zone Segp ?          ; Convenient place for Compaction to find address.
				     ; End of section organised for Compaction.
 004E  0000			      Stem Segp ?          ; Used when a stem wants MoreSpaceEs.
 0050  0000			      PoolPool Segp ?      ; Spare VarScope copies.
 0052  0000			      Level charp ?        ; Latest level of invocation.
 0054  0000			      Base0 charp ?        ; Parser time, for checking how many operands pushed.
 0056  0000			      CurrentDO charp ?    ; Junction of DO blocks and stacked values.
 0058  0000			      ResumeP word ?       ; Save Pcode address while Bcode execution.
 005A	      0000 [		      ResumeDF dword Overlay
	       00000000
	      ]
 005A  0000			      ResumeD word ?       ; Digits() preserved over Bcode execution.
 005C  0000			      ResumeF word ?       ; Fuzz() preserved over Bcode execution.
 005E  00			      ResumeS char ?       ; S/E mode preserved over Bcode execution.
				     ; Section set by ZoneNumerics.  (cf NotS9)
 005F	      0000 [		      DigitsFuzz dword Overlay
	       00000000
	      ]
 005F  0000			      Digits Ushort ?      ; Current digits().
 0061  0000			      Fuzz Ushort ?        ; Current fuzz().
 0063  00000000			      Ceiling dword ?      ; 1eN where N is current digits().
 0067  00000000			      DivBreak dword ?     ; To test for enough digits made in division.
 006B  00000000			      TwiceDigits dword ?  ; 2*N where N is current digits().
 006F  0000			      UseGeneral Ushort ?  ; On for mandatory use of ArithGeneral
				     ; end section set by ZoneNumerics.
				     ; Inserts for messages are divided into (a) those that stay constant or which
				     ; we always want to set when compiling, and (b) those that might be undesirably
				     ; changed when we rescan during execution to find the line number for a message.
				     ; The latter are in a block for save/restore.
				     ; "Ins..." is used as help to identify.
 0071  0000			      InsLine Ushort ?     ; Value for insert
 0073  00			      InsBif byte ?        ; Bif offset.
 0074  00000000			      InsOperator dword ?  ; Actual chars.
 0078  0000			      InsUnqual charp ?    ; Offset in SysFiles. For <source> insert, msg 43.1
 007A	      0000 [		      Insert InsBlock <>   ; For message. The saved copy is Inserts.
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 008F	      0000 [		      Inserts InsBlock <>
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 00A4  00			      SignM byte ?         ; Of mantissa
 00A5  00			      SignE byte ?         ; Of exponent
 00A6  0000			      MantPos charp ?      ; Where mantissa starts.
 00A8  0000			      MantPosZi charp ?    ; Beyond end
 00AA  0000			      ExpPos charp ?       ; Where exponent starts.
 00AC  0000			      ExpPosZi charp ?     ; Beyond end
 00AE  0000			      ExpSign word ?
 00B0  0000			      MantSize word ?
 00B2  00			      OpIs byte ?          ; Remembers operator in execution of it.
 00B3  00			      Flags byte ?         ; In BifTypes
 00B4  00			      BifParmsHi byte ?    ; For Bifs to test how many parameters on instance.
 00B5  00			      BifByte byte ?       ; Combines bif number and a parms count.
				     ; Trace section
 00B6  00000000			      TraceAlign dword ?; Beginning of line of source as offset on source file.
 00BA  00000000			      TraceSource dword ?; Beginning of section of source to be shown.
 00BE  00000000			      TraceEnds dword ?; End of section of source to be shown.
 00C2  0000			      TraceSourceColumn word ?
 00C4  0000			      TraceEndsColumn word ?
 00C6  0000			      DualCode charp ?; Beginning of Pcode for one clause.
 00C8  00			      TraceOp byte ?   ; Trace info for current Pcode operation.
 00C9  00000000			      Relative dword ?; Adjustment between position on file and position in buffer.
 00CD  00000000			      RelativeNow dword ?; Used when Serial contains section of source.
 00D1  0000			      Continue word ?; Pcode offset of next clause.
 00D3  0000			      StackX word ?; Hold StackDi over parsing.
 00D5  0000			      TraceLine word ?; Last shown ClauseLine.
 00D7  00000000			      InhibitTrace dword ?
 00DB  00000000			      InhibitPauses dword ?
 00DF  0000			      Target word ?; Used to carry branch value from original pcode to dual.
				     ; Trace section end
				     ; Main also [ Tokens
 00E1  0000			        Scanp charp ?        ; Where the scan has reached. Zero when executing.
 00E3  0000			        EndUsedBuffer charp ?; Where marker to interrupt scan is placed.
 00E5  0000			        NearEnd charp ?      ; Towards end of buffer.
				     ;]
 00E7  00			        CatOp byte ?         ; $pCat or $pAbut
 00E8  00			        RadixBadWhite byte ?
 00E9  0000			        BackExponent charp ?
 00EB  0000			        LastContent charp ?
 00ED  0000			        CommaLine word ?; NonZero if previous line ended with non-continuation comma.
 00EF  0000			        Condition Ushort ?   ; Latest condition keyword.
 00F1  0000			        UntilPlace Ushort ?  ; Place in Pcode. Held just over UNTIL expression.
 00F3  0000			        StemSym charp ?      ; Temp for A.B.C type Lookup
 00F5  0000			        SoFar word ?         ; Temp for A.B.C type Lookup
 00F7  0000			        PcodePos word ?      ; Used by ConstValue
 00F9  0000			        TraceOnly word ?     ; Used to detect 'trace only' labels.
 00FB  0000			      CompareAt word ?       ; For detecting compare Pcode optimizing.
 00FD  0000			      StackHi charp ?        ; Used for compound lookup.
 00FF  0000			      StackLo charp ?        ; Also for function arguments.
 0101  0000			      OnSoft charp ?         ; Where stacked target symbols start. PARSE compiletime.
				                             ; Tokens tells Pcode.
 0103  0000			      Tail charp ?           ; Work when Pcode made for tailed.
 0105  0000			      TokNum word ?          ; As tokenizer makes, parser sees.
 0107  0000			      TokNow word ?
 0109  0000			      TokWas word ?
 010B  0000			        TokData word ?       ; Data for parser derived from TokNum
 010D  0000			        Synch charp ?        ; Instruction pointer, into Pcode, for synching.
 010F  0000			        Lines Ushort ?       ; Count of lines
 0111  0000			        MsgBegin charp ?     ; Where sub-messages concatenated.
 0113  0000			        MsgSoFar charp ?     ; As sub-messages concatenated.
 0115  0000			        PreZi charp ?        ; End of message before expanding insertions.
 0117	      0000 [		        TargetMajMin word Overlay; This is message being output.
	       0000
	      ]
 0117  00			         TargetMinor byte ?
 0118  00			         TargetMajor byte ?
				        struc                ; See DOS command 4Bh
 0119  0000			         EnvSeg Segp ?
 011B  0000 0000		         ForPSP Farp <>
 011F  0000 0000		         Fcb1 Farp <>
 0123  0000 0000		         Fcb2 Farp <>
				        ends
 0127  0000			        AtPause charp ?       ; NYI
 0129  00			        ArgsB byte ?; For Arg() of BCycle bif.
 012A  0000			        ArgsB0 charp ?; For Arg(exp) of BCycle bif.
				     ; Workspace for the verbs can be shared.
				        struct; For Parse
 012C	      0000 [		         Parsee FarpX <>
	       00000000
	      ] 0000 0000
	      0000 [
	       0000
	      ] 0000
 0132  0000			         ParseeNum Ushort ?; Counts arguments for commas in parsing template.
 0134  0000			         PattLenEtc Ushort ?  ; Length of pattern. Temp for cursor.
 0136  0000			         BreakStart charp ?; Beginning of previous section delimiter.
 0138  0000			         BreakEnd charp ?  ; End of previous section delimiter.
				        ends
 013A  0000 0000 0000 0000	        EnvNow EnvBlock <> ; Used to execute ADDRESS
 0142  0000			      CatTotal word ?      ; Used by Abut$$ & Cat$$
 0144  0000			      LastTarget word ?    ; For detecting when to make $pUnstore.
 0146  0000			      NewJshape charp ?    ; Used by FindKey.
 0148  0000			      FromDos charp ?; A slot addressing a segment DOS gave us. (Cat optim. uses)
 014A  0000			      FromDosWas word ?; To test for cycled through them.
 014C  0000			      FromDosZi charp ?; Bound for FromDos
 014E	      000A [		      MemoryTable Ashape $Ashapes dup(<>)
	       0000 0000 0000
	      ]
 018A	      0000 [		      MemoryTableZi byte Overlay; Just used as an offset.
	       00
	      ]
 018A  0000			      Left charp ?     ; For compaction.
 018C  0000			      Right charp ?    ; For compaction.
 018E  00000000			      AllocBase dword ?; For compaction.
				     ; Grouping matters here.
 0192  0000			      DsWas Segp ?
 0194  0000			      DsNew Segp ?
 0196  0000			      EsWas Segp ?
 0198  0000			      EsNew Segp ?     ; Sometimes reloaded from.
 019A  0000			      FsWas Segp ?
 019C  0000			      FsNew Segp ?
 019E  0000			      GsWas Segp ?
 01A0  0000			      GsNew Segp ?
				     if Debug
 01A2  0000			      DebugStash word ?
 01A4  00000000			      DebugD dword ?
				     endif
 01A8  0000			      DigitCount Ushort ?  ; Checking radix string, Compile and execute.
				     ; Byte before Serial better not accidentally look like $Eof.
 01AA  00			      SerialNow byte ? ; Indicates what is in Serial.
 01AB	      11C8 [		      Serial char $SourceBufferSize dup(?)
	       00
	      ]
				      align 4
 1374	      0007 [		      CommandArg Vshape <>; Parameters from Command line.
	       00
	      ] 00
				     Zshape ends
				     ; Z. is for Zshape objects addressed by [bp]; the Zone
 = (Zshape ptr[bp])		     Z is <(Zshape ptr[bp])>

 0053				     Yshape struc
 0000  00000000			      dword ?; Overlays jmp.
 0004  00000001			      N1 dword 1
 0008  0000000A			      N10 dword 10
 000C  00000064			      N100 dword 100
 0010  000003E8			      N1000 dword 1000
 0014  00002710			      N1e4 dword 10000
 0018  000186A0			      N1e5 dword 100000
 001C  000F4240			      N1e6  dword 1000000
 0020  00989680			      N1e7 dword 10000000
 0024  05F5E100			      N1e8 dword 100000000
 0028  3B9ACA00			      N1e9 dword 1000000000
 002C  0019660D			      N1664525 dword 1664525; For Random
				      Assert $Limit_ExponentDigits eq 9
 0030  3B9AA2F1			      ExponHi dword 1000000000-$Limit_Digits
 0034  C4653602			      ExponLo dword -1000000000+2
 0038  0000			      Cseg Segp ?          ; To be where the machine code is.
 003A	      0000 [		      DOS dword Overlay; Default ADDRESS
	       00000000
	      ]
 003A	      0001 [		       db "DOS "
	       44 4F 53 20
	      ]
 003E	      0001 [		      DosPool db "ENVIRONMENT"; Pool name
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
 0049	      0001 [		       db "..."; Joined to following CrLf
	       2E 2E 2E
	      ]
 004C  22			      DqCrLf db '"'
 004D  0D 0A			      CrLf db 13,10
 004F  0000 0000		      StackSave Farp <>    ; To recover when only CS:IP survives.
				     Yshape ends
				     ; Y. is for Yshape objects addressed by [bp]; the constants.
 = (Yshape ptr cs:[bp])		     Y is <(Yshape ptr cs:[bp])>
 = (Yshape ptr cs:[2*ecx+ebp])	     Ycx2 is <(Yshape ptr cs:[2*ecx+ebp])>
 = (Yshape ptr cs:[si])		     Ysi is <(Yshape ptr cs:[si])>

				     ; These equs should follow the declares of shapes they depend on.
 = 0014				     $SizeConstsHeader equ $StrideH+4
				     ; Configuration variables (used by the implementation but not seen by the user's
				     ; program) are in the order the utility that makes Bcode has numbered them. The
				     ; $Reserved string matches.
				     ; Also constants & reserved variables that are always in ProgScope area.
 = 0014				     $?Omitted equ $SizeConstsHeader
 = 001C				     $?MN equ $?Omitted+$StrideV
 = 0024				     $?RS equ $?MN+$StrideV
 = 002C				     $?RESULT equ $?RS+$StrideV
 = 0034				     $?RC equ $?RESULT+$StrideV
 = 003C				     $?SIGL equ $?RC+$StrideV
 = 0044				     $?SysVars equ $?SIGL+$StrideV
				     ; See $Reserved for number of vars here.
 = 000B				     $SysCount equ 11
 = 0000				     ?OUTCOME equ 0; These are the numbers used in Bcode references.
 = 0044				     $?OUTCOME equ $?SysVars; These are the offsets used in machine code references.
				     ; ie where the system variables are in the ProgScope segment.
 = 0002				     ?BIF equ 2
 = 004C				     $?BIF equ $?SysVars+$StrideV
 = 0004				     ?STREAM equ 4
 = 0054				     $?STREAM equ $?SysVars+2*$StrideV
 = 0006				     ?STREAMSTATE equ 6
 = 005C				     $?STREAMSTATE equ $?SysVars+3*$StrideV
 = 0008				     ?RESPONSE equ 8
 = 0064				     $?RESPONSE equ $?SysVars+4*$StrideV
 = 000A				     ?LINEIN_POSITION equ 10
 = 006C				     $?LINEIN_POSITION equ $?SysVars+5*$StrideV
 = 000C				     ?CLAUSETIME equ 12
 = 0074				     $?CLAUSETIME equ $?SysVars+6*$StrideV
 = 000E				     ?CLAUSELOCAL equ 14
 = 007C				     $?CLAUSELOCAL equ $?SysVars+7*$StrideV
 = 0010				     ?MONTHS equ 16
 = 0084				     $?MONTHS equ $?SysVars+8*$StrideV
 = 0012				     ?WEEKDAYS equ 18
 = 008C				     $?WEEKDAYS equ $?SysVars+9*$StrideV
 = 0014				     ?STARTTIME equ 20
 = 0094				     $?STARTTIME equ $?SysVars+10*$StrideV
 = 009C				     $?Nine equ $?SysVars+11*$StrideV
 = 00A4				     $?Zero equ $?Nine+$StrideV
 = 00AC				     $?Null equ $?Zero+$StrideV
 = 00B4				     $?E equ $?Null+$StrideV
 = 00BC				     $?S equ $?E+$StrideV
				     ; These are variables that are always in current VarScope area.
 = 0010				     $?Discard equ $StrideH; Takes two because ends in dot.
 = 0020				     $?RESULTx equ $?Discard+2*$StrideV
 = 0028				     $?RCx equ $?RESULTx+$StrideV
 = 0030				     $?SIGLx equ $?RCx+$StrideV
				     ; Not in the table, but we need to use some character as an end-used-buffer
				     ; mark. (Saves checking address repeatedly) Using Linefeed helps comment scan.
 = 000A				     $EndBuffer equ $Lf
 = 0000				     $Whole     equ 0
 = 0004				     $WholeGE   equ 4
 = 0008				     $WholeGT   equ 8
 = 000C				     $Num       equ 12
 = 0010				     $M090      equ 16
 = 0014				     $WholeNum  equ 20
 = 0018				     $Pad       equ 24
 = 001C				     $Hex       equ 28
 = 0020				     $Stream    equ 32
 = 0024				     $Bin       equ 36
 = 0028				     $Symbol    equ 40

				     AllocAppend macro Goes:req
				      push si
				      mov si,Z.FromDos; The current allocation source.
				      mov ax,A.Fr.Pt
				      sub ax,V.Len
				      cmp ax,V.Pt
				      jne Goes
				     ; Here if offset fits. Also need to check same segment.
				      mov ax,V.Sg
				      cmp ax,A.Fr.Sg
				      jne Goes
				      mov es,ax
				     ; The segment could be full, but if possible take the extra.
				      mov ax,V.Pt
				      add ax,cx
				      jc Goes
				      cmp ax,A.Amount
				      ja Goes
				      mov A.Fr.Pt,ax
				      sub ax,cx
				      mov V.Len,cx
				      endm
				     ; Here are the numbers which go in the Attributes table.
				     ; Most of this is just for compiling but some equates are relevant to
				     ; execution so those have been put in declares.inc
				     ; First two bits for quick test of Whitespace, Letter, Digit, Special
				     ; $White equ 0 $Digit equ 64 $Letter equ 128 $Special equ 192
				     ; When it is not Special, the remaining bits can be flags.
				     ; When it is Special, there is a switch indexed by the rest of the byte.
				     ; This corresponds to the right six bits of TokVal so we can test in groups.
				     ; In practice it is "+ or -" that gets tested this way.
 = 00FC				      $Group equ 0FCh
 = $AttribPlus and $Group	      $PlusMinus equ $AttribPlus and $Group
				     ; The bits to the right of $White are free, and we could distinquish the
				     ; reak blank from blank equivalents but there seems no reason to do so.
				     ; We are short of a bit for letters. It would be nice to have flags for
				     ; conveniently testing "Ee", "Xx", "Bb", "01", ok as hex digit, having upper
				     ; case, and real-letter, as well as $Letter for the purposes of a symbol.
				     ; Something has to be left out, and real-letter would only be used in
				     ; DATATYPE().
				     ; We are short of a bit for digits. It is highly desirable to be able to scan
				     ; a number using lods and not have to refer to the value before xlat (since
				     ; xlat overwrites al). So we would like to have the value of the digit in the
				     ; low order of the attribute, as opposed to subtracting character '0' from the
				     ; raw character. That leaves two, which gives us difficulty if we want
				     ; OK-for-radix-B, OK-for-radix-X, and a Lower-case-letter. (Since we would
				     ; like to test the latter in the symbol recognition loop without distinquishing
				     ; letter/digit first.)
				     ; The solution seems to be to invert the lowercase flag. Then with blanks and
				     ; specials out of the way (jpe), the upperableness can be tested as zeroness
				     ; of Digit flag and NonUpable flag, together.
				     ; So the scheme for Letter-or-Digit is to make the right nibble dependent on
				     ; whether letter or digit, leaving two bits for OK-for-radix.
 = 0020				      $OKb equ 32
 = 0010				      $OKx equ 16
				     ; For letters:
				     ; $NonUpable equ 8 $Bb equ 4 $Xx equ 2 $Ee equ 1
				     ; $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; These values above $STRING go through switching like specials but are not
				     ; seen by the parser.
 = 0027				     $LineFeed equ $Eq-4
 = 0009				     $Invalid equ $UnAccept+1
 = 000A				     $Colon equ $UnAccept+2
 = 00D8				     $AttribAnd equ $Special+$And
 = 00D5				     $AttribOr equ $Special+$Or
 = 00EB				     $AttribEq equ $Special+$Eq
 = 00E4				     $AttribMinus equ $Special+$Minus
 = 00ED				     $AttribLt equ $Special+$Lt
 = 00F0				     $AttribGt equ $Special+$Gt
 = 00D2				     $AttribSlash equ $Special+$Slash
 = 00DC				     $AttribComma equ $Special+$Comma
 = 00E7				     $AttribLine equ $Special+$LineFeed
 = 00E5				     $AttribPlus equ $Special+$Plus
 = 00D1				     $AttribStar equ $Special+$Asterisk
 = 00FF				     $NoMatch equ $Special+63; No character has these attributes.

				     ; Syntax actions, made public to fulfill slots in syntax tables.
				      PUBLIC Action0;   the action for an operand. (Not numbered in the BNF)
				      PUBLIC Action1;   assignment at =
				      PUBLIC Action2;   end of keyword instruction
				      PUBLIC Action3;   end of command
				      PUBLIC Action6;    PARSE VALUE
				      PUBLIC Action10;   a binary op
				      PUBLIC Action11;   a prefix
				      PUBLIC Action12;   comparisons
				      PUBLIC Action18;   a function name or after CALL
				      PUBLIC Action50;   after the subject of PARSE
				      PUBLIC Action51;   ARG verb
				      PUBLIC Action52;   PULL verb
				      PUBLIC Action53;   Trigger
				      PUBLIC Action55;   +-=
				      PUBLIC Action56;   UPPER
				      PUBLIC Action57;   after template
				      PUBLIC Action58;   comma in template
				      PUBLIC Action20;   at THEN
				      PUBLIC Action21;   at ELSE
				      PUBLIC Action22;   end of if
				      PUBLIC Action23;   end of select
				      PUBLIC Action24;   end of otherwise
				      PUBLIC Action25;   end of when
				      PUBLIC Action26;   PROCEDURE
				      PUBLIC Action28;   ITERATE/LEAVE, no VAR
				      PUBLIC Action29;   ITERATE/LEAVE with VAR
				      PUBLIC Action30;   do-end without var after.
				      PUBLIC Action31;   var after do-end
				      PUBLIC Action32;   end of do.
				      PUBLIC Action33;   dorep done
				      PUBLIC Action34;   While
				      PUBLIC Action35;   Until
				      PUBLIC Action36;   FOREVER
				      PUBLIC Action37;   WHILE/UNTIL
				      PUBLIC Action381;   TO
				      PUBLIC Action382;   BY
				      PUBLIC Action383;   FOR
				      PUBLIC Action41;   missing expressions in a list
				      PUBLIC Action43;   a function completes
				      PUBLIC Action44;   CALL Ftn without expression list
				      PUBLIC Action45;   CALL Ftn with expression list
				      PUBLIC Action60;   callon spec.
				      PUBLIC Action61;   after condition
				      PUBLIC Action62;   OFF
				      PUBLIC Action70;   ADDRESS instruction
				      PUBLIC Action71;   INPUT resources
				      PUBLIC Action72;   OUTPUT resources
				      PUBLIC Action73;   ERROR resources
				      PUBLIC Action74;   APPEND
				      PUBLIC Action75;   Environment name
				      PUBLIC Action80;   after numeric.
				      PUBLIC Action90;   Expression ends
				      PUBLIC Action91;   Clause end
				      EXTERN $CondKeys:near, $WithKey:near; To alter lexical keyword lookups.
				      EXTERN Bifs:near; The table of spellings.
				      EXTERN PcodeBif:near
				      EXTERN StrictFlags:near; Used in ConstValue

 = ah				     OpFactAh is <ah>   ; Byte of facts about the operator.
 = al				     OpFactAl is <al>   ; Ditto
				     ;------------------------------------------------------------------------------
				     ; Lookups need access to the Symbols segment so the discipline is to keep
				     ; SymbolsEs in play, as with the rest of compile activity. The segment Pcode
				     ; is made in is addressed by GS. (As it is also in execution, except during
				     ; Compaction). DS and FS do not have specific uses.
				     ; BX is not needed for the attributes table during Pcode generation so can be
				     ; used for the Pcode cursor, CursorBx. (Picked up from Z.Cursor, current
				     ; position in generated Pcode). There are other uses.
				     ; The principal use of DI is as StackDi, with copy to Z.Stack.
				     ; (Other uses, particularly during Lookup.)
				     ; On entry to Actions, SI addresses the parser stack (use S. and ParseSi) but
				     ; it can be reused.
				     ;------------------------------------------------------------------------------

				     ;------------------------------------------------------------------------------
				     ; Before being put in Pcode, operands are given a compact numbering by Lookup.
				     ;------------------------------------------------------------------------------
				      Assert Vshape.Pair eq 0;
				      Assert Vshape.Lower eq 0;
				     ; During the following loop, ArrayBx locates a tree that may contain the
				     ; searched for value, eventually going to zero if the value is not found
				     ; anywhere.
 0000				     Find:; Takes ds and Z.Middles,LookLabel, LookBin.
				     ; Z.Symbols addresses string to look up.
				     ; Searches (and maybe adds item) according to info in DS header.
				     ; The header of segment ds has zone offset of place that addresses the segment.
				     ; On exit ds:bx is the matching item, es:dx::ax addresses the string, and
				     ; Carry on if the item is new. The relevant probe will have been changed
				     ; and Z.Middles.LookLabel will be off.
				     ; SegOffDi will be zone offset (how much of this matters?).
 0000   1   8B 1E 000C		      mov ArrayBx,Hd.Probe
				      Qry Z.Middles,LookLabel,LookBin
 0004   2   F6 46 0A 0C		  1          test Bptr(Z.Middles), low ??0000
 0008  3,1  74 0E		      jz FindNew
 000A   1   8B 1E 000E		      mov ArrayBx,Hd.Labels
 000E				      @@:
				      Qry Z.Middles,LookBin
 000E   2   F6 46 0A 04		  1          test Bptr(Z.Middles), low ??0001
 0012  3,1  74 04		      jz @F
 0014   1   8B 1E 000A		      mov ArrayBx,Hd.TreeBin
 0018				      @@:
 0018				     FindNew:; Enter here with ArrayBx set, eg zero to ensure isolated item.
 0018   1   26: 8B 56 04	      mov ToFindDx,He.Avail
 001C   1   8B F2		      mov si,ToFindDx
 001E   3   26: 0F B6 04	      movzx ToFindLenAx,SymbolsEs:Bptr[si]
 0022   1   40			      inc ToFindLenAx
				     ; LowSi and HighDi are the offsets of slots (with the slots themselves
				     ; containing offsets). Those slots are filled in by the subsequent iteration.
				     ; Use the next available element for this newly developed place so that it
				     ; will be in the right place if the subject is previously unknown.
 0023   1   8B 36 0004		      mov LowSi,Hd.Avail
 0027   1+  8D 7C 02		      lea HighDi,[LowSi+Vshape.Higher]
				     ; In parallel with searching, the tree is being re-arranged to make the
				     ; found (or new) item the root.  This has good performance characteristics
				     ; when references to the same thing are clustered.
 002A				     WhileArrayBx:TestReg ArrayBx
 002A   1   85 DB		  1         test ArrayBx,ArrayBx
 002C  3,1  74 62		     jz LookNoFind
				     ; Do the string (with length) compare.
 002E   1   56			     LookLoop:push si
 002F   1   57			     push di
 0030   1   8B F2		      mov si,ToFindDx
 0032   1   8B 7F 04		      mov di,Vbx.Here
 0035   1   8B C8		      mov cx,ToFindLenAx
 0037   8n  F3/ 26: A6		      repe cmps SymbolsEs:Bptr[si],Bptr[di]
 003A   1   5F			      pop di
 003B   1   5E			      pop si
 003C  3,1  73 46		      jae SymbolsBelow
				     ; We want the next probe to be at a higher place, so must set ArrayBx from
				     ; Higher. At the same time the tree-rewriting info must be maintained.
				     ; LowSi is set to locate a slot in an item where we followed the 'higher'
				     ; locator.  We are stepping on even higher, so we can refill that slot
				     ; (with an offset to where we are now probed) knowing that there is no
				     ; risk that slot contained an offset to the thing we are looking for.
 003E   1   89 1C		      mov [LowSi],ArrayBx; Complete prior iteration
 0040   1+  8D 77 02		      lea LowSi,Vbx.Higher; Note slot to pick up now
 0043   1   8B 1C		      mov ArrayBx,[LowSi]; Pick up
 0045   3   EB E3		      jmp WhileArrayBx
				     ; Found equality.
				     ; Complete each of the two subtrees we have been making, one
				     ; containing items lower than the probe and one containing higher values.
 0047   1   8B 07		     SymbolEq:mov ax,Vbx.Lower
 0049   1   89 04		     mov [LowSi],ax
 004B   1   8B 47 02		     mov ax,Vbx.Higher
 004E   1   89 05		     mov [HighDi],ax
				     ; Make everything one tree rooted at ArrayBx.
 0050   1   8B 36 0004		      mov si,Hd.Avail
 0054   1   66| 8B 34		      mov esi,Vshape.Pair[si]
 0057   1   66| 89 37		      mov Vbx.Pair,esi
 005A   1   8B 3E 0008		      mov SegOffDi,Hd.Link
				      Qry Z.Middles,LookLabel,LookBin
 005E   2   F6 46 0A 0C		  1          test Bptr(Z.Middles), low ??0002
 0062  3,1  75 09		      jnz FoundLabBin
 0064   1   89 1E 000C		      mov Hd.Probe,ArrayBx
 0068   1   89 5E 34		     @@:mov Z.Resolved,ArrayBx
 006B   2   F8			      clc
 006C   5   C3			      ret; Subject found at ArrayBx.
 006D   8   0F BA 76 0A 03	     FoundLabBin:btr Z.Middles,LookLabel
 0072  3,1  72 0A		      jc FoundLabel
				      Off Z.Middles,LookBin
 0074   3   80 66 0A FB		  1          and Bptr(Z.Middles), low not ??0003
 0078   1   89 1E 000A		      mov Hd.TreeBin,ArrayBx
 007C   3   EB EA		      jmp @B
 007E   1   89 1E 000E		     FoundLabel:mov Hd.Labels,ArrayBx
 0082   3   EB E4		      jmp @B

 0084  3,1  74 C1		     SymbolsBelow:je SymbolEq
				     ; This section by symmetry.
 0086   1   89 1D		      mov [HighDi],ArrayBx
 0088   1+  8D 3F		      lea HighDi,Vbx.Lower
 008A   1   8B 1D		      mov ArrayBx,[HighDi]
				      TestReg ArrayBx
 008C   1   85 DB		  1         test ArrayBx,ArrayBx
 008E  3,1  75 9E		      jnz LookLoop
				     ; It was not found. Complete the two isolated trees.  bx is zero.
 0090				     LookNoFind:z Wptr[LowSi]
 0090   1   89 2C		  1           mov Wptr[LowSi],bp
				     z Wptr[HighDi]
 0092   1   89 2D		  1           mov Wptr[HighDi],bp
				     ; Commit the new item we have been making.
 0094   1   8B 3E 0008		      mov SegOffDi,Hd.Link; Address a pointer in the Zone for the current segment
				     ; Commit the symbol just looked up. This is the first use.
 0098   3   E8 01D2		      call TakeSlotDi
 009B   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
 009E   3   26: 01 46 04	      add He.Avail,ToFindLenAx; For next symbol
 00A2   1   89 57 04		      mov Vbx.Here,ToFindDx
				      Qry Z.Middles,LookLabel,LookBin
 00A5   2   F6 46 0A 0C		  1          test Bptr(Z.Middles), low ??0004
 00A9  3,1  75 09		      jnz NewLabBin
 00AB   1   89 1E 000C		      mov Hd.Probe,ArrayBx
 00AF   1   89 5E 34		     @@:mov Z.Resolved,ArrayBx
 00B2   2   F9			      stc
 00B3   5   C3			      ret; Subject new at ArrayBx. SegOffDi active.
 00B4   8   0F BA 76 0A 03	     NewLabBin:btr Z.Middles,LookLabel
 00B9  3,1  72 0A		      jc NewLabel
				      Off Z.Middles,LookBin
 00BB   3   80 66 0A FB		  1          and Bptr(Z.Middles), low not ??0005
 00BF   1   89 1E 000A		      mov Hd.TreeBin,ArrayBx
 00C3   3   EB EA		      jmp @B
 00C5   1   89 1E 000E		     NewLabel:mov Hd.Labels,ArrayBx
 00C9   3   EB E4		      jmp @B
				     ;------------------------------------------------------------------------------
				     ; The general Find mechanism is used to lookup variables, constants, ....
				     ;------------------------------------------------------------------------------
 00CB   1   50			     Lookup:push ax
 00CC   1   52			     push dx
 00CD   1   56			     push si
 00CE   1   57			     push di
				     ; TokNumAh is argument, to determine what sort of lookup.
				     ; If Z.Clause,Tailed off, Lookup what is at Symbols Avail, using the relevant
				     ; tree. OpAppendCl is set.
				     ; If Z.Clause,Tailed on,(and not a label) Lookup parts of what is at V. (SS:DI)
				     ; Commits space in Symbols segment and Vars/Consts segment, for new item(s).
				     ; Z.Resolved is a place to put the result. Also in ArrayBx.

				     ; Select the segment we are searching and the tree within it.
				     ; There are two possibilities for the segment - one for variables and the
				     ; other for labels and constants. The latter contains three independent trees,
				     ; making four possibilities for what is to be searched.
 00CF   8   0F BA 76 0A 04	      btr Z.Middles,TakenConstant
 00D4  3,1  72 45		      jc AsConst
 00D6   1   80 FC 48		      cmp TokNumAh,$VAR_SYMBOL
 00D9  3,1  75 40		      jne AsConst
				     ; Look up a variable symbol.
 00DB   8   0F BA 76 0C 03	      btr Z.Clause,Tailed
 00E0  3,1  0F 82 01BD		      jc LookTailed
 00E4   3p  8E 5E 42		      mov ds,Z.Vars
 00E7   3   E8 FF16		      call Find
 00EA  3,1  73 27		      jnc LookupRet
				     ; The new current pool variable should initially say dropped.
 00EC   3p  8E 66 46		      mov fs,Z.VarScope
 00EF   1   64: C6 47 07 40	      mov Vbxf.Dtype,$Dropped
				      z Z.PoolPool; Shorter pools no longer useful.
 00F4   1   89 6E 50		  1           mov Z.PoolPool,bp
				     ; If it is a stem variable it takes two slots in the variable array.
				     ; The first is for the default value, the second is special data for a stem.
				     ; The second is not in any tree, uses the same characters as its symbol.
 00F7   1   26: 8B 76 04	      mov si,He.Avail
 00FB   2   26: 80 7C FF 2E	      cmp Bptr SymbolsEs:[si-1],'.'
 0100  3,1  75 11		      jne LookupRet
 0102   4   FF 77 04		      push Vbx.Here
 0105   3   E8 0165		      call TakeSlotDi
 0108   1   64: C6 47 07 40	      mov Vbxf.Dtype,$Dropped
 010D   6   8F 47 04		      pop Vbx.Here; So that second slot can be dumped.
 0110   1   83 EB 08		      sub ArrayBx,$StrideV
 0113				     LookupRet:
 0113   1   5F			      pop di
				     if Debug
 0114   3   E8 0000 E		      call Consist
				     endif
 0117   1   5E			      pop si
 0118   1   5A			      pop dx
 0119   1   58			      pop ax
 011A   5   C3			      ret

 011B				     AsConst:Off Z.Clause,Tailed
 011B   3   80 66 0C F7		  1          and Bptr(Z.Clause), low not ??0006
 011F   3p  8E 5E 40		     mov ds,Z.Consts
				     Qry Z.Middles,LookLabel
 0122   2   F6 46 0A 08		  1          test Bptr(Z.Middles), low ??0007
 0126  3,1  75 5B		     jnz AsLabel
				     ; We will have to pop TokNumAh to ch because Find sets ToFindLenAx
 0128   1   50			      push ax
 0129   3   E8 FED4		      call Find
 012C   1   59			      pop cx
 012D  3,1  73 E4		      jnc LookupRet
				     ; Dot as first of symbol makes it reserved, potential message.
				     ; Unless it came as number or quoted.
 012F   1   80 FD 40		      cmp ch,$CONST_SYMBOL
 0132  3,1  75 10		      jne @F
 0134   1   8B F2		      mov si,ToFindDx
 0136   2   26: 80 7C 01 2E	      cmp Bptr SymbolsEs:[si+1],'.'
 013B  3,1  75 07		      jne @F
 013D   1   83 FB 3C		      cmp ArrayBx,$?SIGL
 0140  3,1  0F 87 011C		      ja Raise50p1
 0144				     @@:
				     ; We are here when the constant is looked up for the first time.  We have the
				     ; symbol in literal form (Consts segment) but we also want it in ProgScope
				     ; at run time. (With any needed conversion)
				     ; Add a type byte after the new symbol.
 0144   1   26: 8B 76 04	      mov si,He.Avail
 0148   3   26: FF 46 04	      inc He.Avail
 014C   1   26: C6 04 FF	      mov Bptr SymbolsEs:[si],$tChar
 0150   3p  8E 5E 44		      mov ds,Z.ProgScope
				     ;MASM .................................
				     ; ToFindDx:ToFindLenAx includes a length byte.
 0153   1   8B F2		      mov si,ToFindDx
 0155   1   46			      inc si
 0156   1   48			      dec ToFindLenAx
 0157   1   83 F8 07		      cmp ToFindLenAx,7
 015A  3,1  77 19		      ja @F
				     ; Simplest to always move 8 chars.
				      Move Vbx,SymbolsEs:Vsid,edx
 015C   1   66| 26: 8B 14	  1    mov edx,SymbolsEs:Vsid.OverExpo
 0160   1   66| 89 17		  1    mov Vbx.OverExpo,edx
 0163   1   66| 26: 8B 54 04	  1    mov edx,SymbolsEs:Vsid.OverMant
 0168   1   66| 89 57 04	  1    mov Vbx.OverMant,edx
				     ; Code for short string is $NullString plus length.
 016C   1   C6 47 07 80		      mov Vbx.Dtype,$NullString
 0170   3   00 47 07		      add Vbx.Dtype,al
 0173   3   EB 0C		      jmp AsString
				     ; Setup lengthy string.
 0175   1   C6 47 07 C0		     @@:mov Vbx.Dtype,$AwayString
 0179   1   89 47 04		      mov Vbx.Len,ax
 017C   3   8C 47 02		      mov Vbx.Sg,SymbolsEs
 017F   1   89 37		      mov Vbx.Pt,si
 0181   3   EB 90		     AsString:jmp LookupRet

				     ; Lookup of a label is in a tree devoted to labels.
 0183   1   50			     AsLabel:push ax
 0184   3   E8 FE79		     call Find
 0187   1   58			     pop ax
 0188  3,1  73 61		     jnc LabelKnown
				     ; Mark it amongst symbols as a label.
 018A   1   26: 8B 76 04	      mov si,He.Avail
 018E   1   26: C6 04 FE	      mov Bptr SymbolsEs:[si],$tLabel
 0192   1   26: 89 6C 01	      mov Wptr SymbolsEs:[si+1],ZeroBp
 0196   3   26: 83 46 04 03	      add He.Avail,3
 019B   3   1E			      push ds
 019C   3p  8E 5E 44		      mov ds,Z.ProgScope
 019F   1   89 2F		      mov Vbx.LabelValue,ZeroBp
 01A1   1   C7 47 06 8B00	      mov Vbx.LabelType,StringOrder(0,$Label)
 01A6   3p  1F			      pop ds; (Z.Consts)
				      TestReg TokNumAh
 01A7   1   84 E4		  1         test TokNumAh,TokNumAh
 01A9  3,1  0F 84 0082		      jz WithColon
				     ; First use of name, not with colon. See whether it is a Bif.
 01AD   1   8B FA		      mov di,ToFindDx
				     ; Bifs have length between 3 and 10
 01AF   3   26: 0F B6 05	      movzx ax,SymbolsEs:Bptr[di]
 01B3   1   3C 0A		      cmp al,10
 01B5  3,1  77 27		      ja NotBif
 01B7   1   3C 03		      cmp al,3
 01B9  3,1  72 23		      jb NotBif
 01BB   1   47			      inc di
				     ; Bif tables with the code.
				     ; Setup to search ones of relevant length.
 01BC   1   8B F0		      mov si,ax
 01BE   1   8B C8		      mov cx,ax
 01C0   1   03 F6		      add si,si
 01C2   1   2E: 8B 94 FFFC E	      mov dx,cs:(Bifs-4)[si]
 01C7   1   2E: 8B B4 FFFA E	      mov si,cs:(Bifs-6)[si]
 01CC   1   56			     BifLoop:push si
 01CD   1   57			      push di
 01CE   1   51			      push cx
 01CF   8n  F3/ 2E: A6		      repe cmpsb cs:[si],[di]
 01D2   1   59			      pop cx
 01D3   1   5F			      pop di
 01D4  3,1  74 0B		      je BifFound
 01D6   1   5E			      pop si
 01D7   1   03 F1		      add si,cx
 01D9   1   46			      inc si
 01DA   1   3B F2		      cmp si,dx
 01DC  3,1  75 EE		      jne BifLoop
 01DE   3   E9 FF32		     NotBif:jmp LookupRet

 01E1   3   2E: 0F B6 04	     BifFound:movzx ax,Bptr cs:[si]; Bif compact number.
 01E5   1   5E			      pop si
 01E6   1   05 FF39		      add ax,$BifBase-$BifTag
 01E9   3   EB 47		      jmp SetLabel

 01EB				     LabelKnown:TestReg TokNumAh
 01EB   1   84 E4		  1         test TokNumAh,TokNumAh
 01ED  3,1  0F 85 FF22		     jnz LookupRet; Had it before, no colon here.
				     ; Here for label that has colon.
 01F1   3   1E			      push ds
 01F2   3p  8E 5E 44		      mov ds,Z.ProgScope
 01F5   1   8B 0F		      mov cx,Vbx.LabelValue
 01F7   3p  1F			      pop ds
				      JcxzQ WithColon; No colon or bif spelling before.
 01F8   1   85 C9		  1    test cx,cx
 01FA  3,1  74 33		  1    je WithColon
				     ; Here are the awkward cases - there is a colon but we think we already
				     ; know about the label.
 01FC   1   83 F9 B9		      cmp cx,$BifBase
 01FF  3,1  73 2A		      jae DupBif
				     ; To avoid the appearence of duplication as each label is scanned
				     ; for a second time during Repass, the non-bif labels are given value
				     ; one before that repass. (Can't be a genuine value because of
				     ; the code segment header).
 0201   1   49			      dec cx
 0202  3,1  74 2B		      jz WithColon
				     ; Not a dup when rescan for Synch.
 0204   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 0208  3,1  0F 85 FF07		      jne LookupRet
				     ; Here with something like ABC:NOP;ABC:
				     ; This is allowed, the second one being for trace purposes.
				     ; We leave the first one as it is, and make another that is not in any tree.
				      z ArrayBx
 020C   1   8B DD		  1           mov ArrayBx,bp
 020E   3p  8E 5E 40		      mov ds,Z.Consts
 0211   4   FF 36 000C		      push Hd.Probe
 0215   3   E8 FE00		      call FindNew
 0218   6   8F 06 000C		      pop Hd.Probe
 021C   1   26: 8B 76 04	      mov si,He.Avail
 0220   1   26: C6 04 FE	      mov Bptr SymbolsEs:[si],$tLabel
 0224   3   26: 83 46 04 03	      add He.Avail,3
 0229   3   EB 04		      jmp WithColon

 022B				     DupBif:; Like CALL SUBSTR;...;SUBSTR:
				      On Z.Program,Repass; Will need to start over knowing it is not a bif.
 022B   3   80 4E 03 40		  1          or  Bptr(Z.Program+1), high ??0008
 022F				     WithColon:; If it comes with a colon it isn't a bif.
 022F   1   8B 46 36		      mov ax,Z.Cursor
 0232				     SetLabel:; Put address in the Symbols, after the byte that tags a label.
 0232   1   8B 77 04		      mov si,Vbx.Here
 0235   3   26: 0F B6 0C	      movzx cx,Bptr SymbolsEs:[si]
 0239   1   03 F1		      add si,cx
 023B   1   26: 89 44 02	      mov Wptr SymbolsEs:[si+2],ax
				     ; Also set it under Z.ProgScope.  The copy under Z.Symbols is only used to
				     ; reconstruct Z.ProgScope segment after program made dormant. NYI
 023F   3p  8E 5E 44		      mov ds,Z.ProgScope
 0242   1   89 07		      mov Vbx.LabelValue,ax
				     ; This already done??
 0244   1   C7 47 06 8B00	      mov Vbx.LabelType,StringOrder(0,$Label)
				     ; Maybe trace-only by reason of DO or SELECT
 0249   2   65: 39 6E 0A	      cmp Hg.Original,ZeroBp
 024D  3,1  0F 85 FEC2		      jne LookupRet
 0251   2   39 AE 00F9		      cmp Z.TraceOnly,ZeroBp
 0255  3,1  0F 84 FEBA		      je LookupRet
 0259   1   C6 47 06 01		      mov Bptr Vbx.LabelType,1
 025D   3   E9 FEB3		      jmp LookupRet

				     ; We have not done Between yet, so set Insert.TokLen.
 0260   1   26: 8A 04		     Raise50p1:mov al,SymbolsEs:[si]
 0263   1   88 86 008D		     mov Bptr Z.Insert.TokLen,al
 0267   1   B8 3201		      mov ax,MkMajMin(50,1)
 026A   3   E9 0000 E		      jmp Raise

 026D				     TakeSlotDi:; SegOffDi identifies segment (in Zone).
				     ; Take slot in segment, set bx to it.
				     ; ds will match SegOffDi. May lead to ds update.
 026D   1   BB 0008		      mov ArrayBx,$StrideV
 0270   4   0F C1 1E 0004	      xadd Hd.Avail,ArrayBx
				     ; It will actually be .Vars or .Consts that is gaining a slot.
				     ; .VarScope or .ProgScope to be matching size.
 0275   3p  8E 46 46		      mov es,Z.VarScope
 0278   1   83 FF 42		      cmp SegOffDi,Zshape.Vars
 027B  3,1  74 03		      je @F
 027D   3p  8E 46 44		      mov es,Z.ProgScope
 0280				      @@:
 0280   3   26: 83 46 04 08	      add He.Avail,$StrideV
 0285   1   26: C6 47 07 40	      mov Vbxe.Dtype,$Dropped
 028A   2   3B 1E 0006		      cmp ArrayBx,Hd.Trigger
 028E  3,1  72 0D		      jb @F
 0290   3   E8 0000 E		      call MoreSpaceEs
				     ; The "shadows" are not tested for size; they expand when what they shadow does.
 0293   1   57			      push di
 0294   1   83 C7 04		      add SegOffDi,Zshape.VarScope-Zshape.Vars
 0297   3   E8 0000 E		      call MoreSpaceEs
 029A   1   5F			      pop di
 029B   3p  8E 1B		      mov ds,Z.w[SegOffDi]; DS from Zone is new.
 029D   3p  8E 46 48		     @@:mov SymbolsEs,Z.Symbols
 02A0   5   C3			      ret

				     ; es is at Symbols but to cope with compaction must be picked up often.
				     ; DS:SI has to be picked up again after each possible compaction.
				     ; StackDi is not necessarily Z.Stack because of PARSE targets.
				     ;; There must be an easier way!
 02A1				     LookTailed:On Z.Clause,WasTailed
 02A1   3   80 4E 0C 04		  1          or  Bptr(Z.Clause), low ??0009
 02A5   1   89 BE 0103		       mov Z.Tail,StackDi
 02A9   3   E8 0000 E		       call ToDsSiCx
				     ; We don't want SymbolsSafe (& possible compaction) within the loop.
 02AC   1   57			      push StackDi
 02AD   1   26: 8B 7E 04	      mov di,He.Avail
 02B1   1   03 F9		      add di,cx
 02B3   3   E8 0000 E		      call SymbolsSafe
 02B6   1   5F			      pop StackDi
				      z OpAppendCx
 02B7   1   8B CD		  1           mov OpAppendCx,bp
 02B9   3   0F B6 14		      movzx SymsZiDx,Bptr[LookupSi]
 02BC   1   46			      inc LookupSi
 02BD   1   03 D6		      add SymsZiDx,LookupSi; Runs from DS:SI up to DS:DX
 02BF   1   C7 86 00F5 0001	      mov Z.SoFar,1
				     ; Copy each component in turn to where it can be looked up, ie at Z.Symbols.
 02C5   1   8B BE 0103		     NextSym:mov StackDi,Z.Tail
 02C9   1   51			      push OpAppendCx
 02CA   3   E8 0000 E		      call ToDsSiCx
 02CD   2   03 B6 00F5		      add LookupSi,Z.SoFar
 02D1   1   59			      pop OpAppendCx
 02D2   1   26: 8B 5E 04	      mov LengthAtBx,He.Avail
 02D6   1   8B FB		      mov di,LengthAtBx
				      z ax
 02D8   1   8B C5		  1           mov ax,bp
 02DA   5   AA			      stosb
 02DB   5   AC			     @@:lodsb
 02DC   3   FF 86 00F5		      inc Z.SoFar
 02E0   5   AA			      stosb
 02E1   3   26: FE 07		      inc Bptr SymbolsEs:[LengthAtBx]
 02E4   1   3C 2E		      cmp al,'.'
 02E6  3,1  74 04		      je @F
 02E8   1   3B F2		      cmp LookupSi,SymsZiDx
 02EA  3,1  76 EF		      jbe @B; Pretend dot at limit.
 02EC				     @@:; One name copied, including tailing dot.
 02EC   1   B4 48		      mov TokNumAh,$VAR_SYMBOL
				      JcxzQ SymFirst; For first only, '.' is part of the name.
 02EE   1   85 C9		  1    test cx,cx
 02F0  3,1  74 31		  1    je SymFirst
				     ; After first, can be constant or null.  Lookup needs to be told Const/Var.
 02F2   3   26: FE 0F		      dec Bptr SymbolsEs:[LengthAtBx]
 02F5  3,1  74 0C		      jz Absent
 02F7   1   26: 8A 47 01	      mov al,Bptr SymbolsEs:[LengthAtBx]+1
 02FB   1   3C 39		      cmp al,'9'
 02FD  3,1  77 06		      ja NotNumb
 02FF   1   3C 30		      cmp al,'0'
 0301  3,1  72 02		      jb NotNumb
 0303   1   B4 40		     Absent:mov TokNumAh,$CONST_SYMBOL; No matter if actually NUMBER
 0305   1   51			     NotNumb:push cx
 0306   3   E8 FDC2		      call Lookup
 0309   1   59			      pop cx
 030A   1   8B C3		      mov ax,ArrayBx
 030C   3   E8 0390		      call Pcode2; Reference to part put on Pcode.
				     ; Count of parts is in units of $StrideV.  BumpSym loops through the parts.
 030F   1   80 C1 08		     BumpSym:add OpAppendCl,$StrideV
 0312   1   3B F2		     cmp si,SymsZiDx
 0314  3,1  72 AF		     jb NextSym
				     ; We are through the parts. Put (potential) opcode (and count) onto Pcode
				     ; (We chose not to stack the tail components during compile.)
 0316   1   83 E9 10		      sub OpAppendCx,2*$StrideV; Discount the stem itself. Less one for $pDots arg.
				     ; Set up what caller of Lookup will see as the operand.
				     ; Pcode addresses first of pair of elements.
 0319   1   8B 9E 00F3		      mov ArrayBx,Z.StemSym
 031D   1   89 5E 34		      mov Z.Resolved,ArrayBx
 0320   3   E9 FDF0		      jmp LookupRet

 0323   1   51			     SymFirst:push cx
 0324   3   E8 FDA4		     call Lookup
 0327   1   59			     pop cx
 0328   1   8B C3		     mov ax,ArrayBx
 032A   1   89 86 00F3		     mov Z.StemSym,ax
 032E   3   EB DF		     jmp BumpSym

				     ;------------------------------------------------------------------------------
				     ; Converting constants to desired value representation at compile time.
				     ;------------------------------------------------------------------------------

 0330   1   5B			     NotNumS:pop bx
				     Down
 0331   1   83 EF 08		  1   sub StackDi,$StrideV
 0334   1   89 7E 06		     mov Z.Stack,StackDi
 0337   3   E9 010A		     jmp NotNewConst

 033A				     ConstValue:; Replace constant reference on stack by its value.
				     ; ah says if we want the type enforced. (See DataType letters)
 033A   3   80 7B 07 8A		      cmp V.Dtype,$Constant
 033E  3,1  0F 85 010A		      jne ConstRet
 0342				     ConstValueX:; This entry when that test inline.
 0342   1   56			      push si
 0343   1   50			      push ax
 0344   1   53			      push bx
 0345   1   51			      push cx
 0346   1   66| 52		      push edx
				     ; Remember where Pcode will have to be patched if this operand changes.
 0348   2   8B 5B 02		      mov bx,V.PcodePos
 034B   1   89 9E 00F7		      mov Z.PcodePos,bx
				     ; Consider the constant's value.
 034F   1   8B 1B		      mov bx,V.WhichCon
 0351   3p  8E 66 44		      mov fs,Z.ProgScope
				      Move V,Vbxf,edx
 0354   1   66| 64: 8B 17	  1    mov edx,Vbxf.OverExpo
 0358   1   66| 89 13		  1    mov V.OverExpo,edx
 035B   1   66| 64: 8B 57 04	  1    mov edx,Vbxf.OverMant
 0360   2   66| 89 53 04	  1    mov V.OverMant,edx
				     ; It is bound to be string type at this stage.
 0364   1   80 FC 00		      cmp ah,0
 0367  3,1  75 2B		      jne NotGuess
				     ; ah = 0 means numeric only if reversible (and written w/o quotes. NYI)
 0369   3   E8 0000 E		      call UpStack
				      Move V,V0,edx
 036C   2   66| 8B 53 F8	  1    mov edx,V0.OverExpo
 0370   1   66| 89 13		  1    mov V.OverExpo,edx
 0373   2   66| 8B 53 FC	  1    mov edx,V0.OverMant
 0377   2   66| 89 53 04	  1    mov V.OverMant,edx
 037B   1   53			      push bx
 037C   3   E8 0000 E		      call NumDxBx; If it a number, V will be converted.
 037F  3,1  75 AF		      jnz NotNumS
 0381   3   E8 0000 E		      call StrictFlags; Are the numeric and char exactly the same? (Drops stack two)
 0384   1   5B			      pop bx
 0385   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
				      UpCare
 0388   1+  8D 7D 08		  1   lea StackDi,$StrideV[StackDi]
 038B   1   89 7E 06		      mov Z.Stack,StackDi
 038E  3,1  0F 85 00B2		      jne NotNewConst
 0392   1   B4 4E		      mov ah,'N'
 0394   1   80 FC 4E		     NotGuess:cmp ah,'N'
 0397  3,1  75 65		      jne NotNum
 0399				     AsVar:; Will this string convert to number? Get flag to say.
 0399   1   53			      push bx
 039A   3   E8 0000 E		      call NumDxBx
 039D   1   5B			      pop bx
				     ; Note that Carry will be on if reason for non-binary is non-number syntax, and
				     ; this will feed back to caller.
 039E  3,1  75 58		      jnz AsVarX
				     ; Is a fit to binary number. We need it added (if not there) to the
				     ; symbols segment (with following $tBinary type byte) . A design choice whether
				     ; to have it there as 8 bytes binary, as that converted to char, or as the
				     ; original string.
 03A0   1   57			      push StackDi
 03A1   3p  8E 5E 40		      mov ds,Z.Consts
 03A4   1   8B 77 04		      mov si,Vbx.Here; Original symbol as string.
 03A7   3   26: 0F B6 0C	      movzx cx,Bptr SymbolsEs:[si]; Its length.
				     ; Assure space with symbols for another copy.
 03AB   1   26: 8B 7E 04	      mov di,He.Avail
 03AF   1   03 F9		      add di,cx
 03B1   3   E8 0000 E		      call SymbolsSafe
 03B4   1   2B F9		      sub di,cx
				     ; Copy (with length) to tentative position of use.
 03B6   1   41			      inc cx
 03B7   7n  F3/ 26: A4		      rep movsb [di],es:[si]
				     ; Look in relevant tree for it.
 03BA   1   53			      push bx
 03BB   3p  8E 5E 40		      mov ds,Z.Consts
				      On Z.Middles,LookBin
 03BE   3   80 4E 0A 04		  1          or  Bptr(Z.Middles), low ??000A
 03C2   3   E8 FC3B		      call Find
 03C5   1   5E			      pop si
 03C6   1   5F			      pop StackDi
 03C7   3p  8E 66 44		      mov fs,Z.ProgScope
 03CA  3,1  73 68		      jnc PcodeUses
 03CC   3   87 F3		      xchg si,bx
				     ; Now bx is the char-style constant, si is the new constant.
				     ; Set value for the new item in ProgScope.
				      Move V,Vbxf
 03CE   1   66| 64: 8B 0F	  1     mov ecx,Vbxf.OverExpo
 03D2   1   66| 89 0B		  1     mov V.OverExpo,ecx
 03D5   1   66| 64: 8B 47 04	  1     mov eax,Vbxf.OverMant
 03DA   2   66| 89 43 04	  1     mov V.OverMant,eax
 03DE   3   E8 0000 E		      call NumDxBx
 03E1   1   66| 64: 89 5C 04	      mov fs:Vsid.OverMant,ebx
 03E6   1   66| 64: 89 14	      mov fs:Vsid.OverExpo,edx
				     ; Add a type byte after the new symbol.
 03EA   1   26: 8B 76 04	      mov si,He.Avail
 03EE   3   26: FF 46 04	      inc He.Avail
 03F2   1   26: C6 04 FD	      mov Bptr SymbolsEs:[si],$tBinary
 03F6   3   EB 3C		      jmp PcodeUses

 03F8   2   C6 43 07 89		     AsVarX:mov V.Dtype,$Variable
 03FC   3   EB 46		     jmp NotNewConst

 03FE   1   80 FC 20		     NotNum:cmp ah,' '
 0401  3,1  74 96		     je AsVar
 0403   1   80 FC 57		     cmp ah,'W'
 0406  3,1  74 91		     je AsVar; Variations of number.
 0408   1   80 FC 4F		      cmp ah,'O'
 040B  3,1  75 37		      jne NotNewConst
				     ; Is it already single uppercase letter?
 040D   3   80 7B 07 81		      cmp V.Dtype,$NullString+1
 0411  3,1  75 0C		      jne @F
 0413   1   8A 0B		      mov cl,V.String
 0415   1   80 F9 41		      cmp cl,'A'
 0418  3,1  72 05		      jb @F
 041A   1   80 F9 5A		      cmp cl,'Z'
 041D  3,1  76 25		      jna NotNewConst
				     ; Lookup desired constant.
 041F   3   E8 002B		     @@:call UpperFirstAh
 0422   1   8A 2B		     mov ch,V.String
 0424   1   B1 01		     mov cl,1
 0426   1   26: 8B 76 04	      mov si,He.Avail
 042A   1   26: 89 0C		      mov Wptr SymbolsEs:[si],cx
				      On Z.Middles,TakenConstant
 042D   3   80 4E 0A 10		  1          or  Bptr(Z.Middles), low ??000B
 0431   3   E8 FC97		      call Lookup
				     ; Reference to the old constant, in the Pcode already made, has to change.
 0434   1   8B 46 34		     PcodeUses:mov ax,Z.Resolved
 0437   1   8B B6 00F7		     mov si,Z.PcodePos
 043B   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 043F  3,1  75 03		      jne @F
 0441   1   65: 89 04		      mov gs:[si],ax
 0444				      @@:
 0444				     NotNewConst:mv ds,cs
 0444   3   0E			  1   push cs
 0445   3p  1F			  1   pop ds
 0446   1   66| 5A		      pop edx
 0448   1   59			      pop cx
 0449   1   5B			      pop bx
 044A   1   58			      pop ax
 044B   1   5E			      pop si
 044C   5   C3			     ConstRet:ret

 044D				     UpperFirstAh:;Uppercase first char of the parameter, and retain only that.
				     ; Also left in ah.
 044D   1   51			      push cx
 044E   1   56			      push si
 044F   3   E8 0000 E		      call ToDsSiCx
 0452   1   8A 24		      mov ah,Bptr[si]
 0454   1   80 FC 61		      cmp ah,'a'
 0457  3,1  72 08		      jb @F
 0459   1   80 FC 7A		      cmp ah,'z'
 045C  3,1  77 03		      ja @F
 045E   1   80 E4 DF		      and ah,0DFh
 0461				      @@:
 0461   1   88 23		      mov V.String,ah
 0463   2   C6 43 07 81		      mov V.Dtype,$NullString+1
 0467   1   5E			      pop si
 0468   1   59			      pop cx
 0469   5   C3			      ret

				     ;------------------------------------------------------------------------------
				     ; Pcode generation.
				     ;------------------------------------------------------------------------------


 046A   1   56			     PcodeOp:push si; Put operator in Pcode and make use of its attributes.
				     ; Pick up flags about this Pcode, which comes in al.
				     ; AX used. CX is input when OpAppendCx, not preserved. DX preserved.
				     ; BX used and set to position of last thing placed.
				     ; SI preserved.
				     ; Make the Pcode, then look at effects on the operands.
 046B   1   8A E0		      mov ah,al
 046D   3   D0 E8		      shr al,1
 046F   1   BB 058F R		      mov bx,OpFlags
 0472   4   2E: D7		      xlat cs:Bptr[bx]
 0474   3   86 E0		      xchg ah,al
				     ; Test for special case of implied operand.
 0476   1   F6 C4 02		      test OpFactAh,mask DownOne
 0479  3,1  74 1B		      jz NotImplied
				     ; This flag means "pop compile time stack".
				     ; When PcodeOp called twice, once to advance original, once for trace, the
				     ; compile time stack adjustment should happen once.
				      Qry Z.Gen,DualOnly
 047B   2   F6 46 0F 10		  1          test Bptr(Z.Gen+1), high ??000C
 047F  3,1  75 15		      jnz NotImplied
 0481   1   8B 7E 06		      mov StackDi,Z.Stack
 0484   2   3B 7E 54		      cmp StackDi,Z.Base0
 0487  3,1  75 0D		      jne NotImplied
				     ; If nothing to pop, an operand is implied, eg SAY;
 0489   1   50			      push ax
 048A   1   B8 0014		      mov ax,$?Omitted
 048D   3   E8 020F		      call Pcode2
 0490   1   58			      pop ax
 0491   3   E8 0000 E		      call UpStack
 0494   3   EB 1A		      jmp NotAssig

 0496				     NotImplied:; Exit can come with and without operand. If any, it is used up.
 0496   1   3C 27		      cmp al,$pExit
 0498  3,1  75 06		      jne @F
 049A   4   FF 76 54		      push Z.Base0
 049D   6   8F 46 06		      pop Z.Stack
 04A0				      @@:
				     ; Nov 99. Avoid assignment operator by flagging target.
 04A0   1   3C 93		      cmp al,$pAssign
 04A2  3,1  75 0C		      jne NotAssig
				     ; Have to make the assign if it is for DO.
				      Qry Z.Cancel,AssignDO
 04A4   2   F6 46 05 40		  1          test Bptr(Z.Cancel+1), high ??000D
 04A8  3,1  75 06		      jnz NotAssig
 04AA   3   83 46 34 06		      add Z.Resolved,$CaseTarget
 04AE   3   EB 1F		      jmp Targeted
 04B0				     NotAssig:; Dual mode code has a prefix to each operator.
				      Qry Z.Gen,DualGen
 04B0   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??000E
 04B4  3,1  74 16		      jz NoPfx
 04B6   8   0F BA 76 04 01	      btr Z.Cancel,BoolBefore
 04BB  3,1  72 07		      jc @F
 04BD   1   50			      push ax
 04BE   1   B0 C1		      mov al,$pTraceEvent
 04C0   3   E8 0255		      call Pcode1D
 04C3   1   58			      pop ax
 04C4   1   3C A1		     @@:cmp al,$pBool
 04C6  3,1  75 04		      jne NoPfx
				      On Z.Cancel,BoolBefore
 04C8   3   80 4E 04 02		  1          or  Bptr(Z.Cancel), low ??000F
 04CC   3   E8 0220		     NoPfx:call Pcode1; Place the operator.
 04CF   1   F6 C4 08		     Targeted:test OpFactAh,mask AppendNum
 04D2  3,1  74 05		      jz @F
				     ; This an operator which needs a count after it, like Dots$$.
 04D4   3   91			      xchg ax,OpAppendCx
 04D5   3   E8 0217		      call Pcode1
 04D8   3   91			      xchg OpAppendCx,ax
 04D9   1   F6 C4 04		     @@:test OpFactAh,mask AppendRef
 04DC  3,1  74 08		      jz NoRef
				     ; This will be a variable reference, like the target of an Assign.
 04DE   1   50			      push ax
 04DF   1   8B 46 34		      mov ax,Z.Resolved
 04E2   3   E8 01BA		      call Pcode2
 04E5   1   58			      pop ax
 04E6				     NoRef:
 04E6   1   3C 57		      cmp al,$PjumpBase; The actual value of the operator.
 04E8  3,1  72 24		      jb NoSpace
 04EA   1   3C 89		      cmp al,$PjumpCeil
 04EC  3,1  73 20		      jae NoSpace
				     ; Two bytes of space to be later filled by FillJump, on original pass.
				     ; When just synchronizing, content is not needed.
				     ; When DualGen, the dual code will want the same values as the original, put
				     ; in different places.  So copy out for that potential purpose.
				      Qry Z.Gen,DualOnly
 04EE   2   F6 46 0F 10		  1          test Bptr(Z.Gen+1), high ??0010
 04F2  3,1  75 0A		      jnz @F
				     ; Two different calls to PCodeOp can be involved.
 04F4   1   8B 5E 36		      mov CursorBx,Z.Cursor
				      move Z.Target,Wptr gs:[CursorBx],cx
 04F7   1   65: 8B 0F		  1    mov cx,Wptr gs:[CursorBx]
 04FA   1   89 8E 00DF		  1    mov Z.Target,cx
 04FE   3   E8 019E		     @@:call Pcode2
				      Qry Z.Gen,DualGen
 0501   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0011
 0505  3,1  74 07		      jz NoSpace
				      move Wptr gs:[CursorBx],Z.Target,cx
 0507   1   8B 8E 00DF		  1    mov cx,Z.Target
 050B   1   65: 89 0F		  1    mov Wptr gs:[CursorBx],cx
 050E				     NoSpace:
				     if Debug
 050E   1   50			      push ax
				     endif
 050F   1   8A C4		      mov al,ah
				     ; Now consider the involved operands.
 0511   1   8B 7E 06		      mov StackDi,Z.Stack
				      Qry Z.Gen,DualOnly
 0514   2   F6 46 0F 10		  1          test Bptr(Z.Gen+1), high ??0012
 0518  3,1  75 73		      jnz PcodeOpDone
 051A   1   A8 02		      test OpFactAl,mask DownOne
 051C  3,1  74 13		      jz NotDow
				     ; Maybe the top stack item is just being lost, eg $pBy, or maybe there were
				     ; two items reduced to one by a binary operator. In the latter case we
				     ; want to look twice for constants and to mark result as $Variable.
				     ; In the former case there will be no type given for the result.
				      Assert mask InTypes eq 0C0h
 051E   1   A8 C0		      test OpFactAl,mask InTypes
 0520  3,1  79 05		      jns NotArithBool
 0522   1   B4 4E		      mov ah,'N'
 0524   3   E8 FE13		      call ConstValue
 0527				     NotArithBool:
				      Down
 0527   1   83 EF 08		  1   sub StackDi,$StrideV
 052A   1   89 7E 06		      mov Z.Stack,StackDi
 052D   1   A8 30		      test OpFactAl,mask ResultType
 052F  3,1  74 19		      jz NoChange
				     ; Note that the tables cannot take care of everything, eg multiple downs and
				     ; unknown result type when $pDots.
 0531				     NotDow:
				     ; There can be nothing on the stack, eg Exit$$.
 0531   1   8B 7E 06		      mov StackDi,Z.Stack
 0534   2   3B 7E 54		      cmp StackDi,Z.Base0
 0537  3,1  74 11		      je PcodeOpRet
 0539   1   A8 C0		      test OpFactAl,mask InTypes
 053B  3,1  79 05		      jns CharBest
 053D   1   B4 4E		      mov ah,'N'
 053F   3   E8 FDF8		      call ConstValue
 0542				     CharBest:
 0542   1   A8 30		      test al,mask ResultType
 0544  3,1  74 04		      jz NoChange
 0546   2   C6 43 07 89		      mov V.Dtype,$Variable
 054A				     NoChange:

 054A				     PcodeOpRet:
				     if Debug
 054A   1   58			      pop ax; Recover operator.
 054B   1   8B 7E 06		      mov StackDi,Z.Stack
 054E   2   3B 7E 54		      cmp StackDi,Z.Base0
 0551  3,1  74 3A		      je Not1p
				     ; We can do some debugging of this compile time stack accounting.
				     ; But only on first pass.
 0553   2   65: 39 6E 0A	      cmp Hg.Original,ZeroBp
 0557  3,1  75 34		      jne Not1p
 0559   1   53			      push bx
 055A   1   57			      push di
				      z bx
 055B   1   8B DD		  1           mov bx,bp
 055D   1   8A D8		      mov bl,al
 055F   3   D1 EB		      shr bx,1
 0561   1   2E: 8A 9F 058F R	      mov bl,Bptr OpFlags[bx]
				      Qry bl,EndsClause
 0566   1   F6 C3 01		  1          test bl, ??0013
 0569  3,1  74 20		      jz @F
				     ; Not an eoc if $pBool preceeds comparison. This test OK for debug.
 056B   1   8B 7E 36		      mov di,Z.Cursor
 056E   2   65: 80 7D FE A1	      cmp gs:Bptr[di-2],$pBool
 0573  3,1  74 16		      je @F
 0575   1   8B 4E 06		      mov cx,Z.Stack
 0578   1   8B 5E 54		      mov bx,Z.Base0
 057B   1   8B 76 08		      mov si,Z.ClauseLine
 057E  26   CC			      int 3
 057F   1   B8 3000		      mov ax,MkMajMin(48,0)
 0582   3   E8 0000 E		      call Create4Dump
 0585   3   E8 0000 E		      call Dumper
 0588   3   E9 0000 E		      jmp Raise
 058B   1   5F			     @@:pop di
 058C   1   5B			      pop bx
 058D				     Not1p:;
				     endif
 058D				     PcodeOpDone:
 058D   1   5E			      pop si
 058E   5   C3			      ret

				     if Solid
				     ; This is information for each opcode. Order here doesn't matter, cos org'ed.
				     ; InTypes 00b general, 01b char, 10b arith, 11b Boole.
				     ; ResultType 00b unaltered, 01b char, 10b arith, 11b Boole
				     ; There may also be an appended jump address.  This is determined by a range
				     ; amongst the opcodes.
				     ; Utility CODES.REX scans the OpFlags from here.
 058F				     OpFlags:
				     ; Flags for InTypes, ResultType, AppendNum, AppendRef, DownOne, EndsClause.
				     ; Unary Boole:
				      org OpFlags+$pNot/2
 05A8  F0			      OperatorRec             <3,3,0,0,0,0>
				     ; Diadic Boole
				      org OpFlags+$pXor/2
 05AB  F2			      OperatorRec             <3,3,0,0,1,0>
				      org OpFlags+$pOr/2
 05AA  F2			      OperatorRec              <3,3,0,0,1,0>
				      org OpFlags+$pAnd/2
 05A9  F2			      OperatorRec             <3,3,0,0,1,0>
				     ; Unary arith:
				      org OpFlags+$pNegate/2
 05AD  A0			      OperatorRec          <2,2,0,0,0,0>
				      org OpFlags+$pPositive/2
 05AC  A0			      OperatorRec        <2,2,0,0,0,0>
				     ; Dyadic arith:
				      org OpFlags+$pIntDivide/2
 05B2  A2			      OperatorRec       <2,2,0,0,1,0>
				      org OpFlags+$pMultiply/2
 05B0  A2			      OperatorRec        <2,2,0,0,1,0>
				      org OpFlags+$pDivide/2
 05B1  A2			      OperatorRec          <2,2,0,0,1,0>
				      org OpFlags+$pRemainder/2
 05B3  A2			      OperatorRec       <2,2,0,0,1,0>
				      org OpFlags+$pSubtract/2
 05AF  A2			      OperatorRec        <2,2,0,0,1,0>
				      org OpFlags+$pAdd/2
 05AE  A2			      OperatorRec             <2,2,0,0,1,0>
				      org OpFlags+$pPower/2
 05B4  A2			      OperatorRec           <2,2,0,0,1,0>
				     ; Dyadic char:
				      org OpFlags+$pAbut/2
 058F  52			      OperatorRec            <1,1,0,0,1,0>
				      org OpFlags+$pCat/2
 0590  52			      OperatorRec             <1,1,0,0,1,0>
				     ; Bif related;
				      org OpFlags+$pLength/2
 05A5  60			      OperatorRec          <1,2,0,0,0,0>; Bif route.
				      org OpFlags+$pMax/2
 05A6  A8			      OperatorRec             <2,2,1,0,0,0>; Bif route.
				      org OpFlags+$pMin/2
 05A7  A8			      OperatorRec             <2,2,1,0,0,0>; Bif route.
				      org OpFlags+$pBifq/2
 05A4  08			      OperatorRec            <0,0,1,0,0,0>
				      org OpFlags+$pBif/2
 05E4  08			      OperatorRec             <0,0,1,0,0,0>
				      org OpFlags+$pBifGroup/2
 05E5  08			      OperatorRec        <0,0,1,0,0,0>
				     ; DO parts:
				     ; Rep$$ and Number$$ build a DO block that incorporates their argument,
				     ; RepEver$$ incorporates a spare.  So it makes more sense to say that
				     ; $pNumber lowers the stack and the $pControlVar does not. (It matters to the
				     ; Bcode making utility.)
				     ; $pNumber does have number output but shouldn't look like a binary operator.
				      org OpFlags+$pNumber/2
 0595  82			      OperatorRec          <2,0,0,0,1,0>
				      org OpFlags+$pTo/2
 0596  82			      OperatorRec              <2,0,0,0,1,0>
				      org OpFlags+$pBy/2
 0597  82			      OperatorRec              <2,0,0,0,1,0>
				      org OpFlags+$pWhile/2
 0599  C2			      OperatorRec           <3,0,0,0,1,0>
				      org OpFlags+$pUntil/2
 059A  C2			      OperatorRec           <3,0,0,0,1,0>
				      org OpFlags+$pLeave/2
 059D  01			      OperatorRec           <0,0,0,0,0,1>
				      org OpFlags+$pIterate/2
 059C  01			      OperatorRec         <0,0,0,0,0,1>
				      org OpFlags+$pIterRep/2
 059B  01			      OperatorRec         <0,0,0,0,0,1>
				      org OpFlags+$pRep/2
 05BA  83			      OperatorRec             <2,0,0,0,1,1>
				      org OpFlags+$pRepEver/2
 05BB  01			      OperatorRec         <0,0,0,0,0,1>
				      org OpFlags+$pUnDo/2
 059E  00			      OperatorRec            <0,0,0,0,0,0>
				      org OpFlags+$pFor/2
 0598  82			      OperatorRec             <2,0,0,0,1,0>
				      org OpFlags+$pIterCV/2
 05E0  01			      OperatorRec          <0,0,0,0,0,1>
				      org OpFlags+$pControlVar/2
 05BC  85			      OperatorRec      <2,0,0,1,0,1>
				      org OpFlags+$pDotControlVar/2
 05BD  85			      OperatorRec   <2,0,0,1,0,1>
				     ; Jumps:
				      org OpFlags+$pThen/2
 05BE  C3			      OperatorRec            <3,0,0,0,1,1>
				      org OpFlags+$pWhen/2
 05BF  C3			      OperatorRec            <3,0,0,0,1,1>
				      org OpFlags+$pJump/2
 05C0  00			      OperatorRec            <0,0,0,0,0,0>
				      org OpFlags+$pEq/2
 05C1  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pNe/2
 05C2  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pLt/2
 05C3  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pLe/2
 05C4  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pGe/2
 05C5  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pGt/2
 05C6  32			      OperatorRec              <0,3,0,0,1,0>
				      org OpFlags+$pSeq/2
 05C7  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pSne/2
 05C8  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pSlt/2
 05C9  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pSle/2
 05CA  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pSge/2
 05CB  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pSgt/2
 05CC  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pCeq/2
 05CD  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pCne/2
 05CE  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pClt/2
 05CF  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pCle/2
 05D0  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pCge/2
 05D1  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pCgt/2
 05D2  72			      OperatorRec             <1,3,0,0,1,0>
				      org OpFlags+$pReturn/2
 05A0  01			      OperatorRec          <0,0,0,0,0,1>
				      org OpFlags+$pCallOn/2
 05D6  0D			      OperatorRec          <0,0,1,1,0,1>
				      org OpFlags+$pSignalOn/2
 05D5  0D			      OperatorRec        <0,0,1,1,0,1>
				      org OpFlags+$pSignal/2
 05D4  05			      OperatorRec          <0,0,0,1,0,1>
				      org OpFlags+$pCall/2
 05B9  05			      OperatorRec            <0,0,0,1,0,1>
				      org OpFlags+$pInvoke/2
 05B8  0C			      OperatorRec          <0,0,1,1,0,0>
				      org OpFlags+$pRaise/2
 05E6  08			      OperatorRec           <0,0,1,0,0,0>
				     ; Assignments:
				      org OpFlags+$pAssignConst/2
 05DB  07			      OperatorRec     <0,0,0,1,1,1>
				      org OpFlags+$pAssign/2
 05D8  07			      OperatorRec          <0,0,0,1,1,1>
				      org OpFlags+$pUnstore/2
 05DC  00			      OperatorRec         <0,0,0,0,0,0>
				      org OpFlags+$pAssignStem/2
 05D9  07			      OperatorRec      <0,0,0,1,1,1>
				      org OpFlags+$pAssignDots/2
 05DA  07			      OperatorRec      <0,0,0,1,1,1>
				      org OpFlags+$pAssignDotsP/2
 0592  04			      OperatorRec     <0,0,0,1,0,0>
				     ; Others. Nop sometimes with THEN so cannot use for EndsClause test.
				      org OpFlags+$pNop/2
 0591  00			      OperatorRec             <0,0,0,0,0,0>
				      org OpFlags+$pParse/2
 0593  08			      OperatorRec           <0,0,1,0,0,0>
				      org OpFlags+$pDots/2
 05D7  0E			      OperatorRec            <0,0,1,1,1,0>
				      org OpFlags+$pBool/2
 05DF  00			      OperatorRec            <0,0,0,0,0,0>; Too soon for result.
				      org OpFlags+$pNumeric/2
 05B7  0B			      OperatorRec         <0,0,1,0,1,1>
				      org OpFlags+$pExit/2
 05A2  01			      OperatorRec            <0,0,0,0,0,1>
				      org OpFlags+$pReturns/2
 05A1  03			      OperatorRec         <0,0,0,0,1,1>
				      org OpFlags+$pDrop/2
 05DD  04			      OperatorRec            <0,0,0,1,0,0>
				      org OpFlags+$pExpose/2
 05DE  04			      OperatorRec          <0,0,0,1,0,0>
				      org OpFlags+$pDropList/2
 05EA  02			      OperatorRec        <0,0,0,0,1,0>
				      org OpFlags+$pExposeList/2
 05EB  04			      OperatorRec      <0,0,0,1,0,0>
				      org OpFlags+$pAddress/2
 05E1  01			      OperatorRec         <0,0,0,0,0,1>
				      org OpFlags+$pEnvName/2
 05E3  42			      OperatorRec         <1,0,0,0,1,0>
				      org OpFlags+$pCommand/2
 05B5  43			      OperatorRec         <1,0,0,0,1,1>
				      org OpFlags+$pCommandEnv/2
 05E2  48			      OperatorRec      <1,0,1,0,0,0>
				      org OpFlags+$pResumeParse/2
 0594  00			      OperatorRec     <0,0,0,0,0,0>
				      org OpFlags+$pResult/2
 059F  03			      OperatorRec          <0,0,0,0,1,1>
				      org OpFlags+$pInterpret/2
 05B6  43			      OperatorRec       <1,0,0,0,1,1>
				      org OpFlags+$pOptions/2
 05F0  43			      OperatorRec         <1,0,0,0,1,1>
				      org OpFlags+$pPush/2
 05EC  43			      OperatorRec            <1,0,0,0,1,1>
				      org OpFlags+$pQueue/2
 05ED  43			      OperatorRec           <1,0,0,0,1,1>
				      org OpFlags+$pTrace/2
 05EE  43			      OperatorRec           <1,0,0,0,1,1>
				      org OpFlags+$pSignalOff/2
 05E7  09			      OperatorRec       <0,0,1,0,0,1>
				      org OpFlags+$pSignalV/2
 05E8  03			      OperatorRec         <0,0,0,0,1,1>
				      org OpFlags+$pInterpEnd/2
 05D3  01			      OperatorRec       <0,0,0,0,0,1>
				      org OpFlags+$pSay/2
 05A3  43			      OperatorRec             <1,0,0,0,1,1>
				      org OpFlags+$pSysVar/2
 05E9  00			      OperatorRec          <0,0,0,0,0,0>
				      org OpFlags+$pTraceEvent/2
 05EF  08			      OperatorRec      <0,0,1,0,0,0>
				      org OpFlags+$PcodesCeil

				     ;------------------------------------------------------------------------------
				     ; This is the tie-in between lexical values and Pcode operators.
				     ;------------------------------------------------------------------------------
				     ; To get freedom over the numbers corresponding to Pcodes, there is a
				     ; translation table from syntax code ($s) to the opcode in the Pcode.
				     ; AL contains the operator. SI is in use for the parser frame.
				     ; DI can be used.

				     ; After the freedoms in group order have been used, there are numeric
				     ; relations between the codes for the syntax elements. These are made
				     ; use of in actions when materializing the $s codes.  The $s codes are
				     ; nearly compact but not in the best order for execution so there is
				     ; later a $s to $p conversion.
				     ; The relations that have to be fitted around are:
				     ;BBBBBB  B           BB     BBBBBBBBBBBB                     BB  B
				     ;                                          V   VV  VVVVV   V   VV
				     ;                                            U   UU
				     ;          P   PPP P   P   P
				     ;         S   S   S
				     ;                                       NN  N
				     ;                                                       III
				     ;      DD   DD
				     ;                       LMM
				     ; Also see intervals for DROP & EXPOSE type.(Got this wrong & had to fixup.)
				     ; Also see needs of PosPlus PosMinus PosEq. (Would like to fit here but
				     ; actually used flags.)
				     ; Also need Length-Max-Min sequential.
 0654				     S2P:
				      Assert $sPercent eq $-S2P
 0654 = 0644			     BaseB equ $-$Percent
				      Assert $ eq BaseB+$Percent
 0654  47			      db $pIntDivide
				      Assert $ eq BaseB+$Asterisk
 0655  43			      db $pMultiply
				      Assert $ eq BaseB+$Slash
 0656  45			      db $pDivide
				      Assert $ eq BaseB+$Rem
 0657  49			      db $pRemainder
				      Assert $ eq BaseB+$Xor
 0658  39			      db $pXor
				      Assert $ eq BaseB+$Or
 0659  37			      db $pOr
				     ; DROP and EXPOSE are treated together. Also DropList and ExposeList
 065A = 05A2			      BaseD equ $-$DROP
				      Assert $sDrop eq $-S2P
				      Assert $ eq BaseD+$DROP
 065A  9D			      db $pDrop
 065B  9F			      db $pExpose
				      Assert $ eq BaseB+$And
 065C  35			      db $pAnd
				     ; STEM/STREAM/NORMAL are treated together
 065D = 0551			     BaseS equ $-$STEM
				      Assert $sStem eq $-S2P
				      Assert $ eq BaseS+$STEM
 065D  00			      db $nStem
				     ; PARSE sources are done together.
 065E = 05E6			     BaseP equ $-$WITH
				      Assert $sWith eq $-S2P
				      Assert $ eq BaseP+$WITH
 065E  02			      db $nWith
				      Assert $sDropList eq $-S2P
 065F  B7			      db $pDropList
 0660  B9			      db $pExposeList
				      Assert $ eq BaseS+$STREAM
 0661  20			      db $nStream
				     ; Historically there were opcodes like $pLineIn but latest is to use markers.
				      Assert $ eq BaseP+$LINEIN
 0662  06			      db $nLineIn
				      Assert $ eq BaseP+$SOURCE
 0663  0A			      db $nSource
				      Assert $ eq BaseP+$VERSION
 0664  0C			      db $nVersion
				      Assert $ eq BaseS+$NORMAL
 0665  40			      db $nNormal
				      Assert $ eq BaseP+$PULL
 0666  08			      db $nPull
 0667  00			      db 0 ; Spare
				      Assert $sMinus eq $-S2P
				      Assert $ eq BaseB+$Minus
 0668  41			      db $pSubtract
				      Assert $ eq BaseB+$Plus
 0669  3F			      db $pAdd
				      Assert $ eq BaseP+$VAR
 066A  00			      db $nVar
				      Assert $sLength eq $-S2P
 066B  2D			      db $pLength
 066C  2F			      db $pMax
 066D  31			      db $pMin
				      Assert $ eq BaseP+$ARG
 066E  04			      db $nArg
				     ; Eq was forced to top of its group, in order to make comparisons compact.
				      Assert $sEq eq $-S2P
				      Assert $ eq BaseB+$Eq
 066F  65			      db $pEq
				      Assert $ eq BaseB+$Ne
 0670  67			      db $pNe
				      Assert $ eq BaseB+$Lt
 0671  69			      db $pLt
				      Assert $ eq BaseB+$Le
 0672  6B			      db $pLe
				      Assert $ eq BaseB+$Ge
 0673  6D			      db $pGe
				      Assert $ eq BaseB+$Gt
 0674  6F			      db $pGt
				      Assert $sSeq eq $-S2P
				      Assert $ eq BaseB+$Seq
 0675  71			      db $pSeq
				      Assert $ eq BaseB+$Sne
 0676  73			      db $pSne
				      Assert $ eq BaseB+$Slt
 0677  75			      db $pSlt
				      Assert $ eq BaseB+$Sle
 0678  77			      db $pSle
				      Assert $ eq BaseB+$Sge
 0679  79			      db $pSge
				      Assert $ eq BaseB+$Sgt
 067A  7B			      db $pSgt
				     ; NUMERIC components are done together.
 067B = 0597			     BaseN equ $-$DIGITS
				      Assert $sDigits eq $-S2P
				      Assert $ eq BaseN+$DIGITS
 067B  00			      db $nDigits
				      Assert $ eq BaseN+$FUZZ
 067C  02			      db $nFuzz
 067D  00			      db 0; $sTailed was here, now unneeded
				     ; Several verbs are done together.
 067E = 05DE			     BaseV equ $-$NOP
				      Assert $sNop eq $-S2P
				      Assert $ eq BaseV+$NOP
 067E  05			      db $pNop
				      Assert $sForm eq $-S2P
				      Assert $ eq BaseN+$FORM
 067F  04			      db $nForm
 0680 = 0660			     BaseU equ $-$Not
				      Assert $ eq BaseU+$Not
 0680  33			      db $pNot
				      Assert $sAddress eq $-S2P
 0681  A5			      db $pAddress
				      Assert $ eq BaseV+$INTERPRET
 0682  4F			      db $pInterpret
				      Assert $ eq BaseV+$OPTIONS
 0683  C3			      db $pOptions
				      Assert $sNegate eq $-S2P
				      Assert $ eq BaseU+$Minus
 0684  3D			      db $pNegate
				      Assert $sPositive eq $-S2P
				      Assert $ eq BaseU+$Plus
 0685  3B			      db $pPositive
				      Assert $sExit eq $-S2P
				      Assert $ eq BaseV+$EXIT
 0686  27			      db $pExit
				      Assert $ eq BaseV+$PUSH
 0687  BB			      db $pPush
				      Assert $ eq BaseV+$QUEUE
 0688  BD			      db $pQueue
				      Assert $sReturns eq $-S2P
				      Assert $ eq BaseV+$RETURN
 0689  25			      db $pReturns
				      Assert $ eq BaseV+$SAY
 068A  29			      db $pSay
				      Assert $sNumber eq $-S2P
 068B  0D			      db $pNumber
 068C  00			      db 0;
				      Assert $sRaise eq $-S2P
 068D  AF			      db $pRaise
				      Assert $ eq BaseV+$TRACE
 068E  BF			      db $pTrace
 068F  00			      db 0; was $sCatDot now unneeded.
				      Assert $ eq BaseB+$Abut
 0690  01			      db $pAbut
				      Assert $ eq BaseB+$Cat
 0691  03			      db $pCat
				      Assert $sLeave eq $-S2P
				      Assert $ eq BaseV+$LEAVE
 0692  1D			      db $pLeave
				      Assert $sIterate eq $-S2P
				      Assert $ eq BaseV+$ITERATE
 0693  1B			      db $pIterate
				      Assert $ eq BaseB+$Power
 0694  4B			      db $pPower
				     endif

 0695   1   53			     Scode:push bx
 0696   1   BB 0654 R		     mov bx,S2P; For XLAT
 0699   4   2E: D7		     xlat cs:Bptr[bx]; Pick up Pcode.
 069B   1   5B			      pop bx
 069C   3   E9 FDCB		      jmp PcodeOp

				     ;------------------------------------------------------------------------------
				     ; Here is where values are directly put into the code segment.
				     ; Pcode2 with Z.Synch=0 puts two bytes of original code in.
				     ; Pcode2 with Z.Synch\=0 adjusts Z.Cursor by 2 to reflect bytes made earlier
				     ; and also makes two bytes dual code at Hg.Avail if DualGen is on.
				     ; So Pcode2 is used when making original, when synching, and when original
				     ; and dual code are to be the same.
				     ; When original and dual are not to be the same:
				     ; Pcode2S is Pcode2 without possibility of making dual code.
				     ; Pcode2D makes the dual code without adjusting Z.Cursor.
				     ; Assert DualGen on implies Z.Synch\=0
				     ;------------------------------------------------------------------------------
 069F				     Pcode2:Qry Z.Gen,DualGen
 069F   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0014
 06A3  3,1  75 30		     jnz Pcode2DSame
 06A5   1   8B 5E 36		     Pcode2S:mov CursorBx,Z.Cursor
 06A8   2   3B AE 010D		     cmp ZeroBp,Z.Synch
 06AC  3,1  75 12		     jne NotOrig
				     ; Original make.
				     if Debug
 06AE   2   65: 3B 5E 04	      cmp CursorBx,Hg.Avail
 06B2  3,1  74 01		      je @F
 06B4  26   CC			      int 3
 06B5				      @@:
				     endif
 06B5   3   E8 006F		      call PcodeSafeGsBx
 06B8   1   65: 89 07		      mov gs:Wptr[CursorBx],ax
 06BB   3   65: 83 46 04 02	      add Hg.Avail,2
 06C0   3   83 46 36 02		     NotOrig:add Z.Cursor,2
 06C4   1   53			      push CursorBx
				      inc2 CursorBx
 06C5   1   43			  1   inc CursorBx
 06C6   1   43			  1   inc CursorBx
 06C7   2   39 AE 010D		     PcodeRet:cmp Z.Synch,ZeroBp
 06CB  3,1  74 06		      je @F
 06CD   2   3B 9E 010D		      cmp CursorBx,Z.Synch
 06D1  3,1  74 7B		      je SynchMatch
 06D3   1   5B			     @@:pop CursorBx
 06D4   5   C3			      ret

 06D5				     Pcode2DSame:Qry Z.Gen,DualOnly
 06D5   2   F6 46 0F 10		  1          test Bptr(Z.Gen+1), high ??0015
 06D9  3,1  75 04		     jnz Pcode2D
 06DB   3   83 46 36 02		     add Z.Cursor,2
 06DF   1   65: 8B 5E 04	     Pcode2D:mov CursorBx,Hg.Avail
 06E3   3   E8 0041		     call PcodeSafeGsBx
 06E6   1   65: 89 07		     mov gs:Wptr[CursorBx],ax
 06E9   3   65: 83 46 04 02	      add Hg.Avail,2
 06EE   5   C3			      ret

 06EF				     Pcode1:Qry Z.Gen,DualGen
 06EF   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0016
 06F3  3,1  75 1A		     jnz Pcode1DSame
 06F5   1   8B 5E 36		     Pcode1S:mov CursorBx,Z.Cursor
 06F8   2   3B AE 010D		     cmp ZeroBp,Z.Synch
 06FC  3,1  75 0A		     jne @F
 06FE   3   E8 0026		      call PcodeSafeGsBx
 0701   1   65: 88 07		      mov gs:Bptr[CursorBx],al
 0704   3   65: FF 46 04	      inc Hg.Avail
 0708   3   FF 46 36		     @@:inc Z.Cursor
 070B   1   53			      push CursorBx
 070C   1   43			      inc CursorBx
 070D   3   EB B8		      jmp PcodeRet

 070F				     Pcode1DSame:Qry Z.Gen,DualOnly
 070F   2   F6 46 0F 10		  1          test Bptr(Z.Gen+1), high ??0017
 0713  3,1  75 03		     jnz Pcode1D
 0715   3   FF 46 36		     inc Z.Cursor
 0718   1   65: 8B 5E 04	     Pcode1D:mov CursorBx,Hg.Avail
 071C   3   E8 0008		     call PcodeSafeGsBx
 071F   1   65: 88 07		     mov gs:Bptr[CursorBx],al
 0722   3   65: FF 46 04	      inc Hg.Avail
 0726   5   C3			      ret

 0727				     PcodeSafeGsBx:; Called when extending Pcode - may need to enlarge the segment.
 0727   2   65: 3B 5E 06	     @@:cmp CursorBx,Hg.Trigger
 072B  3,1  72 10		     jb @F
 072D   1   57			      push di
 072E   1   BF 004A		      mov di,Zshape.Code
 0731   3   E8 0000 E		      call MoreSpaceEs
 0734   1   5F			      pop di
				      mv gs,es
 0735   3   06			  1   push es
 0736   3p  0F A9		  1   pop gs
 0738   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
 073B   3   EB EA		      jmp @B
 073D   5   C3			     @@:ret

 073E   3   83 6E 36 02		     BackOff2:sub Z.Cursor,2
 0742   2   39 AE 010D		     cmp Z.Synch,ZeroBp
 0746  3,1  75 05		     jne @F
 0748   3   65: 83 6E 04 02	     sub Hg.Avail,2
 074D   5   C3			     @@:ret

				     ; Sometimes synchronizing is just to get .MN or msg setup.
 074E				     SynchMatch:Qry Z.Gen,Dual
 074E   2   F6 46 0F 80		  1          test Bptr(Z.Gen+1), high ??0018
 0752  3,1  0F 84 08B8		     jz Terminate
				     ; In this case we have synched in order to setup making dual pcode as we
				     ; continue to the next clause.
				      move Z.DualCode,Hg.Avail,bx; Where code for clause will be made.
 0756   1   65: 8B 5E 04	  1    mov bx,Hg.Avail
 075A   1   89 9E 00C6		  1    mov Z.DualCode,bx
				      On Z.Gen,DualPending
 075E   3   80 4E 0F 40		  1          or  Bptr(Z.Gen+1), high ??0019
 0762   1   5B			      pop CursorBx
 0763   5   C3			      ret

				     ;------------------------------------------------------------------------------
				     ; Generation for Operands.
				     ;------------------------------------------------------------------------------
 0764				     Action0:; The uppercased symbol will be sitting in the Symbols segment.
				     ; Except in the case of a target with dots, it will get looked up.
				     ; Dots are not significant if symbol is taken as a constant.
				      Qry Z.Middles,LookLabel
 0764   2   F6 46 0A 08		  1          test Bptr(Z.Middles), low ??001A
 0768  3,1  0F 85 F95F		      jnz Lookup; And from there ret to Action0 caller.
				      Qry Z.Clause,Tailed
 076C   2   F6 46 0C 08		  1          test Bptr(Z.Clause), low ??001B
 0770  3,1  75 28		      jnz Action0Dots
				     ; Undotted, can be resolved now.
 0772   3   E8 F956		      call Lookup; Result to Z.Resolved
				     ; A target will be held over on the stack, a CheckDO symbol will be held in
				     ; Resolved until the check is made.
				      Qry Z.Middles,TargetSymbol,CheckDO
 0775   2   F6 46 0A C0		  1          test Bptr(Z.Middles), low ??001C
 0779  3,1  74 5E		      jz QueryLoad; Result into Pcode.
				     ; A case like LEAVE ABC does not need resolved ABC kept on the stack.
				      Qry Z.Middles,TargetSymbol
 077B   2   F6 46 0A 40		  1          test Bptr(Z.Middles), low ??001D
 077F  3,1  74 0C		      jz Action0ret
				     ; But ABC= does.
 0781   3   E8 0000 E		      call UpStack
				      move V.HeldOver,Z.Resolved
 0784   1   8B 46 34		  1      mov ax,Z.Resolved
 0787   1   89 03		  1      mov V.HeldOver,ax
 0789   2   C6 43 07 80		      mov V.Dtype,$NullString
 078D   5   C3			     Action0ret:ret


 078E				     ChkDO:On Z.Middles,TakenConstant
 078E   3   80 4E 0A 10		  1          or  Bptr(Z.Middles), low ??001E
 0792   3   E8 F936		     call Lookup
				     ; eg LEAVE A.B - just need Z.Resolved for comparison.
 0795   3   83 6E 06 08		      sub Z.Stack,$StrideV
 0799   5   C3			      ret

 079A   3   E8 0000 E		     Action0Dots:call UpStack
				     ; CheckDO is for symbol with END/ITERATE/LEAVE.
				     ; Dotted CheckDO subject - resolved as "A.B".
				      Qry Z.Middles,CheckDO
 079D   2   F6 46 0A 80		  1          test Bptr(Z.Middles), low ??001F
 07A1  3,1  75 EB		      jnz ChkDO
				     ; Usual dotted - On soft stack as a string.
				      mv ds,es
 07A3   3   06			  1   push es
 07A4   3p  1F			  1   pop ds
 07A5   1   8B 36 0004		      mov si,Hd.Avail
 07A9   3   0F B6 0C		      movzx cx,Bptr[si]
 07AC   1   41			      inc cx
 07AD   1   50			      push ax
 07AE   3   E8 0000 E		      call ResultSpace
 07B1   1   57			      push di
 07B2   1   8B F8		      mov di,ax
 07B4   7n  F3/ A4		      rep movsb
 07B6   1   5F			      pop di
 07B7   1   58			      pop ax
 07B8   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
				     ; Unless a target, the Pcode for the dotted reference will be made now.
				      Qry Z.Middles,TargetSymbol
 07BB   2   F6 46 0A 40		  1          test Bptr(Z.Middles), low ??0020
 07BF  3,1  74 05		      jz @F
				      Off Z.Clause,Tailed
 07C1   3   80 66 0C F7		  1          and Bptr(Z.Clause), low not ??0021
 07C5   5   C3			      ret
				     ; In execution tail components stack but during compile they don't.
 07C6				     @@:; This type awkward in PARSE.
 07C6   8   0F BA 76 0C 04	      btr Z.Clause,InParse
 07CB  3,1  73 05		      jnc @F
 07CD   1   B0 12		      mov al,$mParseEscape
 07CF   3   E8 FF1D		      call Pcode1
 07D2				      @@:
 07D2   3   E8 F8F6		      call Lookup
				     ; Delay the $pDots because it may be $Drop instead.
 07D5   3   83 6E 06 08		      sub Z.Stack,$StrideV

				     ; At this time Z.Resolved is set but before we put the reference in the Pcode
				     ; there are some cases to test where this isn't just a load.
 07D9				     QueryLoad:
				     ; DROP abc and EXPOSE abc are not NOVALUE positions so best if opcode
				     ; precedes operand. On the other hand DROP (abc) is a NOVALUE position.
				     ; EXPOSE (abc) is a NOVALUE position where EXPOSE happens before getting
				     ; the value.
				     ; So maybe best is DROP A => $pDrop A, EXPOSE A => $pExpose A,
				     ; DROP A. => $pDrop A., EXPOSE A. => $pExpose A.,
				     ; DROP A.B => B $pDrop A., EXPOSE A.B => B $pExpose A.
				     ; DROP (A) => A $pDropList, EXPOSE (A) => $pExposeList A
				     ; DROP (A.B) => A.B $pDropList, EXPOSE (A.B) => B $pExposeList A.
				     ; For a.b or (a.b) the tails are already in the Pcode and Z.Resolved is a.
 07D9   1   8B 46 12		      mov ax,Z.KWFound
 07DC   1   3D 00B8		      cmp ax,$DROP
 07DF  3,1  74 07		      je IsDrop
 07E1   1   3D 00BC		      cmp ax,$EXPOSE
 07E4  3,1  75 30		      jne PcodeLoadX
 07E6   1   2C 03		      sub al,3; Fix 'cos I got EXPOSE value wrong.
				     ; Here with DROP and EXPOSE
 07E8   1   04 4E		     IsDrop:add al,$sDrop-$DROP
				     ; Opcode to absorb whether argument is a list.
 07EA   2   83 BE 0109 0C	      cmp Z.TokWas,$Lparen
 07EF  3,1  75 02		      jne @F
 07F1   1   04 05		      add al,$sDropList-$sDrop
 07F3				      @@:
				     ; DropList has no post argument.
 07F3   1   3C 0B		      cmp al,$sDropList
 07F5  3,1  74 07		      je DropList
				      Off Z.Clause,WasTailed
 07F7   3   80 66 0C FB		  1          and Bptr(Z.Clause), low not ??0022
 07FB   3   E9 FE97		      jmp Scode; And the $pDrop/$pExposed will add Z.Resolved (without load).

				     ; WasTailed must be cleared for next lookup.
 07FE   8   0F BA 76 0C 02	     DropList:btr Z.Clause,WasTailed
 0803   1   50			     push ax
 0804  3,1  72 07		      jc @F
 0806   3   E8 0026		      call PcodeLoad
 0809   1   58			      pop ax
 080A   3   E9 FE88		      jmp Scode

 080D				     @@:OpAl $pDots; Flags on $pDots will add Z.Resolved.
 080D   1   B0 91		  1    mov al,$pDots
 080F   3   E8 FC58		  1    call PcodeOp
 0812   1   58			      pop ax
 0813   3   E9 FE7F		      jmp Scode

 0816   8   0F BA 76 0C 02	     PcodeLoadX:btr Z.Clause,WasTailed
 081B  3,1  73 12		     jnc PcodeLoad
 081D   3   E8 0000 E		      call UpStack
 0820   3   E8 0000 E		      call UpStack
				      OpAl $pDots
 0823   1   B0 91		  1    mov al,$pDots
 0825   3   E8 FC42		  1    call PcodeOp
 0828   2   C6 43 07 89		      mov V.Dtype,$Variable
 082C   3   E9 008A		      jmp PcodeLoadRet

 082F				     PcodeLoad:; Puts the latest operand into Pcode with value to stack.
				     ; Often it will be a variable and "value" will be synthetic.
 082F   1   8B 5E 34		      mov ArrayBx,Z.Resolved
 0832   3   E8 0000 E		      call UpStack
				     ; If is a constant, it's value is around. Else synthesize a general value.
 0835   2   C6 43 07 89		      mov V.Dtype,$Variable
 0839   1   F6 C3 07		      test bl,7
 083C  3,1  74 3A		      jz IsVar
				     ; That test isn't quite good enough because some persistent variables, eg .MN,
				     ; are in segment for "constants". Nine is always first constant, cf Reserved.
 083E   1   81 FB 009C		      cmp bx,$?Nine
 0842  3,1  73 14		      jae UsualCon
 0844   2   C6 43 07 48		      mov V.Dtype,$Sigl
				     ; This type awkward in PARSE.
 0848   8   0F BA 76 0C 04	      btr Z.Clause,InParse
 084D  3,1  73 29		      jnc IsVar
 084F   1   B0 12		      mov al,$mParseEscape
 0851   1   53			      push bx
 0852   3   E8 FE9A		      call Pcode1
 0855   1   5B			      pop bx
 0856   3   EB 20		      jmp IsVar
 0858				     UsualCon:
				     ; Well, we do have the value in Vbx. but now is a bit early to load it because
				     ; we don't know what type it will be used as. Better just record the instance.
				     ; We may be able to pick up what the constant became after conversion, so
				     ; later passes have it right without conversion.
 0858   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 085C  3,1  74 0D		      je UCorig
 085E   1   8B 5E 36		      mov CursorBx,Z.Cursor
				     ; Can't be AssignConst case here, but original could be.
 0861   2   65: 80 3F 99	      cmp Bptr gs:[CursorBx],$pAssignConst
 0865  3,1  75 01		      jne @F
 0867   1   43			      inc CursorBx
 0868				      @@:
 0868   1   65: 8B 1F		      mov ArrayBx,gs:[CursorBx]
 086B   2   C6 43 07 8A		     UCorig:mov V.Dtype,$Constant
 086F   1   89 1B		      mov V.WhichCon,ArrayBx
				      move V.PcodePos,Hg.Avail
 0871   1   65: 8B 46 04	  1      mov ax,Hg.Avail
 0875   2   89 43 02		  1      mov V.PcodePos,ax
 0878				     IsVar:
 0878   1   8B C3		      mov ax,ArrayBx
 087A   3   80 7B 07 48		      cmp V.Dtype,$Sigl
 087E  3,1  75 10		      jne @F
 0880   1   50			      push ax
 0881   3   E8 FE1B		      call Pcode2
				      OpAl $pSysVar
 0884   1   B0 B5		  1    mov al,$pSysVar
 0886   3   E8 FBE1		  1    call PcodeOp
 0889   1   58			      pop ax
 088A   2   C6 43 07 89		      mov V.Dtype,$Variable
 088E   3   EB 29		      jmp PcodeLoadRet

				     ; Is the Pcode position where this operand is to go two bytes on from the
				     ; last assignment target?
 0890				     @@:
				     if ForBcode
				     endif
 0890   1   8B 5E 36		      mov CursorBx,Z.Cursor
				      dec2 CursorBx
 0893   1   4B			  1   dec CursorBx
 0894   1   4B			  1   dec CursorBx
 0895   2   3B 9E 0144		      cmp CursorBx,Z.LastTarget
 0899  3,1  75 29		      jne Pcode2Via
				     ; If so, is what was stored then the same as the load now?
 089B   1   8B D0		      mov dx,ax
 089D   1   83 C2 06		      add dx,$CaseTarget
 08A0   2   65: 3B 17		      cmp dx,gs:[CursorBx]
 08A3  3,1  75 1F		      jne Pcode2Via
 08A5   1   50			      push ax
				      OpAl $pUnstore
 08A6   1   B0 9B		  1    mov al,$pUnstore
 08A8   3   E8 FBBF		  1    call PcodeOp
 08AB   1   58			      pop ax
				     ; That won't be right for the tracing version.
				      Qry Z.Gen,DualGen
 08AC   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0023
 08B0  3,1  74 07		      jz @F
 08B2   3   65: FF 4E 04	      dec Hg.Avail
 08B6   3   E8 FE26		      call Pcode2D; replace with ordinary load.
 08B9				     @@:
 08B9   1   A8 07		     PcodeLoadRet:test al,7
 08BB   1   B4 18		      mov ah,$TraceVar
 08BD  3,1  74 02		      jz @F
 08BF   1   B4 16		      mov ah,$TraceLit
 08C1				      @@:
 08C1   3   E9 011C		      jmp TraceEvent

 08C4   3   E8 FDD8		     Pcode2Via:call Pcode2
 08C7   3   EB F0		     jmp PcodeLoadRet
				     ;------------------------------------------------------------------------------
				     ; Generation of specific sequences.
				     ;------------------------------------------------------------------------------
 08C9				     Action1:; Assignment
				     ; There are various opcodes associated with assignment.
				     ; $pAssign covers the majority of cases.
				     ; $pAssignDots handles the A.B.C=99 sort.
				     ; $pAssignStem handles the A.=99 sort.
				     ; $pStore is an optimization for where the value is needed again. A=exp;if A...
				     ; $pAssignConst is an optimization for RHS constant. A=99
				     ; $pControlVar when the assignment is part of DO header activity. DO J=....
				     ; $pDotControlVar when the assignment is part of DO header activity with a
				     ; compound.  Both DO A.B=... and DO A.=....
				     ; Assignments also happen within $pParse complex.
 08C9   3   81 7A 10 0366	      cmp S1.State,$DoFrame
 08CE  3,1  0F 84 0397		      je ControlVar
 08D2				     MakeAssign:EvAh $TraceAssign
 08D2   1   B4 00		  1    mov ah,$TraceAssign
 08D4   3   E8 0109		  1    call TraceEvent
				     ; Top stack item corresponds to is RHS, one below the LHS.
				     ; We will set cx up to indicate constant.
				     ; return dx=0 except when tails.
				      z cx
 08D7   1   8B CD		  1           mov cx,bp
 08D9   3   80 7B 07 8A		      cmp V.Dtype,$Constant
 08DD  3,1  75 06		      jne @F
 08DF   1   41			      inc cx
				     ; We don't know how the LHS is going to be used, so deciding a representation
				     ; for the value is guesswork.
				      z ah
 08E0   1   B4 00		  1         mov ah,0
 08E2   3   E8 FA5D		      call ConstValueX
 08E5				     @@:Down; Removing the RHS
 08E5   1   83 EF 08		  1   sub StackDi,$StrideV
 08E8   1   89 7E 06		      mov Z.Stack,StackDi
				     ; LHS on the stack says what sort of target it is.
 08EB   3   80 7B 07 80		      cmp V.Dtype,$NullString
 08EF  3,1  75 7A		      jne DotsLHS
				     ; The LHS was not tailed and was resolved earlier.
				      move Z.Resolved,V.HeldOver
 08F1   1   8B 03		  1      mov ax,V.HeldOver
 08F3   1   89 46 34		  1      mov Z.Resolved,ax
				     ; Bit of an afterthought here - we can't use the simple constant assignment
				     ; code when the target is a stem.
 08F6   3p  8E 5E 42		      mov ds,Z.Vars
 08F9   1   8B D8		      mov bx,ax
 08FB   1   8B 5F 04		      mov bx,Vbx.Here
				     ; SymbolsEs:bx now addresses "counted string" form of name.
				     ; Does it end with dot?
 08FE   3   26: 0F B6 17	      movzx dx,Bptr SymbolsEs:[bx]
 0902   1   03 DA		      add bx,dx
 0904   2   26: 80 3F 2E	      cmp Bptr SymbolsEs:[bx],'.'
				      z dx
 0908   1   8B D5		  1           mov dx,bp
 090A  3,1  74 56		      je StemTgt
				     ; If the RHS was a constant we can use a Pcode that doesn't check so much.
				     ; This was only 15% faster in execution, despite avoiding stack.
				     ; (Usual doubts about accuracy of measurement)
				     ; DI has the stack item for the target.
				     ; CX nonzero indicates constant being assigned.
				     if ForBcode eq 0
 090C   1   85 C9		      test cx,cx
 090E  3,1  74 48		      jz NotAssignConst
				      z Z.LastTarget; Can't use $pUnstore after this.
 0910   1   89 AE 0144		  1           mov Z.LastTarget,bp
				     ; The dual code will not be the same, so flag fiddling.
				     ; We need to save/restore a single flag - not simple.
 0914   8   0F BA 76 0E 0D	      btr Z.Gen,DualGen
 0919   4p  9C			      pushf
				     ; The RHS is already on the Pcode, at a different place than wanted, original.
				     ; The RHS is already on the Pcode, in midst of AssignConstant, subsequently.
 091A   3   E8 FE21		      call BackOff2
 091D   1   8B 5E 36		      mov CursorBx,Z.Cursor
				     ; If Synch, the $pAssignConst is already made. Pick up RHS and traverse.
 0920   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 0924  3,1  74 01		      jz @F
 0926   1   43			      inc CursorBx
 0927				      @@:
				     ; AX is the LHS. Place $pAssignConst RHS LHS
 0927   1   65: 8B 0F		      mov cx,Wptr gs:[CursorBx]
 092A   1   89 4E 34		      mov Z.Resolved,cx
 092D   1   50			      push ax
				      OpAl $pAssignConst
 092E   1   B0 99		  1    mov al,$pAssignConst
 0930   3   E8 FB37		  1    call PcodeOp
 0933   1   58			      pop ax
 0934   3   E8 FD68		      call Pcode2
 0937   9p  9D			      popf
 0938  3,1  73 04		      jnc @F
				      On Z.Gen,DualGen
 093A   3   80 4E 0F 20		  1          or  Bptr(Z.Gen+1), high ??0024
 093E				      @@:
				      Qry Z.Gen,DualGen
 093E   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0025
 0942  3,1  74 13		      jz @F
 0944   3   E8 0000 E		      call UpStack
				      On Z.Gen,DualOnly
 0947   3   80 4E 0F 10		  1          or  Bptr(Z.Gen+1), high ??0026
 094B   1   89 46 34		      mov Z.Resolved,ax
				      OpAl $pAssign
 094E   1   B0 93		  1    mov al,$pAssign
 0950   3   E8 FB17		  1    call PcodeOp
				      Off Z.Gen,DualOnly
 0953   3   80 66 0F EF		  1          and Bptr(Z.Gen+1), high not ??0027
 0957   5   C3			     @@:ret

				     endif

				     ; Z.LastTarget is used when a subsequent operand is fetched, to possibly
				     ; change $pAssign to $pStore.
				     ; OpAl has special tests for $pAssign, so it may get omitted.
 0958				     NotAssignConst:OpAl $pAssign
 0958   1   B0 93		  1    mov al,$pAssign
 095A   3   E8 FB0D		  1    call PcodeOp
 095D   1   89 9E 0144		     mov Z.LastTarget,CursorBx
 0961   5   C3			     ret

 0962   1   89 AE 0144		     StemTgt:mov Z.LastTarget,ZeroBp
				     OpRet $pAssignStem
 0966   1   B0 95		  1    mov al,$pAssignStem
 0968   3   E9 FAFF		  1    jmp PcodeOp

				     ; Compound name hasn't been looked up yet.
 096B   1   65: 8B 56 04	     DotsLHS:mov dx,Hg.Avail
 096F   1   B4 48		     mov TokNumAh,$VAR_SYMBOL
				     On Z.Clause,Tailed
 0971   3   80 4E 0C 08		  1          or  Bptr(Z.Clause), low ??0028
 0975   1   8B 7E 06		      mov StackDi,Z.Stack
 0978   3   E8 F750		      call Lookup
				     ; Now have tails put in Pcode set, PartCountCl set, and Z.Resolved target.
				      OpRet $pAssignDots
 097B   1   B0 97		  1    mov al,$pAssignDots
 097D   3   E9 FAEA		  1    jmp PcodeOp

 0980				     Action2:; Keyword instructions
				     ; Pick out some simple verbs.
 0980   1   8B 46 12		      mov ax,Z.KWFound
 0983   1   3D 00A0		      cmp ax,$NOP
 0986  3,1  72 19		      jb OtherVerb
 0988   1   3D 00B0		      cmp ax,$TRACE
 098B  3,1  77 14		      ja OtherVerb
 098D   1   04 8A		      add al,$sNop-$NOP
				     ; Faster to have a distinct Pcode for RETURN without argument.
 098F   1   3C 35		      cmp al,$sReturns
 0991  3,1  0F 85 FD00		      jne Scode
 0995   2   3B 7E 54		      cmp StackDi,Z.Base0
 0998  3,1  0F 85 FCF9		      jne Scode
				      OpRet $pReturn
 099C   1   B0 23		  1    mov al,$pReturn
 099E   3   E9 FAC9		  1    jmp PcodeOp

 09A1				     OtherVerb:Qry Z.Clause,Signal; Copes with SIGNAL and NAME
 09A1   2   F6 46 0D 08		  1          test Bptr(Z.Clause+1), high ??0029
 09A5  3,1  0F 85 05AE		     jnz SignalVerb
				      Qry Z.Clause,WasParse
 09A9   2   F6 46 0C 20		  1          test Bptr(Z.Clause), low ??002A
 09AD  3,1  74 1E		      jz ActionRet
				     ; Cannot be in InParse??
 09AF				     @@:Qry Z.Clause,InParse
 09AF   2   F6 46 0C 10		  1          test Bptr(Z.Clause), low ??002B
 09B3  3,1  75 05		     jnz @F
				     OpAl $pResumeParse
 09B5   1   B0 0B		  1    mov al,$pResumeParse
 09B7   3   E8 FAB0		  1    call PcodeOp
 09BA   3   83 6E 06 08		     @@:sub Z.Stack,$StrideV
 09BE   1   B0 1A		     mov al,$mParseEnd
 09C0   3   E9 FD2C		     jmp Pcode1

 09C3				     Action3:; end of command
				     OpRet $pCommand
 09C3   1   B0 4D		  1    mov al,$pCommand
 09C5   3   E9 FAA2		  1    jmp PcodeOp

 09C8				     Action6:; PARSE VALUE
 09C8   1   C7 46 10 0000	      mov Z.KWMiddle,$WithKey
 09CD				     ActionRet:
 09CD   5   C3			      ret

 09CE				     Action11:; Unary operator
				     ; Need to alter + and -. Alters Not also.
 09CE   4   83 42 06 1C		      add S.Token,$sNegate-$sMinus
 09D2   1   B4 14		      mov ah,$TracePrefix
 09D4   3   EB 02		      jmp @F

 09D6				     Action10:; Binary operator
 09D6   1   B4 12		      mov ah,$TraceOperator
 09D8   1   50			     @@:push ax
 09D9   3   E8 005E		      call ActionBin
 09DC   3   E8 FCB6		      call Scode
 09DF   1   58			      pop ax

 09E0				     TraceEvent:; Compile time note of tracing potential.
				      Qry Z.Gen,DualGen
 09E0   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??002C
 09E4  3,1  75 01		      jnz @F
 09E6   5   C3			      ret
 09E7				      @@:
 09E7   1   B0 C1		      mov al,$pTraceEvent
 09E9   3   E9 FCF3		      jmp Pcode2D

 09EC				     Action12:; Comparisons.
				     ; Change from $s codes to $p ones. Simple to do that without the XLAT table.
 09EC   3   E8 004B		      call ActionBin
 09EF   1   02 C0		      add al,al
 09F1   1   04 2F		      add al,$pEq-2*$sEq
				     ; Specialize further, maybe.
 09F3   1   3C 71		      cmp al,$pSeq
 09F5  3,1  73 22		      jae Action12Asis
				     ; If either known to be non-arith then make it a char one.
				     ; ie constants that don't have number syntax.
				     ; Even if we don't know it is arith, it probably helps to use arith const
				     ; where possible.
 09F7   1   B4 4E		      mov ah,'N'
 09F9   3   80 7B 07 8A		      cmp V.Dtype,$Constant
 09FD  3,1  75 07		      jne @F
 09FF   3   E8 F940		      call ConstValueX
				     ; The flags from NumDxBx in ConstValueX are available here.
 0A02  3,1  72 13		      jc Action12Char; Non number syntax so must be char compare.
 0A04   3   EB 13		      jmp Action12Asis

 0A06   3   80 7B FF 8A		     @@:cmp V0.Dtype,$Constant
 0A0A  3,1  75 0D		     jne Action12Asis
				      Down
 0A0C   1   83 EF 08		  1   sub StackDi,$StrideV
 0A0F   3   E8 F930		      call ConstValueX
				      UpCare
 0A12   1+  8D 7D 08		  1   lea StackDi,$StrideV[StackDi]
 0A15  3,1  73 02		      jnc Action12Asis
 0A17				     Action12Char:; A non-strict compare without arithmetic checks.
				     if ForBcode eq 0
 0A17   1   04 18		      add al,$pCeq-$pEq
				     endif
 0A19				     Action12Asis:; Make the long form initially. It may get optimized.
 0A19   1   50			      push ax
				      OpAl $pBool
 0A1A   1   B0 A1		  1    mov al,$pBool
 0A1C   3   E8 FA4B		  1    call PcodeOp
 0A1F   1   58			      pop ax
 0A20   1   43			      inc CursorBx
 0A21   1   89 9E 00FB		      mov Z.CompareAt,CursorBx
 0A25   3   E8 FA42		      call PcodeOp
				     ; Comparison operators have space for a jump value, except when $pBool precedes.
				     ; The tables say 'make space' but we don't want it here.
 0A28   3   E8 FD13		      call BackOff2
				      Qry Z.Gen,DualGen
 0A2B   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??002D
 0A2F  3,1  74 05		      jz @F
 0A31   3   65: 83 6E 04 02	      sub Hg.Avail,2
 0A36				      @@:
				      EvRet $TraceOperator
 0A36   1   B4 12		  1    mov ah,$TraceOperator
 0A38   3   EB A6		  1    jmp TraceEvent

				     ; S.Token was set by the parser on encountering the operator.  Now is the
				     ; time to take it from the parser state and put it in the Pcode.
				     ; ActionBin puts it in al.
 0A3A				     ActionBin:move Z.InsOperator,S.Operation
 0A3A   2   66| 8B 42 08	  1      mov eax,S.Operation
 0A3E   1   66| 89 46 74	  1      mov Z.InsOperator,eax
 0A42   2   8A 42 06		      mov al,Bptr S.Token
 0A45   1   04 F0		      add al,$sPercent-$Percent
 0A47   5   C3			      ret

 0A48				     Action18:; Save function name over the arglist.
 0A48   1   8B 46 34		      mov ax,Z.Resolved
 0A4B   2   89 42 0C		      mov S.Caller,ax
 0A4E   2   89 7A 0E		      mov S.Parms,StackDi
 0A51   5   C3			     Action18Ret:ret

				     ; It would be nice to have had a utility to sort out different actions
				     ; and how they share variables but that is not yet mechanised.

 = 02D6				     $SelectFrame equ 2*363 ; S112 W177   SELECT ncl^....
 = 02B2				     $IfFrame equ 2*345 ; S48 W63         ifexpr.91 ^ ncl
 = 0366				     $DoFrame equ 2*435 ; S8 W9           DO ^ ....

 0A52				     Action20:; THEN
				     ; The THEN of IF and the THEN of WHEN differ only in the message number when the
				     ; subject is non-Boolean. We could save a code point by using a rescan to
				     ; determine that but I have chosen the simpler approach of a different Pcode.
				     ; ?? Rescan for line number anyway.

				     ; Here we find a place of the parser stack where we can store info (FillJump)
				     ; and recover it at the end of the THEN part. (Action 21, Action 22)
				     ; Similarly for SELECT.

 0A52   1   B0 61		      mov al,$pWhen
 0A54   2   81 3A 02B2		      cmp S.State,$IfFrame
 0A58  3,1  74 32		      je UseS1
				     ; Looks like can be different for THEN when THEN starts new line.
 0A5A   3   81 7A 10 02B2	      cmp S1.State,$IfFrame
 0A5F  3,1  75 05		      jne @F
 0A61   1   83 C6 10		      add ParseSi,$StrideS
 0A64   3   EB 26		      jmp UseS1
 0A66				      @@:
 0A66   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0A6B  3,1  75 09		      jne @F
				      z S1.SelectSite
 0A6D   2   89 6A 18		  1           mov S1.SelectSite,bp
 0A70   3   FF 86 00F9		      inc Z.TraceOnly
 0A74   3   EB 1F		      jmp UseS1w
 0A76				      @@:
 0A76   1   83 C6 10		      add ParseSi,$StrideS
				     ; Test S1 (was S2 on entry)
 0A79   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0A7E  3,1  74 15		      je UseS1w
 0A80   1   83 C6 10		      add ParseSi,$StrideS
 0A83   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0A88  3,1  74 0B		      je UseS1w
 0A8A   5p  FF D5		      Error49Bp
				     ; A compare made a $pBool followed by a $pEq or similar. This leaves the
				     ; comparison result on the stack. A $pThen now with target would do the
				     ; conditional jump. We optimize by accepting that sequence with $pBool and
				     ; $pThen bytes left out. However, trace and optimizing don't combine.
 0A8C   1   B0 5F		     UseS1:mov al,$pThen
				     ; Cannot use Hd.Avail as test value because label can get to array before it
				     ; appears with a label.
				      move S1.SoFar,Hg.Avail,dx; See traceonly test.
 0A8E   1   65: 8B 56 04	  1    mov dx,Hg.Avail
 0A92   2   89 52 18		  1    mov S1.SoFar,dx
 0A95   1   8B 96 00FB		     UseS1w:mov dx,Z.CompareAt
				      z Z.CompareAt
 0A99   1   89 AE 00FB		  1           mov Z.CompareAt,bp
 0A9D   1   83 C2 01		      add dx,1
 0AA0   2   3B 56 36		      cmp dx,Z.Cursor
 0AA3  3,1  75 05		      jne @F
 0AA5   3   E8 0012		      call Shorten
 0AA8   3   EB 06		      jmp EndThen
 0AAA   3   E8 F9BD		     @@:call PcodeOp; $pThen/$pWhen retained.
 0AAD   2   89 5A 16		      mov S1.JumpSite,CursorBx
				     ; The 'then' is a separate clause.
				     ; QueryKey did a ClauseSourceEnd when THEN keyword, for what was ahead of THEN.
				     ; Here is one for the THEN itself.
 0AB0   1   8B B6 00E1		     EndThen:mov CursorSi,Z.Scanp
 0AB4   3   E8 0000 E		     call ClauseSourceEnd
 0AB7   3   E9 0525		      jmp Action91

 0ABA				     Shorten:; We have made Bool-Compare when just Compare wanted on short form.
				     ; That's true of first time but later we will have just just stepped over
				     ; so compare-op has to be found somewhere different.
 0ABA   1   8B 5E 36		      mov CursorBx,Z.Cursor
 0ABD   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 0AC1  3,1  74 01		      je @F
 0AC3   1   4B			      dec CursorBx
 0AC4				      @@:
 0AC4   1   65: 8A 57 FF	      mov dl,Bptr gs:[CursorBx-1];The $pEq like.
 0AC8   1   8A F0		      mov dh,al
				     ; Generate twice, with differing flags for original and trace code.
				     ; Saving of individual flag is clumsy.
 0ACA   8   0F BA 76 0E 0D	      btr Z.Gen,DualGen
 0ACF   4p  9C			      pushf
 0AD0   3   E8 FC6B		      call BackOff2
 0AD3   1   8A C2		      mov al,dl
 0AD5   3   E8 F992		      call PcodeOp
 0AD8   2   89 5A 16		      mov S1.JumpSite,CursorBx
 0ADB   9p  9D			      popf
 0ADC  3,1  73 04		      jnc @F
				      On Z.Gen,DualGen
 0ADE   3   80 4E 0F 20		  1          or  Bptr(Z.Gen+1), high ??002E
 0AE2				      @@:
				      Qry Z.Gen,DualGen
 0AE2   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??002F
 0AE6  3,1  74 0D		      jz @F
				     ; Already made Bool-Comp-TraceEvent[Expr]
				      On Z.Gen,DualOnly
 0AE8   3   80 4E 0F 10		  1          or  Bptr(Z.Gen+1), high ??0030
 0AEC   1   8A C6		      mov al,dh
 0AEE   3   E8 F979		      call PcodeOp
				      Off Z.Gen,DualOnly
 0AF1   3   80 66 0F EF		  1          and Bptr(Z.Gen+1), high not ??0031
 0AF5   5   C3			     @@:ret

 0AF6				     Action21:; ELSE
				      OpAl $pJump
 0AF6   1   B0 63		  1    mov al,$pJump
 0AF8   3   E8 F96F		  1    call PcodeOp
 0AFB   1   8B D3		      mov dx,CursorBx
 0AFD   6   87 5A 06		      xchg S.JumpSite,CursorBx
 0B00   3   E8 0025		      call FillJump
 0B03   1   8B B6 00E1		      mov CursorSi,Z.Scanp
 0B07   3   E8 0000 E		      call ClauseSourceEnd
				     ; If we are doing synch for a trace of an ELSE leg we actually want two
				     ; lines, one for the ELSE and one for the first clause of the leg.
				     ; Normally the Z.Synch would take us to the latter because the branch from
				     ; THEN goes there, not to any Pcode from ELSE.
				     ; The Pcode from ELSE will be the jump 3 bytes before that.
				     ; If we detect this case, we can get the ELSE, then repeat the synch for
				     ; the clause.
				     ; That works when the ELSE leg is to be executed.
				     ; In the alternate case, when the THEN leg is executed. We want to take the
				     ; jump that is at the end of the THEN leg but not show the ELSE keyword that
				     ; corresponds to the jump. See the place that outputs source during tracing.
				      Qry Z.Program,ShowELSE
 0B0A   2   F6 46 02 40		  1          test Bptr(Z.Program), low ??0032
 0B0E  3,1  0F 84 04CD		      jz Action91
				      Qry Z.Gen,Dual
 0B12   2   F6 46 0F 80		  1          test Bptr(Z.Gen+1), high ??0033
 0B16  3,1  0F 84 04C5		      jz Action91
 0B1A   1   83 C2 02		      add dx,2
 0B1D   2   3B 96 010D		      cmp dx,Z.Synch
 0B21  3,1  0F 85 04BA		      jne Action91
				     ; End the compile with the flag still on.  Higher level will test
 0B25   3   E9 04E6		      jmp Terminate

				     ; FillJump is always filling a forward reference with a branch to the current
				     ; end of generated code.
				     ; Only fill in the branch targets once. (Not on scans for line numbers.)
 0B28   1   8B 46 36		     FillJump:mov ax,Z.Cursor
 0B2B   2   39 AE 010D		     cmp Z.Synch,ZeroBp
 0B2F  3,1  75 08		     jne SynchTarget
 0B31   1   65: 89 07		      mov gs:[CursorBx],ax
				     ; Can't optimize over branch-in points.
 0B34				     @@:z Z.LastTarget
 0B34   1   89 AE 0144		  1           mov Z.LastTarget,bp
 0B38   5   C3			     ret

 0B39   2   65: 3B 07		     SynchTarget:cmp ax,gs:[CursorBx]
 0B3C  3,1  74 F6		     je @B
 0B3E  26   CC			     int 3
 0B3F   5p  FF D5		     Error49Bp

 0B41				     Action22:; if completion.
				     ; May need to mark labels trace-only, first pass.
 0B41   2   65: 39 6E 0A	      cmp Hg.Original,ZeroBp
 0B45  3,1  75 32		      jne @F
				     ; Looks at labels.
				     ; Clumsy to scan through constants after every IF. Should chain off IF. NYI
 0B47   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 0B4A   3p  8E 5E 40		      mov ds,Z.Consts
 0B4D   1   8B 1E 0004		      mov ArrayBx,Hd.Avail
 0B51   1   83 EB 08		     Action22L:sub ArrayBx,$StrideV
 0B54   1   83 FB 14		      cmp ArrayBx,$SizeConstsHeader
 0B57  3,1  72 20		      jb @F
				     ; Here for each constant since start of IF.
 0B59   2   26: 80 7F 07 8B	      cmp Vbxe.Dtype,$Label
 0B5E  3,1  75 F1		      jne Action22L
				     ; Here if a label.
 0B60   1   26: 8B 07		      mov ax,Vbxe.LabelValue
				      TestReg ax
 0B63   1   85 C0		  1         test ax,ax
 0B65  3,1  74 EA		      jz Action22L
				     ; Here if it has appeared with a colon.
 0B67   3   3B 42 08		      cmp ax,S.SoFar
 0B6A  3,1  72 E5		      jb Action22L
				     ; Here if not pointing to before the IF.
 0B6C   2   65: 3B 46 04	      cmp ax,Hg.Avail
 0B70  3,1  74 DF		      je Action22L
				     ; Here if not at the end of this if clause.
 0B72   1   26: C6 47 06 01	      mov Bptr Vbxe.LabelType,1; Marks trace-only
 0B77   3   EB D8		      jmp Action22L

 0B79   3p  8E 46 48		     @@:mov SymbolsEs,Z.Symbols
 0B7C   2   8B 5A 06		      mov CursorBx,S.JumpSite
 0B7F   3   EB A7		      jmp FillJump

 0B81				     Action23:; select; JumpSite zeroed by otherwise.
 0B81   3   39 6A 06		      cmp S.JumpSite,ZeroBp
 0B84  3,1  74 07		      je @F
				     ; Substitute otherwise is message 7.3
 0B86   1   B1 00		      mov OpAppendCl,$n7p3
				      OpAl $pRaise
 0B88   1   B0 AF		  1    mov al,$pRaise
 0B8A   3   E8 F8DD		  1    call PcodeOp
				     ; NYI also the S.ClauseWas field of the SELECT frame.
 0B8D   2   8B 7A 08		     @@:mov di,S.SelectSite
				     z Z.LastTarget
 0B90   1   89 AE 0144		  1           mov Z.LastTarget,bp
				     ; There is a chain of forward branch sites.
 0B94   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 0B98  3,1  75 0F		      jne Action22Ret
				     ; Fill them all.
 0B9A   1   8B 4E 36		      mov cx,Z.Cursor
 0B9D   1   65: 8B 35		     @@:mov si,gs:[di]
 0BA0   1   65: 89 0D		      mov gs:[di],cx
 0BA3   1   8B FE		      mov di,si
				      TestReg di
 0BA5   1   85 FF		  1         test di,di
 0BA7  3,1  75 F4		      jnz @B
 0BA9   5   C3			     Action22Ret:ret

 0BAA				     Action24:; otherwise; Mark JumpSite with zero.
				     ; 2011 added variety??
				     ; +2 then +1 then +1 instead  of +3 then +1
 0BAA   1   83 C6 20		      add ParseSi,2*$StrideS
 0BAD   2   81 3A 02D6		      cmp S.State,$SelectFrame
 0BB1  3,1  74 14		      je @F
 0BB3   1   83 C6 10		      add ParseSi,$StrideS
 0BB6   2   81 3A 02D6		      cmp S.State,$SelectFrame
 0BBA  3,1  74 0B		      je @F
 0BBC   1   83 C6 10		      add ParseSi,$StrideS
 0BBF   2   81 3A 02D6		      cmp S.State,$SelectFrame
 0BC3  3,1  74 02		      je @F
 0BC5   5p  FF D5		      Error49Bp
 0BC7				     @@:z S.JumpSite
 0BC7   2   89 6A 06		  1           mov S.JumpSite,bp
 0BCA   5   C3			      ret

 0BCB				     Action25:; when completion.
 0BCB   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0BD0  3,1  74 16		      je @F
 0BD2   1   83 C6 10		      add ParseSi,$StrideS
 0BD5   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0BDA  3,1  74 0C		      je @F
 0BDC   1   83 C6 10		      add ParseSi,$StrideS
 0BDF   3   81 7A 10 02D6	      cmp S1.State,$SelectFrame
 0BE4  3,1  74 02		      je @F
 0BE6   5p  FF D5		      Error49Bp
 0BE8				     @@:OpAl $pJump; WHEN end requires a branch to end of SELECT.
 0BE8   1   B0 63		  1    mov al,$pJump
 0BEA   3   E8 F87D		  1    call PcodeOp
 0BED   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 0BF1  3,1  75 09		      jne @F
 0BF3   2   8B 42 18		      mov ax,S1.SelectSite
 0BF6   1   65: 89 07		      mov Wptr gs:[CursorBx],ax
 0BF9   2   89 5A 18		      mov S1.SelectSite,CursorBx
				     ; THEN at start of this WHEN is a jump to here.
 0BFC   2   8B 5A 16		     @@:mov CursorBx,S1.JumpSite
 0BFF   3   E9 FF26		     jmp FillJump

 0C02				     Action26:; PROCEDURE.  Make protection against fall-thru.
 0C02   1   B1 02		      mov OpAppendCl,$n17p1
				      OpRet $pRaise
 0C04   1   B0 AF		  1    mov al,$pRaise
 0C06   3   E9 F861		  1    jmp PcodeOp

 0C09   1   B4 1C		     Raise28:mov ah,28
 0C0B   2   80 7E 12 B4		     cmp Bptr Z.KWFound,low $LEAVE
 0C0F  3,1  74 01		     je @F
 0C11   1   40			     inc ax
 0C12   3   E9 0000 E		     @@:jmp Raise

 0C15				     Action28:; ITERATE/LEAVE without VAR_SYMBOL
 0C15   1   B0 01		     mov al,1
				     ; Scan the stack, looking for DO repetitive.
 0C17   1   83 C6 10		     @@:add ParseSi,$StrideS
 0C1A   2   39 2A		     cmp S.State,ZeroBp
 0C1C  3,1  74 EB		     je Raise28
				      Qry S.Parser,DoRep,DoCV
 0C1E   3   F6 42 02 0C		  1          test Bptr(S.Parser), low ??0034
 0C22  3,1  74 F3		      jz @B
 0C24   3   EB 23		      jmp A29Pcode
 0C26				     Action29:; VAR_SYMBOL after LEAVE or ITERATE
 0C26   1   B0 01		      mov al,1
				     ; Scan the stack, looking for DO info.
 0C28   1   83 C6 10		     @@:add ParseSi,$StrideS
 0C2B   2   39 2A		     cmp S.State,ZeroBp
 0C2D  3,1  74 DA		     je Raise28
				      Qry S.Parser,DoCV,DoRep
 0C2F   3   F6 42 02 0C		  1          test Bptr(S.Parser), low ??0035
 0C33  3,1  74 F3		      jz @B
				      Qry S.Parser,DoRep
 0C35   3   F6 42 02 08		  1          test Bptr(S.Parser), low ??0036
 0C39  3,1  75 05		      jnz A29UnDo
 0C3B   3   E8 0084		      call CompNames
 0C3E  3,1  74 09		      je A29Pcode
 0C40				     A29UnDo:OpAl $pUnDo
 0C40   1   B0 1F		  1    mov al,$pUnDo
 0C42   3   E8 F825		  1    call PcodeOp
 0C45   1   B0 03		      mov al,3
 0C47   3   EB DF		      jmp @B

				     ; Different types of DO use a different iterate Pcode, for speed.
 0C49   2   80 7E 12 B4		     A29Pcode:cmp Bptr Z.KWFound,low $LEAVE
 0C4D  3,1  75 05		     jne @F
				     OpRet $pLeave
 0C4F   1   B0 1D		  1    mov al,$pLeave
 0C51   3   E9 F816		  1    jmp PcodeOp
 0C54				     @@:
 0C54   1   B0 1B		     FromDoEnd:mov al,$pIterate
				     Qry S.Parser,Forever
 0C56   3   F6 42 02 02		  1          test Bptr(S.Parser), low ??0037
 0C5A  3,1  75 0A		     jnz @F
 0C5C   1   B0 A3		      mov al,$pIterCV
				      Qry S.Parser,DoCV
 0C5E   3   F6 42 02 04		  1          test Bptr(S.Parser), low ??0038
 0C62  3,1  75 02		      jnz @F
 0C64   1   B0 19		      mov al,$pIterRep
 0C66   3   E9 F801		     @@:jmp PcodeOp

 0C69				     ControlVar:; Here for DO j=1 TO 99 type of assign.
				     ; We need something in the Pcode because numberness has to be checked
				     ; before TO BY FOR are done and actual assignment done after.
				      OpAl $pNumber
 0C69   1   B0 0D		  1    mov al,$pNumber
 0C6B   3   E8 F7FC		  1    call PcodeOp
				     ; The generation for the assignment is held over the BY etc.
				     ; Carry some info over for the END (and LEAVE/ITERATE)
				     ; Note that the S2.State won't be a DO one, it is just a carrier.
				      On S2.Parser,DoCV,DoDataHost
 0C6E   4   80 4A 22 05		  1          or  Bptr(S2.Parser), low ??0039
				      On Z.Clause,CVar
 0C72   3   80 4E 0D 02		  1          or  Bptr(Z.Clause+1), high ??003A
				     ; The LHS has been soft stacked for hold over the RHS expression.
				     ; We need to remember it for the whole DO group for test of match at END.
				     ; So for DO J=1 we remember the resolved J in the hard stack.
				     ; For DO A.K=1 we look up A.K as the constant "A.K".  Could be a bit
				     ; wasteful since execution may never need that constant, but convenient.
 0C76   3   80 7B 07 80		      cmp V.Dtype,$NullString
 0C7A  3,1  75 06		      jne @F
 0C7C   1   8B 03		      mov ax,V.HeldOver
 0C7E   2   89 42 28		     CVret:mov S2.WhatCV,ax
 0C81   5   C3			      ret; Leave assignment to Action33.

 0C82				     @@:; We will be able to detect later that WhatCV is dotted by its constantness.
				     ; Here we look it up as a constant. Action33 will do it as tailed.
				     ; Copy symbol saved on stack back to Z.Symbols where Lookup expects it.
 0C82   1   56			      push ParseSi
 0C83   1   57			      push StackDi
 0C84   3   E8 0000 E		      call ToDsSiCx
				     ; Check space early because compaction in loop intolerable.
 0C87   1   26: 8B 7E 04	      mov di,He.Avail
 0C8B   1   03 F9		      add di,cx
 0C8D   3   E8 0000 E		      call SymbolsSafe
 0C90   1   5F			      pop StackDi
 0C91   3   E8 0000 E		      call ToDsSiCx
 0C94   1   57			      push StackDi
 0C95   1   26: 8B 7E 04	      mov di,He.Avail
 0C99   7n  F3/ A4		      rep movsb
 0C9B   1   5F			      pop StackDi
 0C9C   1   5E			      pop ParseSi
				      On Z.Middles,TakenConstant
 0C9D   3   80 4E 0A 10		  1          or  Bptr(Z.Middles), low ??003B
 0CA1   3   E8 F427		      call Lookup
 0CA4   1   8B C3		      mov ax,ArrayBx
 0CA6   3   EB D6		      jmp CVret

 0CA8				     Action30:; After do-end, without name.
 0CA8   5   C3			     ret

 0CA9				     Action31:; After do-end, with name.
				     ; Since this name is the latest token there is more than one way to reach it.
				      move Z.ClauseLine,S.ClauseWas
 0CA9   2   8B 42 04		  1      mov ax,S.ClauseWas
 0CAC   1   89 46 08		  1      mov Z.ClauseLine,ax
 0CAF   1   B8 0A02		      mov ax,MkMajMin(10,2); Msg for mismatch.
				      Qry S.Parser,DoCV
 0CB2   3   F6 42 02 04		  1          test Bptr(S.Parser), low ??003C
 0CB6  3,1  75 04		      jnz HasDoCV
 0CB8   1   40			      inc ax
 0CB9   3   E9 0000 E		     @@:jmp Raise
 0CBC   3   E8 0003		     HasDoCV:call CompNames
 0CBF  3,1  75 F8		      jne @B
 0CC1   5   C3			      ret

				     ; Set zero flag iff CV name matches latest token.
 0CC2   1   8B 5E 34		     CompNames:mov ArrayBx,Z.Resolved
 0CC5   3   3B 5A 08		     cmp ArrayBx,S.WhatCV
 0CC8   5   C3			     ret

 0CC9				     Action32:; Complete the do group with a loop address if repetitive.
				      Qry S2.Parser,DoDataHost
 0CC9   3   F6 42 22 01		  1          test Bptr(S2.Parser), low ??003D
 0CCD  3,1  75 03		      jnz @F
 0CCF   1   83 C6 10		      Add ParseSi,$StrideS
 0CD2				      @@:
				      Qry S2.Parser,DoCV,DoRep
 0CD2   3   F6 42 22 0C		  1          test Bptr(S2.Parser), low ??003E
 0CD6  3,1  74 0C		      jz @F
				     ; Adjustment of Parser stack so we can share code.
 0CD8   1   83 C6 20		      add ParseSi,$StrideS*2
 0CDB   3   E8 FF76		      call FromDoEnd
 0CDE   2   8B 5A 06		      mov CursorBx,S.JumpSite
 0CE1   3   E8 FE44		      call FillJump
 0CE4   5   C3			     @@:ret

				     ; FOREVER is like $pRep with no argument. (So why $pRepEver?)
 0CE5				     Action36:
 0CE5				     Action33:; dorep done. Change middle keyword list.
				     ; Make S1 the one filled before.
 0CE5   2   81 3A 0366		      cmp S.State,$DoFrame
 0CE9  3,1  74 14		      je @F
 0CEB   1   83 C6 10		      add ParseSi,$StrideS
 0CEE   2   81 3A 0366		      cmp S.State,$DoFrame
 0CF2  3,1  74 0B		      je @F
 0CF4   1   83 C6 10		      add ParseSi,$StrideS
 0CF7   2   81 3A 0366		      cmp S.State,$DoFrame
 0CFB  3,1  74 02		      je @F
 0CFD   5p  FF D5		      Error49Bp
 0CFF				      @@:
 0CFF   1   C7 46 10 0000	     @@:mov Z.KWMiddle,$CondKeys
				      On Z.Clause,Repit
 0D04   3   80 4E 0D 01		  1          or  Bptr(Z.Clause+1), high ??003F
				     ; Parser stack is not consistent so not easy to test for DoCV. Hence flag.
				      Qry Z.Clause,CVar
 0D08   2   F6 46 0D 02		  1          test Bptr(Z.Clause+1), high ??0040
 0D0C  3,1  74 34		      jz NoCV
				     ; The code generation is not entirely like assignment. The control variable
				     ; needs to be recorded at run time. A different opcode reflects this.
				     ; Also, if there is WHILE or UNTIL, the opcode will not be one that marks
				     ; end-of-clause.
				     ; We also put an argument on this operation to set up the LEAVE target.
				     ; There are two opcodes, the usual $pControlVar and the $pDotControlVar
				     ; which is for either the CV is a stem or is tailed.
				     ; Share code with ordinary assign by making an assignment, then changing the
				     ; opcode.
 0D0E   3   E8 0000 E		      call UpStack; mock RHS
				      On Z.Cancel,AssignDO
 0D11   3   80 4E 05 40		  1          or  Bptr(Z.Cancel+1), high ??0041
 0D15   3   E8 FBBA		      call MakeAssign
				      Off Z.Cancel,AssignDO
 0D18   3   80 66 05 BF		  1          and Bptr(Z.Cancel+1), high not ??0042
				     ; A further complication occurs when the control variable is tailed,
				     ; 'thunking' is needed.
				     ; I've done that by having MakeAssign set dx to the value needed.
 0D1C   1   85 C9		      test cx,cx
 0D1E  3,1  75 16		      jnz Action33Tailed
 0D20   1   B0 5B		      mov al,$pControlVar
 0D22   5   65: 86 47 FF	      xchg al,Bptr gs:[CursorBx-1]
 0D26   1   3C 93		      cmp al,$pAssign
 0D28  3,1  74 05		      je @F
				     ; Add the space for jump address after the reference to the control variable.
 0D2A   1   65: C6 47 FF 5D	     Action33j:mov Bptr gs:[CursorBx-1],$pDotControlVar
 0D2F   3   E8 F96D		     @@:call Pcode2; To make space.
 0D32   2   89 5A 16		     Action33c:mov S1.JumpSite,CursorBx
 0D35   5   C3			     ret

 0D36   3   E8 FFF1		     Action33Tailed:call Action33j
				     ; Use a subcode to show where loop should branch back to reload tail(s).
 0D39   1   B0 02		      mov al,$mRepTail
 0D3B   3   E8 F9B1		      call Pcode1
				      xax dx
 0D3E   3   92			  1     xchg ax,dx
 0D3F   3   E9 F95D		      jmp Pcode2

 0D42   2   3B 7E 54		     NoCV:cmp StackDi,Z.Base0
 0D45  3,1  75 04		     jne @F
				     On S1.Parser,Forever,DoDataHost
 0D47   4   80 4A 12 03		  1          or  Bptr(S1.Parser), low ??0043
 0D4B				     @@:On S1.Parser,DoRep,DoDataHost
 0D4B   4   80 4A 12 09		  1          or  Bptr(S1.Parser), low ??0044
 0D4F   1   B0 59		     mov al,$pRepEver
				      Qry S1.Parser,Forever
 0D51   3   F6 42 12 02		  1          test Bptr(S1.Parser), low ??0045
 0D55  3,1  75 02		      jnz @F
 0D57   1   B0 57		      mov al,$pRep
 0D59   3   E8 F70E		      @@:call PcodeOp
 0D5C   3   EB D4		      jmp Action33c

 0D5E				     Action34:; WHILE exp
				     OpRet $pWhile
 0D5E   1   B0 15		  1    mov al,$pWhile
 0D60   3   E9 F707		  1    jmp PcodeOp

 0D63				     Action35:; UNTIL exp
				      OpAl $pUntil
 0D63   1   B0 17		  1    mov al,$pUntil
 0D65   3   E8 F702		  1    call PcodeOp
				     ; Target jump around UNTIL to here.
 0D68   1   8B 9E 00F1		      mov CursorBx,Z.UntilPlace
 0D6C   3   E9 FDB9		      jmp FillJump

 0D6F				     Action37:; Keywords WHILE/UNTIL
				     ; If there has been no repetition we need to invent one.
				      Qry Z.Clause,Repit
 0D6F   2   F6 46 0D 01		  1          test Bptr(Z.Clause+1), high ??0046
 0D73  3,1  75 03		      jnz @F
 0D75   3   E8 FF6D		      call Action33
 0D78				      @@:
 0D78   2   83 7E 12 70		      cmp Z.KWFound,$UNTIL
 0D7C  3,1  75 09		      jne @F; Make jump around the until code.
				      OpAl $pJump
 0D7E   1   B0 63		  1    mov al,$pJump
 0D80   3   E8 F6E7		  1    call PcodeOp
 0D83   1   89 9E 00F1		      mov Z.UntilPlace,CursorBx
 0D87   5   C3			     @@:ret

				     ; Z.KWFound doesn't work out for Middle keywords.
 0D88				     Action381:OpRet $pTo
 0D88   1   B0 0F		  1    mov al,$pTo
 0D8A   3   E9 F6DD		  1    jmp PcodeOp
 0D8D				     Action382:OpRet $pBy
 0D8D   1   B0 11		  1    mov al,$pBy
 0D8F   3   E9 F6D8		  1    jmp PcodeOp
 0D92				     Action383:OpRet $pFor
 0D92   1   B0 13		  1    mov al,$pFor
 0D94   3   E9 F6D3		  1    jmp PcodeOp

 0D97				     Action41:; Invent for missing parameter.
 0D97   3   E8 0000 E		      call UpStack
 0D9A   2   C6 43 07 88		      mov V.Dtype,$Omitted
 0D9E   1   B8 0014		      mov ax,$?Omitted
 0DA1   3   E9 F8FB		      jmp Pcode2
 0DA4				     Action43:; Function completes. Place invoker name in pcode.
 0DA4   3   E8 0036		      call ActInvokeCl
				     ; Whether Bif or not, there will be function result on this route.
 0DA7   4p  9C			      pushf
 0DA8   3   E8 0000 E		      call UpStack
				     ; Unknown compile time values are set to be something that will fail bif tests.
 0DAB   2   C6 43 07 89		      mov V.Dtype,$Variable
 0DAF   9p  9D			      popf
 0DB0  3,1  72 0B		      jc @F; Carry means it is bif, Pcode was made.
				     ; Pcode for non-bif made here.
				     ; Parameter count before the target makes it easier to share with CALL.
				      move Z.Resolved,S1.Caller
 0DB2   2   8B 42 1C		  1      mov ax,S1.Caller
 0DB5   1   89 46 34		  1      mov Z.Resolved,ax
 0DB8   1   B0 53		      mov al,$pInvoke
 0DBA   3   E8 F6AD		      call PcodeOp
 0DBD				     @@:EvRet $TraceFunction
 0DBD   1   B4 10		  1    mov ah,$TraceFunction
 0DBF   3   E9 FC1E		  1    jmp TraceEvent

 0DC2   1   83 EE 10		     Action44:sub si,$StrideS; After call without parameters.
 0DC5   3   E8 0015		     Action45:call ActInvokeCl
 0DC8  3,1  72 0B		     jc BifCall
				      move Z.Resolved,S1.Caller
 0DCA   2   8B 42 1C		  1      mov ax,S1.Caller
 0DCD   1   89 46 34		  1      mov Z.Resolved,ax
				      OpRet $pCall
 0DD0   1   B0 55		  1    mov al,$pCall
 0DD2   3   E9 F695		  1    jmp PcodeOp

				     ; Call, if Bif, needs to put result in special variable .RESULT
				     ; We could have flagged $pResult as not DownOne since this is only usage.
 0DD5   3   E8 0000 E		     BifCall:call UpStack
				     OpRet $pResult
 0DD8   1   B0 21		  1    mov al,$pResult
 0DDA   3   E9 F68D		  1    jmp PcodeOp

 0DDD				     ActInvokeCl:; Set Z.Stack back to pre-invoke
				     ; Set carry iff this is a bif.
				     ; If not bif, return parameter count in cl.
				     ; If bif syntax error presence/number of parameters wrong, make syntax Pcode.
				     ; If bif non-error put the Pcode to call it as a function.

				     ; Setup StackDx to StackDi as lo:hi retained range. Equal means none.
 0DDD   2   8B 52 1E		      mov StackDx,S1.Parms
 0DE0   1   89 96 00FF		      mov Z.StackLo,StackDx
 0DE4   1   52			      push StackDx
				     ; Pop of StackDx value to Z.Stack will effect removal of the args.
				     ; Trailing commas don't count.
 0DE5   1   3B FA		     @@:cmp StackDi,StackDx
 0DE7  3,1  74 0E		     je @F
 0DE9   3   80 7B 07 88		     cmp V.Dtype,$Omitted
 0DED  3,1  75 08		     jne @F
				      Down
 0DEF   1   83 EF 08		  1   sub StackDi,$StrideV
 0DF2   3   E8 F949		      call BackOff2
 0DF5   3   EB EE		      jmp @B
 0DF7   3   E8 0000 E		     @@:call SetStack; Reflect retained args.
				     ; Set cx to number of parms.
 0DFA   1   8B CF		      mov ParmsCx,StackDi
 0DFC   1   2B CA		      sub ParmsCx,StackDx
 0DFE   2   C1 E9 03		      shr ParmsCx,$ShiftV
 0E01   1   83 F9 64		      cmp ParmsCx,$MaxParms
 0E04  3,1  77 1B		      ja ArgsLim
				     ; Test apparent location to determine bifness.
 0E06   2   8B 5A 1C		      mov ArrayBx,S1.Caller
 0E09   3p  8E 66 44		      mov fs,Z.ProgScope
 0E0C   1   64: 8B 1F		      mov bx,fs:Vbx.LabelValue
 0E0F   1   83 EB B9		      sub bx,$BifBase
 0E12  3,1  73 05		      jnb @F
 0E14   6   8F 46 06		      pop Z.Stack
 0E17   2   F8			      clc
 0E18   5   C3			      ret
 0E19				      @@:
 0E19   3   E8 0000 E		      call PcodeBif
 0E1C   6   8F 46 06		      pop Z.Stack
 0E1F   2   F9			      stc
 0E20   5   C3			      ret

 0E21   1   B2 0A		     ArgsLim:mov dl,$DescArgs
 0E23   3   E9 0000 E		     jmp Raise5p1

 0E26				     Action51:;ARG verb is same as PARSE UPPER ARG
 0E26				     Action52:;PULL verb is same as PARSE UPPER PULL
				      On Z.Clause,WasUpper
 0E26   3   80 4E 0D 80		  1          or  Bptr(Z.Clause+1), high ??0047
 0E2A				     Action50:;After the subject of PARSE
				      On Z.Middles,TargetSymbol,DotOK; For target names
 0E2A   3   80 4E 0A 42		  1          or  Bptr(Z.Middles), low ??0048
				      On Z.Clause,InParse,WasParse
 0E2E   3   80 4E 0C 30		  1          or  Bptr(Z.Clause), low ??0049
 0E32   1   8B 46 12		      mov ax,Z.KWFound
 0E35   1   04 92		      add al,$sWith-$WITH
 0E37   1   BB 0654 R		      mov bx,S2P
 0E3A   4   2E: D7		      xlat cs:Bptr[bx]; Pick up marker.
 0E3C   1   3C 02		      cmp al,$nWith
 0E3E  3,1  76 07		      jbe @F
 0E40   3   E8 0000 E		      call UpStack
 0E43   2   C6 43 07 89		      mov V.Dtype,$Variable
 0E47				     @@:
 0E47   1   8A C8		      mov OpAppendCl,al
				      EvAh $TraceParse
 0E49   1   B4 1C		  1    mov ah,$TraceParse
 0E4B   3   E8 FB92		  1    call TraceEvent
				      OpAl $pParse
 0E4E   1   B0 09		  1    mov al,$pParse
 0E50   3   E8 F617		  1    call PcodeOp
 0E53   1   8B 46 06		      mov ax,Z.Stack
 0E56   1   89 86 0101		      mov Z.OnSoft,ax
				      Qry Z.Clause,WasUpper
 0E5A   2   F6 46 0D 80		  1          test Bptr(Z.Clause+1), high ??004A
 0E5E  3,1  75 01		      jnz @F
 0E60   5   C3			      ret
 0E61   1   B0 0A		     @@:mov al,$mUpper
 0E63   3   E9 F889		      jmp Pcode1


 0E66				     Action53:;Trigger.
 0E66   8   0F BA 6E 0C 04	      bts Z.Clause,InParse
 0E6B  3,1  72 05		      jc @F
				     ; It was turned off if $mParseEscape was made.
				      OpAl $pResumeParse
 0E6D   1   B0 0B		  1    mov al,$pResumeParse
 0E6F   3   E8 F5F8		  1    call PcodeOp
 0E72   1   B0 3A		     @@:mov al,$mPosPlus
 0E74   8   0F BA 76 0C 01	      btr Z.Clause,PosPlus
 0E79  3,1  72 1E		      jc TriggerValue
 0E7B   1   B0 42		      mov al,$mPosMinus
 0E7D   8   0F BA 76 0C 00	      btr Z.Clause,PosMinus
				     ; Stop on neg positional as debug trick.
 0E82  3,1  73 03		      jnc @F
 0E84  26   CC			      int 3
 0E85   3   EB 12		      jmp TriggerValue
 0E87				      @@:
 0E87   1   B0 2A		      mov al,$mPattern
 0E89   8   0F BA 76 0C 07	      btr Z.Clause,PosEq
 0E8E  3,1  72 07		      jc Positional
 0E90   2   83 BE 0107 44	      cmp Z.TokNow,$NUMBER
 0E95  3,1  75 02		      jne TriggerValue
 0E97   1   B0 32		     Positional:mov al,$mPosEq
 0E99				     TriggerValue:; Unless it is pattern we would prefer argument as a number.
 0E99   1   3C 2A		      cmp al,$mPattern
 0E9B  3,1  74 05		      je @F
 0E9D   1   B4 4E		      mov ah,'N'
 0E9F   3   E8 F498		      call ConstValue
 0EA2   3   83 6E 06 08		     @@:sub Z.Stack,$StrideV
 0EA6   3   E8 F846		     PostTrigger:call Pcode1
				     ; Any targets that were before this trigger can now be dealt with.
				     ; they range from above Z.OnSoft to Z.Stack.
 0EA9   1   8B BE 0101		      mov StackDi,Z.OnSoft
 0EAD   1   57			      push StackDi
 0EAE   3   EB 2C		      jmp TestTarsUp

 0EB0				     TarsLoop:; If it was resolved, it is sufficient just to put it as a target.
				     ; NYI StemTarget?
 0EB0   1   57			      push StackDi
 0EB1   3   80 7B 07 80		      cmp V.Dtype,$NullString
 0EB5  3,1  75 0C		      jne TgtTailed
 0EB7   1   8B 03		      mov ax,V.HeldOver
 0EB9   1   83 C0 06		      add ax,$CaseTarget
 0EBC   1   57			      push StackDi
 0EBD   3   E8 F7DF		      call Pcode2
 0EC0   1   5F			      pop StackDi
 0EC1   3   EB 18		      jmp @F
				     ; Tail calculation is introduced by $mParseEscape.
 0EC3   1   B0 12		     TgtTailed:mov al,$mParseEscape
 0EC5   3   E8 F827		     call Pcode1
 0EC8   1   5F			     pop StackDi
 0EC9   1   57			     push StackDi
				     ; Compound name hasn't been looked up yet.
 0ECA   1   8B 56 36		      mov dx,Z.Cursor
 0ECD   1   B4 48		      mov TokNumAh,$VAR_SYMBOL
				      On Z.Clause,Tailed
 0ECF   3   80 4E 0C 08		  1          or  Bptr(Z.Clause), low ??004B
 0ED3   3   E8 F1F5		      call Lookup
				     ; Now have tails put in Pcode set, PartCountCl set, and Z.Resolved target.
				     ; Doesn't look like we can use $pAssignDots because extra on stack.
				      OpAl $pAssignDotsP
 0ED6   1   B0 07		  1    mov al,$pAssignDotsP
 0ED8   3   E8 F58F		  1    call PcodeOp
 0EDB   1   5F			     @@:pop StackDi
 0EDC				     TestTarsUp:Up
 0EDC   1   83 C7 08		  1   add StackDi,$StrideV
 0EDF   2   3B 7E 06		      cmp StackDi,Z.Stack
 0EE2  3,1  76 CC		      jbe TarsLoop
				     ; Stack resets to Z.OnSoft
 0EE4   6   8F 46 06		      pop Z.Stack
				      On Z.Middles,TargetSymbol,DotOK
 0EE7   3   80 4E 0A 42		  1          or  Bptr(Z.Middles), low ??004C
 0EEB   5   C3			      ret

 0EEC				     Action55:; +-= ; Sets PosPlus, PosMinus or PosEq flag.
 0EEC   1   8B 86 0107		     mov ax,Z.TokNow
 0EF0   1   83 E8 24		     sub ax,$Minus
 0EF3  13   0F AB 46 0C		     bts Z.Clause,ax
 0EF7   5   C3			     ret

 0EF8				     Action56:; UPPER
				      On Z.Clause,WasUpper
 0EF8   3   80 4E 0D 80		  1          or  Bptr(Z.Clause+1), high ??004D
 0EFC   5   C3			     ret

 0EFD				     Action57:; Trigger for last set in the template.
 0EFD   1   B0 22		      mov al,$mPosRest
 0EFF   3   EB A5		      jmp PostTrigger

 0F01				     Action58:; Comma in template
				      On Z.Middles,TargetSymbol,DotOK; For target names
 0F01   3   80 4E 0A 42		  1          or  Bptr(Z.Middles), low ??004E
 0F05   1   B0 4A		      mov al,$mTemplateComma
 0F07   3   E9 F7E5		      jmp Pcode1

 0F0A   1   8B 8E 00EF		     ConditionNum:mov cx,Z.Condition
				     ; Set OpAppendCl for subsequent PcodeOp.
				     ; Fiddle to correct order for testing.
 0F0E   1   80 F9 C8		      cmp cl,$NOTREADY
 0F11  3,1  75 01		      jne @F
 0F13   1   49			      dec cx
 0F14   1   80 F9 CC		      @@:cmp cl,$ERROR
 0F17  3,1  75 03		      jne @F
 0F19   1   80 E9 04		      sub cl,4
 0F1C				      @@:
 0F1C   1   80 C1 3C		      add cl,1-$LOSTDIGITS
				     ; Now Syntax,LostDigits,NoValue,NotReady,Error,Failure,Halt
 0F1F   5   C3			      ret

 0F20				     Action60:; callon spec
 0F20   1   B0 8F		     mov al,$pCallOn
 0F22				     Action60x:Qry Z.Clause,OffFlag
 0F22   2   F6 46 0D 40		  1          test Bptr(Z.Clause+1), high ??004F
 0F26  3,1  74 08		     jz CallOn
 0F28   3   E8 FFDF		      call ConditionNum
				      OpRet $pSignalOff
 0F2B   1   B0 B1		  1    mov al,$pSignalOff
 0F2D   3   E9 F53A		  1    jmp PcodeOp

 0F30   2   81 7E 12 00DC	     CallOn:cmp Z.KWFound,$NAME
 0F35  3,1  74 09		     je @F
				     ; The condition looked up as a keyword is still around raw to be a constant.
				      On Z.Middles,LookLabel,TakenConstant
 0F37   3   80 4E 0A 18		  1          or  Bptr(Z.Middles), low ??0050
 0F3B   1   B4 48		      mov TokNumAh,$VAR_SYMBOL
 0F3D   3   E8 F18B		      call Lookup
 0F40   3   E8 FFC7		     @@:call ConditionNum
 0F43   3   E9 F524		      jmp PcodeOp

 0F46   1   8B 46 12		     Action61:mov ax,Z.KWFound
 0F49   1   89 86 00EF		     mov Z.Condition,ax
				     On Z.Clause,Condition
 0F4D   3   80 4E 0D 20		  1          or  Bptr(Z.Clause+1), high ??0051
 0F51   5   C3			     ret

 0F52				     Action62:On Z.Clause,OffFlag
 0F52   3   80 4E 0D 40		  1          or  Bptr(Z.Clause+1), high ??0052
 0F56   5   C3			     ret

 0F57				     SignalVerb:
 0F57   1   B0 8D		      mov al,$pSignalOn
				      Qry Z.Clause,Condition
 0F59   2   F6 46 0D 20		  1          test Bptr(Z.Clause+1), high ??0053
 0F5D  3,1  75 C3		      jnz Action60x; Join CALL ON
				     ; Lookup has distinquished SIGNAL ABC and SIGNAL VALUE ABC.(Labels not stacked)
 0F5F   2   3B 7E 54		      cmp StackDi,Z.Base0
 0F62  3,1  74 05		      je @F
				      OpRet $pSignalV
 0F64   1   B0 B3		  1    mov al,$pSignalV
 0F66   3   E9 F501		  1    jmp PcodeOp

				     ; SIGNAL ABC, argument not on stack.
				     ; We could save code by converting this to be like VALUE "ConstSymbol" but
				     ; using another opcode makes execution much faster.
 0F69				     @@:OpRet $pSignal
 0F69   1   B0 8B		  1    mov al,$pSignal
 0F6B   3   E9 F4FC		  1    jmp PcodeOp

				     ; This is setup to use just one opcode $pCommandEnv with value following for
				     ; STEM/STREAM/NORMAL + in/out/err + append.
 0F6E				     Action70:; ADDRESS instruction completes.
				      move Z.Stack,Z.Base0
 0F6E   1   8B 46 54		  1      mov ax,Z.Base0
 0F71   1   89 46 06		  1      mov Z.Stack,ax
				      OpRet $pAddress
 0F74   1   B0 A5		  1    mov al,$pAddress
 0F76   3   E9 F4F1		  1    jmp PcodeOp

 0F79				     Action71:; INPUT resources
 0F79   1   B1 02		     mov OpAppendCl,offset EnvBlock.EnvResourceI
 0F7B				     A7n:
				     ; Add flags to those in OpAppendCl.
 0F7B   1   8B 46 12		      mov ax,Z.KWFound
 0F7E   1   04 FD		      add al,low($sStem-$STEM)
 0F80   1   BB 0654 R		      mov bx,S2P
 0F83   4   2E: D7		      xlat cs:Bptr[bx]
 0F85   1   0A C8		      or OpAppendCl,al
				      OpRet $pCommandEnv
 0F87   1   B0 A7		  1    mov al,$pCommandEnv
 0F89   3   E9 F4DE		  1    jmp PcodeOp

 0F8C				     Action72:; OUTPUT resources
 0F8C   1   B1 04		     mov OpAppendCl,offset EnvBlock.EnvResourceO
 0F8E   8   0F BA 76 0C 0C	     @@:btr Z.Clause,Append
 0F93  3,1  73 E6		     jnc A7n
 0F95   1   80 C9 80		     or OpAppendCl,080h
 0F98   3   EB E1		     jmp A7n

 0F9A				     Action73:; ERROR resources
 0F9A   1   B1 06		     mov OpAppendCl,offset EnvBlock.EnvResourceE
 0F9C   3   EB F0		     jmp @B

 0F9E				     Action74:; APPEND
				     On Z.Clause,Append
 0F9E   3   80 4E 0D 10		  1          or  Bptr(Z.Clause+1), high ??0054
 0FA2   5   C3			     ret

 0FA3				     Action75:; Environment name. Can be VALUEd so needs runtime lookup.
				      OpRet $pEnvName
 0FA3   1   B0 A9		  1    mov al,$pEnvName
 0FA5   3   E9 F4C2		  1    jmp PcodeOp

 0FA8				     Action80:; numerics
				     ; We could have set up the BNF so as to have separate actions but that
				     ; would have meant duplicated code here.
				     ; We could do the defaults dynamically without noticeable loss of speed
				     ; but we choose compile time.
				     ; First construct subcode and done if there is an operand.
 0FA8   1   8B 46 12		      mov ax,Z.KWFound
 0FAB   1   04 43		      add al,$sDigits-$DIGITS
				     ; Simplest to work out default even when it might not be needed.
				     ; Provide default operand. Tied in with order of groups and $Reserved.
				     ; $?Nine: (9 0 '' 'E' 'S') on Reserved
				     ; DIGITS,FUZZ, ,NOP,FORM on Scodes.
				     ; Adjust to stride for constants (the defaults).
 0FAD   1   50			      push ax
 0FAE   1   B4 08		      mov ah,$StrideV
 0FB0  13+  F6 E4		      mul ah
				     ; If bigger than $sForm it will be Engineering/Scientific.
				     ; Else DIGITS...FORM range fits 9...'S' range.
 0FB2   1   3D 0158		      cmp ax,$StrideV*$sForm
 0FB5  3,1  76 07		      jna @F
				     ; Subcode becomes FORM for ENGINEERING/SCIENTIFIC keywords.
 0FB7   1   5B			      pop bx
 0FB8   1   B3 2B		      mov bl,$sForm
 0FBA   1   53			      push bx
				     ; Adjust for values 'E' and 'S'.
				     ; Cancel the $DIGITS factor and substitute $ENGINEERING.
				     ; Cancel the $?Nine factor (coming later) and substitute $?E.
				     ; The brackets below help the assembler!
 0FBB   1   83 C0 D8		      add ax,($?E)-($?Nine)-($ENGINEERING-$DIGITS)*$StrideV
 0FBE   2   3B 7E 54		     @@:cmp StackDi,Z.Base0
 0FC1  3,1  75 0A		      jne HaveValue
 0FC3   1   05 FF64		      add ax,$?Nine-$StrideV*$sDigits
 0FC6   3   E8 F6D6		      call Pcode2
 0FC9   3   83 46 06 08		      add Z.Stack,$StrideV
 0FCD   1   58			     HaveValue:pop ax
 0FCE   1   BB 0654 R		      mov bx,S2P
 0FD1   4   2E: D7		      xlat cs:Bptr[bx]
 0FD3   1   8A C8		      mov OpAppendCl,al
				      OpRet $pNumeric
 0FD5   1   B0 51		  1    mov al,$pNumeric
 0FD7   3   E9 F490		  1    jmp PcodeOp

 0FDA				     Action90:; Trace event for end-of-expression.
				      EvRet $TraceExpr
 0FDA   1   B4 0C		  1    mov ah,$TraceExpr
 0FDC   3   E9 FA01		  1    jmp TraceEvent

 0FDF				     Action91:; Can use NOP as an end-of-clause marker, if one is needed.
				      Qry Z.Middles,EndClause
 0FDF   2   F6 46 0B 02		  1          test Bptr(Z.Middles+1), high ??0055
 0FE3  3,1  74 05		      jz @F
				      OpRet $pNop
 0FE5   1   B0 05		  1    mov al,$pNop
 0FE7   3   E9 F480		  1    jmp PcodeOp
				     ; Trace event for end-of-clause
 0FEA				     @@:Qry Z.Gen,DualGen
 0FEA   2   F6 46 0F 20		  1          test Bptr(Z.Gen+1), high ??0056
 0FEE  3,1  74 12		     jz NotDualGen
				     ; Compiling for dual mode.
				      EvAh $TraceEndClause
 0FF0   1   B4 1E		  1    mov ah,$TraceEndClause
 0FF2   3   E8 F9EB		  1    call TraceEvent
				     if Debug
				     ; Make dump show newest code.
 0FF5   3   E8 0000 E		      call Create4Dump
 0FF8   3   E8 0000 E		      call Dumper
				     endif
				     ; One clause at a time is compiled in dual mode.
				      Qry Z.Gen,Dual
 0FFB   2   F6 46 0F 80		  1          test Bptr(Z.Gen+1), high ??0057
 0FFF  3,1  75 0D		      jnz Terminate
 1001   5   C3			      ret

				     ; If the Z.Synch was for tracing, the following clause needs
				     ; dual code generated.
 1002   8   0F BA 76 0E 0E	     NotDualGen:btr Z.Gen,DualPending
 1007  3,1  73 04		     jnc @F
				     On Z.Gen,DualGen
 1009   3   80 4E 0F 20		  1          or  Bptr(Z.Gen+1), high ??0058
 100D   5   C3			     @@:ret

				     ;------------------------------------------------------------------------------
				     ; Terminate the code made when Cycle reaches end of source.
				     ; Used from Syntax.
				     ;------------------------------------------------------------------------------
 100E				     Terminate:z Z.Scanp
 100E   1   89 AE 00E1		  1           mov Z.Scanp,bp
				      move Z.Stack,Z.Base0,StackDi
 1012   1   8B 7E 54		  1    mov StackDi,Z.Base0
 1015   1   89 7E 06		  1    mov Z.Stack,StackDi
 1018   2   39 AE 010D		      cmp Z.Synch,ZeroBp
 101C  3,1  75 0E		      jne NoTrailer
				     ; ?? Probably need a flag for TraceBack anyway so Exit & InterpEnd could share?
 101E   1   B0 27		      mov al,$pExit
 1020   8   0F BA 76 02 0D	      btr Z.Program,LabelsBad
 1025  3,1  73 02		      jnc NotInterp
 1027   1   B0 89		      mov al,$pInterpEnd
 1029   3   E8 F43E		     NotInterp:call PcodeOp
 102C				     NoTrailer:
				     ; Does this every time because code segment could have extended.
				     ; Note results of compilation.
				     ; Is there a problem that we should update F.Code as soon as Z.Code changes,
				     ; avoiding situation when compaction in between would save both versions??
 102C   6p  C5 5E 3C		      lds bx,Z.SysFile
				      On F.Flags,BeenCompiled
 102F   3   80 4F E7 01		  1          or  Bptr(F.Flags+1), high ??0059
				      move F.Symbols,Z.Symbols
 1033   1   8B 46 48		  1      mov ax,Z.Symbols
 1036   1   89 47 F6		  1      mov F.Symbols,ax
				      move F.Code,Z.Code
 1039   1   8B 46 4A		  1      mov ax,Z.Code
 103C   1   89 47 F8		  1      mov F.Code,ax
				      move F.Consts,Z.Consts
 103F   1   8B 46 40		  1      mov ax,Z.Consts
 1042   1   89 47 FC		  1      mov F.Consts,ax
				      move F.Vars,Z.Vars
 1045   1   8B 46 42		  1      mov ax,Z.Vars
 1048   1   89 47 FA		  1      mov F.Vars,ax
				      move F.ProgScope,Z.ProgScope
 104B   1   8B 46 44		  1      mov ax,Z.ProgScope
 104E   1   89 47 FE		  1      mov F.ProgScope,ax
 1051   1   8B 66 2C		      mov sp,Z.ParseResetSp
 1054   5   C3			      ret

				      end
Microsoft (R) Macro Assembler Version 6.11		    01/27/12 18:24:09
pcode.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

AllocAppend  . . . . . . . . . . . . .	Proc
BackRet  . . . . . . . . . . . . . . .	Proc
Back . . . . . . . . . . . . . . . . .	Proc
CheckType  . . . . . . . . . . . . . .	Proc
CodeModeR  . . . . . . . . . . . . . .	Proc
DownCare . . . . . . . . . . . . . . .	Proc
Down . . . . . . . . . . . . . . . . .	Proc
EvAh . . . . . . . . . . . . . . . . .	Proc
EvRet  . . . . . . . . . . . . . . . .	Proc
JcxzQ  . . . . . . . . . . . . . . . .	Proc
LoopQ  . . . . . . . . . . . . . . . .	Proc
MkMajMin . . . . . . . . . . . . . . .	Func
Move . . . . . . . . . . . . . . . . .	Proc
Mv . . . . . . . . . . . . . . . . . .	Proc
Off  . . . . . . . . . . . . . . . . .	Proc
On . . . . . . . . . . . . . . . . . .	Proc
OpAl . . . . . . . . . . . . . . . . .	Proc
OpRet  . . . . . . . . . . . . . . . .	Proc
PopJunk  . . . . . . . . . . . . . . .	Proc
Pos  . . . . . . . . . . . . . . . . .	Func
Qry  . . . . . . . . . . . . . . . . .	Proc
Repmovsb . . . . . . . . . . . . . . .	Proc
RetSi  . . . . . . . . . . . . . . . .	Proc
Splat  . . . . . . . . . . . . . . . .	Proc
StringOrder  . . . . . . . . . . . . .	Func
TestReg  . . . . . . . . . . . . . . .	Proc
UnCodeMode . . . . . . . . . . . . . .	Proc
UpCare . . . . . . . . . . . . . . . .	Proc
Up . . . . . . . . . . . . . . . . . .	Proc
XlatBDLS . . . . . . . . . . . . . . .	Proc
dec2 . . . . . . . . . . . . . . . . .	Proc
inc2 . . . . . . . . . . . . . . . . .	Proc
la . . . . . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . . . . .	Proc
mv . . . . . . . . . . . . . . . . . .	Proc
top  . . . . . . . . . . . . . . . . .	Proc
xax  . . . . . . . . . . . . . . . . .	Proc
z  . . . . . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Ashape . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Amount . . . . . . . . . . . . . . .	 0004	     Word
Dshape . . . . . . . . . . . . . . . .	 0028
  TailsAt  . . . . . . . . . . . . . .	 0000	     Word
  Subject  . . . . . . . . . . . . . .	 0000	     QWord
  CVinit . . . . . . . . . . . . . . .	 0000	     QWord
  Reps . . . . . . . . . . . . . . . .	 0000	     QWord
  To . . . . . . . . . . . . . . . . .	 0008	     QWord
  By . . . . . . . . . . . . . . . . .	 0010	     QWord
  ForCount . . . . . . . . . . . . . .	 0018	     QWord
  PcodePos . . . . . . . . . . . . . .	 0020	     Word
  Iteration  . . . . . . . . . . . . .	 0020	     Word
  Leaving  . . . . . . . . . . . . . .	 0022	     Word
  UpDO . . . . . . . . . . . . . . . .	 0024	     Word
  CV . . . . . . . . . . . . . . . . .	 0024	     Word
  Rec  . . . . . . . . . . . . . . . .	 0027	     Byte
EnvBlock . . . . . . . . . . . . . . .	 0008
  EnvNumber  . . . . . . . . . . . . .	 0000	     Word
  EnvResourceI . . . . . . . . . . . .	 0002	     Word
  EnvResourceO . . . . . . . . . . . .	 0004	     Word
  EnvResourceE . . . . . . . . . . . .	 0006	     Word
FarpX  . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
Farp . . . . . . . . . . . . . . . . .	 0004
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
Fshape . . . . . . . . . . . . . . . .	 001A
  Flags  . . . . . . . . . . . . . . .	 0000	     Word
  ToQual . . . . . . . . . . . . . . .	 0002	     Word
  Lines  . . . . . . . . . . . . . . .	 0004	     DWord
  Hand . . . . . . . . . . . . . . . .	 0008	     Word
  Other_Position . . . . . . . . . . .	 000A	     DWord
  Exten  . . . . . . . . . . . . . . .	 000E	     Byte
  TraceWidth . . . . . . . . . . . . .	 000F	     Byte
  Symbols  . . . . . . . . . . . . . .	 0010	     Word
  Code . . . . . . . . . . . . . . . .	 0012	     Word
  Vars . . . . . . . . . . . . . . . .	 0014	     Word
  Consts . . . . . . . . . . . . . . .	 0016	     Word
  ProgScope  . . . . . . . . . . . . .	 0018	     Word
Hshape . . . . . . . . . . . . . . . .	 0010
  Hdw0 . . . . . . . . . . . . . . . .	 0000	     DWord
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  Bump . . . . . . . . . . . . . . . .	 0002	     Word
  Avail  . . . . . . . . . . . . . . .	 0004	     Word
  Trigger  . . . . . . . . . . . . . .	 0006	     Word
  Link . . . . . . . . . . . . . . . .	 0008	     Word
  TreeBin  . . . . . . . . . . . . . .	 000A	     Word
  Original . . . . . . . . . . . . . .	 000A	     Word
  UpPool . . . . . . . . . . . . . . .	 000A	     Word
  Probe  . . . . . . . . . . . . . . .	 000C	     Word
  TreeProg . . . . . . . . . . . . . .	 000E	     Word
  Labels . . . . . . . . . . . . . . .	 000E	     Word
InsBlock . . . . . . . . . . . . . . .	 0015
  MajMin . . . . . . . . . . . . . . .	 0000	     Word
  Minor  . . . . . . . . . . . . . . .	 0000	     Byte
  Major  . . . . . . . . . . . . . . .	 0001	     Byte
  Value  . . . . . . . . . . . . . . .	 0002	     Word
  Named  . . . . . . . . . . . . . . .	 0004	     Word
  Position . . . . . . . . . . . . . .	 0004	     Word
  KeysList . . . . . . . . . . . . . .	 0006	     Word
  ArgNum . . . . . . . . . . . . . . .	 0008	     Byte
  Desc . . . . . . . . . . . . . . . .	 0009	     Byte
  Hex  . . . . . . . . . . . . . . . .	 000A	     Byte
  Char . . . . . . . . . . . . . . . .	 000A	     Byte
  Options  . . . . . . . . . . . . . .	 000B	     Word
  OptsHi . . . . . . . . . . . . . . .	 000D	     Word
  Digits . . . . . . . . . . . . . . .	 000F	     Word
  TokPos . . . . . . . . . . . . . . .	 0011	     Word
  TokLen . . . . . . . . . . . . . . .	 0013	     Word
Jshape . . . . . . . . . . . . . . . .	 000E
  Valued . . . . . . . . . . . . . . .	 0000	     QWord
  Pair . . . . . . . . . . . . . . . .	 0008	     DWord
  Lower  . . . . . . . . . . . . . . .	 0008	     Word
  Higher . . . . . . . . . . . . . . .	 000A	     Word
  KeyLen . . . . . . . . . . . . . . .	 000C	     Word
  Key  . . . . . . . . . . . . . . . .	 000E	     Byte
Lshape . . . . . . . . . . . . . . . .	 007C
  DigitsFuzz . . . . . . . . . . . . .	 0000	     DWord
  Digits . . . . . . . . . . . . . . .	 0000	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0002	     Word
  Form . . . . . . . . . . . . . . . .	 0004	     Byte
  StartTime  . . . . . . . . . . . . .	 0005	     QWord
  TraceLetter  . . . . . . . . . . . .	 000D	     Byte
  TraceWord  . . . . . . . . . . . . .	 000D	     Word
  Active . . . . . . . . . . . . . . .	 000F	     QWord
  Alternate  . . . . . . . . . . . . .	 0017	     QWord
  Syntax . . . . . . . . . . . . . . .	 001F	     Byte
  LostDigits . . . . . . . . . . . . .	 0020	     Byte
  NoValue  . . . . . . . . . . . . . .	 0021	     Byte
  NotReady . . . . . . . . . . . . . .	 0022	     Byte
  Error  . . . . . . . . . . . . . . .	 0023	     Byte
  Failure  . . . . . . . . . . . . . .	 0024	     Byte
  Halt . . . . . . . . . . . . . . . .	 0025	     Byte
  TrapName . . . . . . . . . . . . . .	 0026	     Word
  EventLevel . . . . . . . . . . . . .	 0034	     Word
  Condition  . . . . . . . . . . . . .	 0036	     Word
  ConditionDescription . . . . . . . .	 0038	     QWord
  ConditionExtra . . . . . . . . . . .	 0040	     QWord
  Inherit  . . . . . . . . . . . . . .	 0048	     Byte
  ClauseTime . . . . . . . . . . . . .	 0048	     QWord
  ClauseLocal  . . . . . . . . . . . .	 0050	     QWord
  PendingDescription . . . . . . . . .	 0058	     QWord
  PendingExtra . . . . . . . . . . . .	 0060	     QWord
  LevelDO  . . . . . . . . . . . . . .	 0068	     Word
  StackSave  . . . . . . . . . . . . .	 006A	     DWord
  File . . . . . . . . . . . . . . . .	 006E	     Word
  ProgScope  . . . . . . . . . . . . .	 0070	     Word
  VarScope . . . . . . . . . . . . . .	 0072	     Word
  Access . . . . . . . . . . . . . . .	 0074	     Word
  Flags  . . . . . . . . . . . . . . .	 0074	     Word
  UpLevel  . . . . . . . . . . . . . .	 0076	     Word
  Resume . . . . . . . . . . . . . . .	 0078	     Word
  Arg0 . . . . . . . . . . . . . . . .	 007A	     Word
PushShape  . . . . . . . . . . . . . .	 0010
  di_  . . . . . . . . . . . . . . . .	 0000	     Word
  si_  . . . . . . . . . . . . . . . .	 0002	     Word
  bp_  . . . . . . . . . . . . . . . .	 0004	     Word
  sp_  . . . . . . . . . . . . . . . .	 0006	     Word
  bx_  . . . . . . . . . . . . . . . .	 0008	     Word
  bl_  . . . . . . . . . . . . . . . .	 0008	     Byte
  bh_  . . . . . . . . . . . . . . . .	 0009	     Byte
  dx_  . . . . . . . . . . . . . . . .	 000A	     Word
  dl_  . . . . . . . . . . . . . . . .	 000A	     Byte
  dh_  . . . . . . . . . . . . . . . .	 000B	     Byte
  cx_  . . . . . . . . . . . . . . . .	 000C	     Word
  cl_  . . . . . . . . . . . . . . . .	 000C	     Byte
  ch_  . . . . . . . . . . . . . . . .	 000D	     Byte
  ax_  . . . . . . . . . . . . . . . .	 000E	     Word
  al_  . . . . . . . . . . . . . . . .	 000E	     Byte
  ah_  . . . . . . . . . . . . . . . .	 000F	     Byte
Sshape . . . . . . . . . . . . . . . .	 0010
  State  . . . . . . . . . . . . . . .	 0000	     Word
  Parser . . . . . . . . . . . . . . .	 0002	     Word
  ClauseWas  . . . . . . . . . . . . .	 0004	     Word
  Token  . . . . . . . . . . . . . . .	 0006	     Word
  Operation  . . . . . . . . . . . . .	 0008	     DWord
  Caller . . . . . . . . . . . . . . .	 000C	     Word
  Parms  . . . . . . . . . . . . . . .	 000E	     Word
  JumpSite . . . . . . . . . . . . . .	 0006	     Word
  SoFar  . . . . . . . . . . . . . . .	 0008	     Word
  WhatCV . . . . . . . . . . . . . . .	 0008	     Word
  SelectSite . . . . . . . . . . . . .	 0008	     Word
Vshape . . . . . . . . . . . . . . . .	 0008
  String . . . . . . . . . . . . . . .	 0000	     Byte
  Dtype  . . . . . . . . . . . . . . .	 0007	     Byte
  Sign . . . . . . . . . . . . . . . .	 0000	     Byte
  ExpAnd . . . . . . . . . . . . . . .	 0000	     DWord
  ExpoUses . . . . . . . . . . . . . .	 0000	     Byte
  ExpoSign . . . . . . . . . . . . . .	 0003	     Byte
  Mantissa . . . . . . . . . . . . . .	 0004	     DWord
  MantLow  . . . . . . . . . . . . . .	 0004	     Word
  MantHigh . . . . . . . . . . . . . .	 0006	     Word
  OverExpo . . . . . . . . . . . . . .	 0000	     DWord
  OverMant . . . . . . . . . . . . . .	 0004	     DWord
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
  LabelValue . . . . . . . . . . . . .	 0000	     Word
  LabelType  . . . . . . . . . . . . .	 0006	     Word
  WhichCon . . . . . . . . . . . . . .	 0000	     Word
  PcodePos . . . . . . . . . . . . . .	 0002	     Word
  HeldOver . . . . . . . . . . . . . .	 0000	     Word
  Pair . . . . . . . . . . . . . . . .	 0000	     DWord
  Lower  . . . . . . . . . . . . . . .	 0000	     Word
  Higher . . . . . . . . . . . . . . .	 0002	     Word
  Here . . . . . . . . . . . . . . . .	 0004	     Word
Yshape . . . . . . . . . . . . . . . .	 0053
  N1 . . . . . . . . . . . . . . . . .	 0004	     DWord
  N10  . . . . . . . . . . . . . . . .	 0008	     DWord
  N100 . . . . . . . . . . . . . . . .	 000C	     DWord
  N1000  . . . . . . . . . . . . . . .	 0010	     DWord
  N1e4 . . . . . . . . . . . . . . . .	 0014	     DWord
  N1e5 . . . . . . . . . . . . . . . .	 0018	     DWord
  N1e6 . . . . . . . . . . . . . . . .	 001C	     DWord
  N1e7 . . . . . . . . . . . . . . . .	 0020	     DWord
  N1e8 . . . . . . . . . . . . . . . .	 0024	     DWord
  N1e9 . . . . . . . . . . . . . . . .	 0028	     DWord
  N1664525 . . . . . . . . . . . . . .	 002C	     DWord
  ExponHi  . . . . . . . . . . . . . .	 0030	     DWord
  ExponLo  . . . . . . . . . . . . . .	 0034	     DWord
  Cseg . . . . . . . . . . . . . . . .	 0038	     Word
  DOS  . . . . . . . . . . . . . . . .	 003A	     DWord
  DosPool  . . . . . . . . . . . . . .	 003E	     Byte
  DqCrLf . . . . . . . . . . . . . . .	 004C	     Byte
  CrLf . . . . . . . . . . . . . . . .	 004D	     Byte
  StackSave  . . . . . . . . . . . . .	 004F	     DWord
Zshape . . . . . . . . . . . . . . . .	 137C
  w  . . . . . . . . . . . . . . . . .	 0000	     Word
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  ProgramCancel  . . . . . . . . . . .	 0002	     DWord
  Program  . . . . . . . . . . . . . .	 0002	     Word
  Cancel . . . . . . . . . . . . . . .	 0004	     Word
  Stack  . . . . . . . . . . . . . . .	 0006	     Word
  ClauseLine . . . . . . . . . . . . .	 0008	     Word
  Middles  . . . . . . . . . . . . . .	 000A	     Word
  Clause . . . . . . . . . . . . . . .	 000C	     Word
  Gen  . . . . . . . . . . . . . . . .	 000E	     Word
  KWMiddle . . . . . . . . . . . . . .	 0010	     Word
  KWFound  . . . . . . . . . . . . . .	 0012	     Word
  Stdout . . . . . . . . . . . . . . .	 0014	     Word
  Stderr . . . . . . . . . . . . . . .	 0016	     Word
  SourceHandle . . . . . . . . . . . .	 0018	     Word
  HowInvoked . . . . . . . . . . . . .	 001A	     Word
  Radix  . . . . . . . . . . . . . . .	 001C	     Byte
  AxAsNum  . . . . . . . . . . . . . .	 001D	     Byte
  Tag  . . . . . . . . . . . . . . . .	 0023	     Byte
  Seed . . . . . . . . . . . . . . . .	 0028	     DWord
  ParseResetSp . . . . . . . . . . . .	 002C	     Word
  XCycleResetSp  . . . . . . . . . . .	 002E	     Word
  Dumper . . . . . . . . . . . . . . .	 0030	     Word
  Stash  . . . . . . . . . . . . . . .	 0032	     Word
  Resolved . . . . . . . . . . . . . .	 0034	     Word
  Cursor . . . . . . . . . . . . . . .	 0036	     Word
  Stream . . . . . . . . . . . . . . .	 0038	     Word
  Queue  . . . . . . . . . . . . . . .	 003A	     Word
  InsSource  . . . . . . . . . . . . .	 003C	     DWord
  SysFile  . . . . . . . . . . . . . .	 003C	     DWord
  File . . . . . . . . . . . . . . . .	 003C	     Word
  SysFiles . . . . . . . . . . . . . .	 003E	     Word
  Consts . . . . . . . . . . . . . . .	 0040	     Word
  Vars . . . . . . . . . . . . . . . .	 0042	     Word
  ProgScope  . . . . . . . . . . . . .	 0044	     Word
  VarScope . . . . . . . . . . . . . .	 0046	     Word
  Symbols  . . . . . . . . . . . . . .	 0048	     Word
  Code . . . . . . . . . . . . . . . .	 004A	     Word
  Zone . . . . . . . . . . . . . . . .	 004C	     Word
  Stem . . . . . . . . . . . . . . . .	 004E	     Word
  PoolPool . . . . . . . . . . . . . .	 0050	     Word
  Level  . . . . . . . . . . . . . . .	 0052	     Word
  Base0  . . . . . . . . . . . . . . .	 0054	     Word
  CurrentDO  . . . . . . . . . . . . .	 0056	     Word
  ResumeP  . . . . . . . . . . . . . .	 0058	     Word
  ResumeDF . . . . . . . . . . . . . .	 005A	     DWord
  ResumeD  . . . . . . . . . . . . . .	 005A	     Word
  ResumeF  . . . . . . . . . . . . . .	 005C	     Word
  ResumeS  . . . . . . . . . . . . . .	 005E	     Byte
  DigitsFuzz . . . . . . . . . . . . .	 005F	     DWord
  Digits . . . . . . . . . . . . . . .	 005F	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0061	     Word
  Ceiling  . . . . . . . . . . . . . .	 0063	     DWord
  DivBreak . . . . . . . . . . . . . .	 0067	     DWord
  TwiceDigits  . . . . . . . . . . . .	 006B	     DWord
  UseGeneral . . . . . . . . . . . . .	 006F	     Word
  InsLine  . . . . . . . . . . . . . .	 0071	     Word
  InsBif . . . . . . . . . . . . . . .	 0073	     Byte
  InsOperator  . . . . . . . . . . . .	 0074	     DWord
  InsUnqual  . . . . . . . . . . . . .	 0078	     Word
  Insert . . . . . . . . . . . . . . .	 007A	      0015
  Inserts  . . . . . . . . . . . . . .	 008F	      0015
  SignM  . . . . . . . . . . . . . . .	 00A4	     Byte
  SignE  . . . . . . . . . . . . . . .	 00A5	     Byte
  MantPos  . . . . . . . . . . . . . .	 00A6	     Word
  MantPosZi  . . . . . . . . . . . . .	 00A8	     Word
  ExpPos . . . . . . . . . . . . . . .	 00AA	     Word
  ExpPosZi . . . . . . . . . . . . . .	 00AC	     Word
  ExpSign  . . . . . . . . . . . . . .	 00AE	     Word
  MantSize . . . . . . . . . . . . . .	 00B0	     Word
  OpIs . . . . . . . . . . . . . . . .	 00B2	     Byte
  Flags  . . . . . . . . . . . . . . .	 00B3	     Byte
  BifParmsHi . . . . . . . . . . . . .	 00B4	     Byte
  BifByte  . . . . . . . . . . . . . .	 00B5	     Byte
  TraceAlign . . . . . . . . . . . . .	 00B6	     DWord
  TraceSource  . . . . . . . . . . . .	 00BA	     DWord
  TraceEnds  . . . . . . . . . . . . .	 00BE	     DWord
  TraceSourceColumn  . . . . . . . . .	 00C2	     Word
  TraceEndsColumn  . . . . . . . . . .	 00C4	     Word
  DualCode . . . . . . . . . . . . . .	 00C6	     Word
  TraceOp  . . . . . . . . . . . . . .	 00C8	     Byte
  Relative . . . . . . . . . . . . . .	 00C9	     DWord
  RelativeNow  . . . . . . . . . . . .	 00CD	     DWord
  Continue . . . . . . . . . . . . . .	 00D1	     Word
  StackX . . . . . . . . . . . . . . .	 00D3	     Word
  TraceLine  . . . . . . . . . . . . .	 00D5	     Word
  InhibitTrace . . . . . . . . . . . .	 00D7	     DWord
  InhibitPauses  . . . . . . . . . . .	 00DB	     DWord
  Target . . . . . . . . . . . . . . .	 00DF	     Word
  Scanp  . . . . . . . . . . . . . . .	 00E1	     Word
  EndUsedBuffer  . . . . . . . . . . .	 00E3	     Word
  NearEnd  . . . . . . . . . . . . . .	 00E5	     Word
  CatOp  . . . . . . . . . . . . . . .	 00E7	     Byte
  RadixBadWhite  . . . . . . . . . . .	 00E8	     Byte
  BackExponent . . . . . . . . . . . .	 00E9	     Word
  LastContent  . . . . . . . . . . . .	 00EB	     Word
  CommaLine  . . . . . . . . . . . . .	 00ED	     Word
  Condition  . . . . . . . . . . . . .	 00EF	     Word
  UntilPlace . . . . . . . . . . . . .	 00F1	     Word
  StemSym  . . . . . . . . . . . . . .	 00F3	     Word
  SoFar  . . . . . . . . . . . . . . .	 00F5	     Word
  PcodePos . . . . . . . . . . . . . .	 00F7	     Word
  TraceOnly  . . . . . . . . . . . . .	 00F9	     Word
  CompareAt  . . . . . . . . . . . . .	 00FB	     Word
  StackHi  . . . . . . . . . . . . . .	 00FD	     Word
  StackLo  . . . . . . . . . . . . . .	 00FF	     Word
  OnSoft . . . . . . . . . . . . . . .	 0101	     Word
  Tail . . . . . . . . . . . . . . . .	 0103	     Word
  TokNum . . . . . . . . . . . . . . .	 0105	     Word
  TokNow . . . . . . . . . . . . . . .	 0107	     Word
  TokWas . . . . . . . . . . . . . . .	 0109	     Word
  TokData  . . . . . . . . . . . . . .	 010B	     Word
  Synch  . . . . . . . . . . . . . . .	 010D	     Word
  Lines  . . . . . . . . . . . . . . .	 010F	     Word
  MsgBegin . . . . . . . . . . . . . .	 0111	     Word
  MsgSoFar . . . . . . . . . . . . . .	 0113	     Word
  PreZi  . . . . . . . . . . . . . . .	 0115	     Word
  TargetMajMin . . . . . . . . . . . .	 0117	     Word
  TargetMinor  . . . . . . . . . . . .	 0117	     Byte
  TargetMajor  . . . . . . . . . . . .	 0118	     Byte
  EnvSeg . . . . . . . . . . . . . . .	 0119	     Word
  ForPSP . . . . . . . . . . . . . . .	 011B	     DWord
  Fcb1 . . . . . . . . . . . . . . . .	 011F	     DWord
  Fcb2 . . . . . . . . . . . . . . . .	 0123	     DWord
  AtPause  . . . . . . . . . . . . . .	 0127	     Word
  ArgsB  . . . . . . . . . . . . . . .	 0129	     Byte
  ArgsB0 . . . . . . . . . . . . . . .	 012A	     Word
  Parsee . . . . . . . . . . . . . . .	 012C	     FWord
  ParseeNum  . . . . . . . . . . . . .	 0132	     Word
  PattLenEtc . . . . . . . . . . . . .	 0134	     Word
  BreakStart . . . . . . . . . . . . .	 0136	     Word
  BreakEnd . . . . . . . . . . . . . .	 0138	     Word
  EnvNow . . . . . . . . . . . . . . .	 013A	     QWord
  CatTotal . . . . . . . . . . . . . .	 0142	     Word
  LastTarget . . . . . . . . . . . . .	 0144	     Word
  NewJshape  . . . . . . . . . . . . .	 0146	     Word
  FromDos  . . . . . . . . . . . . . .	 0148	     Word
  FromDosWas . . . . . . . . . . . . .	 014A	     Word
  FromDosZi  . . . . . . . . . . . . .	 014C	     Word
  MemoryTable  . . . . . . . . . . . .	 014E	     FWord
  MemoryTableZi  . . . . . . . . . . .	 018A	     Byte
  Left . . . . . . . . . . . . . . . .	 018A	     Word
  Right  . . . . . . . . . . . . . . .	 018C	     Word
  AllocBase  . . . . . . . . . . . . .	 018E	     DWord
  DsWas  . . . . . . . . . . . . . . .	 0192	     Word
  DsNew  . . . . . . . . . . . . . . .	 0194	     Word
  EsWas  . . . . . . . . . . . . . . .	 0196	     Word
  EsNew  . . . . . . . . . . . . . . .	 0198	     Word
  FsWas  . . . . . . . . . . . . . . .	 019A	     Word
  FsNew  . . . . . . . . . . . . . . .	 019C	     Word
  GsWas  . . . . . . . . . . . . . . .	 019E	     Word
  GsNew  . . . . . . . . . . . . . . .	 01A0	     Word
  DebugStash . . . . . . . . . . . . .	 01A2	     Word
  DebugD . . . . . . . . . . . . . . .	 01A4	     DWord
  DigitCount . . . . . . . . . . . . .	 01A8	     Word
  SerialNow  . . . . . . . . . . . . .	 01AA	     Byte
  Serial . . . . . . . . . . . . . . .	 01AB	     Byte
  CommandArg . . . . . . . . . . . . .	 1374	     QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

CancelRec  . . . . . . . . . . . . . .	 0010	   0010
  Format5  . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  AssignDO . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ForExpose  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FromIterCV . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  ForBIF . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  TokIsValue . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  ExpRange . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Description  . . . . . . . . . . . .	 0008	   0001	     0100     ?
  Compacted  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  BcodeInterpret . . . . . . . . . . .	 0006	   0001	     0040     ?
  MapOnly  . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ParseUpper . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ParseTrace . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  SourceFiles  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  BoolBefore . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  WasDropped . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ClauseRec  . . . . . . . . . . . . . .	 0010	   0010
  WasUpper . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  OffFlag  . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Condition  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  Append . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Signal . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ClauseSet  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  CVar . . . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Repit  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PosEq  . . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NotAssign  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  WasParse . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  InParse  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  Tailed . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  WasTailed  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PosPlus  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PosMinus . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ConditionRec . . . . . . . . . . . . .	 0008	   0005
  Enabling . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  Delayed  . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PendingNow . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  Instruction  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  CRspare  . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ErrorRec . . . . . . . . . . . . . . .	 0010	   0004
  HasShiftOn . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAloneOn . . . . . . . . . . . .	 000E	   0001	     4000     ?
  MajorField . . . . . . . . . . . . .	 0006	   0008	     3FC0     ?
  MinorField . . . . . . . . . . . . .	 0000	   0006	     003F     ?
FRec . . . . . . . . . . . . . . . . .	 0010	   0009
  Qual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Read . . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Open . . . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  BeenRead . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  BeenWrite  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  WriteMode  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  IsSource . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  BeenCompiled . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FFpad  . . . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
GenRec . . . . . . . . . . . . . . . .	 0010	   0005
  Dual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  DualPending  . . . . . . . . . . . .	 000E	   0001	     4000     ?
  DualGen  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  DualOnly . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  GenSpare . . . . . . . . . . . . . .	 0000	   000C	     0FFF     ?
KeyRec . . . . . . . . . . . . . . . .	 0008	   0003
  KeyFlags . . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  EndList  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KeyLen . . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
LevelRecI  . . . . . . . . . . . . . .	 0010	   0003
  LIPad  . . . . . . . . . . . . . . .	 0002	   000E	     FFFC     ?
  Interactive  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ConditionInstruction . . . . . . . .	 0000	   0001	     0001     ?
LevelRec . . . . . . . . . . . . . . .	 0010	   0007
  Lpad . . . . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  InheritDone  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DigitsSet  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IsProcedure  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IsExternal . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IsFunction . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  Lpad2  . . . . . . . . . . . . . . .	 0000	   0003	     0007     ?
LoopsRec . . . . . . . . . . . . . . .	 0008	   0007
  LoopsPad . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  HasDot . . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  HasDots  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HasTo  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  HasFor . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IsInterp . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ByDown . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MiddleRec  . . . . . . . . . . . . . .	 0010	   0010
  NotLabel . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  SemiAfter  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ValueBefore  . . . . . . . . . . . .	 000D	   0001	     2000     ?
  AbutOK . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  NoBlanks . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ModEquals  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  EndClause  . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  ImplicitValue  . . . . . . . . . . .	 0008	   0001	     0100     ?
  CheckDO  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TargetSymbol . . . . . . . . . . . .	 0006	   0001	     0040     ?
  Function . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  TakenConstant  . . . . . . . . . . .	 0004	   0001	     0010     ?
  LookLabel  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LookBin  . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DotOK  . . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  MRspare  . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OperatorRec  . . . . . . . . . . . . .	 0008	   0006
  InTypes  . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ResultType . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  AppendNum  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  AppendRef  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DownOne  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  EndsClause . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ParmsRec . . . . . . . . . . . . . . .	 0008	   0003
  ParmsMin . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ParmsXtr . . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  NonCheck . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ParserRec  . . . . . . . . . . . . . .	 0010	   0005
  ParserPad  . . . . . . . . . . . . .	 0004	   000C	     FFF0     ?
  DoRep  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DoCV . . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  Forever  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DoDataHost . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ProgramRec . . . . . . . . . . . . . .	 0010	   000B
  API_Enabled  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Repass . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  LabelsBad  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FirstBetween . . . . . . . . . . . .	 000C	   0001	     1000     ?
  EndSource  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  BifCheck . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  RandomSeeded . . . . . . . . . . . .	 0009	   0001	     0200     ?
  NotS9  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  TraceIF  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ShowELSE . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PRSpare  . . . . . . . . . . . . . .	 0000	   0006	     003F     ?
RedRec . . . . . . . . . . . . . . . .	 0010	   0005
  HasShiftOff  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  HasAction  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PruneCt  . . . . . . . . . . . . . .	 000C	   0002	     3000     ?
  Rtype  . . . . . . . . . . . . . . .	 000A	   0002	     0C00     ?
  Rstate . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
ShiftRec . . . . . . . . . . . . . . .	 0010	   0008
  HasShift . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAlone . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  CatFlag  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  HasKeys  . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Reference  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  Direct . . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  Indexb . . . . . . . . . . . . . . .	 0005	   0005	     03E0     ?
  Index  . . . . . . . . . . . . . . .	 0000	   0005	     001F     ?
TokRec . . . . . . . . . . . . . . . .	 0010	   0003
  X02  . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  NdxbT  . . . . . . . . . . . . . . .	 000A	   0005	     7C00     ?
  Aim  . . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
TokVal . . . . . . . . . . . . . . . .	 0008	   0002
  GrpNdx . . . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SubNum . . . . . . . . . . . . . . .	 0000	   0002	     0003     ?


Types:

                N a m e                  Size     Attr

Boolp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
Bool . . . . . . . . . . . . . . . . .	 0001	  Byte 
Handlep  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Handle . . . . . . . . . . . . . . . .	 0002	  Word 
Segp . . . . . . . . . . . . . . . . .	 0002	  Word 
Ulong  . . . . . . . . . . . . . . . .	 0004	  DWord 
Ushortp  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Ushort . . . . . . . . . . . . . . . .	 0002	  Word 
bytep  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
charfp . . . . . . . . . . . . . . . .	 0004	  FarPTR Byte 
charp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
char . . . . . . . . . . . . . . . . .	 0001	  Byte 
shortp . . . . . . . . . . . . . . . .	 0002	  PTR Word 
short  . . . . . . . . . . . . . . . .	 0002	  Word 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . . . . .	16 Bit	 1055	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

$0 . . . . . . . . . . . . . . . . . .	Number	 0000h	 
$10  . . . . . . . . . . . . . . . . .	Number	 0007h	 
$11  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$12  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$15  . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$16  . . . . . . . . . . . . . . . . .	Number	 0017h	 
$17  . . . . . . . . . . . . . . . . .	Number	 0019h	 
$18  . . . . . . . . . . . . . . . . .	Number	 0018h	 
$19  . . . . . . . . . . . . . . . . .	Number	 001Ah	 
$1 . . . . . . . . . . . . . . . . . .	Number	 0013h	 
$21  . . . . . . . . . . . . . . . . .	Number	 0016h	 
$23  . . . . . . . . . . . . . . . . .	Number	 001Eh	 
$28  . . . . . . . . . . . . . . . . .	Number	 0012h	 
$2 . . . . . . . . . . . . . . . . . .	Number	 0015h	 
$3 . . . . . . . . . . . . . . . . . .	Number	 0004h	 
$5 . . . . . . . . . . . . . . . . . .	Number	 0006h	 
$6 . . . . . . . . . . . . . . . . . .	Number	 0003h	 
$7 . . . . . . . . . . . . . . . . . .	Number	 000Eh	 
$8 . . . . . . . . . . . . . . . . . .	Number	 0014h	 
$9 . . . . . . . . . . . . . . . . . .	Number	 0009h	 
$?BIF  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$?CLAUSELOCAL  . . . . . . . . . . . .	Number	 007Ch	 
$?CLAUSETIME . . . . . . . . . . . . .	Number	 0074h	 
$?Discard  . . . . . . . . . . . . . .	Number	 0010h	 
$?E  . . . . . . . . . . . . . . . . .	Number	 00B4h	 
$?LINEIN_POSITION  . . . . . . . . . .	Number	 006Ch	 
$?MN . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$?MONTHS . . . . . . . . . . . . . . .	Number	 0084h	 
$?Nine . . . . . . . . . . . . . . . .	Number	 009Ch	 
$?Null . . . . . . . . . . . . . . . .	Number	 00ACh	 
$?OUTCOME  . . . . . . . . . . . . . .	Number	 0044h	 
$?Omitted  . . . . . . . . . . . . . .	Number	 0014h	 
$?RCx  . . . . . . . . . . . . . . . .	Number	 0028h	 
$?RC . . . . . . . . . . . . . . . . .	Number	 0034h	 
$?RESPONSE . . . . . . . . . . . . . .	Number	 0064h	 
$?RESULTx  . . . . . . . . . . . . . .	Number	 0020h	 
$?RESULT . . . . . . . . . . . . . . .	Number	 002Ch	 
$?RS . . . . . . . . . . . . . . . . .	Number	 0024h	 
$?SIGLx  . . . . . . . . . . . . . . .	Number	 0030h	 
$?SIGL . . . . . . . . . . . . . . . .	Number	 003Ch	 
$?STARTTIME  . . . . . . . . . . . . .	Number	 0094h	 
$?STREAMSTATE  . . . . . . . . . . . .	Number	 005Ch	 
$?STREAM . . . . . . . . . . . . . . .	Number	 0054h	 
$?SysVars  . . . . . . . . . . . . . .	Number	 0044h	 
$?S  . . . . . . . . . . . . . . . . .	Number	 00BCh	 
$?WEEKDAYS . . . . . . . . . . . . . .	Number	 008Ch	 
$?Zero . . . . . . . . . . . . . . . .	Number	 00A4h	 
$ADDRESS . . . . . . . . . . . . . . .	Number	 008Ch	 
$APPEND  . . . . . . . . . . . . . . .	Number	 0090h	 
$ARG . . . . . . . . . . . . . . . . .	Number	 0088h	 
$Abut  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$And . . . . . . . . . . . . . . . . .	Number	 0018h	 
$Ashapes . . . . . . . . . . . . . . .	Number	 000Ah	 
$Assign  . . . . . . . . . . . . . . .	Number	 0054h	 
$Asterisk  . . . . . . . . . . . . . .	Number	 0011h	 
$AttribAnd . . . . . . . . . . . . . .	Number	 00D8h	 
$AttribComma . . . . . . . . . . . . .	Number	 00DCh	 
$AttribEq  . . . . . . . . . . . . . .	Number	 00EBh	 
$AttribGt  . . . . . . . . . . . . . .	Number	 00F0h	 
$AttribLine  . . . . . . . . . . . . .	Number	 00E7h	 
$AttribLt  . . . . . . . . . . . . . .	Number	 00EDh	 
$AttribMinus . . . . . . . . . . . . .	Number	 00E4h	 
$AttribOr  . . . . . . . . . . . . . .	Number	 00D5h	 
$AttribPlus  . . . . . . . . . . . . .	Number	 00E5h	 
$AttribSlash . . . . . . . . . . . . .	Number	 00D2h	 
$AttribStar  . . . . . . . . . . . . .	Number	 00D1h	 
$AwayString  . . . . . . . . . . . . .	Number	 00C0h	 
$BPcodesCeil . . . . . . . . . . . . .	Number	 005Dh	 
$BY  . . . . . . . . . . . . . . . . .	Number	 006Ch	 
$Bb  . . . . . . . . . . . . . . . . .	Number	 0004h	 
$BcodesBase  . . . . . . . . . . . . .	Number	 00B3h	 
$BifABBREV . . . . . . . . . . . . . .	Number	 0014h	 
$BifABS  . . . . . . . . . . . . . . .	Number	 002Ah	 
$BifADDRESS  . . . . . . . . . . . . .	Number	 0020h	 
$BifARG  . . . . . . . . . . . . . . .	Number	 0021h	 
$BifB2X  . . . . . . . . . . . . . . .	Number	 002Dh	 
$BifBITAND . . . . . . . . . . . . . .	Number	 0034h	 
$BifBITOR  . . . . . . . . . . . . . .	Number	 0035h	 
$BifBITXOR . . . . . . . . . . . . . .	Number	 0036h	 
$BifBase . . . . . . . . . . . . . . .	Number	 FFB9h	 
$BifC2D  . . . . . . . . . . . . . . .	Number	 0031h	 
$BifC2X  . . . . . . . . . . . . . . .	Number	 002Ch	 
$BifCENTER . . . . . . . . . . . . . .	Number	 0015h	 
$BifCENTRE . . . . . . . . . . . . . .	Number	 0016h	 
$BifCHANGESTR  . . . . . . . . . . . .	Number	 0042h	 
$BifCHARIN . . . . . . . . . . . . . .	Number	 0004h	 
$BifCHAROUT  . . . . . . . . . . . . .	Number	 0005h	 
$BifCHARS  . . . . . . . . . . . . . .	Number	 0003h	 
$BifCOMPARE  . . . . . . . . . . . . .	Number	 0017h	 
$BifCONDITION  . . . . . . . . . . . .	Number	 0022h	 
$BifCOPIES . . . . . . . . . . . . . .	Number	 0038h	 
$BifCOUNTSTR . . . . . . . . . . . . .	Number	 0041h	 
$BifD2C  . . . . . . . . . . . . . . .	Number	 0032h	 
$BifD2X  . . . . . . . . . . . . . . .	Number	 0033h	 
$BifDATATYPE . . . . . . . . . . . . .	Number	 001Fh	 
$BifDATE . . . . . . . . . . . . . . .	Number	 0000h	 
$BifDELSTR . . . . . . . . . . . . . .	Number	 0018h	 
$BifDELWORD  . . . . . . . . . . . . .	Number	 0019h	 
$BifDIGITS . . . . . . . . . . . . . .	Number	 0025h	 
$BifERRORTEXT  . . . . . . . . . . . .	Number	 000Eh	 
$BifFORMAT . . . . . . . . . . . . . .	Number	 0011h	 
$BifFORM . . . . . . . . . . . . . . .	Number	 001Eh	 
$BifFUZZ . . . . . . . . . . . . . . .	Number	 0024h	 
$BifINSERT . . . . . . . . . . . . . .	Number	 001Ch	 
$BifLASTPOS  . . . . . . . . . . . . .	Number	 001Bh	 
$BifLEFT . . . . . . . . . . . . . . .	Number	 003Dh	 
$BifLENGTH . . . . . . . . . . . . . .	Number	 0043h	 
$BifLINEIN . . . . . . . . . . . . . .	Number	 0006h	 
$BifLINEOUT  . . . . . . . . . . . . .	Number	 0007h	 
$BifLINES  . . . . . . . . . . . . . .	Number	 0002h	 
$BifMAX  . . . . . . . . . . . . . . .	Number	 0044h	 
$BifMIN  . . . . . . . . . . . . . . .	Number	 0045h	 
$BifOVERLAY  . . . . . . . . . . . . .	Number	 001Dh	 
$BifPOS  . . . . . . . . . . . . . . .	Number	 003Ch	 
$BifQUALIFY  . . . . . . . . . . . . .	Number	 000Bh	 
$BifQUEUED . . . . . . . . . . . . . .	Number	 003Fh	 
$BifRANDOM . . . . . . . . . . . . . .	Number	 0028h	 
$BifREVERSE  . . . . . . . . . . . . .	Number	 0029h	 
$BifRIGHT  . . . . . . . . . . . . . .	Number	 001Ah	 
$BifSIGN . . . . . . . . . . . . . . .	Number	 002Bh	 
$BifSOURCELINE . . . . . . . . . . . .	Number	 0026h	 
$BifSPACE  . . . . . . . . . . . . . .	Number	 000Fh	 
$BifSTREAM . . . . . . . . . . . . . .	Number	 0008h	 
$BifSTRIP  . . . . . . . . . . . . . .	Number	 0009h	 
$BifSUBSTR . . . . . . . . . . . . . .	Number	 003Eh	 
$BifSUBWORD  . . . . . . . . . . . . .	Number	 003Bh	 
$BifSYMBOL . . . . . . . . . . . . . .	Number	 0040h	 
$BifTIME . . . . . . . . . . . . . . .	Number	 0001h	 
$BifTRACE  . . . . . . . . . . . . . .	Number	 0023h	 
$BifTRANSLATE  . . . . . . . . . . . .	Number	 0010h	 
$BifTRUNC  . . . . . . . . . . . . . .	Number	 000Dh	 
$BifTag  . . . . . . . . . . . . . . .	Number	 0080h	 
$BifVALUE  . . . . . . . . . . . . . .	Number	 0037h	 
$BifVERIFY . . . . . . . . . . . . . .	Number	 000Ah	 
$BifWORDINDEX  . . . . . . . . . . . .	Number	 003Ah	 
$BifWORDLENGTH . . . . . . . . . . . .	Number	 0012h	 
$BifWORDPOS  . . . . . . . . . . . . .	Number	 0013h	 
$BifWORDS  . . . . . . . . . . . . . .	Number	 000Ch	 
$BifWORD . . . . . . . . . . . . . . .	Number	 0039h	 
$BifX2B  . . . . . . . . . . . . . . .	Number	 002Eh	 
$BifX2C  . . . . . . . . . . . . . . .	Number	 002Fh	 
$BifX2D  . . . . . . . . . . . . . . .	Number	 0030h	 
$BifXRANGE . . . . . . . . . . . . . .	Number	 0027h	 
$Bin . . . . . . . . . . . . . . . . .	Number	 0024h	 
$CALL  . . . . . . . . . . . . . . . .	Number	 0094h	 
$CONST_SYMBOL  . . . . . . . . . . . .	Number	 0040h	 
$CaseTarget  . . . . . . . . . . . . .	Number	 0006h	 
$Cat . . . . . . . . . . . . . . . . .	Number	 004Dh	 
$Colon . . . . . . . . . . . . . . . .	Number	 000Ah	 
$Comma . . . . . . . . . . . . . . . .	Number	 001Ch	 
$CondKeys  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
$Constant  . . . . . . . . . . . . . .	Number	 008Ah	 
$Cr  . . . . . . . . . . . . . . . . .	Text   	 0dh
$DIGITS  . . . . . . . . . . . . . . .	Number	 00E4h	 
$DO  . . . . . . . . . . . . . . . . .	Number	 0098h	 
$DROP  . . . . . . . . . . . . . . . .	Number	 00B8h	 
$Desc59H . . . . . . . . . . . . . . .	Number	 000Bh	 
$DescArgs  . . . . . . . . . . . . . .	Number	 000Ah	 
$DescFiles . . . . . . . . . . . . . .	Number	 000Ch	 
$DescQueue . . . . . . . . . . . . . .	Number	 000Dh	 
$DescString  . . . . . . . . . . . . .	Number	 0005h	 
$Descriptions  . . . . . . . . . . . .	Number	 0037h	 
$Digit . . . . . . . . . . . . . . . .	Number	 0040h	 
$DoFrame . . . . . . . . . . . . . . .	Number	 0366h	 
$DosAllocate . . . . . . . . . . . . .	Number	 0048h	 
$DosChmod  . . . . . . . . . . . . . .	Number	 0043h	 
$DosClose  . . . . . . . . . . . . . .	Number	 003Eh	 
$DosCreate . . . . . . . . . . . . . .	Number	 003Ch	 
$DosDate . . . . . . . . . . . . . . .	Number	 002Ah	 
$DosDelete . . . . . . . . . . . . . .	Number	 0041h	 
$DosDisk . . . . . . . . . . . . . . .	Number	 0019h	 
$DosExecute  . . . . . . . . . . . . .	Number	 004Bh	 
$DosExit . . . . . . . . . . . . . . .	Number	 004Ch	 
$DosFree . . . . . . . . . . . . . . .	Number	 0049h	 
$DosGetError . . . . . . . . . . . . .	Number	 0059h	 
$DosModifyAllocated  . . . . . . . . .	Number	 004Ah	 
$DosOpen . . . . . . . . . . . . . . .	Number	 003Dh	 
$DosPSP  . . . . . . . . . . . . . . .	Number	 0062h	 
$DosPath . . . . . . . . . . . . . . .	Number	 0047h	 
$DosRead . . . . . . . . . . . . . . .	Number	 003Fh	 
$DosReturnCode . . . . . . . . . . . .	Number	 004Dh	 
$DosSeek . . . . . . . . . . . . . . .	Number	 0042h	 
$DosTime . . . . . . . . . . . . . . .	Number	 002Ch	 
$DosWrite  . . . . . . . . . . . . . .	Number	 0040h	 
$Dropped . . . . . . . . . . . . . . .	Number	 0040h	 
$ELSE  . . . . . . . . . . . . . . . .	Number	 009Ch	 
$END . . . . . . . . . . . . . . . . .	Number	 005Ch	 
$ENGINEERING . . . . . . . . . . . . .	Number	 00ECh	 
$ERROR . . . . . . . . . . . . . . . .	Number	 00CCh	 
$EXIT  . . . . . . . . . . . . . . . .	Number	 00A8h	 
$EXPOSE  . . . . . . . . . . . . . . .	Number	 00BCh	 
$Ee  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$EndBuffer . . . . . . . . . . . . . .	Number	 000Ah	 
$Eof . . . . . . . . . . . . . . . . .	Text   	 1ah
$Eos . . . . . . . . . . . . . . . . .	Number	 0000h	 
$Eq  . . . . . . . . . . . . . . . . .	Number	 002Bh	 
$Exposed . . . . . . . . . . . . . . .	Number	 0050h	 
$FAILURE . . . . . . . . . . . . . . .	Number	 00C9h	 
$FOREVER . . . . . . . . . . . . . . .	Number	 0118h	 
$FORM  . . . . . . . . . . . . . . . .	Number	 00E8h	 
$FOR . . . . . . . . . . . . . . . . .	Number	 0064h	 
$FUZZ  . . . . . . . . . . . . . . . .	Number	 00E5h	 
$FileBufferSize  . . . . . . . . . . .	Number	 0400h	 
$Ge  . . . . . . . . . . . . . . . . .	Number	 002Fh	 
$Group . . . . . . . . . . . . . . . .	Number	 00FCh	 
$Gt  . . . . . . . . . . . . . . . . .	Number	 0030h	 
$HALT  . . . . . . . . . . . . . . . .	Number	 00CAh	 
$Hex . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$IF  . . . . . . . . . . . . . . . . .	Number	 00D4h	 
$INPUT . . . . . . . . . . . . . . . .	Number	 00D8h	 
$INTERPRET . . . . . . . . . . . . . .	Number	 00A4h	 
$ITERATE . . . . . . . . . . . . . . .	Number	 00B5h	 
$IfFrame . . . . . . . . . . . . . . .	Number	 02B2h	 
$InitStackSize . . . . . . . . . . . .	Number	 2000h	 
$Invalid . . . . . . . . . . . . . . .	Number	 0009h	 
$LEAVE . . . . . . . . . . . . . . . .	Number	 00B4h	 
$LINEIN  . . . . . . . . . . . . . . .	Number	 007Ch	 
$LOSTDIGITS  . . . . . . . . . . . . .	Number	 00C5h	 
$Label . . . . . . . . . . . . . . . .	Number	 008Bh	 
$Leeway  . . . . . . . . . . . . . . .	Number	 0003h	 
$Letter  . . . . . . . . . . . . . . .	Number	 0080h	 
$Le  . . . . . . . . . . . . . . . . .	Number	 002Eh	 
$Lf  . . . . . . . . . . . . . . . . .	Text   	 0ah
$Limit_Digits  . . . . . . . . . . . .	Number	 270Fh	 
$Limit_EnvironmentName . . . . . . . .	Number	 000Ah	 
$Limit_ExponentDigits  . . . . . . . .	Number	 0009h	 
$Limit_Insert  . . . . . . . . . . . .	Number	 0032h	 
$Limit_Literal . . . . . . . . . . . .	Number	 00FAh	 
$Limit_Major . . . . . . . . . . . . .	Number	 0036h	 
$Limit_Name  . . . . . . . . . . . . .	Number	 00FAh	 
$Limit_String  . . . . . . . . . . . .	Number	 C350h	 
$LineFeed  . . . . . . . . . . . . . .	Number	 0027h	 
$Lowercase . . . . . . . . . . . . . .	Number	 0048h	 
$Lparen  . . . . . . . . . . . . . . .	Number	 000Ch	 
$Lt  . . . . . . . . . . . . . . . . .	Number	 002Dh	 
$M090  . . . . . . . . . . . . . . . .	Number	 0010h	 
$MaxParms  . . . . . . . . . . . . . .	Number	 0064h	 
$MaxPreInsert  . . . . . . . . . . . .	Number	 00AFh	 
$Minus . . . . . . . . . . . . . . . .	Number	 0024h	 
$MsgChunk  . . . . . . . . . . . . . .	Number	 0050h	 
$MsgNum  . . . . . . . . . . . . . . .	Number	 0044h	 
$MsgRoom . . . . . . . . . . . . . . .	Number	 00C8h	 
$NAME  . . . . . . . . . . . . . . . .	Number	 00DCh	 
$NOP . . . . . . . . . . . . . . . . .	Number	 00A0h	 
$NORMAL  . . . . . . . . . . . . . . .	Number	 0114h	 
$NOTREADY  . . . . . . . . . . . . . .	Number	 00C8h	 
$NOVALUE . . . . . . . . . . . . . . .	Number	 00C6h	 
$NUMBER  . . . . . . . . . . . . . . .	Number	 0044h	 
$NUMERIC . . . . . . . . . . . . . . .	Number	 00E0h	 
$Ne  . . . . . . . . . . . . . . . . .	Number	 002Ch	 
$NoMatch . . . . . . . . . . . . . . .	Number	 00FFh	 
$NonUpable . . . . . . . . . . . . . .	Number	 0008h	 
$Not . . . . . . . . . . . . . . . . .	Number	 0020h	 
$NullString  . . . . . . . . . . . . .	Number	 0080h	 
$Num . . . . . . . . . . . . . . . . .	Number	 000Ch	 
$OFF . . . . . . . . . . . . . . . . .	Number	 011Ch	 
$OKb . . . . . . . . . . . . . . . . .	Number	 0020h	 
$OKx . . . . . . . . . . . . . . . . .	Number	 0010h	 
$ON  . . . . . . . . . . . . . . . . .	Number	 0120h	 
$OPTIONS . . . . . . . . . . . . . . .	Number	 00A5h	 
$OTHERWISE . . . . . . . . . . . . . .	Number	 00F0h	 
$OUTPUT  . . . . . . . . . . . . . . .	Number	 00F4h	 
$Omitted . . . . . . . . . . . . . . .	Number	 0088h	 
$Or  . . . . . . . . . . . . . . . . .	Number	 0015h	 
$PARSE . . . . . . . . . . . . . . . .	Number	 00F8h	 
$PROCEDURE . . . . . . . . . . . . . .	Number	 00FCh	 
$PULL  . . . . . . . . . . . . . . . .	Number	 0080h	 
$PUSH  . . . . . . . . . . . . . . . .	Number	 00A9h	 
$Pad . . . . . . . . . . . . . . . . .	Number	 0018h	 
$PcodesBase  . . . . . . . . . . . . .	Number	 0001h	 
$PcodesCeil  . . . . . . . . . . . . .	Number	 00C5h	 
$Percent . . . . . . . . . . . . . . .	Number	 0010h	 
$PjumpBase . . . . . . . . . . . . . .	Number	 0057h	 
$PjumpCeil . . . . . . . . . . . . . .	Number	 0089h	 
$PlusMinus . . . . . . . . . . . . . .	Text   	 $AttribPlus and $Group
$Plus  . . . . . . . . . . . . . . . .	Number	 0025h	 
$Power . . . . . . . . . . . . . . . .	Number	 0050h	 
$QUEUE . . . . . . . . . . . . . . . .	Number	 00AAh	 
$REPLACE . . . . . . . . . . . . . . .	Number	 0108h	 
$RETURN  . . . . . . . . . . . . . . .	Number	 00ABh	 
$Rem . . . . . . . . . . . . . . . . .	Number	 0013h	 
$Rparen  . . . . . . . . . . . . . . .	Number	 0038h	 
$SAY . . . . . . . . . . . . . . . . .	Number	 00ACh	 
$SCIENTIFIC  . . . . . . . . . . . . .	Number	 00EDh	 
$SELECT  . . . . . . . . . . . . . . .	Number	 0100h	 
$SIGNAL  . . . . . . . . . . . . . . .	Number	 00C0h	 
$SOURCE  . . . . . . . . . . . . . . .	Number	 007Dh	 
$STEM  . . . . . . . . . . . . . . . .	Number	 010Ch	 
$STREAM  . . . . . . . . . . . . . . .	Number	 0110h	 
$STRING  . . . . . . . . . . . . . . .	Number	 003Ch	 
$SYNTAX  . . . . . . . . . . . . . . .	Number	 00C4h	 
$SelectFrame . . . . . . . . . . . . .	Number	 02D6h	 
$Semi  . . . . . . . . . . . . . . . .	Number	 0004h	 
$Seq . . . . . . . . . . . . . . . . .	Number	 0031h	 
$SerialCompaction  . . . . . . . . . .	Number	 0002h	 
$SerialInterpret . . . . . . . . . . .	Number	 0003h	 
$SerialNone  . . . . . . . . . . . . .	Number	 0000h	 
$SerialQue . . . . . . . . . . . . . .	Number	 0001h	 
$SerialSource  . . . . . . . . . . . .	Number	 0004h	 
$Sge . . . . . . . . . . . . . . . . .	Number	 0035h	 
$Sgt . . . . . . . . . . . . . . . . .	Number	 0036h	 
$ShiftV  . . . . . . . . . . . . . . .	Number	 0003h	 
$Sigl  . . . . . . . . . . . . . . . .	Number	 0048h	 
$SizeConstsHeader  . . . . . . . . . .	Number	 0014h	 
$Slash . . . . . . . . . . . . . . . .	Number	 0012h	 
$Sle . . . . . . . . . . . . . . . . .	Number	 0034h	 
$Slt . . . . . . . . . . . . . . . . .	Number	 0033h	 
$Sne . . . . . . . . . . . . . . . . .	Number	 0032h	 
$SourceBufferSize  . . . . . . . . . .	Number	 11C8h	 
$Special . . . . . . . . . . . . . . .	Number	 00C0h	 
$Stem  . . . . . . . . . . . . . . . .	Number	 0060h	 
$Stream  . . . . . . . . . . . . . . .	Number	 0020h	 
$StrideA . . . . . . . . . . . . . . .	Number	 0006h	 
$StrideD . . . . . . . . . . . . . . .	Number	 0028h	 
$StrideF . . . . . . . . . . . . . . .	Number	 001Ah	 
$StrideH . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideJ . . . . . . . . . . . . . . .	Number	 000Eh	 
$StrideL . . . . . . . . . . . . . . .	Number	 007Ch	 
$StrideS . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideV . . . . . . . . . . . . . . .	Number	 0008h	 
$Symbol  . . . . . . . . . . . . . . .	Number	 0028h	 
$SysCount  . . . . . . . . . . . . . .	Number	 000Bh	 
$THEN  . . . . . . . . . . . . . . . .	Number	 0060h	 
$TO  . . . . . . . . . . . . . . . . .	Number	 0068h	 
$TRACE . . . . . . . . . . . . . . . .	Number	 00B0h	 
$Test  . . . . . . . . . . . . . . . .	Number	 00C0h	 
$TraceAssign . . . . . . . . . . . . .	Number	 0000h	 
$TraceBY . . . . . . . . . . . . . . .	Number	 0002h	 
$TraceBack . . . . . . . . . . . . . .	Number	 001Ah	 
$TraceClause . . . . . . . . . . . . .	Number	 0004h	 
$TraceCompound . . . . . . . . . . . .	Number	 0006h	 
$TraceDot  . . . . . . . . . . . . . .	Number	 0008h	 
$TraceEndClause  . . . . . . . . . . .	Number	 001Eh	 
$TraceError  . . . . . . . . . . . . .	Number	 000Ah	 
$TraceExpr . . . . . . . . . . . . . .	Number	 000Ch	 
$TraceFailure  . . . . . . . . . . . .	Number	 000Eh	 
$TraceFunction . . . . . . . . . . . .	Number	 0010h	 
$TraceLit  . . . . . . . . . . . . . .	Number	 0016h	 
$TraceOperator . . . . . . . . . . . .	Number	 0012h	 
$TraceParse  . . . . . . . . . . . . .	Number	 001Ch	 
$TracePrefix . . . . . . . . . . . . .	Number	 0014h	 
$TraceVar  . . . . . . . . . . . . . .	Number	 0018h	 
$UNTIL . . . . . . . . . . . . . . . .	Number	 0070h	 
$UPPER . . . . . . . . . . . . . . . .	Number	 00D0h	 
$UnAccept  . . . . . . . . . . . . . .	Number	 0008h	 
$VALUE . . . . . . . . . . . . . . . .	Number	 0058h	 
$VAR_SYMBOL  . . . . . . . . . . . . .	Number	 0048h	 
$VAR . . . . . . . . . . . . . . . . .	Number	 0084h	 
$VERSION . . . . . . . . . . . . . . .	Number	 007Eh	 
$Variable  . . . . . . . . . . . . . .	Number	 0089h	 
$WHEN  . . . . . . . . . . . . . . . .	Number	 0104h	 
$WHILE . . . . . . . . . . . . . . . .	Number	 0074h	 
$WITH  . . . . . . . . . . . . . . . .	Number	 0078h	 
$White . . . . . . . . . . . . . . . .	Number	 0000h	 
$WholeGE . . . . . . . . . . . . . . .	Number	 0004h	 
$WholeGT . . . . . . . . . . . . . . .	Number	 0008h	 
$WholeNum  . . . . . . . . . . . . . .	Number	 0014h	 
$Whole . . . . . . . . . . . . . . . .	Number	 0000h	 
$WithKey . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
$Xor . . . . . . . . . . . . . . . . .	Number	 0014h	 
$Xx  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$mParseEnd . . . . . . . . . . . . . .	Number	 001Ah	 
$mParseEscape  . . . . . . . . . . . .	Number	 0012h	 
$mPattern  . . . . . . . . . . . . . .	Number	 002Ah	 
$mPosEq  . . . . . . . . . . . . . . .	Number	 0032h	 
$mPosMinus . . . . . . . . . . . . . .	Number	 0042h	 
$mPosPlus  . . . . . . . . . . . . . .	Number	 003Ah	 
$mPosRest  . . . . . . . . . . . . . .	Number	 0022h	 
$mRepTail  . . . . . . . . . . . . . .	Number	 0002h	 
$mTemplateComma  . . . . . . . . . . .	Number	 004Ah	 
$mUpper  . . . . . . . . . . . . . . .	Number	 000Ah	 
$n17p1 . . . . . . . . . . . . . . . .	Number	 0002h	 
$n40p3 . . . . . . . . . . . . . . . .	Number	 0004h	 
$n40p4 . . . . . . . . . . . . . . . .	Number	 0006h	 
$n40p5 . . . . . . . . . . . . . . . .	Number	 0008h	 
$n7p3  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nArg  . . . . . . . . . . . . . . . .	Number	 0004h	 
$nDigits . . . . . . . . . . . . . . .	Number	 0000h	 
$nForm . . . . . . . . . . . . . . . .	Number	 0004h	 
$nFuzz . . . . . . . . . . . . . . . .	Number	 0002h	 
$nLineIn . . . . . . . . . . . . . . .	Number	 0006h	 
$nNormal . . . . . . . . . . . . . . .	Number	 0040h	 
$nPull . . . . . . . . . . . . . . . .	Number	 0008h	 
$nSource . . . . . . . . . . . . . . .	Number	 000Ah	 
$nStem . . . . . . . . . . . . . . . .	Number	 0000h	 
$nStream . . . . . . . . . . . . . . .	Number	 0020h	 
$nVar  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nVersion  . . . . . . . . . . . . . .	Number	 000Ch	 
$nWith . . . . . . . . . . . . . . . .	Number	 0002h	 
$pAbut . . . . . . . . . . . . . . . .	Number	 0001h	 
$pAddress  . . . . . . . . . . . . . .	Number	 00A5h	 
$pAdd  . . . . . . . . . . . . . . . .	Number	 003Fh	 
$pAnd  . . . . . . . . . . . . . . . .	Number	 0035h	 
$pAssignConst  . . . . . . . . . . . .	Number	 0099h	 
$pAssignDotsP  . . . . . . . . . . . .	Number	 0007h	 
$pAssignDots . . . . . . . . . . . . .	Number	 0097h	 
$pAssignStem . . . . . . . . . . . . .	Number	 0095h	 
$pAssign . . . . . . . . . . . . . . .	Number	 0093h	 
$pBifGroup . . . . . . . . . . . . . .	Number	 00ADh	 
$pBifq . . . . . . . . . . . . . . . .	Number	 002Bh	 
$pBif  . . . . . . . . . . . . . . . .	Number	 00ABh	 
$pBool . . . . . . . . . . . . . . . .	Number	 00A1h	 
$pBy . . . . . . . . . . . . . . . . .	Number	 0011h	 
$pCallOn . . . . . . . . . . . . . . .	Number	 008Fh	 
$pCall . . . . . . . . . . . . . . . .	Number	 0055h	 
$pCat  . . . . . . . . . . . . . . . .	Number	 0003h	 
$pCeq  . . . . . . . . . . . . . . . .	Number	 007Dh	 
$pCge  . . . . . . . . . . . . . . . .	Number	 0085h	 
$pCgt  . . . . . . . . . . . . . . . .	Number	 0087h	 
$pCle  . . . . . . . . . . . . . . . .	Number	 0083h	 
$pClt  . . . . . . . . . . . . . . . .	Number	 0081h	 
$pCne  . . . . . . . . . . . . . . . .	Number	 007Fh	 
$pCommandEnv . . . . . . . . . . . . .	Number	 00A7h	 
$pCommand  . . . . . . . . . . . . . .	Number	 004Dh	 
$pControlVar . . . . . . . . . . . . .	Number	 005Bh	 
$pDivide . . . . . . . . . . . . . . .	Number	 0045h	 
$pDotControlVar  . . . . . . . . . . .	Number	 005Dh	 
$pDots . . . . . . . . . . . . . . . .	Number	 0091h	 
$pDropList . . . . . . . . . . . . . .	Number	 00B7h	 
$pDrop . . . . . . . . . . . . . . . .	Number	 009Dh	 
$pEnvName  . . . . . . . . . . . . . .	Number	 00A9h	 
$pEq . . . . . . . . . . . . . . . . .	Number	 0065h	 
$pExit . . . . . . . . . . . . . . . .	Number	 0027h	 
$pExposeList . . . . . . . . . . . . .	Number	 00B9h	 
$pExpose . . . . . . . . . . . . . . .	Number	 009Fh	 
$pFor  . . . . . . . . . . . . . . . .	Number	 0013h	 
$pGe . . . . . . . . . . . . . . . . .	Number	 006Dh	 
$pGt . . . . . . . . . . . . . . . . .	Number	 006Fh	 
$pIntDivide  . . . . . . . . . . . . .	Number	 0047h	 
$pInterpEnd  . . . . . . . . . . . . .	Number	 0089h	 
$pInterpret  . . . . . . . . . . . . .	Number	 004Fh	 
$pInvoke . . . . . . . . . . . . . . .	Number	 0053h	 
$pIterCV . . . . . . . . . . . . . . .	Number	 00A3h	 
$pIterRep  . . . . . . . . . . . . . .	Number	 0019h	 
$pIterate  . . . . . . . . . . . . . .	Number	 001Bh	 
$pJump . . . . . . . . . . . . . . . .	Number	 0063h	 
$pLeave  . . . . . . . . . . . . . . .	Number	 001Dh	 
$pLength . . . . . . . . . . . . . . .	Number	 002Dh	 
$pLe . . . . . . . . . . . . . . . . .	Number	 006Bh	 
$pLt . . . . . . . . . . . . . . . . .	Number	 0069h	 
$pMax  . . . . . . . . . . . . . . . .	Number	 002Fh	 
$pMin  . . . . . . . . . . . . . . . .	Number	 0031h	 
$pMultiply . . . . . . . . . . . . . .	Number	 0043h	 
$pNegate . . . . . . . . . . . . . . .	Number	 003Dh	 
$pNe . . . . . . . . . . . . . . . . .	Number	 0067h	 
$pNop  . . . . . . . . . . . . . . . .	Number	 0005h	 
$pNot  . . . . . . . . . . . . . . . .	Number	 0033h	 
$pNumber . . . . . . . . . . . . . . .	Number	 000Dh	 
$pNumeric  . . . . . . . . . . . . . .	Number	 0051h	 
$pOptions  . . . . . . . . . . . . . .	Number	 00C3h	 
$pOr . . . . . . . . . . . . . . . . .	Number	 0037h	 
$pParse  . . . . . . . . . . . . . . .	Number	 0009h	 
$pPositive . . . . . . . . . . . . . .	Number	 003Bh	 
$pPower  . . . . . . . . . . . . . . .	Number	 004Bh	 
$pPush . . . . . . . . . . . . . . . .	Number	 00BBh	 
$pQueue  . . . . . . . . . . . . . . .	Number	 00BDh	 
$pRaise  . . . . . . . . . . . . . . .	Number	 00AFh	 
$pRemainder  . . . . . . . . . . . . .	Number	 0049h	 
$pRepEver  . . . . . . . . . . . . . .	Number	 0059h	 
$pRep  . . . . . . . . . . . . . . . .	Number	 0057h	 
$pResult . . . . . . . . . . . . . . .	Number	 0021h	 
$pResumeParse  . . . . . . . . . . . .	Number	 000Bh	 
$pReturns  . . . . . . . . . . . . . .	Number	 0025h	 
$pReturn . . . . . . . . . . . . . . .	Number	 0023h	 
$pSay  . . . . . . . . . . . . . . . .	Number	 0029h	 
$pSeq  . . . . . . . . . . . . . . . .	Number	 0071h	 
$pSge  . . . . . . . . . . . . . . . .	Number	 0079h	 
$pSgt  . . . . . . . . . . . . . . . .	Number	 007Bh	 
$pSignalOff  . . . . . . . . . . . . .	Number	 00B1h	 
$pSignalOn . . . . . . . . . . . . . .	Number	 008Dh	 
$pSignalV  . . . . . . . . . . . . . .	Number	 00B3h	 
$pSignal . . . . . . . . . . . . . . .	Number	 008Bh	 
$pSle  . . . . . . . . . . . . . . . .	Number	 0077h	 
$pSlt  . . . . . . . . . . . . . . . .	Number	 0075h	 
$pSne  . . . . . . . . . . . . . . . .	Number	 0073h	 
$pSubtract . . . . . . . . . . . . . .	Number	 0041h	 
$pSysVar . . . . . . . . . . . . . . .	Number	 00B5h	 
$pThen . . . . . . . . . . . . . . . .	Number	 005Fh	 
$pTo . . . . . . . . . . . . . . . . .	Number	 000Fh	 
$pTraceEvent . . . . . . . . . . . . .	Number	 00C1h	 
$pTrace  . . . . . . . . . . . . . . .	Number	 00BFh	 
$pUnDo . . . . . . . . . . . . . . . .	Number	 001Fh	 
$pUnstore  . . . . . . . . . . . . . .	Number	 009Bh	 
$pUntil  . . . . . . . . . . . . . . .	Number	 0017h	 
$pWhen . . . . . . . . . . . . . . . .	Number	 0061h	 
$pWhile  . . . . . . . . . . . . . . .	Number	 0015h	 
$pXor  . . . . . . . . . . . . . . . .	Number	 0039h	 
$ret . . . . . . . . . . . . . . . . .	Number	 00C3h	 
$sAddress  . . . . . . . . . . . . . .	Number	 002Dh	 
$sDigits . . . . . . . . . . . . . . .	Number	 0027h	 
$sDropList . . . . . . . . . . . . . .	Number	 000Bh	 
$sDrop . . . . . . . . . . . . . . . .	Number	 0006h	 
$sEq . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$sExit . . . . . . . . . . . . . . . .	Number	 0032h	 
$sForm . . . . . . . . . . . . . . . .	Number	 002Bh	 
$sIterate  . . . . . . . . . . . . . .	Number	 003Fh	 
$sLeave  . . . . . . . . . . . . . . .	Number	 003Eh	 
$sLength . . . . . . . . . . . . . . .	Number	 0017h	 
$sMinus  . . . . . . . . . . . . . . .	Number	 0014h	 
$sNegate . . . . . . . . . . . . . . .	Number	 0030h	 
$sNop  . . . . . . . . . . . . . . . .	Number	 002Ah	 
$sNumber . . . . . . . . . . . . . . .	Number	 0037h	 
$sPercent  . . . . . . . . . . . . . .	Number	 0000h	 
$sPositive . . . . . . . . . . . . . .	Number	 0031h	 
$sRaise  . . . . . . . . . . . . . . .	Number	 0039h	 
$sReturns  . . . . . . . . . . . . . .	Number	 0035h	 
$sSeq  . . . . . . . . . . . . . . . .	Number	 0021h	 
$sStem . . . . . . . . . . . . . . . .	Number	 0009h	 
$sWith . . . . . . . . . . . . . . . .	Number	 000Ah	 
$tBinary . . . . . . . . . . . . . . .	Number	 00FDh	 
$tChar . . . . . . . . . . . . . . . .	Number	 00FFh	 
$tLabel  . . . . . . . . . . . . . . .	Number	 00FEh	 
??0000 . . . . . . . . . . . . . . . .	Number	 000Ch	 
??0001 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0002 . . . . . . . . . . . . . . . .	Number	 000Ch	 
??0003 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0004 . . . . . . . . . . . . . . . .	Number	 000Ch	 
??0005 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0006 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0007 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0008 . . . . . . . . . . . . . . . .	Number	 4000h	 
??0009 . . . . . . . . . . . . . . . .	Number	 0004h	 
??000A . . . . . . . . . . . . . . . .	Number	 0004h	 
??000B . . . . . . . . . . . . . . . .	Number	 0010h	 
??000C . . . . . . . . . . . . . . . .	Number	 1000h	 
??000D . . . . . . . . . . . . . . . .	Number	 4000h	 
??000E . . . . . . . . . . . . . . . .	Number	 2000h	 
??000F . . . . . . . . . . . . . . . .	Number	 0002h	 
??0010 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0011 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0012 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0013 . . . . . . . . . . . . . . . .	Number	 0001h	 
??0014 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0015 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0016 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0017 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0018 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0019 . . . . . . . . . . . . . . . .	Number	 4000h	 
??001A . . . . . . . . . . . . . . . .	Number	 0008h	 
??001B . . . . . . . . . . . . . . . .	Number	 0008h	 
??001C . . . . . . . . . . . . . . . .	Number	 00C0h	 
??001D . . . . . . . . . . . . . . . .	Number	 0040h	 
??001E . . . . . . . . . . . . . . . .	Number	 0010h	 
??001F . . . . . . . . . . . . . . . .	Number	 0080h	 
??0020 . . . . . . . . . . . . . . . .	Number	 0040h	 
??0021 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0022 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0023 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0024 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0025 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0026 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0027 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0028 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0029 . . . . . . . . . . . . . . . .	Number	 0800h	 
??002A . . . . . . . . . . . . . . . .	Number	 0020h	 
??002B . . . . . . . . . . . . . . . .	Number	 0010h	 
??002C . . . . . . . . . . . . . . . .	Number	 2000h	 
??002D . . . . . . . . . . . . . . . .	Number	 2000h	 
??002E . . . . . . . . . . . . . . . .	Number	 2000h	 
??002F . . . . . . . . . . . . . . . .	Number	 2000h	 
??0030 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0031 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0032 . . . . . . . . . . . . . . . .	Number	 0040h	 
??0033 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0034 . . . . . . . . . . . . . . . .	Number	 000Ch	 
??0035 . . . . . . . . . . . . . . . .	Number	 000Ch	 
??0036 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0037 . . . . . . . . . . . . . . . .	Number	 0002h	 
??0038 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0039 . . . . . . . . . . . . . . . .	Number	 0005h	 
??003A . . . . . . . . . . . . . . . .	Number	 0200h	 
??003B . . . . . . . . . . . . . . . .	Number	 0010h	 
??003C . . . . . . . . . . . . . . . .	Number	 0004h	 
??003D . . . . . . . . . . . . . . . .	Number	 0001h	 
??003E . . . . . . . . . . . . . . . .	Number	 000Ch	 
??003F . . . . . . . . . . . . . . . .	Number	 0100h	 
??0040 . . . . . . . . . . . . . . . .	Number	 0200h	 
??0041 . . . . . . . . . . . . . . . .	Number	 4000h	 
??0042 . . . . . . . . . . . . . . . .	Number	 4000h	 
??0043 . . . . . . . . . . . . . . . .	Number	 0003h	 
??0044 . . . . . . . . . . . . . . . .	Number	 0009h	 
??0045 . . . . . . . . . . . . . . . .	Number	 0002h	 
??0046 . . . . . . . . . . . . . . . .	Number	 0100h	 
??0047 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0048 . . . . . . . . . . . . . . . .	Number	 0042h	 
??0049 . . . . . . . . . . . . . . . .	Number	 0030h	 
??004A . . . . . . . . . . . . . . . .	Number	 8000h	 
??004B . . . . . . . . . . . . . . . .	Number	 0008h	 
??004C . . . . . . . . . . . . . . . .	Number	 0042h	 
??004D . . . . . . . . . . . . . . . .	Number	 8000h	 
??004E . . . . . . . . . . . . . . . .	Number	 0042h	 
??004F . . . . . . . . . . . . . . . .	Number	 4000h	 
??0050 . . . . . . . . . . . . . . . .	Number	 0018h	 
??0051 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0052 . . . . . . . . . . . . . . . .	Number	 4000h	 
??0053 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0054 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0055 . . . . . . . . . . . . . . . .	Number	 0200h	 
??0056 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0057 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0058 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0059 . . . . . . . . . . . . . . . .	Number	 0100h	 
?BIF . . . . . . . . . . . . . . . . .	Number	 0002h	 
?CLAUSELOCAL . . . . . . . . . . . . .	Number	 000Eh	 
?CLAUSETIME  . . . . . . . . . . . . .	Number	 000Ch	 
?LINEIN_POSITION . . . . . . . . . . .	Number	 000Ah	 
?MONTHS  . . . . . . . . . . . . . . .	Number	 0010h	 
?OUTCOME . . . . . . . . . . . . . . .	Number	 0000h	 
?RESPONSE  . . . . . . . . . . . . . .	Number	 0008h	 
?STARTTIME . . . . . . . . . . . . . .	Number	 0014h	 
?STREAMSTATE . . . . . . . . . . . . .	Number	 0006h	 
?STREAM  . . . . . . . . . . . . . . .	Number	 0004h	 
?WEEKDAYS  . . . . . . . . . . . . . .	Number	 0012h	 
@CodeSize  . . . . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . . . . .	Text   	 DGROUP
A29Pcode . . . . . . . . . . . . . . .	L Near	 0C49	  _TEXT	
A29UnDo  . . . . . . . . . . . . . . .	L Near	 0C40	  _TEXT	
A7n  . . . . . . . . . . . . . . . . .	L Near	 0F7B	  _TEXT	
Absent . . . . . . . . . . . . . . . .	L Near	 0303	  _TEXT	
ActInvokeCl  . . . . . . . . . . . . .	L Near	 0DDD	  _TEXT	
Action0Dots  . . . . . . . . . . . . .	L Near	 079A	  _TEXT	
Action0ret . . . . . . . . . . . . . .	L Near	 078D	  _TEXT	
Action0  . . . . . . . . . . . . . . .	L Near	 0764	  _TEXT	Public
Action10 . . . . . . . . . . . . . . .	L Near	 09D6	  _TEXT	Public
Action11 . . . . . . . . . . . . . . .	L Near	 09CE	  _TEXT	Public
Action12Asis . . . . . . . . . . . . .	L Near	 0A19	  _TEXT	
Action12Char . . . . . . . . . . . . .	L Near	 0A17	  _TEXT	
Action12 . . . . . . . . . . . . . . .	L Near	 09EC	  _TEXT	Public
Action18Ret  . . . . . . . . . . . . .	L Near	 0A51	  _TEXT	
Action18 . . . . . . . . . . . . . . .	L Near	 0A48	  _TEXT	Public
Action1  . . . . . . . . . . . . . . .	L Near	 08C9	  _TEXT	Public
Action20 . . . . . . . . . . . . . . .	L Near	 0A52	  _TEXT	Public
Action21 . . . . . . . . . . . . . . .	L Near	 0AF6	  _TEXT	Public
Action22L  . . . . . . . . . . . . . .	L Near	 0B51	  _TEXT	
Action22Ret  . . . . . . . . . . . . .	L Near	 0BA9	  _TEXT	
Action22 . . . . . . . . . . . . . . .	L Near	 0B41	  _TEXT	Public
Action23 . . . . . . . . . . . . . . .	L Near	 0B81	  _TEXT	Public
Action24 . . . . . . . . . . . . . . .	L Near	 0BAA	  _TEXT	Public
Action25 . . . . . . . . . . . . . . .	L Near	 0BCB	  _TEXT	Public
Action26 . . . . . . . . . . . . . . .	L Near	 0C02	  _TEXT	Public
Action28 . . . . . . . . . . . . . . .	L Near	 0C15	  _TEXT	Public
Action29 . . . . . . . . . . . . . . .	L Near	 0C26	  _TEXT	Public
Action2  . . . . . . . . . . . . . . .	L Near	 0980	  _TEXT	Public
Action30 . . . . . . . . . . . . . . .	L Near	 0CA8	  _TEXT	Public
Action31 . . . . . . . . . . . . . . .	L Near	 0CA9	  _TEXT	Public
Action32 . . . . . . . . . . . . . . .	L Near	 0CC9	  _TEXT	Public
Action33Tailed . . . . . . . . . . . .	L Near	 0D36	  _TEXT	
Action33c  . . . . . . . . . . . . . .	L Near	 0D32	  _TEXT	
Action33j  . . . . . . . . . . . . . .	L Near	 0D2A	  _TEXT	
Action33 . . . . . . . . . . . . . . .	L Near	 0CE5	  _TEXT	Public
Action34 . . . . . . . . . . . . . . .	L Near	 0D5E	  _TEXT	Public
Action35 . . . . . . . . . . . . . . .	L Near	 0D63	  _TEXT	Public
Action36 . . . . . . . . . . . . . . .	L Near	 0CE5	  _TEXT	Public
Action37 . . . . . . . . . . . . . . .	L Near	 0D6F	  _TEXT	Public
Action381  . . . . . . . . . . . . . .	L Near	 0D88	  _TEXT	Public
Action382  . . . . . . . . . . . . . .	L Near	 0D8D	  _TEXT	Public
Action383  . . . . . . . . . . . . . .	L Near	 0D92	  _TEXT	Public
Action3  . . . . . . . . . . . . . . .	L Near	 09C3	  _TEXT	Public
Action41 . . . . . . . . . . . . . . .	L Near	 0D97	  _TEXT	Public
Action43 . . . . . . . . . . . . . . .	L Near	 0DA4	  _TEXT	Public
Action44 . . . . . . . . . . . . . . .	L Near	 0DC2	  _TEXT	Public
Action45 . . . . . . . . . . . . . . .	L Near	 0DC5	  _TEXT	Public
Action50 . . . . . . . . . . . . . . .	L Near	 0E2A	  _TEXT	Public
Action51 . . . . . . . . . . . . . . .	L Near	 0E26	  _TEXT	Public
Action52 . . . . . . . . . . . . . . .	L Near	 0E26	  _TEXT	Public
Action53 . . . . . . . . . . . . . . .	L Near	 0E66	  _TEXT	Public
Action55 . . . . . . . . . . . . . . .	L Near	 0EEC	  _TEXT	Public
Action56 . . . . . . . . . . . . . . .	L Near	 0EF8	  _TEXT	Public
Action57 . . . . . . . . . . . . . . .	L Near	 0EFD	  _TEXT	Public
Action58 . . . . . . . . . . . . . . .	L Near	 0F01	  _TEXT	Public
Action60x  . . . . . . . . . . . . . .	L Near	 0F22	  _TEXT	
Action60 . . . . . . . . . . . . . . .	L Near	 0F20	  _TEXT	Public
Action61 . . . . . . . . . . . . . . .	L Near	 0F46	  _TEXT	Public
Action62 . . . . . . . . . . . . . . .	L Near	 0F52	  _TEXT	Public
Action6  . . . . . . . . . . . . . . .	L Near	 09C8	  _TEXT	Public
Action70 . . . . . . . . . . . . . . .	L Near	 0F6E	  _TEXT	Public
Action71 . . . . . . . . . . . . . . .	L Near	 0F79	  _TEXT	Public
Action72 . . . . . . . . . . . . . . .	L Near	 0F8C	  _TEXT	Public
Action73 . . . . . . . . . . . . . . .	L Near	 0F9A	  _TEXT	Public
Action74 . . . . . . . . . . . . . . .	L Near	 0F9E	  _TEXT	Public
Action75 . . . . . . . . . . . . . . .	L Near	 0FA3	  _TEXT	Public
Action80 . . . . . . . . . . . . . . .	L Near	 0FA8	  _TEXT	Public
Action90 . . . . . . . . . . . . . . .	L Near	 0FDA	  _TEXT	Public
Action91 . . . . . . . . . . . . . . .	L Near	 0FDF	  _TEXT	Public
ActionBin  . . . . . . . . . . . . . .	L Near	 0A3A	  _TEXT	
ActionRet  . . . . . . . . . . . . . .	L Near	 09CD	  _TEXT	
AllocateCx_EsAx  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ArgsLim  . . . . . . . . . . . . . . .	L Near	 0E21	  _TEXT	
ArrayBx  . . . . . . . . . . . . . . .	Text   	 bx
ArraySi  . . . . . . . . . . . . . . .	Text   	 si
AsConst  . . . . . . . . . . . . . . .	L Near	 011B	  _TEXT	
AsLabel  . . . . . . . . . . . . . . .	L Near	 0183	  _TEXT	
AsString . . . . . . . . . . . . . . .	L Near	 0181	  _TEXT	
AsVarX . . . . . . . . . . . . . . . .	L Near	 03F8	  _TEXT	
AsVar  . . . . . . . . . . . . . . . .	L Near	 0399	  _TEXT	
Assert . . . . . . . . . . . . . . . .	Text   	 .erre
AssignExposed  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AssureSiPlus . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AttribAl . . . . . . . . . . . . . . .	Text   	 al
Attributes . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AwayEsAxCx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Away . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ax2DsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
A  . . . . . . . . . . . . . . . . . .	Text   	 (Ashape ptr[bp+si])
BackOff2 . . . . . . . . . . . . . . .	L Near	 073E	  _TEXT	
BaseB  . . . . . . . . . . . . . . . .	Number	 0644h	 
BaseD  . . . . . . . . . . . . . . . .	Number	 05A2h	 
BaseN  . . . . . . . . . . . . . . . .	Number	 0597h	 
BaseP  . . . . . . . . . . . . . . . .	Number	 05E6h	 
BaseS  . . . . . . . . . . . . . . . .	Number	 0551h	 
BaseU  . . . . . . . . . . . . . . . .	Number	 0660h	 
BaseV  . . . . . . . . . . . . . . . .	Number	 05DEh	 
BifBound . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifCall  . . . . . . . . . . . . . . .	L Near	 0DD5	  _TEXT	
BifFound . . . . . . . . . . . . . . .	L Near	 01E1	  _TEXT	
BifLoop  . . . . . . . . . . . . . . .	L Near	 01CC	  _TEXT	
Bifs . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BooleryRejumps . . . . . . . . . . . .	Number	 0000h	 External
Boolery  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bptr . . . . . . . . . . . . . . . . .	Text   	 byte ptr
BumpSym  . . . . . . . . . . . . . . .	L Near	 030F	  _TEXT	
CD . . . . . . . . . . . . . . . . . .	Number	 0000h	 
CONFIG_ARITH . . . . . . . . . . . . .	Number	 00FFh	 
CONFIG_B2C . . . . . . . . . . . . . .	Number	 00E9h	 
CONFIG_C2B . . . . . . . . . . . . . .	Number	 00E7h	 
CONFIG_MSG . . . . . . . . . . . . . .	Number	 00E5h	 
CONFIG_RAISE40$$ . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_RAISE40 . . . . . . . . . . . .	Number	 00E1h	 
CONFIG_RAISE . . . . . . . . . . . . .	Number	 00DFh	 
CONFIG_STREAM_CHARIN . . . . . . . . .	Number	 00EDh	 
CONFIG_STREAM_CHAROUT  . . . . . . . .	Number	 00F3h	 
CONFIG_STREAM_CLOSE  . . . . . . . . .	Number	 00F1h	 
CONFIG_STREAM_COMMAND  . . . . . . . .	Number	 00F9h	 
CONFIG_STREAM_COUNT  . . . . . . . . .	Number	 00F5h	 
CONFIG_STREAM_POSITION . . . . . . . .	Number	 00EBh	 
CONFIG_STREAM_QUALIFIED  . . . . . . .	Number	 00F7h	 
CONFIG_STREAM_QUERY  . . . . . . . . .	Number	 00EFh	 
CONFIG_STREAM_STATE  . . . . . . . . .	Number	 00FBh	 
CONFIG_TIME  . . . . . . . . . . . . .	Number	 00FDh	 
CONFIG_UPPER$$ . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_UPPER . . . . . . . . . . . . .	Number	 00E3h	 
CVret  . . . . . . . . . . . . . . . .	L Near	 0C7E	  _TEXT	
CallOn . . . . . . . . . . . . . . . .	L Near	 0F30	  _TEXT	
CharBest . . . . . . . . . . . . . . .	L Near	 0542	  _TEXT	
ChkDO  . . . . . . . . . . . . . . . .	L Near	 078E	  _TEXT	
ClauseSourceEnd  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Command  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CompNames  . . . . . . . . . . . . . .	L Near	 0CC2	  _TEXT	
Compiler . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiling  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConditionNum . . . . . . . . . . . . .	L Near	 0F0A	  _TEXT	
Consist  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstRet . . . . . . . . . . . . . . .	L Near	 044C	  _TEXT	
ConstValueX  . . . . . . . . . . . . .	L Near	 0342	  _TEXT	Public
ConstValue . . . . . . . . . . . . . .	L Near	 033A	  _TEXT	Public
ControlVar . . . . . . . . . . . . . .	L Near	 0C69	  _TEXT	
Create4Dump  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CursorBx . . . . . . . . . . . . . . .	Text   	 bx
CursorSi . . . . . . . . . . . . . . .	Text   	 si
D1 . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD])
Debug  . . . . . . . . . . . . . . . .	Number	 0001h	 
DepthBl  . . . . . . . . . . . . . . .	Text   	 bl
DepthBx  . . . . . . . . . . . . . . .	Text   	 bx
DigitsChange . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DosMemCheck  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsExposed  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSiX  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSi . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsLHS  . . . . . . . . . . . . . . .	L Near	 096B	  _TEXT	
Dptr . . . . . . . . . . . . . . . . .	Text   	 dword ptr
DropList . . . . . . . . . . . . . . .	L Near	 07FE	  _TEXT	
DualSwitch . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dumper . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DupBif . . . . . . . . . . . . . . . .	L Near	 022B	  _TEXT	
D  . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD+$StrideV])
EndThen  . . . . . . . . . . . . . . .	L Near	 0AB0	  _TEXT	
Error49Bp  . . . . . . . . . . . . . .	Text   	 call bp
ExposedFs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
FileBx . . . . . . . . . . . . . . . .	Text   	 bx
FillJump . . . . . . . . . . . . . . .	L Near	 0B28	  _TEXT	
FindNew  . . . . . . . . . . . . . . .	L Near	 0018	  _TEXT	
Find . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	
ForBcode . . . . . . . . . . . . . . .	Number	 0000h	 
ForBig . . . . . . . . . . . . . . . .	Number	 0000h	 
FoundLabBin  . . . . . . . . . . . . .	L Near	 006D	  _TEXT	
FoundLabel . . . . . . . . . . . . . .	L Near	 007E	  _TEXT	
FromDoEnd  . . . . . . . . . . . . . .	L Near	 0C54	  _TEXT	
F  . . . . . . . . . . . . . . . . . .	Text   	 (Fshape ptr[bx-$StrideF])
GiveDosMem . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Hang . . . . . . . . . . . . . . . . .	Text   	 jmp $
HasDoCV  . . . . . . . . . . . . . . .	L Near	 0CBC	  _TEXT	
HaveValue  . . . . . . . . . . . . . .	L Near	 0FCD	  _TEXT	
Hd . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr ds:[0])
HeritageDi . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
He . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr es:[bp])
Hf . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr fs:[bp])
Hg . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr gs:[bp])
HighDi . . . . . . . . . . . . . . . .	Text   	 di
H  . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr[si])
InitMemory . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InitSegDs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
IsDrop . . . . . . . . . . . . . . . .	L Near	 07E8	  _TEXT	
IsVar  . . . . . . . . . . . . . . . .	L Near	 0878	  _TEXT	
Jbx  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[bx])
Jdi  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[di])
J  . . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[si])
KeyListCx  . . . . . . . . . . . . . .	Text   	 cx
KeysBase . . . . . . . . . . . . . . .	Number	 0028h	 
KeywordOffsetCx  . . . . . . . . . . .	Text   	 cx
LabelKnown . . . . . . . . . . . . . .	L Near	 01EB	  _TEXT	
Lbx  . . . . . . . . . . . . . . . . .	Text   	 ss:(Lshape ptr[bx-$StrideL+$StrideV])
LengthAtBx . . . . . . . . . . . . . .	Text   	 bx
LevelDi  . . . . . . . . . . . . . . .	Text   	 di
LevelSi  . . . . . . . . . . . . . . .	Text   	 si
LinkBcodeX . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LinkBcode  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookFileDsBx . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookLoop . . . . . . . . . . . . . . .	L Near	 002E	  _TEXT	
LookNoFind . . . . . . . . . . . . . .	L Near	 0090	  _TEXT	
LookTailed . . . . . . . . . . . . . .	L Near	 02A1	  _TEXT	
LookupRet  . . . . . . . . . . . . . .	L Near	 0113	  _TEXT	
LookupSi . . . . . . . . . . . . . . .	Text   	 si
Lookup . . . . . . . . . . . . . . . .	L Near	 00CB	  _TEXT	Public
LowPartLenCl . . . . . . . . . . . . .	Text   	 cl
LowSi  . . . . . . . . . . . . . . . .	Text   	 si
Lsi  . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+si-$StrideL+$StrideV])
L  . . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+di-$StrideL+$StrideV])
MajMinDx . . . . . . . . . . . . . . .	Text   	 dx
MajorDh  . . . . . . . . . . . . . . .	Text   	 dh
MakeAssign . . . . . . . . . . . . . .	L Near	 08D2	  _TEXT	
MemCheck . . . . . . . . . . . . . . .	Number	 0001h	 
MinorDl  . . . . . . . . . . . . . . .	Text   	 dl
MinorDx  . . . . . . . . . . . . . . .	Text   	 dx
MoreSpaceEs  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Name2File  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NewLabBin  . . . . . . . . . . . . . .	L Near	 00B4	  _TEXT	
NewLabel . . . . . . . . . . . . . . .	L Near	 00C5	  _TEXT	
NextSym  . . . . . . . . . . . . . . .	L Near	 02C5	  _TEXT	
NoCV . . . . . . . . . . . . . . . . .	L Near	 0D42	  _TEXT	
NoChange . . . . . . . . . . . . . . .	L Near	 054A	  _TEXT	
NoPfx  . . . . . . . . . . . . . . . .	L Near	 04CC	  _TEXT	
NoRef  . . . . . . . . . . . . . . . .	L Near	 04E6	  _TEXT	
NoSpace  . . . . . . . . . . . . . . .	L Near	 050E	  _TEXT	
NoTrailer  . . . . . . . . . . . . . .	L Near	 102C	  _TEXT	
Not1p  . . . . . . . . . . . . . . . .	L Near	 058D	  _TEXT	
NotArithBool . . . . . . . . . . . . .	L Near	 0527	  _TEXT	
NotAssignConst . . . . . . . . . . . .	L Near	 0958	  _TEXT	
NotAssig . . . . . . . . . . . . . . .	L Near	 04B0	  _TEXT	
NotBif . . . . . . . . . . . . . . . .	L Near	 01DE	  _TEXT	
NotDow . . . . . . . . . . . . . . . .	L Near	 0531	  _TEXT	
NotDualGen . . . . . . . . . . . . . .	L Near	 1002	  _TEXT	
NotGuess . . . . . . . . . . . . . . .	L Near	 0394	  _TEXT	
NotImplied . . . . . . . . . . . . . .	L Near	 0496	  _TEXT	
NotInterp  . . . . . . . . . . . . . .	L Near	 1029	  _TEXT	
NotNewConst  . . . . . . . . . . . . .	L Near	 0444	  _TEXT	
NotNumS  . . . . . . . . . . . . . . .	L Near	 0330	  _TEXT	
NotNumb  . . . . . . . . . . . . . . .	L Near	 0305	  _TEXT	
NotNum . . . . . . . . . . . . . . . .	L Near	 03FE	  _TEXT	
NotOrig  . . . . . . . . . . . . . . .	L Near	 06C0	  _TEXT	
NotPresent . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Null . . . . . . . . . . . . . . . . .	Number	 00B7h	 
NumDxBx  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
One  . . . . . . . . . . . . . . . . .	Number	 00B5h	 
OpAppendCl . . . . . . . . . . . . . .	Text   	 cl
OpAppendCx . . . . . . . . . . . . . .	Text   	 cx
OpFactAh . . . . . . . . . . . . . . .	Text   	 ah
OpFactAl . . . . . . . . . . . . . . .	Text   	 al
OpFlags  . . . . . . . . . . . . . . .	L Near	 058F	  _TEXT	Public
OperandBl  . . . . . . . . . . . . . .	Text   	 bl
OperandBx  . . . . . . . . . . . . . .	Text   	 bx
OtherVerb  . . . . . . . . . . . . . .	L Near	 09A1	  _TEXT	
Overlay  . . . . . . . . . . . . . . .	Text   	 0 dup(?)
ParaAllocAx  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ParmsCl  . . . . . . . . . . . . . . .	Text   	 cl
ParmsCx  . . . . . . . . . . . . . . .	Text   	 cx
ParseDot . . . . . . . . . . . . . . .	Number	 00FEh	 
ParseDx  . . . . . . . . . . . . . . .	Text   	 dx
ParseSi  . . . . . . . . . . . . . . .	Text   	 si
PartLenCx  . . . . . . . . . . . . . .	Text   	 cx
Pcode1DSame  . . . . . . . . . . . . .	L Near	 070F	  _TEXT	
Pcode1D  . . . . . . . . . . . . . . .	L Near	 0718	  _TEXT	
Pcode1S  . . . . . . . . . . . . . . .	L Near	 06F5	  _TEXT	
Pcode1 . . . . . . . . . . . . . . . .	L Near	 06EF	  _TEXT	Public
Pcode2DSame  . . . . . . . . . . . . .	L Near	 06D5	  _TEXT	
Pcode2D  . . . . . . . . . . . . . . .	L Near	 06DF	  _TEXT	
Pcode2S  . . . . . . . . . . . . . . .	L Near	 06A5	  _TEXT	
Pcode2Via  . . . . . . . . . . . . . .	L Near	 08C4	  _TEXT	
Pcode2 . . . . . . . . . . . . . . . .	L Near	 069F	  _TEXT	Public
PcodeArg . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeBif . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeGapBx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeLoadRet . . . . . . . . . . . . .	L Near	 08B9	  _TEXT	
PcodeLoadX . . . . . . . . . . . . . .	L Near	 0816	  _TEXT	
PcodeLoad  . . . . . . . . . . . . . .	L Near	 082F	  _TEXT	
PcodeOpDone  . . . . . . . . . . . . .	L Near	 058D	  _TEXT	
PcodeOpRet . . . . . . . . . . . . . .	L Near	 054A	  _TEXT	
PcodeOp  . . . . . . . . . . . . . . .	L Near	 046A	  _TEXT	Public
PcodeRet . . . . . . . . . . . . . . .	L Near	 06C7	  _TEXT	
PcodeSafeGsBx  . . . . . . . . . . . .	L Near	 0727	  _TEXT	
PcodeUses  . . . . . . . . . . . . . .	L Near	 0434	  _TEXT	
PcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Positional . . . . . . . . . . . . . .	L Near	 0E97	  _TEXT	
PostTrigger  . . . . . . . . . . . . .	L Near	 0EA6	  _TEXT	
ProbeBx  . . . . . . . . . . . . . . .	Text   	 bx
ProgEs . . . . . . . . . . . . . . . .	Text   	 es
QueryLoad  . . . . . . . . . . . . . .	L Near	 07D9	  _TEXT	
RadixTypeDl  . . . . . . . . . . . . .	Text   	 dl
Raise28  . . . . . . . . . . . . . . .	L Near	 0C09	  _TEXT	
Raise50p1  . . . . . . . . . . . . . .	L Near	 0260	  _TEXT	
Raise5p1d  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RawCharAh  . . . . . . . . . . . . . .	Text   	 ah
RawCharAl  . . . . . . . . . . . . . .	Text   	 al
RawChar  . . . . . . . . . . . . . . .	Text   	 byte ptr ss:[si+bp]
Rejumps  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResultSpace  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResumeP$ . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RetEsSi  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RtypeAh  . . . . . . . . . . . . . . .	Text   	 ah
S1 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+$StrideS])
S2P  . . . . . . . . . . . . . . . . .	L Near	 0654	  _TEXT	
S2 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+2*$StrideS])
Say$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ScanSi . . . . . . . . . . . . . . . .	Text   	 si
ScannerSi  . . . . . . . . . . . . . .	Text   	 si
Scode  . . . . . . . . . . . . . . . .	L Near	 0695	  _TEXT	Public
SegOffDi . . . . . . . . . . . . . . .	Text   	 di
Serialize  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetInherit . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetLabel . . . . . . . . . . . . . . .	L Near	 0232	  _TEXT	
SetStack . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetSymLenJa  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Shorten  . . . . . . . . . . . . . . .	L Near	 0ABA	  _TEXT	
SignalVerb . . . . . . . . . . . . . .	L Near	 0F57	  _TEXT	
Solid  . . . . . . . . . . . . . . . .	Number	 0001h	 
SortSpaceSS  . . . . . . . . . . . . .	Number	 0001h	 
StackDi  . . . . . . . . . . . . . . .	Text   	 di
StackDx  . . . . . . . . . . . . . . .	Text   	 dx
StackSafe  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StackSi  . . . . . . . . . . . . . . .	Text   	 si
StartExecutionY  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StartExecution . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StateBx  . . . . . . . . . . . . . . .	Text   	 bx
StateDi  . . . . . . . . . . . . . . .	Text   	 di
StateSi  . . . . . . . . . . . . . . .	Text   	 si
StemBx . . . . . . . . . . . . . . . .	Text   	 bx
StemEs . . . . . . . . . . . . . . . .	Text   	 es
StemTgt  . . . . . . . . . . . . . . .	L Near	 0962	  _TEXT	
StrictFlags  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
String1  . . . . . . . . . . . . . . .	Number	 00BBh	 
String2  . . . . . . . . . . . . . . .	Number	 00BDh	 
String . . . . . . . . . . . . . . . .	Number	 00B9h	 
SymFirst . . . . . . . . . . . . . . .	L Near	 0323	  _TEXT	
SymbolEq . . . . . . . . . . . . . . .	L Near	 0047	  _TEXT	
SymbolLook . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymbolsBelow . . . . . . . . . . . . .	L Near	 0084	  _TEXT	
SymbolsEs  . . . . . . . . . . . . . .	Text   	 es
SymbolsSafe  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymsZiDx . . . . . . . . . . . . . . .	Text   	 dx
SynchMatch . . . . . . . . . . . . . .	L Near	 074E	  _TEXT	
SynchTarget  . . . . . . . . . . . . .	L Near	 0B39	  _TEXT	
S  . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si])
TailSi . . . . . . . . . . . . . . . .	Text   	 si
TakeSlotDi . . . . . . . . . . . . . .	L Near	 026D	  _TEXT	
Targeted . . . . . . . . . . . . . . .	L Near	 04CF	  _TEXT	
TarsLoop . . . . . . . . . . . . . . .	L Near	 0EB0	  _TEXT	
Terminate  . . . . . . . . . . . . . .	L Near	 100E	  _TEXT	Public
TestTarsUp . . . . . . . . . . . . . .	L Near	 0EDC	  _TEXT	
TgtTailed  . . . . . . . . . . . . . .	L Near	 0EC3	  _TEXT	
TheMsgBh . . . . . . . . . . . . . . .	Text   	 bh
Then$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToDsSiCx . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToFindDx . . . . . . . . . . . . . . .	Text   	 dx
ToFindLenAx  . . . . . . . . . . . . .	Text   	 ax
ToWholeEbx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TokNowCh . . . . . . . . . . . . . . .	Text   	 ch
TokNumAh . . . . . . . . . . . . . . .	Text   	 ah
TraceEvent . . . . . . . . . . . . . .	L Near	 09E0	  _TEXT	
Trial  . . . . . . . . . . . . . . . .	Number	 0000h	 
TriggerValue . . . . . . . . . . . . .	L Near	 0E99	  _TEXT	
UCorig . . . . . . . . . . . . . . . .	L Near	 086B	  _TEXT	
UpStack  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperFirstAh . . . . . . . . . . . . .	L Near	 044D	  _TEXT	Public
UseS1w . . . . . . . . . . . . . . . .	L Near	 0A95	  _TEXT	
UseS1  . . . . . . . . . . . . . . . .	L Near	 0A8C	  _TEXT	
UsualCon . . . . . . . . . . . . . . .	L Near	 0858	  _TEXT	
V00  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-2*$StrideV])
V0 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-$StrideV])
V2 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+$StrideV])
V3 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+2*$StrideV])
V4 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+3*$StrideV])
VasDsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Vbxe . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bx])
Vbxf2  . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx+$StrideV])
Vbxf . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx])
Vbxs . . . . . . . . . . . . . . . . .	Text   	 ss:(Vshape ptr[bx])
Vbxt . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx-$CaseTarget])
Vbx  . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[bx])
Vdid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[di])
Ve . . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bp])
Vf . . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bp])
Vsid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[si])
Vsif . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[si])
Vsi  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+si])
V  . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di])
WhileArrayBx . . . . . . . . . . . . .	L Near	 002A	  _TEXT	
WithColon  . . . . . . . . . . . . . .	L Near	 022F	  _TEXT	
Wptr . . . . . . . . . . . . . . . . .	Text   	 word ptr
XCycle . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ycx2 . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[2*ecx+ebp])
Ysi  . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[si])
Y  . . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[bp])
Zero$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZeroBp . . . . . . . . . . . . . . . .	Text   	 bp
Zero . . . . . . . . . . . . . . . . .	Number	 00B3h	 
ZoneNumerics . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZoneToLevel  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Z  . . . . . . . . . . . . . . . . . .	Text   	 (Zshape ptr[bp])
_Eq  . . . . . . . . . . . . . . . . .	Number	 00CDh	 
_Exists  . . . . . . . . . . . . . . .	Number	 00C7h	 
_Ge  . . . . . . . . . . . . . . . . .	Number	 00D5h	 
_Gt  . . . . . . . . . . . . . . . . .	Number	 00D7h	 
_IterCV  . . . . . . . . . . . . . . .	Number	 00C5h	 
_Jump  . . . . . . . . . . . . . . . .	Number	 00CBh	 
_Le  . . . . . . . . . . . . . . . . .	Number	 00D3h	 
_Lt  . . . . . . . . . . . . . . . . .	Number	 00D1h	 
_Ne  . . . . . . . . . . . . . . . . .	Number	 00CFh	 
_RetBc . . . . . . . . . . . . . . . .	Number	 00BFh	 
_RetB  . . . . . . . . . . . . . . . .	Number	 00C1h	 
_RetF  . . . . . . . . . . . . . . . .	Number	 00C3h	 
_Seq . . . . . . . . . . . . . . . . .	Number	 00D9h	 
_Slt . . . . . . . . . . . . . . . . .	Number	 00DDh	 
_Sne . . . . . . . . . . . . . . . . .	Number	 00DBh	 
_Then  . . . . . . . . . . . . . . . .	Number	 00C9h	 
is . . . . . . . . . . . . . . . . . .	Text   	 textequ

	   0 Warnings
	   0 Errors
