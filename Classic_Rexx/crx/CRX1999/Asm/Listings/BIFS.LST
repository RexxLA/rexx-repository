Microsoft (R) Macro Assembler Version 6.11		    01/21/12 18:44:55
bifs.asm						     Page 1 - 1


				     ; Copyright Formcroft Ltd 1997-1999
				      .model small
				      .486
 0000				      .code
				     ;------------------------------------------------------------------------------
				     ; Literal and numeric replacements
				     ;------------------------------------------------------------------------------
 = textequ			     is textequ <textequ>
 = byte ptr			     Bptr  is <byte ptr>
 = word ptr			     Wptr  is <word ptr>
 = dword ptr			     Dptr  is <dword ptr>
 = jmp $			     Hang  is <jmp $>
 = 0dh				     $Cr   is <0dh>
 = 0ah				     $Lf   is <0ah>
 = 1ah				     $Eof  is <1ah>
 = 0 dup(?)			     Overlay is <0 dup(?)>
 = .erre			     Assert is <.erre>
				     ;------------------------------------------------------------------------------
				     ; Typedefs. MASMs pointers are offsets in a segment.
				     ; Some of this is to indicate the purpose to the reader rather than MASM,
				     ; ie CHAR v BYTE since both are unsigned 8 bits.
				     ; However, pointerness is worth saying for words containing offsets since
				     ; debugger will take note.
				     ; WORD will tend not to get used since a word is either an integer (USHORT)
				     ; or an offset.
				     ; I haven't yet found the penalty in giving up SHORT as a keyword so as to
				     ; use it in the 'C' sense.
				     ;------------------------------------------------------------------------------
				       option nokeyword:<short>
				       option nokeyword:<C>
				     ; One byte target:
				     char   typedef byte
				     Bool   typedef byte
				     bytep  typedef ptr byte
				     charp  typedef ptr byte
				     charfp  typedef far ptr byte
				     Boolp  typedef ptr byte
				     ; Two byte
				     Ushort typedef word
				     Ushortp typedef ptr word
				     short typedef sword
				     shortp typedef ptr sword
				     Handle typedef word
				     Handlep typedef ptr word
				     Segp typedef word; Slightly different sense.
				     ; Four byte
				     Ulong typedef dword
 0004				     Farp struc; For les,lds
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
				     Farp ends

				     ;------------------------------------------------------------------------------
				     ; Macros
				     ;------------------------------------------------------------------------------

				     MkMajMin macro Maj:req, Min:req
				      
; Makes parts of msg number into one number.
				      exitm %(256*Maj+Min)
				     endm

				     StringOrder macro a:req, b:req, c, d
				      
; Load so that a store puts them in the written order.
				      ifnb <d>
				       exitm %(256*256*256*(d)+256*256*(c)+256*(b)+(a))
				      endif
				      exitm %(256*(b)+(a))
				     endm

				     ; Splat makes a visual 'noise' on the output.
				     Splat macro It:=<'*'>
				      mov dl,It
				      mov ah,02h
				      int 21h
				     endm

				     LoopQ macro tgt:req
				     
; Faster than single loop instruction
				       dec cx
				       jnz tgt
				     endm

				     JcxzQ macro tgt:req
				     
; jcxz is written only where retaining flags matters, else JcxzQ
				     
; JcxzQ can be rendered in way that can do long jump. (And maybe faster)
				       test cx,cx
				       je tgt
				     endm

				     Pos macro Needle:req, Hay:req
				      exitm % @InStr(1,Hay,Needle)
				     endm

				     ; As provided in MASM readme, plus fixing:
				      la macro Dest:req, Symbol:req
				     ; This can go wrong because replacement in operand occurs later.
				     ; Page 583 of Waite suggests we can test this but...
				      if (opattr(Symbol)) and 20h
				        if (opattr(Symbol)) and 08h
				          mov Dest, offset Symbol
				        else
				          lea Dest, Symbol
				        endif
				      else
				        ; Assume MOV if errors
				        mov Dest, offset Symbol
				      endif
				      endm

				     ; Having bp=0 makes a difference to zeroing.
				     ; XOR is no better than MOV of 0, and disturbs flags so this is just shorthand.
				     ; XOR faster than MOV of 0 on some machines?
				     ; Actually XOR is better for accum, but macro can't distinquish accum.
				     ; If Ax is positive CWD is better for DX, but macro doesn't do that.
				      z macro Dest:req
				     ; Drop this bit because XOR never better than register move.
				          if (type Dest) eq 1
				            mov Dest,0
				          else
				            if (type Dest) eq 2
				              mov Dest,bp
				            else
				              if (type Dest) eq 4
				                mov Dest,ebp
				              else
				                Whoops
				              endif
				            endif
				          endif
				      endm

				     ; Illuminate special use of test to set flags.
				     TestReg macro arg:req
				            test arg,arg
				     endm

				     ; Illuminate pop that discards.
				     PopJunk  macro arg:req
				       pop arg
				     endm

				     ; Setting bits in records.
				     ; I'm having trouble with MASM. If arg is complicated, it uses two byte
				     ; offsets where one would do. (Cured by overlay of word on record)
				     ; I cannot get MASM to put what I want on the listing. I would like the
				     ; values computed to show in the listed expansion but MASM will only show
				     ; the macro variable names there.  A % at the beginning of the line returned
				     ; by the macro does nothing. A % before the macro variable name in it is seen
				     ; as a syntax error. Short of conditional generation returning lines with
				     ; only the macro arguments in (these do get replaced on the listing), I don't
				     ; see a solution.

				     On      macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             or  arg,masksum
				       else
				         if masksum gt 255
				             or  Bptr(arg+1), high masksum
				         else
				             or  Bptr(arg), low masksum
				         endif
				       endif
				     endm
				     Off     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             and arg, not masksum
				       else
				         if masksum gt 255
				             and Bptr(arg+1), high not masksum
				         else
				             and Bptr(arg), low not masksum
				         endif
				       endif
				     endm
				     Qry     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             test arg, masksum
				       else
				         if masksum gt 255
				           if @SizeStr("&arg") gt 4
				             test Bptr(arg+1), high masksum
				           else
				             if "cx" ne "&arg"
				               test Bptr(arg+1), high masksum
				             else
				               test ch, high masksum
				             endif
				           endif
				         else
				             test Bptr(arg), low masksum
				         endif
				       endif
				     endm

				     mv   macro To:req,From:req
				     ; Used for segment moves
				      push From
				      pop To
				     endm

				     xax macro To:req
				     ; Used for ax moves when xchg saves a byte. (At expense of cycles)
				     ; Don't use xax form if exchange is "real" exchange.
				      if (type To) eq 2
				        xchg ax,To
				      else
				        xchg eax,To
				      endif
				     endm

				     inc2 macro Subj:req
				     ; Shorter than add Subj,2 when non-acc 16 bit reg.
				      inc Subj
				      inc Subj
				     endm

				     dec2 macro Subj:req
				     ; Shorter than dec Subj,2 when non-acc 16 bit reg.
				      dec Subj
				      dec Subj
				     endm

				     top macro To:req
				     ; Top element of hardware stack without disturbing it.
				      pop To
				      push To
				     endm

				     move macro To:req,From:req,Via
				     ; Memory to memory with arguments in same order as a mov.
				      ifb <Via>
				       if (type To) eq 2
				         mov ax,From
				         mov To,ax
				       elseif (type To) eq 1
				         mov al,From
				         mov To,al
				       else
				         mov eax,From
				         mov To,eax
				       endif
				      else
				       mov Via,From
				       mov To,Via
				      endif
				     endm

				     ;------------------------------------------------------------------------------
				     ; Shapes of structures for based addressing.
				     ;------------------------------------------------------------------------------
				     ; If we PUSHA and then copy SP to BP the caller's
				     ; registers have become locals accessible on [BP].
				     ; Structure PushShape holds the shape for this.
 0010				     PushShape struct
 0000  0000			      di_ word ?
 0002  0000			      si_ word ?
 0004  0000			      bp_ word ?
 0006  0000			      sp_ word ?
 0008	    0000 [		      bx_ word Overlay
	     0000
	    ]
 0008  00			      bl_ byte ?
 0009  00			      bh_ byte ?
 000A	    0000 [		      dx_ word Overlay
	     0000
	    ]
 000A  00			      dl_ byte ?
 000B  00			      dh_ byte ?
 000C	    0000 [		      cx_ word Overlay
	     0000
	    ]
 000C  00			      cl_ byte ?
 000D  00			      ch_ byte ?
 000E	    0000 [		      ax_ word Overlay
	     0000
	    ]
 000E  00			      al_ byte ?
 000F  00			      ah_ byte ?
				     PushShape ends
				     ; Build characteristics:
 = 0000				      CD equ 0; On when dump of compaction activity needed. See CD.REXX
 = 0001				      Debug equ 1; On for normal checks detecting internal flaws early.
 = 0001				      MemCheck equ 1; On for DOS memory checks.
 = 0000				      ForBcode equ 0; When making code that will be turned to BCode.
 = 0000				      ForBig equ 0; When making code that will be turned into one big assembly.
 = 0001				      SortSpaceSS equ 1; Design has compaction list under SS.
 = 0000				      Trial equ 0; Design change experiment.
 = 0001				      Solid equ 1; Always 1, used to mark sensitive areas for ForBig technology.
				     ;(Solid section with following label is assumed not to fall through.)
				     if ForBig
				      endif
				     if Debug
				     CheckType macro
				      test V.Dtype,$Test
				      jz @F
				      cmp V.Dtype,$AwayString
				      je @F
				      cmp V.Dtype,$NullString
				      je @F
				      cmp V.Dtype,$NullString+1
				      je @F
				      cmp V.Dtype,$NullString+2
				      je @F
				      cmp V.Dtype,$NullString+3
				      je @F
				      cmp V.Dtype,$NullString+4
				      je @F
				      cmp V.Dtype,$NullString+5
				      je @F
				      cmp V.Dtype,$NullString+6
				      je @F
				      cmp V.Dtype,$NullString+7
				      je @F
				     endm
				     endif
				      EXTERNDEF ToWholeEbx:near; Converts from Rexx variable to integer in EBX.
				      EXTERNDEF Zero$$:near; Puts zero on the stack.
				      EXTERNDEF Then$$:near; Execution of THEN
				      EXTERNDEF DigitsChange:near; Called at places where Digits() setting may change.
				      EXTERNDEF ZoneNumerics:near; Updates Zone for fast access to numeric settings.
				      EXTERNDEF SetInherit:near; Inherit, for an external routine.
				      EXTERNDEF Compiling:near; To start compiling something.
				      EXTERNDEF Compiler:near; To start compiling something.
				      EXTERNDEF StartExecution:near; To start executing made Pcode.
				      EXTERNDEF StartExecutionY:near; To start executing made Pcode.
				      EXTERNDEF ResumeP$:near; To start executing Pcode after Bcode.
				      EXTERNDEF Command:near; To start compiling source named on a command.
				      EXTERNDEF AssureSiPlus:near
				      EXTERNDEF AssignExposed:near
				      EXTERNDEF Name2File:near
				      EXTERNDEF ZoneToLevel:near
				      EXTERNDEF BifBound:near; A place separating code on basis of address
				      EXTERNDEF ConstValue:near
				      EXTERNDEF ConstValueX:near
				      EXTERNDEF Terminate:near
				      EXTERNDEF UpperFirstAh:near
				      EXTERNDEF NotPresent:near
				      EXTERNDEF Consist:near
				      EXTERNDEF Serialize:near
				      EXTERNDEF RetEsSi:near
				      EXTERNDEF ExposedFs:near, DotsExposed:near
				     ; Make the memory services available to all modules.
				      EXTERNDEF InitMemory:near, AllocateCx_EsAx:near, InitSegDs:near
				      EXTERNDEF MoreSpaceEs:near,GiveDosMem:near
				      EXTERNDEF ParaAllocAx:near, Raise5p1:near, Raise5p1d:near
				      EXTERNDEF StackSafe:near, SetStack:near, UpStack:near
				     ; Most modules need to load values from Rexx variables to registers.
				      EXTERNDEF ToDsSiCx:near, NumDxBx:near
				     ; Many modules create pseudo-code, test operator attributes..
				      EXTERNDEF Scode:near, Pcode1:near, Pcode2:near, PcodeArg:near
				      EXTERNDEF PcodeGapBx:near, PcodeOp:near, OpFlags:near
				     ; Lookup things may be needed in execution, eg for DROP (abc)
				      EXTERNDEF Lookup:near,SymbolsSafe:near,SetSymLenJa:near,SymbolLook:near
				      EXTERNDEF VasDsSiCx:near
				     ; And a few more in common use.
				      EXTERNDEF Ax2DsSiCx:near,HeritageDi:near, Raise:near
				      EXTERNDEF Attributes:near; Table for uppercasing, etc.
				      EXTERNDEF ResultSpace:near, AwayEsAxCx:near
				      EXTERNDEF LinkBcode:near, LinkBcodeX:near
				      EXTERNDEF CONFIG_UPPER$$:near
				      EXTERNDEF CONFIG_RAISE40$$:near
				      EXTERNDEF PcodesBase$:near
				      EXTERNDEF DotsFsBxDsSi:near
				      EXTERNDEF DotsFsBxDsSiX:near
				      EXTERNDEF XCycle:near,Rejumps:near,Boolery:near,BooleryRejumps:abs
				      EXTERNDEF LookFileDsBx:near
				      EXTERNDEF Away:near
				      EXTERNDEF ClauseSourceEnd:near
				      EXTERNDEF DualSwitch:near
				     if Debug
				      EXTERNDEF Say$$:near ; only for Consist debug
				      EXTERNDEF DosMemCheck:near
				      EXTERNDEF Create4Dump:near
				      EXTERNDEF Dumper:near
				     endif

 = 0001				     $PcodesBase equ 01h
 = 005D				     $BPcodesCeil equ 05Dh
 = 00C5				     $PcodesCeil equ 0C5h
 = 0057				     $PjumpBase equ 057h
 = 0089				     $PjumpCeil equ 089h
 = 0001				     $pAbut equ 01h
 = 0003				     $pCat equ 03h
 = 0005				     $pNop equ 05h
 = 0007				     $pAssignDotsP equ 07h
 = 0009				     $pParse equ 09h
 = 000B				     $pResumeParse equ 0Bh
 = 000D				     $pNumber equ 0Dh
 = 000F				     $pTo equ 0Fh
 = 0011				     $pBy equ 011h
 = 0013				     $pFor equ 013h
 = 0015				     $pWhile equ 015h
 = 0017				     $pUntil equ 017h
 = 0019				     $pIterRep equ 019h
 = 001B				     $pIterate equ 01Bh
 = 001D				     $pLeave equ 01Dh
 = 001F				     $pUnDo equ 01Fh
 = 0021				     $pResult equ 021h
 = 0023				     $pReturn equ 023h
 = 0025				     $pReturns equ 025h
 = 0027				     $pExit equ 027h
 = 0029				     $pSay equ 029h
 = 002B				     $pBifq equ 02Bh
 = 002D				     $pLength equ 02Dh
 = 002F				     $pMax equ 02Fh
 = 0031				     $pMin equ 031h
 = 0033				     $pNot equ 033h
 = 0035				     $pAnd equ 035h
 = 0037				     $pOr equ 037h
 = 0039				     $pXor equ 039h
 = 003B				     $pPositive equ 03Bh
 = 003D				     $pNegate equ 03Dh
 = 003F				     $pAdd equ 03Fh
 = 0041				     $pSubtract equ 041h
 = 0043				     $pMultiply equ 043h
 = 0045				     $pDivide equ 045h
 = 0047				     $pIntDivide equ 047h
 = 0049				     $pRemainder equ 049h
 = 004B				     $pPower equ 04Bh
 = 004D				     $pCommand equ 04Dh
 = 004F				     $pInterpret equ 04Fh
 = 0051				     $pNumeric equ 051h
 = 0053				     $pInvoke equ 053h
 = 0055				     $pCall equ 055h
 = 0057				     $pRep equ 057h
 = 0059				     $pRepEver equ 059h
 = 005B				     $pControlVar equ 05Bh
 = 005D				     $pDotControlVar equ 05Dh
 = 005F				     $pThen equ 05Fh
 = 0061				     $pWhen equ 061h
 = 0063				     $pJump equ 063h
 = 0065				     $pEq equ 065h
 = 0067				     $pNe equ 067h
 = 0069				     $pLt equ 069h
 = 006B				     $pLe equ 06Bh
 = 006D				     $pGe equ 06Dh
 = 006F				     $pGt equ 06Fh
 = 0071				     $pSeq equ 071h
 = 0073				     $pSne equ 073h
 = 0075				     $pSlt equ 075h
 = 0077				     $pSle equ 077h
 = 0079				     $pSge equ 079h
 = 007B				     $pSgt equ 07Bh
 = 007D				     $pCeq equ 07Dh
 = 007F				     $pCne equ 07Fh
 = 0081				     $pClt equ 081h
 = 0083				     $pCle equ 083h
 = 0085				     $pCge equ 085h
 = 0087				     $pCgt equ 087h
 = 0089				     $pInterpEnd equ 089h
 = 008B				     $pSignal equ 08Bh
 = 008D				     $pSignalOn equ 08Dh
 = 008F				     $pCallOn equ 08Fh
 = 0091				     $pDots equ 091h
 = 0093				     $pAssign equ 093h
 = 0095				     $pAssignStem equ 095h
 = 0097				     $pAssignDots equ 097h
 = 0099				     $pAssignConst equ 099h
 = 009B				     $pUnstore equ 09Bh
 = 009D				     $pDrop equ 09Dh
 = 009F				     $pExpose equ 09Fh
 = 00A1				     $pBool equ 0A1h
 = 00A3				     $pIterCV equ 0A3h
 = 00A5				     $pAddress equ 0A5h
 = 00A7				     $pCommandEnv equ 0A7h
 = 00A9				     $pEnvName equ 0A9h
 = 00AB				     $pBif equ 0ABh
 = 00AD				     $pBifGroup equ 0ADh
 = 00AF				     $pRaise equ 0AFh
 = 00B1				     $pSignalOff equ 0B1h
 = 00B3				     $pSignalV equ 0B3h
 = 00B5				     $pSysVar equ 0B5h
 = 00B7				     $pDropList equ 0B7h
 = 00B9				     $pExposeList equ 0B9h
 = 00BB				     $pPush equ 0BBh
 = 00BD				     $pQueue equ 0BDh
 = 00BF				     $pTrace equ 0BFh
 = 00C1				     $pTraceEvent equ 0C1h
 = 00C3				     $pOptions equ 0C3h
 = 0000				     $BifDATE equ 0
 = 0001				     $BifTIME equ 1
 = 0002				     $BifLINES equ 2
 = 0003				     $BifCHARS equ 3
 = 0004				     $BifCHARIN equ 4
 = 0005				     $BifCHAROUT equ 5
 = 0006				     $BifLINEIN equ 6
 = 0007				     $BifLINEOUT equ 7
 = 0008				     $BifSTREAM equ 8
 = 0009				     $BifSTRIP equ 9
 = 000A				     $BifVERIFY equ 10
 = 000B				     $BifQUALIFY equ 11
 = 000C				     $BifWORDS equ 12
 = 000D				     $BifTRUNC equ 13
 = 000E				     $BifERRORTEXT equ 14
 = 000F				     $BifSPACE equ 15
 = 0010				     $BifTRANSLATE equ 16
 = 0011				     $BifFORMAT equ 17
 = 0012				     $BifWORDLENGTH equ 18
 = 0013				     $BifWORDPOS equ 19
 = 0014				     $BifABBREV equ 20
 = 0015				     $BifCENTER equ 21
 = 0016				     $BifCENTRE equ 22
 = 0017				     $BifCOMPARE equ 23
 = 0018				     $BifDELSTR equ 24
 = 0019				     $BifDELWORD equ 25
 = 001A				     $BifRIGHT equ 26
 = 001B				     $BifLASTPOS equ 27
 = 001C				     $BifINSERT equ 28
 = 001D				     $BifOVERLAY equ 29
 = 001E				     $BifFORM equ 30
 = 001F				     $BifDATATYPE equ 31
 = 0020				     $BifADDRESS equ 32
 = 0021				     $BifARG equ 33
 = 0022				     $BifCONDITION equ 34
 = 0023				     $BifTRACE equ 35
 = 0024				     $BifFUZZ equ 36
 = 0025				     $BifDIGITS equ 37
 = 0026				     $BifSOURCELINE equ 38
 = 0027				     $BifXRANGE equ 39
 = 0028				     $BifRANDOM equ 40
 = 0029				     $BifREVERSE equ 41
 = 002A				     $BifABS equ 42
 = 002B				     $BifSIGN equ 43
 = 002C				     $BifC2X equ 44
 = 002D				     $BifB2X equ 45
 = 002E				     $BifX2B equ 46
 = 002F				     $BifX2C equ 47
 = 0030				     $BifX2D equ 48
 = 0031				     $BifC2D equ 49
 = 0032				     $BifD2C equ 50
 = 0033				     $BifD2X equ 51
 = 0034				     $BifBITAND equ 52
 = 0035				     $BifBITOR equ 53
 = 0036				     $BifBITXOR equ 54
 = 0037				     $BifVALUE equ 55
 = 0038				     $BifCOPIES equ 56
 = 0039				     $BifWORD equ 57
 = 003A				     $BifWORDINDEX equ 58
 = 003B				     $BifSUBWORD equ 59
 = 003C				     $BifPOS equ 60
 = 003D				     $BifLEFT equ 61
 = 003E				     $BifSUBSTR equ 62
 = 003F				     $BifQUEUED equ 63
 = 0040				     $BifSYMBOL equ 64
 = 0041				     $BifCOUNTSTR equ 65
 = 0042				     $BifCHANGESTR equ 66
 = 0043				     $BifLENGTH equ 67
 = 0044				     $BifMAX equ 68
 = 0045				     $BifMIN equ 69
 = 00B3				     $BcodesBase equ 0B3h
 = 00B3				     Zero equ 0B3h
 = 00B5				     One equ 0B5h
 = 00B7				     Null equ 0B7h
 = 00B9				     String equ 0B9h
 = 00BB				     String1 equ 0BBh
 = 00BD				     String2 equ 0BDh
 = 00BF				     _RetBc equ 0BFh
 = 00C1				     _RetB equ 0C1h
 = 00C3				     _RetF equ 0C3h
 = 00C5				     _IterCV equ 0C5h
 = 00C7				     _Exists equ 0C7h
 = 00C9				     _Then equ 0C9h
 = 00CB				     _Jump equ 0CBh
 = 00CD				     _Eq equ 0CDh
 = 00CF				     _Ne equ 0CFh
 = 00D1				     _Lt equ 0D1h
 = 00D3				     _Le equ 0D3h
 = 00D5				     _Ge equ 0D5h
 = 00D7				     _Gt equ 0D7h
 = 00D9				     _Seq equ 0D9h
 = 00DB				     _Sne equ 0DBh
 = 00DD				     _Slt equ 0DDh
 = 00DF				     CONFIG_RAISE equ 0DFh
 = 00E1				     CONFIG_RAISE40 equ 0E1h
 = 00E3				     CONFIG_UPPER equ 0E3h
 = 00E5				     CONFIG_MSG equ 0E5h
 = 00E7				     CONFIG_C2B equ 0E7h
 = 00E9				     CONFIG_B2C equ 0E9h
 = 00EB				     CONFIG_STREAM_POSITION equ 0EBh
 = 00ED				     CONFIG_STREAM_CHARIN equ 0EDh
 = 00EF				     CONFIG_STREAM_QUERY equ 0EFh
 = 00F1				     CONFIG_STREAM_CLOSE equ 0F1h
 = 00F3				     CONFIG_STREAM_CHAROUT equ 0F3h
 = 00F5				     CONFIG_STREAM_COUNT equ 0F5h
 = 00F7				     CONFIG_STREAM_QUALIFIED equ 0F7h
 = 00F9				     CONFIG_STREAM_COMMAND equ 0F9h
 = 00FB				     CONFIG_STREAM_STATE equ 0FBh
 = 00FD				     CONFIG_TIME equ 0FDh
 = 00FF				     CONFIG_ARITH equ 0FFh
 = 0000				     $0 equ 0
 = 0000				     $Eos equ 0*4
 = 0001				     $12 equ 1
 = 0004				     $Semi equ 1*4
 = 0002				     $11 equ 2
 = 0008				     $UnAccept equ 2*4
 = 0003				     $6 equ 3
 = 000C				     $Lparen equ 3*4
 = 0004				     $3 equ 4
 = 0010				     $Percent equ 4*4
 = 0011				     $Asterisk equ 4*(5-1) + 1
 = 0012				     $Slash equ 4*(5-1) + 2
 = 0013				     $Rem equ 4*(5-1) + 3
 = 0014				     $Xor equ 5*4
 = 0015				     $Or equ 4*(6-1) + 1
 = 0006				     $5 equ 6
 = 0018				     $And equ 6*4
 = 0007				     $10 equ 7
 = 001C				     $Comma equ 7*4
 = 0020				     $Not equ 8*4
 = 0009				     $9 equ 9
 = 0024				     $Minus equ 9*4
 = 0025				     $Plus equ 4*(10-1) + 1
 = 002B				     $Eq equ 10*4+3
 = 002C				     $Ne equ 11*4
 = 002D				     $Lt equ 4*(12-1) + 1
 = 002E				     $Le equ 4*(12-1) + 2
 = 002F				     $Ge equ 4*(12-1) + 3
 = 0030				     $Gt equ 12*4
 = 0031				     $Seq equ 4*(13-1) + 1
 = 0032				     $Sne equ 4*(13-1) + 2
 = 0033				     $Slt equ 4*(13-1) + 3
 = 0034				     $Sle equ 13*4
 = 0035				     $Sge equ 4*(14-1) + 1
 = 0036				     $Sgt equ 4*(14-1) + 2
 = 000E				     $7 equ 14
 = 0038				     $Rparen equ 14*4
 = 003C				     $STRING equ 15*4
 = 0040				     $CONST_SYMBOL equ 16*4
 = 0044				     $NUMBER equ 17*4
 = 0012				     $28 equ 18
 = 0048				     $VAR_SYMBOL equ 18*4
 = 0013				     $1 equ 19
 = 004C				     $Abut equ 19*4
 = 004D				     $Cat equ 4*(20-1) + 1
 = 0014				     $8 equ 20
 = 0050				     $Power equ 20*4
 = 0015				     $2 equ 21
 = 0054				     $Assign equ 21*4
 = 0016				     $21 equ 22
 = 0058				     $VALUE equ 22*4
 = 0017				     $16 equ 23
 = 005C				     $END equ 23*4
 = 0018				     $18 equ 24
 = 0060				     $THEN equ 24*4
 = 0019				     $17 equ 25
 = 0064				     $FOR equ 25*4
 = 001A				     $19 equ 26
 = 0068				     $TO equ 26*4
 = 001B				     $15 equ 27
 = 006C				     $BY equ 27*4
 = 0070				     $UNTIL equ 28*4
 = 0074				     $WHILE equ 29*4
 = 001E				     $23 equ 30
 = 0078				     $WITH equ 30*4
 = 007C				     $LINEIN equ 31*4
 = 007D				     $SOURCE equ 4*(32-1) + 1
 = 007E				     $VERSION equ 4*(32-1) + 2
 = 0080				     $PULL equ 32*4
 = 0084				     $VAR equ 33*4
 = 0088				     $ARG equ 34*4
 = 008C				     $ADDRESS equ 35*4
 = 0090				     $APPEND equ 36*4
 = 0094				     $CALL equ 37*4
 = 0098				     $DO equ 38*4
 = 009C				     $ELSE equ 39*4
 = 00A0				     $NOP equ 40*4
 = 00A4				     $INTERPRET equ 41*4
 = 00A5				     $OPTIONS equ 4*(42-1) + 1
 = 00A8				     $EXIT equ 42*4
 = 00A9				     $PUSH equ 4*(43-1) + 1
 = 00AA				     $QUEUE equ 4*(43-1) + 2
 = 00AB				     $RETURN equ 4*(43-1) + 3
 = 00AC				     $SAY equ 43*4
 = 00B0				     $TRACE equ 44*4
 = 00B4				     $LEAVE equ 45*4
 = 00B5				     $ITERATE equ 4*(46-1) + 1
 = 00B8				     $DROP equ 46*4
 = 00BC				     $EXPOSE equ 47*4
 = 00C0				     $SIGNAL equ 48*4
 = 00C4				     $SYNTAX equ 49*4
 = 00C5				     $LOSTDIGITS equ 4*(50-1) + 1
 = 00C6				     $NOVALUE equ 4*(50-1) + 2
 = 00C8				     $NOTREADY equ 50*4
 = 00C9				     $FAILURE equ 4*(51-1) + 1
 = 00CA				     $HALT equ 4*(51-1) + 2
 = 00CC				     $ERROR equ 51*4
 = 00D0				     $UPPER equ 52*4
 = 00D4				     $IF equ 53*4
 = 00D8				     $INPUT equ 54*4
 = 00DC				     $NAME equ 55*4
 = 00E0				     $NUMERIC equ 56*4
 = 00E4				     $DIGITS equ 57*4
 = 00E5				     $FUZZ equ 4*(58-1) + 1
 = 00E8				     $FORM equ 58*4
 = 00EC				     $ENGINEERING equ 59*4
 = 00ED				     $SCIENTIFIC equ 4*(60-1) + 1
 = 00F0				     $OTHERWISE equ 60*4
 = 00F4				     $OUTPUT equ 61*4
 = 00F8				     $PARSE equ 62*4
 = 00FC				     $PROCEDURE equ 63*4
 = 0100				     $SELECT equ 64*4
 = 0104				     $WHEN equ 65*4
 = 0108				     $REPLACE equ 66*4
 = 010C				     $STEM equ 67*4
 = 0110				     $STREAM equ 68*4
 = 0114				     $NORMAL equ 69*4
 = 0118				     $FOREVER equ 70*4
 = 011C				     $OFF equ 71*4
 = 0120				     $ON equ 72*4
 = 0000				     $sPercent equ 0
 = 0006				     $sDrop equ 6
 = 0009				     $sStem equ 9
 = 000A				     $sWith equ 10
 = 000B				     $sDropList equ 11
 = 0014				     $sMinus equ 20
 = 0017				     $sLength equ 23
 = 001B				     $sEq equ 27
 = 0021				     $sSeq equ 33
 = 0027				     $sDigits equ 39
 = 002A				     $sNop equ 42
 = 002B				     $sForm equ 43
 = 002D				     $sAddress equ 45
 = 0030				     $sNegate equ 48
 = 0031				     $sPositive equ 49
 = 0032				     $sExit equ 50
 = 0035				     $sReturns equ 53
 = 0037				     $sNumber equ 55
 = 0039				     $sRaise equ 57
 = 003E				     $sLeave equ 62
 = 003F				     $sIterate equ 63
 = 00FE				     ParseDot equ 254; A non-operator Bcode value otherwise unused.
 = 0028				     KeysBase equ 4*10; Manual
				     ; Here are some symbolic names of registers, used for readability of this code.
 = bp				     ZeroBp is <bp>
 = di				     StackDi is <di>      ; The soft stack pointer.
 = si				     StackSi is <si>      ; Another soft stack pointer.
 = dx				     StackDx is <dx>      ; Limit of range on soft stack.
 = bx				     ArrayBx is <bx>      ; To an element of Vshape.
 = bx				     StemBx is <bx>       ; When the subject is a stem.
 = si				     TailSi is <si>       ; When the subject is a tailed variable.
 = bx				     FileBx is <bx>       ; To an element of Fshape.
 = si				     ArraySi is <si>      ; To an element of Vshape.
 = bx				     OperandBx is <bx>    ; A pointer to an operand in one of the arrays of Vshapes.
 = bl				     OperandBl is <bl>    ;
 = bx				     ProbeBx is <bx>      ; Used when searching a binary tree for a stemmed variable.
 = si				     LowSi is <si>        ; Used when searching a binary tree.
 = di				     HighDi is <di>       ; Used when searching a binary tree.
 = ax				     ToFindLenAx is <ax>  ; Used when searching a binary tree.
 = dx				     ToFindDx is <dx>     ; Used when searching a binary tree.
 = cx				     KeyListCx is <cx>;   ; Parameter to keyword lookup.
 = ch				     TokNowCh is <ch>;    ; One of the places numbers for tokens are held.
 = si				     StateSi is <si>      ; The state in parsing.
 = si				     ParseSi is <si>      ; Parse state pushed on hard stack.
 = di				     StateDi is <di>      ; Address first word of the state.
 = bx				     StateBx is <bx>      ; Often distance from StateOrig to some state data.
 = dx				     ParseDx is <dx>      ; Token data in form the parser uses.
 = ah				     RtypeAh is <ah>      ; Type of reduction done in Cycle.
 = ah				     TokNumAh is <ah>     ; Where next token is returned, becoming TokNum.
 = si				     LookupSi is <si>     ; Where Lookup finds unresolved compound symbol.
 = si				     LevelSi is <si>      ; To block for this invocation level.
 = di				     LevelDi is <di>
 = si				     CursorSi is <si>     ; Offset in Pcode.
 = bx				     CursorBx is <bx>     ; Offset in Pcode.
 = cx				     OpAppendCx is <cx>   ; Numeric argument to PcodeOp routine.
 = si				     ScanSi is <si>       ; Scanning the user's source program.
 = cl				     OpAppendCl is <cl>
 = al				     RawCharAl is <al>
 = ah				     RawCharAh is <ah>
 = al				     AttribAl is <al>
 = dl				     RadixTypeDl is <dl>
 = cx				     ParmsCx is <cx>
 = cl				     ParmsCl is <cl>
 = bx				     LengthAtBx is <bx>
 = dx				     SymsZiDx is <dx>
 = di				     SegOffDi is <di> ; Offset in Zone of a segment pointer.
				     ; Special use of bp for two-byte call.
 = call bp			     Error49Bp is <call bp>
				     ; Shorthand for current byte of input.
 = byte ptr ss:[si+bp]		     RawChar is <byte ptr ss:[si+bp]>
				     ; These for making messages.
 = bl				     DepthBl is <bl>; of recursion.
 = bx				     DepthBx is <bx>; Bug if inc/dec affects bh.
 = bh				     TheMsgBh is <bh>; on when scanning the target.
 = cx				     PartLenCx is <cx>; Amount of compressed to expand.
 = cl				     LowPartLenCl is <cl>
 = cx				     KeywordOffsetCx is <cx>
 = dx				     MajMinDx is <dx>
 = dh				     MajorDh is <dh>
 = dl				     MinorDl is <dl>
 = dx				     MinorDx is <dx>; inc/dec
 = si				     ScannerSi is <si>; SI the address in table. (LODS used)
				     ; For segment registers.
				     ; ES has some transient uses (particularly because it cannot be overridden
				     ; in movsb) but mainly it is set to the symbols segment during compilation
				     ; and the program scope segment during execution.  Tailed variable references
				     ; also use it (transiently) because each stem variable has it's own segment.
 = es				     SymbolsEs is <es>
 = es				     ProgEs is <es>
 = es				     StemEs is <es>

 = 0019				     $DosDisk equ 19h
 = 002A				     $DosDate equ 2Ah
 = 002C				     $DosTime equ 2Ch
 = 003C				     $DosCreate equ 3Ch
 = 003D				     $DosOpen equ 3Dh
 = 003E				     $DosClose equ 3Eh
 = 003F				     $DosRead equ 3Fh
 = 0040				     $DosWrite equ 40h
 = 0041				     $DosDelete equ 41h
 = 0042				     $DosSeek equ 42h
 = 0043				     $DosChmod equ 43h
 = 0047				     $DosPath equ 47h
 = 0048				     $DosAllocate equ 48h
 = 0049				     $DosFree equ 49h
 = 004A				     $DosModifyAllocated equ 4Ah
 = 004B				     $DosExecute equ 4Bh
 = 004C				     $DosExit equ 4Ch
 = 004D				     $DosReturnCode equ 4Dh
 = 0059				     $DosGetError equ 59h
 = 0062				     $DosPSP equ 62h
				     ; As allowed by the Standard:
 = 000A				     $Limit_EnvironmentName equ 10
 = C350				     $Limit_String equ 50000
 = 00FA				     $Limit_Literal equ 250
 = 00FA				     $Limit_Name equ 250
 = 270F				     $Limit_Digits equ 9999; Note Msg33.2 must be generated to match.
 = 0009				     $Limit_ExponentDigits equ 9
 = 0032				     $Limit_Insert equ 50; Longest insert.
				     ; Ours
 = 0036				     $Limit_Major equ 54; Highest message user sees.
 = 0037				     $Descriptions equ 55; A place in the message numbering for oddment prose.
 = 00C8				     $MsgRoom equ 4*$Limit_Insert
 = 00AF				     $MaxPreInsert equ 175; Chars in message.
 = 0050				     $MsgChunk equ 80; Strictly, ANSI says leave chunking to system.
 = 0064				     $MaxParms equ 100; Per invokation. (Or temporary results within an expression)
 = 0400				     $FileBufferSize equ 1024
 = 0003				     $Leeway equ 3
				     ; Data types within symbols segment:
 = 00FF				     $tChar equ 0FFh
 = 00FE				     $tLabel equ 0FEh
 = 00FD				     $tBinary equ 0FDh
				     ; Minor bits on an operand reference.
 = 0006				     $CaseTarget equ 6
				     ; Subcodes to Pcodes.
				     ; These are used by the utility. Avoid putting semicolon abutting the "h".
				     ; These markers share values with Sysvar references in Bcode but we don't
				     ; parse into sysvars in our Bcode.
				     ; If we want to detect presence/absence of these they need to be 2 modulo 8.
				     ; However if they always follow something known, any value will do.
				     ; In practice we sometimes use the modulo 8 approach (even at the expense of
				     ; a shift when they are used) so as to make scanning of Pcode simpler.
 = 0002				     $mRepTail equ 02h        ; Used when $pDotControlVar addresses tails.
 = 000A				     $mUpper equ 0Ah          ; Modifier on parse source.
 = 0012				     $mParseEscape equ 12h    ; Parse part too complex to handle as single action.
 = 001A				     $mParseEnd equ 1Ah       ; Parse ends.
 = 0022				     $mPosRest equ 22h        ; Parse trigger
 = 002A				     $mPattern equ 2Ah        ; Parse trigger after operand
 = 0032				     $mPosEq equ 32h          ; Parse trigger after operand
 = 003A				     $mPosPlus equ 3Ah        ; Parse trigger after operand
 = 0042				     $mPosMinus equ 42h       ; Parse trigger after operand
 = 004A				     $mTemplateComma equ 4Ah  ; Parse trigger
				     ; These in number field of $pParse:
 = 0000				     $nVar equ 0              ; These
 = 0002				     $nWith equ 2             ;       two lowest of parse sources.
 = 0004				     $nArg equ 4
 = 0006				     $nLineIn equ 6
 = 0008				     $nPull equ 8
 = 000A				     $nSource equ 10
 = 000C				     $nVersion equ 12
				     ; These in number field of $pCommandEnv
 = 0000				     $nStem equ 00h
 = 0020				     $nStream equ 20h
 = 0040				     $nNormal equ 40h
				     ; These in number field of $pNumeric
 = 0000				     $nDigits equ 00h
 = 0002				     $nFuzz equ 02h
 = 0004				     $nForm equ 04h
				     ; These in number field of $pRaise
 = 0000				     $n7p3 equ 0
 = 0002				     $n17p1 equ 2
 = 0004				     $n40p3 equ 4
 = 0006				     $n40p4 equ 6
 = 0008				     $n40p5 equ 8
				     ; Types for things in Z.Serial
				     ; $SerialNone is also used for message building.
				     ; $SerialSource is qualified by Z.RelativeNow - what part of source file.
				     ; These are modals except for $SerialCompaction which saves/restores previous.
 = 0000				     $SerialNone equ 0
 = 0001				     $SerialQue equ 1
 = 0002				     $SerialCompaction equ 2
 = 0003				     $SerialInterpret equ 3
 = 0004				     $SerialSource equ 4
				     ; Trace events. (Order unexploited except for highest.)
 = 0000				     $TraceAssign equ 0
 = 0002				     $TraceBY equ 1*2
 = 0004				     $TraceClause equ 2*2
 = 0006				     $TraceCompound equ 3*2
 = 0008				     $TraceDot equ 4*2
 = 000A				     $TraceError equ 5*2
 = 000C				     $TraceExpr equ 6*2
 = 000E				     $TraceFailure equ 7*2
 = 0010				     $TraceFunction equ 8*2
 = 0012				     $TraceOperator equ 9*2
 = 0014				     $TracePrefix equ 10*2
 = 0016				     $TraceLit equ 11*2
 = 0018				     $TraceVar equ 12*2
 = 001A				     $TraceBack equ 13*2; Highest for $TrEv.
 = 001C				     $TraceParse equ 14*2; Only sets flag.
 = 001E				     $TraceEndClause equ 15*2; Compiled at end of a traced clause.
				     ; Descriptions on messages.    See OverfullMem for some.
				     Assert Zshape.SysFiles-Zshape.SysFiles eq 2*1-2
				     Assert Zshape.Consts-Zshape.SysFiles eq 2*2-2
				     Assert Zshape.Vars-Zshape.SysFiles eq 2*3-2
				     Assert Zshape.ProgScope-Zshape.SysFiles eq 2*4-2 ; Used for 'memory' msg.
				     Assert Zshape.VarScope-Zshape.SysFiles eq 2*5-2 ; Used for 'string length'
				     Assert Zshape.Symbols-Zshape.SysFiles eq 2*6-2
				     Assert Zshape.Code-Zshape.SysFiles eq 2*7-2
				     Assert Zshape.Zone-Zshape.SysFiles eq 2*8-2
				     Assert Zshape.Stem-Zshape.SysFiles eq 2*9-2
 = 0005				     $DescString equ 5
 = 000A				     $DescArgs   equ 10
 = 000B				     $Desc59H    equ 11
 = 000C				     $DescFiles  equ 12
 = 000D				     $DescQueue  equ 13
 = 0080				     $BifTag equ 80h; Helps with reverse lookup
				     ; As well as source coming from a file, there are the cases of INTERPRET,
				     ; VALUE, and SYMBOL where some compiling is needed.  Also VarPool cases.
				     ; Even if only Lookup is needed, it can be simplest to compile and pick
				     ; the answer up from the generated code.
 = 11C8				     $SourceBufferSize equ 4552; Allows for long bit literal.
 = 2000				     $InitStackSize equ 8192
 = 0000				      $White equ 0
 = 0040				      $Digit equ 64
 = 0080				      $Letter equ 128
 = 00C0				      $Special equ 192
 = 0008				      $NonUpable equ 8
 = 0004				      $Bb equ 4
 = 0002				      $Xx equ 2
 = 0001				      $Ee equ 1
 = 0048				      $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; Constants for Bifs.
 = FFB9				     $BifBase equ 65535-70; 68 bifs at high numbers.
				     ; The equates for pseudo code operations are with the P switch.
				     ; (See also $Reserved)
 = 00C0				     $Test       equ 11000000b; To test the most vital bits.
 = 0080				     $NullString equ 10000000b; 01000nnn for 0-7 length strings.
 = 0088				     $Omitted    equ 10001000b; Value of omitted is null string.
 = 0089				     $Variable   equ 10001001b; Only used at compile time.
 = 008A				     $Constant   equ 10001010b; Only used at compile time. (Untyped constant.)
 = 008B				     $Label      equ 10001011b;
 = 00C0				     $AwayString equ 11000000b;
				     ; NYI $AwayNumber equ 11110000b;
				     ; The 01 tags don't reach the runtime stack.
				     ; (That avoids a test when type checking operands now and allows future use.)
 = 0040				     $Dropped    equ 01000000b;
 = 0050				     $Exposed    equ 01010000b;
 = 0060				     $Stem       equ 01100000b;
 = 0044				     $MsgNum     equ 01000100b; Msg number in Major/Minor form.
 = 0048				     $Sigl       equ 01001000b; Jump point still as code offset.
				     ; Not to be confused with the bits from the table of characters:
				     XlatBDLS macro ;; 0=Blanks 1=Digits 2=Letters 3=Special
				      
; Picks up attributes of current char and sets flags.
				      xlat Bptr cs:[bx]
				      test al,0C0h
				     endm
				     Down macro
				      sub StackDi,$StrideV
				     endm
				     Up macro
				      add StackDi,$StrideV
				     endm
				     DownCare macro
				      lea StackDi,(-$StrideV)[StackDi]
				     endm
				     UpCare macro
				      lea StackDi,$StrideV[StackDi]
				     endm
				     ; Hard & soft cursors return.
				     RetSi macro
				      pop CursorSi
				      ret
				     endm
				     ; Macros for some common idioms in Pcode making.
				     OpAl macro $p
				       mov al,$p
				       call PcodeOp
				     endm
				     OpRet macro $p
				       mov al,$p
				       jmp PcodeOp
				     endm
				     EvAh macro $p
				       mov ah,$p
				       call TraceEvent
				     endm
				     EvRet macro $p
				       mov ah,$p
				       jmp TraceEvent
				     endm

				     ; Macros are used to make that clear where code is run out of the interpreter
				     ; loop, and to allow experiments in how the return is made.
				     ; These experiments never worked out because of the difficulty in having some
				     ; operations that needed to be routines (eg Assign as part of ControlVar) and
				     ; some that didn't.  Changing code to achieve sometimes-routine is a speed
				     ; killer.

				     Back macro
				     jmp XCycle
				     endm
				     BackRet macro
				     ret
				     endm

				     ; When all the operations end with a jump to XCycle we can turn them into
				     ; callable routines by sticking a ret instruction the code at XCycle.
				     ; Performance killer so rarely used.
 = 00C3				     $ret equ 0C3h
				     CodeModeR macro
				      push Wptr cs:XCycle
				      mov Bptr cs:XCycle,$ret
				     endm
				     UnCodeMode macro
				      pop Wptr cs:XCycle
				     endm

				     Repmovsb macro
				     local IsEven
				     if 1
				      rep movsb
				     endif
				     if 0
				     ; This ought to be faster but didn't seem to be. Perhaps jnc high cost.
				      shr cx,1
				      rep movsw
				      jnc IsEven
				      movsb
				      IsEven:
				     endif
				     endm

				     ; There is a "mv" macro that moves registers by push & pop.
				     ; There is a "move" that saves typing when memory-to-memory.
				     ; Here is "Mv" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by push & pop.
				     ; Here is "Move" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by shuffling through general registers.
				     Mv macro To,From
				     ; "Move" is faster than "Mv" and no bigger, if there is a spare register.
				        pushd From.OverExpo
				        pop To.OverExpo
				        pushd From.OverMant
				        pop To.OverMant
				     endm

				     Move macro To,From,Via
				     ; Move of a Rexx value. Convention is to use ecx:eax
				      ifb <To>
				     ; No target means load usual registers.
				        mov ecx,From.OverExpo
				        mov eax,From.OverMant
				      elseifb <From>
				     ; No source means store from usual registers.
				        mov To.OverExpo,ecx
				        mov To.OverMant,eax
				      elseifb <Via>
				     ; Copy via usual registers.
				        mov ecx,From.OverExpo
				        mov To.OverExpo,ecx
				        mov eax,From.OverMant
				        mov To.OverMant,eax
				      else
				     ; Copy via specified register.
				       mov Via,From.OverExpo
				       mov To.OverExpo,Via
				       mov Via,From.OverMant
				       mov To.OverMant,Via
				      endif
				     endm

 0006				     FarpX struc
 0000	    0000 [		      Fr dword Overlay
	     00000000
	    ]
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
 0004	    0000 [		      Limit word Overlay
	     0000
	    ]
 0004  0000			      Len word 0
				     FarpX ends


 0008				     Vshape union
				      struc; When containing a short string.
 0000	    0007 [		       String db 7 dup(?)
	     00
	    ]
 0007  00			       Dtype db ?                        ; Whether string or not and used length.
				      ends
				      struc; When binary number
				       Sign byte Overlay     ; Odd means negative mantissa.
				       ExpAnd dword Overlay  ; Exponent and sign of mantissa.
				        ExpoUses db 3 dup(?)
				        ExpoSign db ?        ; Sign of exponent.
				       Mantissa dword Overlay
				        MantLow word ?
				        MantHigh word ?
				      ends
				      struc; When treated as just bytes.
				       OverExpo dword ?
				       OverMant dword ?
				      ends
				      struc; When referencing a long string.
				       FarpX <>
				       dw ?                              ; Covers Dtype.
				      ends
				      struc; When referencing label information
				       LabelValue word ?                 ; Offset in Pcode.
				       dword ?
				       LabelType word Overlay
				       byte ?                            ; 0 = normal, 1 = TraceOnly
				       db ?                              ; Covers Dtype. Will be $Label.
				      ends
				      struc; When compile time stack item for a constant.
				       WhichCon word ?                  ; Offset under ProgScope.
				       PcodePos word ?                  ; Where it will be in Pcode.
				       db 4 dup(?)                       ; Covers Dtype. Will be $Constant.
				      ends
				      struc; When compile time stack item for a resolved target.
				       HeldOver word ?                   ; To go in Pcode eventually.
				       db 6 dup(?)                       ; Covers Dtype. Will be $NullString
				      ends
				      struc ; When used to look up symbols.  Dtype not relevant then.
				     ; Moot whether this is really a Vshape but pretending it is allows use of Vbx.
				       Pair dd 0 dup(?)                  ; Next two together.
				        Lower Ushortp ?                  ; a subtree.
				        Higher Ushortp ?                 ; a subtree
				       Here charp ?                      ; to the symbol.
				      ends
				     Vshape ends
				     ; V. is for Vshape objects addressed by [di+bp]; eg variables on the stack.
 = (Vshape ptr[bp+di])		     V is <(Vshape ptr[bp+di])>
				     ; 1-origin numbers for the parameters of bif, but V is used for V1 (and result).
				     ; So lhs and rhs of binary operation are V and V2, result overlays V.
				     ; Of course, changing di by $StrideV is an alternative to using different Vn.
 = 0008				     $StrideV equ size Vshape
 = 0003				     $ShiftV equ 3
 = (Vshape ptr[bp+di-$StrideV])	     V0 is <(Vshape ptr[bp+di-$StrideV])>
 = (Vshape ptr[bp+di-2*$StrideV]     V00 is <(Vshape ptr[bp+di-2*$StrideV])>
   )
 = (Vshape ptr[bp+di+$StrideV])	     V2 is <(Vshape ptr[bp+di+$StrideV])>
 = (Vshape ptr[bp+di+2*$StrideV]     V3 is <(Vshape ptr[bp+di+2*$StrideV])>
   )
 = (Vshape ptr[bp+di+3*$StrideV]     V4 is <(Vshape ptr[bp+di+3*$StrideV])>
   )
				     ; Vsi. is for Vshape objects addressed by [si+bp]; variables on the stack.
 = (Vshape ptr[bp+si])		     Vsi is <(Vshape ptr[bp+si])>
				     ;Vsif. is for Vshape objects addressed by fs:[si]; Variables of procedure.
 = fs:(Vshape ptr[si])		     Vsif is <fs:(Vshape ptr[si])>
				     ; Vdid. is for Vshape objects addressed by ds:[di]
 = ds:(Vshape ptr[di])		     Vdid is <ds:(Vshape ptr[di])>
				     ; Vsid. is for Vshape objects addressed by ds:[si]
 = ds:(Vshape ptr[si])		     Vsid is <ds:(Vshape ptr[si])>
				     ;Vbx. is for Vshape objects addressed by ds:[bx]
 = ds:(Vshape ptr[bx])		     Vbx is <ds:(Vshape ptr[bx])>
				     ;Vbxf. is for Vshape objects addressed by fs:[bx]; Variables of procedure.
 = fs:(Vshape ptr[bx])		     Vbxf is <fs:(Vshape ptr[bx])>
 = fs:(Vshape ptr[bx-$CaseTarget     Vbxt is <fs:(Vshape ptr[bx-$CaseTarget])>
   ])
 = fs:(Vshape ptr[bx+$StrideV])	     Vbxf2 is <fs:(Vshape ptr[bx+$StrideV])>
				     ;Vbxs. is for Vshape objects addressed by ss:[bx]; Variables on the stack.
 = ss:(Vshape ptr[bx])		     Vbxs is <ss:(Vshape ptr[bx])>
				     ;Ve. is for Vshape objects addressed by es:[bp]; (Saves a byte sometimes)
 = es:(Vshape ptr[bp])		     Ve is <es:(Vshape ptr[bp])>
 = fs:(Vshape ptr[bp])		     Vf is <fs:(Vshape ptr[bp])>
				     ;Vbxe. is for Vshape objects addressed by es:[bx]
 = es:(Vshape ptr[bx])		     Vbxe is <es:(Vshape ptr[bx])>
				     if 0
				     endif
 0028				     Dshape struc; The elements of soft stack for DO loops.    (And INTERPRET)
				     ; Here the n of "DO n;" will wind up.
				     ; Also x of DO j=x...  We don't need to retain that through the DO-END, but
				     ; harmless to do so. (Overlaid when DO A.K=....)
 0000	    0000 [		      TailsAt word Overlay; Where the pcode to reload tails is.
	     0000
	    ]
 0000	    0000 [		      Subject Vshape 0 dup(<>); When block is for an INTERPRET.
	     0007 [
	      00 00
	     ]
 0000	     0000 [		      CVinit Vshape 0 dup(<>)
	      0007 [
	       00 00
	      ]
 0000	      0007 [		      Reps Vshape <>
	       00
	      ] 00
 0008	      0007 [		      To Vshape <>
	       00
	      ] 00
 0010	      0007 [		      By Vshape <>
	       00
	      ] 00
 0018	      0007 [		      ForCount Vshape <>
	       00
	      ] 00
				     ; The rest is made similar to a Vshape so that Bcode can overlay Dshape as
				     ; variables.
 0020	      0000 [		      PcodePos charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0020  0000			      Iteration charp ?; Where to branch on ITERATE
 0022  0000			      Leaving charp ?  ; Where to branch on LEAVE
 0024	      0000 [		      UpDO charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0024  0000			      CV charp ?; Offset of the control variable.
 0026  00			      byte ?
 0027  00			      Rec byte ?;  MASM confused when LoopsRec<> used.
				     Dshape ends
 = 0028				     $StrideD equ size Dshape
				     ; D. is for Dshape objects addressed by [di+bp]; the DO nesting.
				     ; These objects are addressed from partway through them.  This is because the
				     ; XCycle loop benefits from moving StackDi over the "previous operand" when
				     ; loading the latest operand. But the "previous operand" may actually have
				     ; been one of these DO control blocks.
				     ; Use D1 to address the DO block when StackDi has been upped to indicate
				     ; there is a value stacked later than the DO block.
 = (Dshape ptr[bp+di-$StrideD+$S     D is <(Dshape ptr[bp+di-$StrideD+$StrideV])>
   trideV])
 = (Dshape ptr[bp+di-$StrideD])	     D1 is <(Dshape ptr[bp+di-$StrideD])>

				      FRec record Qual:1,Read:1,Open:1,BeenRead:1,BeenWrite:1,
				                  WriteMode:1,IsSource:1,BeenCompiled:1,FFpad:8
 001A				     Fshape struct ; Data for a file, the key is the file name.
 0000  0000			       Flags FRec <>
 0002  0000			       ToQual word ? ; To item for fully qualified name.
 0004  00000000			       Lines Ulong ?
 0008  0000			       Hand Handle ?
 000A  00000000			       Other_Position Ulong ? ; A position on the file, provided by DOS.
 000E  00			       Exten byte ?; 1=REX/CMD 2=COM 3=EXE 4=BAT
 000F  00			       TraceWidth byte ?; How many chars in a clause identifier.
 0010  0000			       Symbols Segp ? ; Saved from Zone when file inactive.
 0012  0000			       Code Segp ?
 0014  0000			       Vars Segp ?
 0016  0000			       Consts Segp ?
 0018  0000			       ProgScope Segp ?
				     Fshape ends
 = 001A				     $StrideF equ size Fshape
				     ; F. is for Fshape objects addressed by [bx]; a file.
				     ; An Fshape is put ahead of a Jshape.
 = (Fshape ptr[bx-$StrideF])	     F is <(Fshape ptr[bx-$StrideF])>

 0008				     EnvBlock struc 2
 0000  0000			      EnvNumber    word ?
 0002  0000			      EnvResourceI word ?
 0004  0000			      EnvResourceO word ?
 0006  0000			      EnvResourceE word ?
				     EnvBlock ends
				     if 1; Private to memory object
 0006				     Ashape struc; Describe pieces of memory got from Dos, and part of them used.
 0000  0000 0000		      Fr Farp <>
 0004  0000			      Amount Ushort 0
				     Ashape ends
				     ; A. is for Ashape objects addressed by [si+bp]; For memory allocation.
 = (Ashape ptr[bp+si])		     A is <(Ashape ptr[bp+si])>
 = 0006				     $StrideA equ size Ashape
				     endif
 0015				     InsBlock struc;  Used by issuing of messages, to deduce inserts.
 0000	      0000 [		      MajMin word Overlay    ; This is an error detected.
	       0000
	      ]
 0000  00			       Minor byte ?
 0001  00			       Major byte ?
 0002  0000			      Value word ?           ; Soft stack offset of value.
 0004	      0000 [		      Named Ushort Overlay
	       0000
	      ]
 0004  0000			      Position Ushort ?
 0006  0000			      KeysList charp ?       ; Yields keyword list
 0008  00			      ArgNum byte ?
 0009  00			      Desc byte ?            ; To find text of <Description>
 000A	      0000 [		      Hex byte Overlay
	       00
	      ]
 000A  00			      Char byte ?
 000B  0000			      Options charp ?        ; Msg 40.28
 000D  0000			      OptsHi charp ?         ; Msg 40.28
 000F  0000			      Digits word ?          ; Msgs 26.1 and 33.1  Don't overlay, zero meaningful.
 0011  0000			      TokPos charp ?         ; Position of token within segment holding source.
 0013  0000			      TokLen Ushort ?        ; Ushort although inserts have low limit length.
				     InsBlock ends

				     ; "Interacting" is a bug for "Interactive" ?. Pad 8 makes byte offset zero.
				     LevelRec record Lpad:8,InheritDone:1,DigitsSet:1,IsProcedure:1,IsExternal:1,
				         IsFunction:1,Lpad2:3

				     LevelRecI record LIPad:14,Interactive:1,ConditionInstruction:1
				     ; Instruction.Condition and ConditionInstruction are the same value.

				     ConditionRec record Enabling:1,Delayed:1,PendingNow:1,Instruction:1,CRspare:4

 007C				     Lshape struc; The elements of soft stack for invocations.
				     ; The part inherited from the level above. (When there is one.)
				      align 4; We move the inherited bit using doublewords.
 0000	      0000 [		       DigitsFuzz dword Overlay
	       00000000
	      ]
 0000  0000			       Digits Ushort ?
 0002  0000			       Fuzz Ushort ?
 0004  00			       Form char ?
 0005  0000000000000000		       StartTime qword ?
 000D	      0000 [		       TraceLetter char Overlay
	       00
	      ]
 000D  0000			       TraceWord word ?; LevelRecI <>.
 000F  0000 0000 0000 0000	       Active EnvBlock <>
 0017  0000 0000 0000 0000	       Alternate EnvBlock <>
 001F  00			       Syntax ConditionRec <>
 0020  00			       LostDigits ConditionRec <>
 0021  00			       NoValue ConditionRec <>
 0022  00			       NotReady ConditionRec <>
 0023  00			       Error ConditionRec <>
 0024  00			       Failure ConditionRec <>
 0025  00			       Halt ConditionRec <>
 0026	      0007 [		       TrapName word 7 dup(?)
	       0000
	      ]
 0034  0000			       EventLevel word ?   ; Only used for Halt.
 0036  0000			       Condition word ?    ; As CONDITION bif result(C)
 0038	      0007 [		       ConditionDescription Vshape <>; As CONDITION bif result(D)
	       00
	      ] 00
 0040	      0007 [		       ConditionExtra Vshape <>; As CONDITION bif result(E)
	       00
	      ] 00
				      align 4; We move the inherited bit using doublewords.
 0048	      0000 [		       Inherit char Overlay; End of inherited.
	       00
	      ]
 0048  0000000000000000		      ClauseTime qword ?
 0050  0000000000000000		      ClauseLocal qword ?
 0058  0000000000000000		      PendingDescription qword ?
 0060  0000000000000000		      PendingExtra qword ?
 0068  0000			      LevelDO charp ?;  Level's CurrentDO held over call.
 006A  0000 0000		      StackSave Farp <>; To make save over DosExecute recursive.
 006E  0000			      File charp ?     ; Save which external file is source when external call made.
 0070  0000			      ProgScope Segp ? ; Saved values of constants, when external call.
 0072  0000			      VarScope Segp ?  ; Saved values of variables, when external call.
				      align 4
				     ;The Lshape is normally addressed a few bytes ($StrideV) down from its high end.
 0074	      0000 [		      Access word Overlay; MASM gets confused if this is attached to the LevelRec.
	       0000
	      ]
 0074  0000			      Flags LevelRec <>
 0076  0000			      UpLevel charp ?; Invoker's block.
 0078  0000			      Resume charp ? ; On return from invoke from here.
 007A  0000			      Arg0 charp ?   ; Parameters to this invoke.
				     Lshape ends
 = 007C				      $StrideL equ size Lshape
				     ; L. is for Lshape objects addressed by ss:[di+bp]; the level of the execution.
 = (Lshape ptr[bp+di-$StrideL+$S     L is <(Lshape ptr[bp+di-$StrideL+$StrideV])>
   trideV])
				     ; Lsi. is for Lshape objects addressed by ss:[si+bp]
 = (Lshape ptr[bp+si-$StrideL+$S     Lsi is <(Lshape ptr[bp+si-$StrideL+$StrideV])>
   trideV])
				     ; Lbx. is for Lshape objects addressed by ss:[bx]; the level of the execution.
 = ss:(Lshape ptr[bx-$StrideL+$S     Lbx is <ss:(Lshape ptr[bx-$StrideL+$StrideV])>
   trideV])

				     ; LoopsRec is used only in Dshape.
				     ;HasDot:1,      ; When DO X.=
				     ;HasDots:1,     ; When DO X.Y =
				     ;HasTo:1,
				     ;HasFor:1,
				     ;ByDown:1,      ; When control variable values are going down.
				     ;IsInterp:1     ; When block is for INTERPRET, not DO.
				     LoopsRec record LoopsPad:2,HasDot:1,HasDots:1,HasTo:1,HasFor:1,IsInterp:1,
				                     ByDown:1; ByDown last - see use in CompareTo

				     ; API_Enabled:1,   Controls "Variable Pool" interface.
				     ; NoSource:1,      $5.10.11, but no need to implement.
				     ; RandomSeeded:1,  Has the seed been initialized?
				     ; NotS9:1,         Off if numerics are 9 digit SCIENTIFIC.
				     ; The following are to do with compiling - they are off in execution.
				     ; LabelsBad:1,     On when the compile is of text from INTERPRET.
				     ; Repass:1,        When user overides Bif name.
				     ; FirstBetween:1,  On when parsing should start with a Between call.
				     ; EndSource:1,     Helps parser detect end-of-source.
				     ; BifCheck:1,      Tells whether Bif check failed, for compile time .
				     ; TraceIF:1,       Controls trace output.
				     ; ShowELSE:1,      Controls trace output.
				     ProgramRec record API_Enabled:1,
				        Repass:1,
				        LabelsBad:1,
				        FirstBetween:1,
				        EndSource:1,
				        BifCheck:1,RandomSeeded:1,NotS9:1,TraceIF:1,ShowELSE:1,PRSpare:6

				     ; InTypes:2     What are the types of the input operand(s)?
				     ; ResultType:2  Mark result on stack with its type.
				     ; AppendNum:1   When opcode is followed by a number.
				     ; AppendRef:1   When opcode (plus maybe number) is followed by a reference.
				     ; DownOne:1     On if operator leaves stack down one on when it started.
				     ; EndsClause:1  On if operator ends a clause. (Only for internal checks)
				     OperatorRec record InTypes:2,ResultType:2,AppendNum:1,AppendRef:1,DownOne:1,
				                        EndsClause:1

				     ; The Dtype byte is too complex to describe as individual flags. See equates.

 000E				     Jshape struc
 0000	      0007 [		      Valued Vshape <>                  ; Will be addressable Vsid. and J.
	       00
	      ] 00
 0008	      0000 [		      Pair dd 0 dup(?)                  ; Next two together.
	       00000000
	      ]
 0008  0000			      Lower Ushortp ?                   ; a subtree.
 000A  0000			      Higher Ushortp ?                  ; a subtree
 000C  0000			      KeyLen word ?                     ; Always a word of length. Chars may follow.
 000E	      0000 [		      Key char 0 dup(?)
	       00
	      ]
				     Jshape ends
 = 000E				     $StrideJ equ size Jshape
				     ; J. is for Jshape objects addressed by [si]; To look up tails.
 = (Jshape ptr[si])		     J is <(Jshape ptr[si])>
				     ; Jbx. is for Jshape objects addressed by [bx]; To look up tails.
 = (Jshape ptr[bx])		     Jbx is <(Jshape ptr[bx])>
				     ; Jdi. is for Jshape objects addressed by [di]; To look up tails.
 = (Jshape ptr[di])		     Jdi is <(Jshape ptr[di])>

				     TokVal record  GrpNdx:6,SubNum:2; Shape of $name
				     TokRec record X02:1, NdxbT:5, Aim:10
				     KeyRec record KeyFlags:3,EndList:1, KeyLen:4
				     ; Shapes for interpreting syntax tables. Ensure match with table generator.
				     ShiftRec record HasShift:1, ErrorAlone:1, CatFlag:1, HasKeys:1, Reference:1,
				                     Direct:1,Indexb:5, Index:5
				     ErrorRec record HasShiftOn:1, ErrorAloneOn:1, MajorField:8, MinorField:6
				     RedRec record HasShiftOff:1, HasAction:1, PruneCt:2, Rtype:2, Rstate:10
				     ; Every element on the parser stack will have the same size but the contents
				     ; are not always the same, except for State which is the reference state
				     ; needed by the parser mechanism.  The other fields are used for error
				     ; message data, and code generation.
				     ; Field order of Sshape is sensitive, matched to pushes that create an item.
				     ParserRec record ParserPad:12,DoRep:1,DoCV:1,Forever:1,DoDataHost:1
 0010				     Sshape struc
 0000  0000			      State word ?
 0002	      0000 [		      Parser word Overlay
	       0000
	      ]
 0002  0000			      ParserRec <>
				     ; Some of these fields could logically be overlaid but they are not, so that
				     ; logic is avoided in deciding what to push. (They are all pushed)
				     ; Actually that applies to just ClauseWas.
 0004  0000			      ClauseWas  word ?; Line number for message 10.n and 7.n
				      union
				       struct; This one for an operation. Element is made on basis that it is this.
 0006  0000			        Token Ushort ?; Numeric coding of the operation.
 0008  00000000			        Operation dword ?; ASCII coding with length ahead, eg 3,">>=".
 000C  0000			        Caller word ?; Resolved reference to what is to be invoked.
 000E  0000			        Parms Ushort ?; To compute how many arguments there are.
				       ends
				       struct; This overlay for info on a SELECT structure. (Also IF & DO)
				        JumpSite word ?; Records how Pcode jumps from WHEN test to WHEN test.
				                       ; (Also used by IF-ELSE)
				        SoFar charp Overlay; For TraceOnly
				        WhatCV charp Overlay; Control variable identification.
				        SelectSite word ?; Records how Pcode jumps from end of WHENs to end SELECT.
				       ends
				      ends
				     Sshape ends
				     ; S. is for Sshape objects addressed by [si+bp]; the parser stack.
 = (Sshape ptr[bp+si])		     S is <(Sshape ptr[bp+si])>
 = 0010				     $StrideS equ size Sshape
 = (Sshape ptr[bp+si+$StrideS])	     S1 is <(Sshape ptr[bp+si+$StrideS])>
 = (Sshape ptr[bp+si+2*$StrideS]     S2 is <(Sshape ptr[bp+si+2*$StrideS])>
   )
				     ParmsRec record ParmsMin:2,ParmsXtr:2,NonCheck:4
				     MiddleRec record NotLabel:1,SemiAfter:1,ValueBefore:1,
				       AbutOK:1,NoBlanks:1,ModEquals:1,EndClause:1,ImplicitValue:1,
				       CheckDO:1,TargetSymbol:1,Function:1,TakenConstant:1,LookLabel:1,
				       LookBin:1,DotOK:1,MRspare:1

				     ; More flags for clause level.
				     ; NotAssign:1,     Off includes DO j=
				     ; ClauseSet:1,     On when ClauseLine set.
				     ; Tailed:1,        Tells Lookup that compound name is on stack.
				     ; WasTailed:1,     Last Lookup was of tailed.
				     ; WasUpper:1,      Remembers UPPER option on PARSE.
				     ; OffFlag:1,       Remembers OFF of CALL OFF.
				     ; Condition:1,     Remembers there was a condition on CALL ON or SIGNAL ON.
				     ; Append:1,        Remembers there is APPEND during ADDRESS.
				     ; Signal:1,        Remembers when the verb was SIGNAL
				     ; CVar:1,          Remembers when there is a control variable on DO.
				     ; Repit:1,         Remembers when there is repetition part in DO.
				     ; PosEq:1,         Grouped with PosPlus & PosMinus - triggers in PARSE.
				     ; InParse:1,       On during Parse instruction. (Off when escape)
				     ; WasParse:1,      On during Parse instruction.
				       ClauseRec record WasUpper:1,OffFlag:1,Condition:1,Append:1,Signal:1,
				       ClauseSet:1,CVar:1,Repit:1,PosEq:1,NotAssign:1,
				       WasParse:1,InParse:1,Tailed:1,WasTailed:1,
				       PosPlus:1,PosMinus:1; Using 5-gap of PosEq and PosPlus.

				     ; Format5:1,       On for FORMAT bif with five args.
				     ; AssignDO:1,      On when assignment is for DO.
				     ; ForExpose:1,     On while executing EXPOSE.
				     ; FromIterCV:1,    Used when DO loop execution has dotted control variable.
				     ; ForBIF:1,        TargetMsg without expanding inserts. Needed for ERRORTEXT.
				     ; TokIsValue:1     Conditions error message insert.
				     ; ExpRange:1,      Number failure due to exponent oversize.
				     ; Description:1,   Used in msg production.
				     ; Compacted:1,     Used to detect a loop within Compaction.
				     ; BcodeInterpret:1, On when INTERPRET executing on behalf of Bcode.
				     ; MapOnly:1,       Used by Debug for when to fill allocations.
				     ; ParseUpper:1,    On when PARSE has UPPER, in execution.
				     ; ParseTrace:1,    On when PARSE tracing, in execution.
				     ; SourceFiles:1, On when source files rather than ordinary data files relevant.
				     ; BoolBefore:1,    On to prevent code generated for trace making undue prefix.
				     ; WasDropped:1     On to tell us that last load of variable found it dropped.
				     CancelRec record Format5:1,AssignDO:1,ForExpose:1,FromIterCV:1,
				      ForBIF:1,TokIsValue:1, ExpRange:1, Description:1, Compacted:1,
				      BcodeInterpret:1, MapOnly:1, ParseUpper:1, ParseTrace:1, SourceFiles:1,
				      BoolBefore:1, WasDropped:1

				     ; Dual:1,          On when the purpose of compiling is clause by clause run.
				     ; DualPending:1,   On when DualGen is to be set later.
				     ; DualGen:1,       On when Pcode for trace events is being made.
				     ; DualOnly:1,      On when Pcode for Dual differs from original.
				     GenRec record Dual:1,DualPending:1,DualGen:1,DualOnly:1,
				      GenSpare:12

				     ; Experience may show how many allocations the Dos space will be in.
 = 000A				     $Ashapes equ 10
				     ; Shortest code for addressing Header fields is varied. If mov with ax, then
				     ; 2-byte offset is reasonable because there are dedicated opcodes. Else it
				     ; will usually pay to specify indexing with a zero-value index because that
				     ; uses a one byte offset. The index can be bp when there is segment override.
				     ; Otherwise it may pay to zero si especially for the purpose.
 0010				     Hshape struct
 0000	      0000 [		      Hdw0 dword Overlay; This and next dword used when making a copy of a segment.
	       00000000
	      ]
 0000  0000			      SegSize Ushort ?  ; Bytes including our header.
				     ; The segments for different purposes need different subsets of these fields.
				     ; They all need SegSize because Compaction uses it.
				     ; The stack segment needs only SegSize because it has its own routine for
				     ; expansion on demand.
				     ; The pool-type segments only need SegSize&Bump; their size changes only when
				     ; the relevant Vars or Consts segment changes size.
 0002  0000			      Bump Ushort ?   ; Number of new bytes added each expansion
				     ; Things that grow independently (Symbols, Vars, Consts, SysFiles, and each
				     ; compound variable) need Avail and Trigger.
 0004  0000			      Avail Ushort ?  ; Place, below Trigger, for new-stuff-at-end.
 0006  0000			      Trigger Ushort ?; Limit before extension.
				     ; Link identifies the type of segment and allows Zone updates.
 0008  0000			      Link Ushort ?   ; To find slot in Zone that addresses this segment.
 000A	      0000 [		      TreeBin Ushort Overlay ; Field reused in the constants lookup segment.
	       0000
	      ]
 000A	      0000 [		      Original Ushort Overlay ; Field reused in the Pcode segment.
	       0000
	      ]
				                              ; (End of original Pcode.)
 000A  0000			      UpPool Segp ?   ; When segment is a pool. (Also used as chain of free ones)
 000C  0000			      Probe Ushort ?  ; Place to start search if this is a lookup type segment.
 000E	      0000 [		      TreeProg Ushort Overlay ; Field reused as root for source file names lookup.
	       0000
	      ]
 000E  0000			      Labels Ushort ? ; Alternative needed since label and constant trees same seg.
				     Hshape ends
 = 0010				     $StrideH equ size Hshape
				     ; H. is for Hshape objects addressed by [si]; Headers on segments (si=0).
 = (Hshape ptr[si])		     H is <(Hshape ptr[si])>
				     ; Hd. is for Hshape objects addressed by ds:; Headers on segments.
 = (Hshape ptr ds:[0])		     Hd is <(Hshape ptr ds:[0])>
				     ; He. is for Hshape objects addressed by es:[bp]; Headers on segments.
 = (Hshape ptr es:[bp])		     He is <(Hshape ptr es:[bp])>
				     ; Hf. is for Hshape objects addressed by fs:[bp]; Headers on segments.
 = (Hshape ptr fs:[bp])		     Hf is <(Hshape ptr fs:[bp])>
				     ; Hg. is for Hshape objects addressed by gs:[bp]; Headers on segments.
 = (Hshape ptr gs:[bp])		     Hg is <(Hshape ptr gs:[bp])>

				     ; Zshape is resized by StackSafe, not by MoreSpaceEs, so doesn't need all
				     ; the Hshape header. It does need SegSize in correct location though because
				     ; Compaction treats it like a headed segment.
 137C				     Zshape struc
 0000	      0000 [		      w word Overlay       ; Not used in this position - always used like Z.w[index]
	       0000
	      ]
 0000  0000			      SegSize word ?       ; Bytes.
 0002	      0000 [		      ProgramCancel dword Overlay; Used for zeroing.
	       00000000
	      ]
 0002  0000			      Program ProgramRec <>; Program flags
 0004  0000			      Cancel CancelRec <>  ; Flags for transient logic.
 0006  0000			      Stack word ? ; Current variable for Compaction. (Top of soft stack-$StrideV)
 0008  0000			      ClauseLine Ushort ?  ; Line this clause starts on. (First token)
 000A  0000			      Middles MiddleRec <> ; Extension of Clause. Keep with Clause for zeroing.
 000C  0000			      Clause ClauseRec <>  ; Compile time clause flags
 000E  0000			      Gen GenRec <>        ; Flags for control of what gets compiled.
 0010  0000			      KWMiddle charp ?     ; List of search keywords.
 0012  0000			      KWFound Ushort ?     ; Latest keyword found.
 0014  0000			      Stdout Handle ?      ; A constant but potential redirection.
 0016  0000			      Stderr Handle ?      ; A constant but potential redirection.
 0018  0000			      SourceHandle Handle ?
 001A  0000			      HowInvoked Ushort ?  ; Length of COMMAND/FUNCTION/SUBROUTINE.
 001C  00			      Radix byte ?         ; Normally has value 10.
 001D	      0006 [		      AxAsNum char 6 dup(?); For result of Ax2DsSiCx
	       00
	      ]
 0023	      0005 [		      Tag char 5 dup(?)    ; For trace. Joined to AxAsNum
	       00
	      ]
 0028  00000000			      Seed dword ?         ; For Random bif.
 002C  0000			      ParseResetSp charp ? ; Where the parser started work on the hard stack.
 002E  0000			      XCycleResetSp charp ?; Where the execution started work on the hard stack.
 0030  0000			      Dumper word ?        ; Handle when we are writing Pcode to disk.
 0032  0000			      Stash word ?         ; Various
 0034  0000			      Resolved charp ?     ; Result of Lookup.
 0036  0000			      Cursor charp ?       ; Offset into code. (Compile time)
 0038  0000			      Stream charp ?       ; The current stream.  In SysFiles segment.
 003A  0000			      Queue  charp ?       ; The FileBx for CRXREXX.QUE in SysFiles segment.
				     ; Compaction exploits these Segp things being adjacent.
 003C	      0000 [		      InsSource dword Overlay
	       00000000
	      ]
 003C	      0000 [		      SysFile dword Overlay
	       00000000
	      ]
 003C  0000			      File charp ?         ; Current external file of source.
 003E  0000			      SysFiles Segp ?      ; DOS interface
 0040  0000			      Consts Segp ?        ; To an array, fixed size per constant.
 0042  0000			      Vars Segp ?          ; To an array, fixed size per variable.
 0044  0000			      ProgScope Segp ?     ; Shadow of Consts. Order is exploited, see MoreSpaceEs.
 0046  0000			      VarScope Segp ?      ; Shadow of Vars.
 0048  0000			      Symbols Segp ?       ; To a write-once for names and constants.
 004A  0000			      Code Segp ?          ; To the internal code.
 004C  0000			      Zone Segp ?          ; Convenient place for Compaction to find address.
				     ; End of section organised for Compaction.
 004E  0000			      Stem Segp ?          ; Used when a stem wants MoreSpaceEs.
 0050  0000			      PoolPool Segp ?      ; Spare VarScope copies.
 0052  0000			      Level charp ?        ; Latest level of invocation.
 0054  0000			      Base0 charp ?        ; Parser time, for checking how many operands pushed.
 0056  0000			      CurrentDO charp ?    ; Junction of DO blocks and stacked values.
 0058  0000			      ResumeP word ?       ; Save Pcode address while Bcode execution.
 005A	      0000 [		      ResumeDF dword Overlay
	       00000000
	      ]
 005A  0000			      ResumeD word ?       ; Digits() preserved over Bcode execution.
 005C  0000			      ResumeF word ?       ; Fuzz() preserved over Bcode execution.
 005E  00			      ResumeS char ?       ; S/E mode preserved over Bcode execution.
				     ; Section set by ZoneNumerics.  (cf NotS9)
 005F	      0000 [		      DigitsFuzz dword Overlay
	       00000000
	      ]
 005F  0000			      Digits Ushort ?      ; Current digits().
 0061  0000			      Fuzz Ushort ?        ; Current fuzz().
 0063  00000000			      Ceiling dword ?      ; 1eN where N is current digits().
 0067  00000000			      DivBreak dword ?     ; To test for enough digits made in division.
 006B  00000000			      TwiceDigits dword ?  ; 2*N where N is current digits().
 006F  0000			      UseGeneral Ushort ?  ; On for mandatory use of ArithGeneral
				     ; end section set by ZoneNumerics.
				     ; Inserts for messages are divided into (a) those that stay constant or which
				     ; we always want to set when compiling, and (b) those that might be undesirably
				     ; changed when we rescan during execution to find the line number for a message.
				     ; The latter are in a block for save/restore.
				     ; "Ins..." is used as help to identify.
 0071  0000			      InsLine Ushort ?     ; Value for insert
 0073  00			      InsBif byte ?        ; Bif offset.
 0074  00000000			      InsOperator dword ?  ; Actual chars.
 0078  0000			      InsUnqual charp ?    ; Offset in SysFiles. For <source> insert, msg 43.1
 007A	      0000 [		      Insert InsBlock <>   ; For message. The saved copy is Inserts.
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 008F	      0000 [		      Inserts InsBlock <>
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 00A4  00			      SignM byte ?         ; Of mantissa
 00A5  00			      SignE byte ?         ; Of exponent
 00A6  0000			      MantPos charp ?      ; Where mantissa starts.
 00A8  0000			      MantPosZi charp ?    ; Beyond end
 00AA  0000			      ExpPos charp ?       ; Where exponent starts.
 00AC  0000			      ExpPosZi charp ?     ; Beyond end
 00AE  0000			      ExpSign word ?
 00B0  0000			      MantSize word ?
 00B2  00			      OpIs byte ?          ; Remembers operator in execution of it.
 00B3  00			      Flags byte ?         ; In BifTypes
 00B4  00			      BifParmsHi byte ?    ; For Bifs to test how many parameters on instance.
 00B5  00			      BifByte byte ?       ; Combines bif number and a parms count.
				     ; Trace section
 00B6  00000000			      TraceAlign dword ?; Beginning of line of source as offset on source file.
 00BA  00000000			      TraceSource dword ?; Beginning of section of source to be shown.
 00BE  00000000			      TraceEnds dword ?; End of section of source to be shown.
 00C2  0000			      TraceSourceColumn word ?
 00C4  0000			      TraceEndsColumn word ?
 00C6  0000			      DualCode charp ?; Beginning of Pcode for one clause.
 00C8  00			      TraceOp byte ?   ; Trace info for current Pcode operation.
 00C9  00000000			      Relative dword ?; Adjustment between position on file and position in buffer.
 00CD  00000000			      RelativeNow dword ?; Used when Serial contains section of source.
 00D1  0000			      Continue word ?; Pcode offset of next clause.
 00D3  0000			      StackX word ?; Hold StackDi over parsing.
 00D5  0000			      TraceLine word ?; Last shown ClauseLine.
 00D7  00000000			      InhibitTrace dword ?
 00DB  00000000			      InhibitPauses dword ?
 00DF  0000			      Target word ?; Used to carry branch value from original pcode to dual.
				     ; Trace section end
				     ; Main also [ Tokens
 00E1  0000			        Scanp charp ?        ; Where the scan has reached. Zero when executing.
 00E3  0000			        EndUsedBuffer charp ?; Where marker to interrupt scan is placed.
 00E5  0000			        NearEnd charp ?      ; Towards end of buffer.
				     ;]
 00E7  00			        CatOp byte ?         ; $pCat or $pAbut
 00E8  00			        RadixBadWhite byte ?
 00E9  0000			        BackExponent charp ?
 00EB  0000			        LastContent charp ?
 00ED  0000			        CommaLine word ?; NonZero if previous line ended with non-continuation comma.
 00EF  0000			        Condition Ushort ?   ; Latest condition keyword.
 00F1  0000			        UntilPlace Ushort ?  ; Place in Pcode. Held just over UNTIL expression.
 00F3  0000			        StemSym charp ?      ; Temp for A.B.C type Lookup
 00F5  0000			        SoFar word ?         ; Temp for A.B.C type Lookup
 00F7  0000			        PcodePos word ?      ; Used by ConstValue
 00F9  0000			        TraceOnly word ?     ; Used to detect 'trace only' labels.
 00FB  0000			      CompareAt word ?       ; For detecting compare Pcode optimizing.
 00FD  0000			      StackHi charp ?        ; Used for compound lookup.
 00FF  0000			      StackLo charp ?        ; Also for function arguments.
 0101  0000			      OnSoft charp ?         ; Where stacked target symbols start. PARSE compiletime.
				                             ; Tokens tells Pcode.
 0103  0000			      Tail charp ?           ; Work when Pcode made for tailed.
 0105  0000			      TokNum word ?          ; As tokenizer makes, parser sees.
 0107  0000			      TokNow word ?
 0109  0000			      TokWas word ?
 010B  0000			        TokData word ?       ; Data for parser derived from TokNum
 010D  0000			        Synch charp ?        ; Instruction pointer, into Pcode, for synching.
 010F  0000			        Lines Ushort ?       ; Count of lines
 0111  0000			        MsgBegin charp ?     ; Where sub-messages concatenated.
 0113  0000			        MsgSoFar charp ?     ; As sub-messages concatenated.
 0115  0000			        PreZi charp ?        ; End of message before expanding insertions.
 0117	      0000 [		        TargetMajMin word Overlay; This is message being output.
	       0000
	      ]
 0117  00			         TargetMinor byte ?
 0118  00			         TargetMajor byte ?
				        struc                ; See DOS command 4Bh
 0119  0000			         EnvSeg Segp ?
 011B  0000 0000		         ForPSP Farp <>
 011F  0000 0000		         Fcb1 Farp <>
 0123  0000 0000		         Fcb2 Farp <>
				        ends
 0127  0000			        AtPause charp ?       ; NYI
 0129  00			        ArgsB byte ?; For Arg() of BCycle bif.
 012A  0000			        ArgsB0 charp ?; For Arg(exp) of BCycle bif.
				     ; Workspace for the verbs can be shared.
				        struct; For Parse
 012C	      0000 [		         Parsee FarpX <>
	       00000000
	      ] 0000 0000
	      0000 [
	       0000
	      ] 0000
 0132  0000			         ParseeNum Ushort ?; Counts arguments for commas in parsing template.
 0134  0000			         PattLenEtc Ushort ?  ; Length of pattern. Temp for cursor.
 0136  0000			         BreakStart charp ?; Beginning of previous section delimiter.
 0138  0000			         BreakEnd charp ?  ; End of previous section delimiter.
				        ends
 013A  0000 0000 0000 0000	        EnvNow EnvBlock <> ; Used to execute ADDRESS
 0142  0000			      CatTotal word ?      ; Used by Abut$$ & Cat$$
 0144  0000			      LastTarget word ?    ; For detecting when to make $pUnstore.
 0146  0000			      NewJshape charp ?    ; Used by FindKey.
 0148  0000			      FromDos charp ?; A slot addressing a segment DOS gave us. (Cat optim. uses)
 014A  0000			      FromDosWas word ?; To test for cycled through them.
 014C  0000			      FromDosZi charp ?; Bound for FromDos
 014E	      000A [		      MemoryTable Ashape $Ashapes dup(<>)
	       0000 0000 0000
	      ]
 018A	      0000 [		      MemoryTableZi byte Overlay; Just used as an offset.
	       00
	      ]
 018A  0000			      Left charp ?     ; For compaction.
 018C  0000			      Right charp ?    ; For compaction.
 018E  00000000			      AllocBase dword ?; For compaction.
				     ; Grouping matters here.
 0192  0000			      DsWas Segp ?
 0194  0000			      DsNew Segp ?
 0196  0000			      EsWas Segp ?
 0198  0000			      EsNew Segp ?     ; Sometimes reloaded from.
 019A  0000			      FsWas Segp ?
 019C  0000			      FsNew Segp ?
 019E  0000			      GsWas Segp ?
 01A0  0000			      GsNew Segp ?
				     if Debug
 01A2  0000			      DebugStash word ?
 01A4  00000000			      DebugD dword ?
				     endif
 01A8  0000			      DigitCount Ushort ?  ; Checking radix string, Compile and execute.
				     ; Byte before Serial better not accidentally look like $Eof.
 01AA  00			      SerialNow byte ? ; Indicates what is in Serial.
 01AB	      11C8 [		      Serial char $SourceBufferSize dup(?)
	       00
	      ]
				      align 4
 1374	      0007 [		      CommandArg Vshape <>; Parameters from Command line.
	       00
	      ] 00
				     Zshape ends
				     ; Z. is for Zshape objects addressed by [bp]; the Zone
 = (Zshape ptr[bp])		     Z is <(Zshape ptr[bp])>

 0053				     Yshape struc
 0000  00000000			      dword ?; Overlays jmp.
 0004  00000001			      N1 dword 1
 0008  0000000A			      N10 dword 10
 000C  00000064			      N100 dword 100
 0010  000003E8			      N1000 dword 1000
 0014  00002710			      N1e4 dword 10000
 0018  000186A0			      N1e5 dword 100000
 001C  000F4240			      N1e6  dword 1000000
 0020  00989680			      N1e7 dword 10000000
 0024  05F5E100			      N1e8 dword 100000000
 0028  3B9ACA00			      N1e9 dword 1000000000
 002C  0019660D			      N1664525 dword 1664525; For Random
				      Assert $Limit_ExponentDigits eq 9
 0030  3B9AA2F1			      ExponHi dword 1000000000-$Limit_Digits
 0034  C4653602			      ExponLo dword -1000000000+2
 0038  0000			      Cseg Segp ?          ; To be where the machine code is.
 003A	      0000 [		      DOS dword Overlay; Default ADDRESS
	       00000000
	      ]
 003A	      0001 [		       db "DOS "
	       44 4F 53 20
	      ]
 003E	      0001 [		      DosPool db "ENVIRONMENT"; Pool name
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
 0049	      0001 [		       db "..."; Joined to following CrLf
	       2E 2E 2E
	      ]
 004C  22			      DqCrLf db '"'
 004D  0D 0A			      CrLf db 13,10
 004F  0000 0000		      StackSave Farp <>    ; To recover when only CS:IP survives.
				     Yshape ends
				     ; Y. is for Yshape objects addressed by [bp]; the constants.
 = (Yshape ptr cs:[bp])		     Y is <(Yshape ptr cs:[bp])>
 = (Yshape ptr cs:[2*ecx+ebp])	     Ycx2 is <(Yshape ptr cs:[2*ecx+ebp])>
 = (Yshape ptr cs:[si])		     Ysi is <(Yshape ptr cs:[si])>

				     ; These equs should follow the declares of shapes they depend on.
 = 0014				     $SizeConstsHeader equ $StrideH+4
				     ; Configuration variables (used by the implementation but not seen by the user's
				     ; program) are in the order the utility that makes Bcode has numbered them. The
				     ; $Reserved string matches.
				     ; Also constants & reserved variables that are always in ProgScope area.
 = 0014				     $?Omitted equ $SizeConstsHeader
 = 001C				     $?MN equ $?Omitted+$StrideV
 = 0024				     $?RS equ $?MN+$StrideV
 = 002C				     $?RESULT equ $?RS+$StrideV
 = 0034				     $?RC equ $?RESULT+$StrideV
 = 003C				     $?SIGL equ $?RC+$StrideV
 = 0044				     $?SysVars equ $?SIGL+$StrideV
				     ; See $Reserved for number of vars here.
 = 000B				     $SysCount equ 11
 = 0000				     ?OUTCOME equ 0; These are the numbers used in Bcode references.
 = 0044				     $?OUTCOME equ $?SysVars; These are the offsets used in machine code references.
				     ; ie where the system variables are in the ProgScope segment.
 = 0002				     ?BIF equ 2
 = 004C				     $?BIF equ $?SysVars+$StrideV
 = 0004				     ?STREAM equ 4
 = 0054				     $?STREAM equ $?SysVars+2*$StrideV
 = 0006				     ?STREAMSTATE equ 6
 = 005C				     $?STREAMSTATE equ $?SysVars+3*$StrideV
 = 0008				     ?RESPONSE equ 8
 = 0064				     $?RESPONSE equ $?SysVars+4*$StrideV
 = 000A				     ?LINEIN_POSITION equ 10
 = 006C				     $?LINEIN_POSITION equ $?SysVars+5*$StrideV
 = 000C				     ?CLAUSETIME equ 12
 = 0074				     $?CLAUSETIME equ $?SysVars+6*$StrideV
 = 000E				     ?CLAUSELOCAL equ 14
 = 007C				     $?CLAUSELOCAL equ $?SysVars+7*$StrideV
 = 0010				     ?MONTHS equ 16
 = 0084				     $?MONTHS equ $?SysVars+8*$StrideV
 = 0012				     ?WEEKDAYS equ 18
 = 008C				     $?WEEKDAYS equ $?SysVars+9*$StrideV
 = 0014				     ?STARTTIME equ 20
 = 0094				     $?STARTTIME equ $?SysVars+10*$StrideV
 = 009C				     $?Nine equ $?SysVars+11*$StrideV
 = 00A4				     $?Zero equ $?Nine+$StrideV
 = 00AC				     $?Null equ $?Zero+$StrideV
 = 00B4				     $?E equ $?Null+$StrideV
 = 00BC				     $?S equ $?E+$StrideV
				     ; These are variables that are always in current VarScope area.
 = 0010				     $?Discard equ $StrideH; Takes two because ends in dot.
 = 0020				     $?RESULTx equ $?Discard+2*$StrideV
 = 0028				     $?RCx equ $?RESULTx+$StrideV
 = 0030				     $?SIGLx equ $?RCx+$StrideV
				     ; Not in the table, but we need to use some character as an end-used-buffer
				     ; mark. (Saves checking address repeatedly) Using Linefeed helps comment scan.
 = 000A				     $EndBuffer equ $Lf
 = 0000				     $Whole     equ 0
 = 0004				     $WholeGE   equ 4
 = 0008				     $WholeGT   equ 8
 = 000C				     $Num       equ 12
 = 0010				     $M090      equ 16
 = 0014				     $WholeNum  equ 20
 = 0018				     $Pad       equ 24
 = 001C				     $Hex       equ 28
 = 0020				     $Stream    equ 32
 = 0024				     $Bin       equ 36
 = 0028				     $Symbol    equ 40

				     AllocAppend macro Goes:req
				      push si
				      mov si,Z.FromDos; The current allocation source.
				      mov ax,A.Fr.Pt
				      sub ax,V.Len
				      cmp ax,V.Pt
				      jne Goes
				     ; Here if offset fits. Also need to check same segment.
				      mov ax,V.Sg
				      cmp ax,A.Fr.Sg
				      jne Goes
				      mov es,ax
				     ; The segment could be full, but if possible take the extra.
				      mov ax,V.Pt
				      add ax,cx
				      jc Goes
				      cmp ax,A.Amount
				      ja Goes
				      mov A.Fr.Pt,ax
				      sub ax,cx
				      mov V.Len,cx
				      endm
				     ; Here are the numbers which go in the Attributes table.
				     ; Most of this is just for compiling but some equates are relevant to
				     ; execution so those have been put in declares.inc
				     ; First two bits for quick test of Whitespace, Letter, Digit, Special
				     ; $White equ 0 $Digit equ 64 $Letter equ 128 $Special equ 192
				     ; When it is not Special, the remaining bits can be flags.
				     ; When it is Special, there is a switch indexed by the rest of the byte.
				     ; This corresponds to the right six bits of TokVal so we can test in groups.
				     ; In practice it is "+ or -" that gets tested this way.
 = 00FC				      $Group equ 0FCh
 = $AttribPlus and $Group	      $PlusMinus equ $AttribPlus and $Group
				     ; The bits to the right of $White are free, and we could distinquish the
				     ; reak blank from blank equivalents but there seems no reason to do so.
				     ; We are short of a bit for letters. It would be nice to have flags for
				     ; conveniently testing "Ee", "Xx", "Bb", "01", ok as hex digit, having upper
				     ; case, and real-letter, as well as $Letter for the purposes of a symbol.
				     ; Something has to be left out, and real-letter would only be used in
				     ; DATATYPE().
				     ; We are short of a bit for digits. It is highly desirable to be able to scan
				     ; a number using lods and not have to refer to the value before xlat (since
				     ; xlat overwrites al). So we would like to have the value of the digit in the
				     ; low order of the attribute, as opposed to subtracting character '0' from the
				     ; raw character. That leaves two, which gives us difficulty if we want
				     ; OK-for-radix-B, OK-for-radix-X, and a Lower-case-letter. (Since we would
				     ; like to test the latter in the symbol recognition loop without distinquishing
				     ; letter/digit first.)
				     ; The solution seems to be to invert the lowercase flag. Then with blanks and
				     ; specials out of the way (jpe), the upperableness can be tested as zeroness
				     ; of Digit flag and NonUpable flag, together.
				     ; So the scheme for Letter-or-Digit is to make the right nibble dependent on
				     ; whether letter or digit, leaving two bits for OK-for-radix.
 = 0020				      $OKb equ 32
 = 0010				      $OKx equ 16
				     ; For letters:
				     ; $NonUpable equ 8 $Bb equ 4 $Xx equ 2 $Ee equ 1
				     ; $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; These values above $STRING go through switching like specials but are not
				     ; seen by the parser.
 = 0027				     $LineFeed equ $Eq-4
 = 0009				     $Invalid equ $UnAccept+1
 = 000A				     $Colon equ $UnAccept+2
 = 00D8				     $AttribAnd equ $Special+$And
 = 00D5				     $AttribOr equ $Special+$Or
 = 00EB				     $AttribEq equ $Special+$Eq
 = 00E4				     $AttribMinus equ $Special+$Minus
 = 00ED				     $AttribLt equ $Special+$Lt
 = 00F0				     $AttribGt equ $Special+$Gt
 = 00D2				     $AttribSlash equ $Special+$Slash
 = 00DC				     $AttribComma equ $Special+$Comma
 = 00E7				     $AttribLine equ $Special+$LineFeed
 = 00E5				     $AttribPlus equ $Special+$Plus
 = 00D1				     $AttribStar equ $Special+$Asterisk
 = 00FF				     $NoMatch equ $Special+63; No character has these attributes.

				     MyGroup GROUP _TEXT, BifSeg
 0000				     BifSeg SEGMENT WORD PUBLIC 'CODE'
 0000  089A R			      dw BifFORM
 0002  0388 R			      dw BifDATATYPE
 0004  07B9 R			      dw BifADDRESS
 0006  07D4 R			      dw BifARG
 0008  085F R			      dw BifCONDITION
 000A  08F9 R			      dw BifTRACE
 000C  08C1 R			      dw BifFUZZ
 000E  0888 R			      dw BifDIGITS
 0010  08C8 R			      dw BifSOURCELINE
 0012  0757 R			      dw BifXRANGE
 0014  0A14 R			      dw BifRANDOM
 0016  0596 R			      dw BifREVERSE
 0018  0788 R			      dw BifABS
 001A  0792 R			      dw BifSIGN
 001C  0000 E			      dw BifC2X
 001E  0000 E			      dw BifB2X
 0020  0000 E			      dw BifX2B
 0022  0000 E			      dw BifX2C
 0024  0000 E			      dw BifX2D
 0026  0000 E			      dw BifC2D
 0028  0000 E			      dw BifD2C
 002A  0000 E			      dw BifD2X
 002C  0000 E			      dw BifBITAND
 002E  0000 E			      dw BifBITOR
 0030  0000 E			      dw BifBITXOR
 0032  0BA0 R			      dw BifVALUE
 0034  0333 R			      dw BifCOPIES
 0036  0702 R			      dw BifWORD
 0038  0711 R			      dw BifWORDINDEX
 003A  0674 R			      dw BifSUBWORD
 003C  0549 R			      dw BifPOS
 003E  050C R			      dw BifLEFT
 0040  05C8 R			      dw BifSUBSTR
				     ; Things which can't fail on argument type can be given simpler treatment.
				     ;Some of these can use same Pcode point because number of args will distinquish.
				     ; They need a bif number only so that messages can invert it to the name.
				     ; Need specials high values. FORMAT with 5 args is special.
				     ; Need these higher values than others.
 0042  09CF R			      dw BifQUEUED
 0044  0AD6 R			      dw BifSYMBOL
 0046  0000 E			      dw BifCOUNTSTR
 0048  0000 E			      dw BifCHANGESTR
 004A  0C72 R			      dw BifLENGTH
 004C  0000 E			      dw BifMAX
 004E  0000 E			      dw BifMIN
 0000				     BifSeg ENDS

				      PUBLIC BifNames; Used by messages to convert from bif number.
				      PUBLIC Bifs; For lookup of spellings.
				      PUBLIC BifGroup$$
				      PUBLIC Bif$$
				      PUBLIC Max$$
				      PUBLIC Min$$
				      PUBLIC Length$$
				      PUBLIC Bifq$$
				      PUBLIC Trace$$
				      PUBLIC BifCHARIN, BifCHAROUT, BifSTREAM

				      PUBLIC AfterCheck
				      PUBLIC PcodeBif
				      EXTERN B4VALUE1:near
				      EXTERN B4VALUE2:near

				      EXTERN Raise40p11:near
				      EXTERN Raise40p32:near
				      EXTERN Raise40p33:near
				      EXTERN Raise40:near

				      EXTERN BifCOUNTSTR:near
				      EXTERN BifCHANGESTR:near
				      EXTERN BifMAX:near
				      EXTERN BifMIN:near
				      EXTERN BifX2B:near; !! could be avoided.
				      EXTERN BifD2X:near; !! could be avoided.
 EXTERN BifC2X:near; !! could be avoided.
				      EXTERN BifB2X:near; !! could be avoided.
				      EXTERN BifX2C:near; !! could be avoided.
				      EXTERN BifX2D:near; !! could be avoided.
				      EXTERN BifC2D:near; !! could be avoided.
				      EXTERN BifD2C:near; !! could be avoided.
				      EXTERN BifBITAND:near; !! could be avoided.
				      EXTERN BifBITOR:near; !! could be avoided.
				      EXTERN BifBITXOR:near; !! could be avoided.

				      EXTERN UpperFirstAh:near
				      EXTERN Bswitch:near
 = 003F				     $BifSpecial equ $BifQUEUED
				     ;------------------------------------------------------------------------------
				     ; Make Pcode for a Bif.
				     ;------------------------------------------------------------------------------
 0000				     PcodeBif:; Here is Bif checking/generation.
				     ; StackDx and StackDi come as the lo:hi bounds of parameters to be consumed.
				     ; ParmsCl, Z.StackLo, Z.Stack are also set.
 0000   1   8B FA		      mov StackDi,StackDx; StackDi to below leftmost arg.
				     ; bx will address the checking data. $9.2.1
 0002   1   88 5E 73		      mov Z.InsBif,bl
 0005   1   03 DB		      add bx,bx
 0007   1   2E: 8B 9F 0000 E	      mov SpecsBx,Wptr(Bswitch)[bx]
 000C   1   88 8E 00B4		      mov Z.BifParmsHi,ParmsCl
				     ; The byte before the label has the data we want.
 = dl				     BoundsDl is <dl>;
 0010   1   4B			      dec SpecsBx
 0011   1   8A 17		      mov BoundsDl,[SpecsBx]
				     ; Isolate limits.
 = ah				     MinAh is <ah>;
 = al				     MaxAl is <al>;
 0013   1   8A E2		      mov MinAh,BoundsDl
 0015   2   C0 EC 06		      shr MinAh,ParmsMin
 0018   1   8A C2		      mov MaxAl,BoundsDl
 001A   1   24 30		      and MaxAl,mask ParmsXtr
 001C   2   C0 E8 04		      shr MaxAl,ParmsXtr
 001F   1   02 C4		      add MaxAl,MinAh
				     ; Usually the Pcode second byte will show BifNum and number of (optional) args.
				     ; Special cases are MAX MIN & FORMAT
 0021   2   80 7E 73 11		      cmp Z.InsBif,$BifFORMAT
 0025  3,1  75 03		      jne @F
 0027   1   B8 0105		      mov ax,MkMajMin(1,5)
 002A				      @@:
				     ; 255 equals infinity because of $MaxParms
 002A   1   80 FA F0		      cmp BoundsDl,(3 shl ParmsMin + 3 shl ParmsXtr)
 002D  3,1  72 03		      jb @F
 002F   1   B8 01FF		      mov ax,MkMajMin(1,255)
 0032				      @@:
 0032   1   8A F1		      mov dh,ParmsCl
 0034   1   2A F4		      sub dh,MinAh
 0036   2   C0 E6 06		      shl dh,6
 0039   2   02 76 73		      add dh,Z.InsBif
 003C   3   D0 C6		      rol dh,1
 003E   1   88 B6 00B5		      mov Z.BifByte,dh
 = dl				     ErrDl is <dl>;
 0042   1   B2 04		      mov ErrDl,$n40p3; Possible error
 0044   1   88 A6 0082		      mov Z.Insert.ArgNum,MinAh
 0048   1   38 E1		      cmp ParmsCl,MinAh
 004A  3,1  72 59		      jb DelayedRaise
 004C   1   B2 06		      mov ErrDl,$n40p4
 004E   1   88 86 0082		      mov Z.Insert.ArgNum,MaxAl
 0052   1   38 C1		      cmp ParmsCl,MaxAl
 0054  3,1  77 4F		      ja DelayedRaise
				     ; The ARG() count is good but that can include omitted arguments.
				     ; x=arg(,'E') is not allowed.
 0056   2   80 7E 73 21		      cmp Z.InsBif,$BifARG
 005A  3,1  75 07		      jne @F
 005C   1   80 F9 02		      cmp ParmsCl,2
 005F  3,1  75 02		      jne @F
 0061   1   FE C4		      inc MinAh
 0063				      @@:
 0063   1   B2 08		      mov ErrDl,$n40p5
 0065   3   EB 0F		      jmp TestOmitted
 0067   1   FE C5		     @@:inc ch
 0069   1   88 AE 0082		      mov Z.Insert.ArgNum,ch
				      Up
 006D   1   83 C7 08		  1   add StackDi,$StrideV
 0070   3   80 7B 07 88		      cmp V.Dtype,$Omitted
 0074  3,1  74 2F		      je DelayedRaise
 0076   1   38 E5		     TestOmitted:cmp ch,MinAh
 0078  3,1  75 ED		      jne @B
				     ; The presence/absence of arguments is OK, but they may not be the right types.
 007A   1   8B BE 00FF		      mov StackDi,Z.StackLo
 007E   1   8B 56 06		      mov StackDx,Z.Stack; Hi end
				     ; There are some special bifs for which type testing isn't relevant.
 0081   1   8A 46 73		      mov al,Z.InsBif
				     ; FORMAT with 5 parameters is special.
 0084   1   80 F9 05		      cmp ParmsCl,5
 0087  3,1  75 04		      jne @F
 0089   1   3C 11		      cmp al,$BifFORMAT
 008B  3,1  74 13		      je BifGroup
 008D				      @@:
 008D   1   3C 3F		      cmp al,$BifSpecial
 008F  3,1  72 1B		      jb BifPlain
				     ; LENGTH MAX MIN have their own Pcodes.
 0091   1   2C 43		      sub al,$BifLENGTH
 0093  3,1  72 0B		      jb BifGroup
 0095  3,1  74 04		      jz @F
				     ; MAX & MIN need the (excess) parameter count.
 0097   1   FE C9		      dec ParmsCl
 0099   1   02 C0		      add al,al
 009B   1   04 2D		     @@:add al,$pLength
 009D   3   E9 0000 E		      jmp PcodeOp

				     ; QUEUE etc initially use the same runtime; number of parameters distinquishes.
 00A0				     BifGroup:OpRet $pBifGroup
 00A0   1   B0 AD		  1    mov al,$pBifGroup
 00A2   3   E9 0000 E		  1    jmp PcodeOp

				     ; Put $pRaise and error code. Parsing will recover what more a message needs.
 00A5   1   8A CA		     DelayedRaise:mov OpAppendCl,ErrDl
				     OpRet $pRaise
 00A7   1   B0 AF		  1    mov al,$pRaise
 00A9   3   E9 0000 E		  1    jmp PcodeOp


 00AC				     BifPlain:
				     ; Bifs that can set the NotReady condition need a check at the end of the clause
				     ; to see if it happened.  Set a flag now and compile a $pNop at end-of-clause.
 00AC   1   3C 08		      cmp al,$BifSTREAM
 00AE  3,1  77 04		      ja @F
				      On Z.Middles,EndClause
 00B0   3   80 4E 0B 02		  1          or  Bptr(Z.Middles+1), high ??0000
 00B4				      @@:
				     ; BifTypes expects StackDi,StackDx,SpecsBx. StackDi below 1st, StackDx at last.
 00B4   3   E8 0162		      call BifTypes
				     ; Here when BifTypes has been used at compile time.
				     ; If all types were checked good, because they are consts, the faster form
				     ; of Pcode can be used.
				     ; Soft stack left with the parameters removed. Function action adds result.
 00B7   1   B0 AB		      mov al,$pBif
 00B9   1   8A 8E 00B5		      mov cl,Z.BifByte
				     ; If any check failed, use $pBif which does tests at run time.
 00BD   8   0F BA 76 02 0A	      btr Z.Program,BifCheck
 00C2  3,1  72 02		      jc @F
 00C4   1   B0 2B		      mov al,$pBifq
 00C6				      @@:
				     if ForBcode
				     endif
 00C6   3   E9 0000 E		      jmp PcodeOp


				     if Solid
 00C9				     WhichCheck:
				     ; Minor msg number. Letter for DataType
				     ; Difference of Whole and WholeNum is only in the conversion, not the test.
				     ; The DATATYPE bif uses 'N' and 'W', which convert at current precision.
				     ; CheckArgs needs a similar test, but with bif precision. Detect that
				     ; as zero datatype.
				     ; WholeGE needs to complain about wholeness in preference to about GE.
				     Assert $Whole     eq $-WhichCheck
 00C9  0C 20			     db 12,' '
 00CB  00FF R			     dw AnyRet
				     Assert $WholeGE   eq $-WhichCheck
 00CD  0C 20			     db 12,' '
 00CF  010B R			     dw WholeGE$
				     Assert $WholeGT   eq $-WhichCheck
 00D1  0C 20			     db 12,' '
 00D3  0100 R			     dw WholeGT$
				     Assert $Num       eq $-WhichCheck
 00D5  0B 4E			     db 11,'N'
 00D7  00FF R			     dw AnyRet
				     Assert $M090      eq $-WhichCheck
 00D9  11 4E			     db 17,'N'
 00DB  0115 R			     dw M090$
				     Assert $WholeNum  eq $-WhichCheck
 00DD  0C 57			     db 12,'W'
 00DF  0118 R			     dw WholeNum$
				     ; Pad is distinctive in not needing a DataType test. Internally nop.
				     Assert $Pad       eq $-WhichCheck
 00E1  17 24			     db 23,'$'
 00E3  00F5 R			     dw Pad$
				     Assert $Hex       eq $-WhichCheck
 00E5  19 58			     db 25,'X'
 00E7  00FF R			     dw AnyRet
				     ; The DATATYPE bif doesn't have Stream test. Internally we add one.
				     Assert $Stream    eq $-WhichCheck
 00E9  1B 5A			     db 27,'Z'
 00EB  00FF R			     dw AnyRet
				     Assert $Bin       eq $-WhichCheck
 00ED  18 42			     db 24,'B'
 00EF  00FF R			     dw AnyRet
				     Assert $Symbol    eq $-WhichCheck
 00F1  1A 53			     db 26,'S'
 00F3  00FF R			     dw AnyRet
				     endif

				     ; Pads have to be length one.
 00F5   3   E8 0000 E		     Pad$:call ToDsSiCx
 00F8   1   83 F9 01		     cmp cx,1
 00FB  3,1  0F 85 00B8		     jne Failed
 00FF   5   C3			     AnyRet:ret

 0100				     WholeGT$:; If we got this far it was a whole number. (Else was msg 40.12)
 0100   1   B0 0E		      mov al,14
 0102   3   66| 39 6B 04	      cmp V.Mantissa,ebp
 0106  3,1  75 05		      jne @F
 0108   3   E9 00AC		      jmp Failed

 010B   1   B0 0D		     WholeGE$:mov al,13
 010D   2   F6 03 01		     @@:test V.Sign,1
 0110  3,1  0F 85 00A3		     jnz Failed
 0114   5   C3			     ret

 0115   1   B0 11		     M090$:mov al,17
				     ; If we tested here we would be able to put constants right a compile time,
				     ; eg 41.10 => 41.1
				     ; However, it seems easier to put the algorithm in Rexx.
				     ; Fail on negative.
				     ; Convert to string.
				     ; Fail if 'E'
				     ; Split at dot.
				     ; Fail major > 90
				     ; Kill trailing zeroes on minor
				     ; Fail first digit of minor 9 unless only digit.
 0117   5   C3			      ret

 0118				     WholeNum$:
				     ; What is this test ?? Only runtime use of ParmsHi?
 0118   2   80 BE 00B4 02	      cmp Z.BifParmsHi,2
 011D  3,1  72 0B		      jb @F
				     ; !! what if too many digits for binary.
 011F   3   F6 43 07 80		      test Bptr(V.Mantissa+3),80h
 0123  3,1  74 05		      jz @F
 0125   1   B0 0D		      mov al,13
 0127   3   E9 008D		      jmp Failed
 012A   5   C3			     @@:ret

				     ; Maybe better code here if list of letters had been reversed but that would
				     ; make producing <options> in a message harder.
				     ; al holds negative of the length of the letter sequence.
				     ; Trace is a special case - any number of leading question marks.
 012B   3   98			     LetterList:cbw
 012C   1   4B			     dec SpecsBx
 012D   2   80 3F 3F		      cmp Bptr[SpecsBx],'?'
 0130  3,1  75 35		      jne PostTrace

				     ; What to do with '?' of the subject !!
 0132   1   40			      inc ax
 0133   1   4B			      dec SpecsBx
				     ; Make it a runtime problem.
 0134   3   80 7B 07 89		      cmp V.Dtype,$Variable
 0138  3,1  74 7D		      je Failed
 013A   3   80 7B 07 8A		      cmp V.Dtype,$Constant
 013E  3,1  74 77		      je Failed
				     ; Throw them away for now.         NYI
 0140   3   E8 0000 E		     Qdrop:call ToDsSiCx
				     JcxzQ PostTrace
 0143   1   85 C9		  1    test cx,cx
 0145  3,1  74 20		  1    je PostTrace
 0147   2   80 3C 3F		      cmp Bptr[si],'?'
 014A  3,1  75 1B		      jne PostTrace
				     ; take SUBSTR(it,2)
				      Up
 014C   1   83 C7 08		  1   add StackDi,$StrideV
 014F   1   66| 89 2B		      mov V.ExpAnd,ebp
 0152   2   66| 89 6B 04	      mov V.Mantissa,ebp
 0156   2   C6 43 04 02		      mov Bptr(V.Mantissa),2
 015A   1   B0 00		      mov al,0
 015C   1   53			      push SpecsBx
 015D   1   68 0164 R		      push PostSubstr
 0160   1   56			      push si
 0161   3   E9 0464		      jmp BifSUBSTR
 0164   1   5B			     PostSubstr:pop SpecsBx
 0165   3   EB D9		      jmp Qdrop

 0167				     PostTrace:
				     ; About to check an options letter against the list.
				     ; We may need the list for a syntax msg.
				      mv ds,cs
 0167   3   0E			  1   push cs
 0168   3p  1F			  1   pop ds
 0169   1   40			      inc ax
 016A   1   89 9E 0087		      mov Z.Insert.OptsHi,SpecsBx
 016E   1   03 D8		      add SpecsBx,ax
 0170   1   89 9E 0085		      mov Z.Insert.Options,SpecsBx
 0174   2   8A 4B 07		      mov cl,V.Dtype
				     ; Parameter == '' is SYNTAX 40.21
 0177   1   B0 15		      mov al,21
 0179   1   80 F9 80		      cmp cl,$NullString
 017C  3,1  74 39		      je Failed
 017E   1   80 F9 8A		      cmp cl,$Constant
 0181  3,1  75 0B		      jne @F
 0183   1   8B 33		      mov si,V.WhichCon
 0185   3p  8E 5E 44		      mov ds,Z.ProgScope
 0188   2   80 7C 07 80		      cmp Vsid.Dtype,$NullString
 018C  3,1  74 29		      je Failed
 018E				     @@:
				     ; Special case for STREAM bif, but I'll do that in the STREAM routine.
				     ; (If the second argument isn't 'C' then a third is wrong.)
				     ; Parameter omitted will be defaulted.
 018E   1   80 F9 88		      cmp cl,$Omitted
 0191  3,1  74 1D		      je NoLetter
				     ; Uppercase the parameter, and shorten to one char.
				     ; At compile time we may alter the constant.
 0193   1   B4 4F		      mov ah,'O'
 0195   1   80 F9 8A		      cmp cl,$Constant
 0198  3,1  75 03		      jne @F
 019A   3   E8 0000 E		      call ConstValueX
 019D				      @@:
 019D   1   B0 1C		      mov al,28
				     ; More by luck than good coding this doesn't change $Variable things to letters.
 019F   3   E8 0000 E		      call UpperFirstAh
				      mv ds,cs
 01A2   3   0E			  1   push cs
 01A3   3p  1F			  1   pop ds
				     ; See if match in string.
 01A4   1   4B			      dec SpecsBx
 01A5   1   43			     @@:inc SpecsBx
 01A6   2   3B 9E 0087		      cmp SpecsBx,Z.Insert.OptsHi
 01AA  3,1  77 0B		      ja Failed
 01AC   2   3A 27		      cmp ah,Bptr[SpecsBx]
 01AE  3,1  75 F5		      jne @B
 01B0				     NoLetter:
 01B0   1   8B 9E 0085		      mov SpecsBx,Z.Insert.Options
 01B4   3   E9 00BF		      jmp AfterCheck

				     ; Here is a set of ways of raising SYNTAX, jumped to from the bif testing.
				     ; The numeric tests can fail with "Exponent out of range."
				     ; Change 40.11 to 40.9 if exponent too big.
				     ;MASM........................
 01B7				     Failed:
 01B7   8   0F BA 76 04 09	      btr Z.Cancel,ExpRange
 01BC  3,1  73 02		      jnc @F
 01BE   1   B0 09		      mov al,9
 01C0				      @@:
				     ; Z.Insert.Value will be good for Value insert. (Raise will set it from StackDi)
				     ; Z.Insert.Options is good if relevant.
				     ; Z.Insert.ArgNum has been maintained.
				     ; Z.InsBif has not been set, the rescan will do that.
				     ; al has been set to minor code.
				     ; CursorSi was pushed early on for line number.
				     ; When Bif parameters are checked at compile time a failure will come here.
				     ; Instead of following through we need to continue checking, with a flag
				     ; to ensure we eventually make code to check again at run time.
 01C0   2   39 AE 00E1		      cmp Z.Scanp,ZeroBp
 01C4  3,1  0F 84 0000 E	      jz Raise40
				     ; Assert SpecsBx, StackDi, StackDx in play.
 01C8   1   8B 66 32		      mov sp,Z.Stash
				      On Z.Program,BifCheck
 01CB   3   80 4E 03 04		  1          or  Bptr(Z.Program+1), high ??0001
 01CF   3   E9 00A4		      jmp AfterCheck

				     ; These bifs have a fixed number of arguments so we can economize on codes by
				     ; distinguishing them here. Only FORMAT requires argument checking.
 01D2				     BifGroup$$:
 01D2   1   65: 8A 1C		      mov bl,Bptr gs:[CursorSi]
 01D5   1   46			      inc CursorSi
 01D6   1   56			      push CursorSi
 01D7   1   80 FB 05		      cmp bl,5
 01DA  3,1  75 0A		      jne @F
 01DC   1   B3 22		      mov bl,2*$BifFORMAT
 01DE   1   B0 04		      mov al,4
				      On Z.Cancel,Format5
 01E0   3   80 4E 05 80		  1          or  Bptr(Z.Cancel+1), high ??0002
 01E4   3   EB 18		      jmp FromFORMAT5
 01E6   1   80 C3 3F		     @@:add bl,$BifQUEUED
 01E9   1   03 DB		      add bx,bx
				      z al
 01EB   1   B0 00		  1         mov al,0
 01ED   3   E9 00AC		      jmp FromBifGroup

				     ; Bif, and Bifq both invoke a builtin function.
				     ; Bif$$ does full checking.
 01F0   1   56			     Bif$$:push CursorSi
 01F1   1   65: 8A 04		      mov al,gs:[CursorSi]
 01F4   1   8A D8		      mov bl,al
 01F6   1   80 E3 7E		      and bl,7Eh
				     ; InsBif isn't needed for potential error message because parser will be
				     ; reused to synch the message and that sets InsBif.
 = bx				     SpecsBx is <bx>; SpecsBx will address the checking data. $9.2.1
 01F9   2   C0 C8 07		      ror al,7
 01FC   1   24 03		      and al,3
 01FE				     FromFORMAT5:
				      mv ds,cs
 01FE   3   0E			  1   push cs
 01FF   3p  1F			  1   pop ds
 0200   1   2E: 8B 9F 0000 E	      mov bx,(Bswitch)[bx]
				     ; Combine the count of optional parameters now in al with count of mandatory.
 0205   1   4B			      dec SpecsBx
 0206   1   8A 0F		      mov cl,Bptr[SpecsBx]
 0208   2   C0 E9 06		      shr cl,ParmsMin
 020B   1   02 C1		      add al,cl
 020D   1   88 86 00B4		      mov Z.BifParmsHi,al
				     ; Set StackDi to address any parameters from below the leftmost.
 0211   1   8B D7		      mov StackDx,StackDi
 0213   1   B4 08		      mov ah,$StrideV
 0215  13+  F6 E4		      mul ah
 0217   1   2B F8		      sub StackDi,ax
 0219				     BifTypes:; Note this routine is used both at compile and run times.
				     ; Hence care with segment register non-use or reload.
				     ; Either way label Raise handles things that don't pass the testing.
				     ; The number of parameters has already been checked, because that is always a
				     ; compile time job.
				     ; At this point, it is SpecsBx, StackDi and StackDx that define to-be-done.
 0219   1   C6 86 0082 00	      mov Z.Insert.ArgNum,0
 021E   1   52			      push StackDx
				     ; First byte says which parameters need checking.
 021F   1   8A 07		      mov al,Bptr[SpecsBx]
 0221   2   C0 E0 04		      shl al,8-width NonCheck
 0224   1   89 66 32		      mov Z.Stash,sp; To tidy up in Failed.
 0227   1   88 86 00B3		      mov Z.Flags,al
 022B   3   EB 49		      jmp AfterCheck
 022D   3   FE 86 0082		     ParmLoop:inc Z.Insert.ArgNum
 0231   4   D0 A6 00B3		      shl Z.Flags,1
 0235  3,1  72 3F		      jc AfterCheck

 0237   1   4B			      dec SpecsBx
 0238   1   8A 07		      mov al,Bptr[SpecsBx]
 023A   1   3C F6		      cmp al,-@SizeStr(<ACEFILNOR?>)
 023C  3,1  0F 83 FEEB		      jae LetterList
 0240   3   80 7B 07 88		      cmp V.Dtype,$Omitted
 0244  3,1  74 30		      je AfterCheck
				     ; StackDi is for the current argument, StackDx yields how many there were.
				     ; The table at WhichCheck gives input to a datatype test plus actual address
				     ; of a relevant particular test.
 0246   3   0F B6 F0		      movzx si,al
 0249   1   81 C6 00C9 R	      add si,WhichCheck
 024D   5   AD			      lodsw
				     ; Make a version of a constant argument that is of suitable type, if possible.
				     ; ah is type letter.
 024E   3   80 7B 07 8A		      cmp V.Dtype,$Constant
 0252  3,1  75 03		      jne @F
				     ; Only happens at compile time.
 0254   3   E8 0000 E		      call ConstValueX
 0257				     @@:
				     ; The test of $Variable is only relevant at compile time and wouldn't be
				     ; needed if I made sure conversions always failed for that type.
 0257   3   80 7B 07 89		      cmp V.Dtype,$Variable
 025B  3,1  0F 84 FF58		      je Failed
				     ; al now will be minor message number. ah will be letter option for datatype.
				     ; Carry will be set on by DataType if the type test fails.
				     ; Otherwise DataType will convert the argument, according to ah.
				     ; DataType doesn't do its own saving; sometimes called with nothing to save.
 025F   1   53			      push SpecsBx
 0260   1   52			      push StackDx
 0261   1   56			      push si
 0262   1   50			      push ax
 0263   1   8A C4		      mov al,ah
 0265   3   E8 0164		      call DataType
 0268   1   58			      pop ax
 0269   1   5E			      pop si
 026A   1   5A			      pop StackDx
 026B   1   5B			      pop SpecsBx
				      mv ds,cs
 026C   3   0E			  1   push cs
 026D   3p  1F			  1   pop ds
 026E  3,1  0F 82 FF45		      jc Failed
				     ; Symbol is only checked as the first parameter of VALUE, and can't be wrong
				     ; then if there is a third parameter.
				     ; I have decided to test this only in the BifVALUE code.
 0272   5p  FF 14		      call Wptr[si]; For specialized tests on the argument.
				      mv ds,cs
 0274   3   0E			  1   push cs
 0275   3p  1F			  1   pop ds
 0276				     AfterCheck:Up
 0276   1   83 C7 08		  1   add StackDi,$StrideV
 0279   1   3B FA		      cmp StackDi,StackDx
 027B  3,1  76 B0		      jna ParmLoop
				     ; Reached here if no check failed.
 027D   1   5F			      pop StackDi
				      z bh
 027E   1   B7 00		  1         mov bh,0
				     ; If BifTypes was used from compile time it returns from here.
 0280   2   39 AE 00E1		      cmp Z.Scanp,ZeroBp
 0284  3,1  74 01		      je @F
 0286   5   C3			      ret
 0287				      @@:
				      Qry Z.Cancel,Format5
 0287   2   F6 46 05 80		  1          test Bptr(Z.Cancel+1), high ??0003
 028B  3,1  74 06		      jz @F
				     ; Typical Format awkwardness.
 028D   1   B0 04		      mov al,4
 028F   1   B3 22		      mov bl,2*$BifFORMAT
 0291   3   EB 09		      jmp FromBifGroup
 0293				     @@:
 0293   1   5E			      pop CursorSi
				     ; End of Bif$$ pre-checking of arguments. Now is like Bifq$$.
				     ;------------------------------------------------------------------------------
				     ; The XCycle fans to Add$$, Iterate$$ etc.  Bifq$$ is another fan-out.
				     ;  (Bif$$ does parameter checking on the way to Bifq$$ when necessary.)
				     ;------------------------------------------------------------------------------
 0294   5   65: AC		     Bifq$$:lodsb gs:[CursorSi]
 0296   1   56			     push CursorSi; Many Bifs need to use this.
				     ; Pick up address of BifABBREV or whatever it is.
 0297   1   8A D8		      mov bl,al
 0299   1   80 E3 7E		      and bl,7Eh
 029C				     FromBifGroup:
 029C   1   2E: 8B B7 0000 E	      mov si,cs:(Bswitch)[bx]
				     ; Some are hard codes, some use Bcodes.
				     ; BEWARE - this test depends on the order in which object modules are linked.
 02A1   1   81 FE 0000 E	      cmp si,offset BifBound
 02A5  3,1  72 0C		      jb BifBcoded
				     ; Adjust the optional extra parameters out of the StackDi position.
 02A7   1   8A D8		      mov bl,al
 02A9   1   80 E3 81		      and bl,81h
 02AC   2   C0 C3 04		      rol bl,$ShiftV+1
 02AF   1   2B FB		      sub StackDi,bx
				     ; The bif routines are entered with:
				     ;AH free, AL showing what optional parameters were present. (need not preserve)
				     ;BH zero, BX free
				     ;CH free, CL showing options letter as number, where relevant. (need not pre..)
				     ;DX free
				     ;SI free Must be restored on return, by pop.
				     ;DI addressing the last mandatory argument. On return must address result.
				     ;DS free
				     ;ES free
				     ;FS not free
				     ;GS not free
				     ;Extended parts of registers can be changed.
 02B1   5p  FF E6		      jmp si; Will return to XCycle

				     ; When we come from setting up a builtin AL describes the builtin and number
				     ; of actual arguments. SI addresses the implementing Bcode and the byte
				     ; before that gives the maximum possible number of optional arguments.
				     ; (Exception - MAX and MIN)
				     ; The stack about to be padded with $Omitted arguments so that the implementing
				     ; code always sees the same amount of stack for arguments.
				     ; (Z.ArgsB0 and Z.ArgsB also say where args are; this needed for MAX/MIN)
				     ; CursorSi is now the cursor on Bcode.
				     ; The CursorSi position has been pushed. (That is Pcode position if top level.)
				     ; Set ah to allowed extras, al to extras on this invocation.
 02B3				     BifBcoded:
 02B3   1   80 FB 68		      cmp bl,2*$BifBITAND
 02B6  3,1  75 14		      jne @F
 02B8   1   66| 26: C7 46 4C	      mov Dptr(Ve.String[$?BIF]),StringOrder('B','I','T','A')
	      41544942
 02C1   1   66| 26: C7 46 50	      mov Dptr(Ve.String[$?BIF+4]),StringOrder('N','D',0,($NullString+6))
	      8600444E
 02CA   3   EB 42		      jmp BifUsual
 02CC   1   80 FB 6A		     @@:cmp bl,2*$BifBITOR
 02CF  3,1  75 14		      jne @F
 02D1   1   66| 26: C7 46 4C	      mov Dptr(Ve.String[$?BIF]),StringOrder('B','I','T','O')
	      4F544942
 02DA   1   66| 26: C7 46 50	      mov Dptr(Ve.String[$?BIF+4]),StringOrder('R',0,0,($NullString+5))
	      85000052
 02E3   3   EB 29		      jmp BifUsual
 02E5   1   80 FB 6C		     @@:cmp bl,2*$BifBITXOR
 02E8  3,1  75 14		      jne @F
 02EA   1   66| 26: C7 46 4C	      mov Dptr(Ve.String[$?BIF]),StringOrder('B','I','T','X')
	      58544942
 02F3   1   66| 26: C7 46 50	      mov Dptr(Ve.String[$?BIF+4]),StringOrder('O','R',0,($NullString+6))
	      8600524F
 02FC   3   EB 10		      jmp BifUsual
 02FE   1   80 FB 22		     @@:cmp bl,2*$BifFORMAT
 0301  3,1  75 0B		      jne BifUsual
 0303   1   B4 04		      mov ah,4; Max extras.
 0305   8   0F BA 76 04 0F	      btr Z.Cancel,Format5
 030A  3,1  72 10		      jc Format5n
 030C   3   EB 0A		      jmp Formatn
 030E   1   2E: 8A 64 FF	     BifUsual:mov ah,cs:[CursorSi-1]
 0312   1   80 E4 30		      and ah,mask ParmsXtr
 0315   2   C0 EC 04		      shr ah,ParmsXtr
 0318   3   D0 C0		     Formatn:rol al,1
 031A   1   24 03		      and al,3
 031C   1   88 86 0129		     Format5n:mov Z.ArgsB,al; Actual extras.
 0320   3   EB 08		      jmp BifArgPad
 0322				     @@:Up
 0322   1   83 C7 08		  1   add StackDi,$StrideV
 0325   2   C6 43 07 88		      mov V.Dtype,$Omitted
 0329   1   40			      inc ax
 032A   1   38 E0		     BifArgPad:cmp al,ah
 032C  3,1  75 F4		      jne @B
 032E   3   E9 0000 E		      jmp LinkBcodeX

				     ; Bifs implemented. Data for checking parameters ahead of the machine code.

				     if Solid
				     ;$9.3.6
 0331  04			      db $WholeGE
 0332  8B			      ParmsRec <2,0,1011b>
 0333				     BifCOPIES:
				     endif
 0333   2   8B 5B 04		      mov bx,V.MantLow
				      Down
 0336   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; Zero copies returns null string.
				      TestReg bx
 0339   1   85 DB		  1         test bx,bx
 033B  3,1  75 06		      jnz @F
 033D   2   C6 43 07 80		      mov V.Dtype,$NullString
				      RetSi
 0341   1   5E			  1   pop CursorSi
 0342   5   C3			  1   ret
 0343				      @@:
 0343   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ @3p6ret
 0346   1   85 C9		  1    test cx,cx
 0348  3,1  74 30		  1    je @3p6ret
				      Move V2,V,edx
 034A   1   66| 8B 13		  1    mov edx,V.OverExpo
 034D   2   66| 89 53 08	  1    mov V2.OverExpo,edx
 0351   2   66| 8B 53 04	  1    mov edx,V.OverMant
 0355   2   66| 89 53 0C	  1    mov V2.OverMant,edx
				     ; Setup for result loses first argument.
				      xax cx
 0359   3   91			  1     xchg ax,cx
 035A  13+  F7 E3		      mul bx
 035C  3,1  0F 82 0000 E	      jc Raise5p1d
				      xax cx
 0360   3   91			  1     xchg ax,cx
 0361   3   E8 0000 E		      call ResultSpace
				     ; In case compaction.
				      Up
 0364   1   83 C7 08		  1   add StackDi,$StrideV
 0367   3   E8 0000 E		      call ToDsSiCx
				      Down
 036A   1   83 EF 08		  1   sub StackDi,$StrideV
 036D   1   57			      push StackDi
 036E   1   8B F8		      mov di,ax
 0370   1   51			     @@:push cx
 0371   1   56			      push si
 0372   7n  F3/ A4		      rep movsb
 0374   1   5E			      pop si
 0375   1   59			      pop cx
 0376   1   4B			      dec bx
 0377  3,1  75 F7		      jnz @B
 0379   1   5F			      pop StackDi
 037A   3   E9 0290		     @3p6ret:jmp BackEsSi

				     if Solid
				     ;$9.3.8
 037D  41 42 4C 4D 4E 53 55 57	      db "ABLMNSUWX"
	      58
 0386  F7			      db -@SizeStr(<ABLMNSUWX>)
 0387  5B			      ParmsRec <1,1,1011b>
 0388				     BifDATATYPE:
				     endif
 0388   1   A8 81		      test al,81h
 038A  3,1  75 06		      jnz @F
 038C   1   FE C7		      inc bh
 038E   1   B0 4E		      mov al,'N'
 0390   3   EB 0B		      jmp WithLetter
 0392				     @@:Up
 0392   1   83 C7 08		  1   add StackDi,$StrideV
 0395   3   E8 0000 E		      call UpperFirstAh
 0398   1   8A C4		      mov al,ah
				      Down
 039A   1   83 EF 08		  1   sub StackDi,$StrideV
 039D   3   E8 002C		     WithLetter:call DataType
				     ; Carry is set if *not* this type.
 03A0   1   66| 8B C5		      mov eax,ebp
 03A3  3,1  72 01		      jc @F
 03A5   1   40			      inc ax
 03A6				      @@:
 03A6   2   66| 89 43 04	      mov V.Mantissa,eax
 03AA   1   66| 89 2B		      mov V.ExpAnd,ebp
 03AD   1   84 FF		      test bh,bh
 03AF  3,1  74 19		      je BifDret
 03B1   2   C6 43 07 83		      mov V.Dtype,$NullString+3
 03B5   1   66| C7 03 204D554E	      mov Dptr(V.String),StringOrder('N','U','M',' ')
 03BC   1   48			      dec ax
 03BD  3,1  74 0B		      jz BifDret
 03BF   2   C6 43 07 84		      mov V.Dtype,$NullString+4
 03C3   1   66| C7 03 52414843	      mov Dptr(V.String),StringOrder('C','H','A','R')
 03CA   1   5E			     BifDret:pop CursorSi
				      BackRet
 03CB   5   C3			  1  ret

 03CC				     DataType:
				     ; DataType determines whether the data type of the value on the stack is
				     ; as expected, and does some conversion.
				     ; On entry StackDi gives the subject.
				     ; On entry al is the option letter.
				     ; On exit carry is Boolean for "not as expected"
				     ; A side-effect of some types is to "normalise" the subject.

				     ; al blank on entry means that this is one of the tests for whole numbers
				     ; with bifs. The test for number syntax is the same as with 'N' but the
				     ; integerness test may be different because always at precision 9.
				     ; ToWholeEbx also used for FOR argument etc.
 03CC   1   3C 20		      cmp al,' '
 03CE  3,1  0F 84 0000 E	      je ToWholeEbx

				     ; Get the null string cases out of the way
 03D2   3   80 7B 07 80		      cmp V.Dtype,$NullString
 03D6  3,1  75 0E		      jne TqNonNull
 03D8   1   3C 42		      cmp al,'B'
 03DA  3,1  74 09		      je @F
 03DC   1   3C 58		      cmp al,'X'
 03DE  3,1  74 05		      je @F
 03E0   1   3C 5A		      cmp al,'Z'
 03E2  3,1  74 01		      je @F
 03E4   2   F9			      stc
 03E5   5   C3			      @@:ret

 03E6  11   60			     TqNonNull:pusha
				     ; The three major representations are number, short string, and long string.
				     ; A particular Rexx value can be held in different representations.
 03E7   1   BB 0000 E		      mov bx,Attributes; For potential XLAT

 03EA   1   3C 4E		      cmp al,'N'
 03EC  3,1  75 0A		      jne DNotN
				     ; !! Is current digits, not 9.  Carry from NumDxBx is bad syntax.  jnz for bin.
 03EE   3   E8 0000 E		      call NumDxBx
 03F1  3,1  0F 82 00D1		      jc TqFail
 03F5   3   E9 00D2		      jmp TqOK
 03F8				     DNotN:
 03F8   1   3C 57		      cmp al,'W'
 03FA  3,1  75 0A		      jne DNotW
				     ; WholeNum. DATATYPE uses the current digits.
 03FC   3   E8 0000 E		      call ToWholeEbx
 03FF  3,1  0F 82 00C3		      jc TqFail
 0403   3   E9 00C4		      jmp TqOK

 0406				     DNotW:
 0406   3   E8 0000 E		      call ToDsSiCx
 0409   1   BB 0000 E		      mov bx,Attributes
 040C   1   3C 41		      cmp al,'A'
 040E  3,1  75 20		      jne DNotA
				     ; Letters and digits OK. Not including '_' etc which our table has as letters.
				     ; Not including '.' which our table has as a letter.
				     ; Sadly. '@' is mixed in with the uppercase letters in ASCII sequence.
 0410   5   AC			     @@:lodsb
 0411   1   3C 30		     cmp al,'0'
 0413  3,1  0F 82 00AF		     jb TqFail
 0417   1   3C 40		     cmp al,'@'
 0419  3,1  0F 84 00A9		     je TqFail
 041D   1   3C 2E		      cmp al,'.'
 041F  3,1  0F 84 00A3		      je TqFail
				      XlatBDLS
 0423   4   2E: D7		  1   xlat Bptr cs:[bx]
 0425   1   A8 C0		  1   test al,0C0h
 0427  3,1  0F 8A 009B		      jpe TqFail
 042B  2,6  E2 E3		      loop @B
 042D   3   E9 009A		      jmp TqOK
 0430				     DNotA:

 0430   1   3C 42		      cmp al,'B'
 0432  3,1  75 05		      jne DNotB
 0434   1   BA 0320		      mov dx,MkMajMin(3,$OKb)
 0437   3   EB 55		      jmp FromB
 0439				     DNotB:

 0439   1   3C 4C		      cmp al,'L'
 043B  3,1  75 11		      jne DNotL
				     ; Lower case OK, same as uppercaseable letter/digit
 043D   5   AC			     @@:lodsb
				     XlatBDLS
 043E   4   2E: D7		  1   xlat Bptr cs:[bx]
 0440   1   A8 C0		  1   test al,0C0h
 0442  3,1  0F 8A 0080		     jpe TqFail
 0446   1   A8 48		      test al,$Lowercase
 0448  3,1  75 7C		      jnz TqFail
 044A  2,6  E2 F1		      loop @B
 044C   3   EB 7C		      jmp TqOK
 044E				     DNotL:

 044E   1   3C 4D		      cmp al,'M'
 0450  3,1  75 0F		      jne DNotM
				     ; Mixed, same as 'A' except excludes digits.
 0452   5   AC			     @@:lodsb
 0453   1   3C 41		     cmp al,'A'
 0455  3,1  72 6F		     jb TqFail
				     XlatBDLS
 0457   4   2E: D7		  1   xlat Bptr cs:[bx]
 0459   1   A8 C0		  1   test al,0C0h
 045B  3,1  7A 69		     jpe TqFail
 045D  2,6  E2 F3		     loop @B
 045F   3   EB 69		     jmp TqOK
 0461				     DNotM:

 0461   1   3C 53		      cmp al,'S'
 0463  3,1  75 11		      jne DNotS
				     ; Not easy to share Symbol test with compile time.
 0465   1   81 F9 00FA		      cmp cx,$Limit_Name
 0469  3,1  77 5B		      ja TqFail
				     ; Dot as letter.
				     ; What about reserveds in SYMBOL()?
 046B   5   AC			     @@:lodsb
				     XlatBDLS
 046C   4   2E: D7		  1   xlat Bptr cs:[bx]
 046E   1   A8 C0		  1   test al,0C0h
 0470  3,1  7A 54		     jpe TqFail
 0472  2,6  E2 F7		     loop @B
 0474   3   EB 54		     jmp TqOK
 0476				     DNotS:

 0476   1   3C 55		      cmp al,'U'
 0478  3,1  75 0D		      jne DNotU
				     ; Upper
 047A   5   AC			     @@:lodsb
 047B   1   3C 41		     cmp al,'A'
 047D  3,1  72 47		     jb TqFail
 047F   1   3C 5A		     cmp al,'Z'
 0481  3,1  77 43		     ja TqFail
 0483  2,6  E2 F5		     loop @B
 0485   3   EB 43		     jmp TqOK
 0487				     DNotU:

 0487   1   3C 58		      cmp al,'X'
 0489  3,1  75 39		      jne DNotX
				     ; The same loop is used for hex and binary, with parameters.
				     ; To test for valid chars, RadixTypeDl.
				     ; To test for blanks badly placed dh, 1 for Hex, 3 for Bin.
 048B   1   BA 0110		      mov dx,MkMajMin(1,$OKx)
 048E				     FromB:
				     ; Check first and last of content for blanks.
 048E   1   8A 04		      mov al,[si]
				      XlatBDLS
 0490   4   2E: D7		  1   xlat Bptr cs:[bx]
 0492   1   A8 C0		  1   test al,0C0h
 0494  3,1  74 30		      jz TqFail
 0496   1   03 F1		      add si,cx
 0498   1   4E			      dec si
 0499   1   8A 04		      mov al,[si]
				      XlatBDLS
 049B   4   2E: D7		  1   xlat Bptr cs:[bx]
 049D   1   A8 C0		  1   test al,0C0h
 049F  3,1  74 25		      jz TqFail
				     ; Check the string content which goes down from si for cx.
				     ; Whitespace is allowed for formatting.
				     ; But not at ends or in middle of nibbles.
				      z Z.DigitCount
 04A1   1   89 AE 01A8		  1           mov Z.DigitCount,bp
 04A5   2   FD			      std
 04A6   5   AC			     RadiLoop:lodsb [si]
				      XlatBDLS
 04A7   4   2E: D7		  1   xlat Bptr cs:[bx]
 04A9   1   A8 C0		  1   test al,0C0h
 04AB  3,1  75 08		      jnz NonWhi
 04AD   2   84 B6 01A8		      test Bptr Z.DigitCount,dh
 04B1  3,1  75 13		      jnz TqFail
 04B3   3   EB 0A		      jmp @F
 04B5  3,1  7A 0F		     NonWhi:jpe TqFail; Not a letter or digit
 04B7   1   84 C2		      test AttribAl,RadixTypeDl
 04B9  3,1  74 0B		      jz TqFail; Not good for this radix
 04BB   3   FF 86 01A8		      inc Z.DigitCount
 04BF				     @@:LoopQ RadiLoop
 04BF   1   49			  1    dec cx
 04C0  3,1  75 E4		  1    jnz RadiLoop
 04C2   3   EB 06		      jmp TqOK
 04C4				     DNotX:

				     ; Here would be test for allowable characters in a stream name.
				     ; cmp al,'Z'    NYI
 04C4  3,1  75 04		      jne DNotZ

 04C6   9   61			     TqFail:popa
 04C7   2   FC			     cld
 04C8   2   F9			     stc
 04C9   5   C3			     ret

 04CA				     DNotZ:; Pad type always succeeding.
 04CA   9   61			     TqOK:popa
 04CB   2   FC			     cld
 04CC   2   F8			     clc
 04CD   5   C3			     ret

 04CE   1   FE C7		     Max$$:inc bh
 04D0   5   65: AC		     Min$$:lodsb gs:[CursorSi]
 04D2   1   88 86 0129		     mov Z.ArgsB,al
 04D6   1   40			     inc ax; Actual args.
				     ; Check Numberness in the original order.
 04D7   1   B4 F8		      mov ah,-$StrideV
 04D9  13+  F6 EC		      imul ah
 04DB   1   8B CF		      mov cx,StackDi
 04DD   1   03 F8		      add StackDi,ax
 04DF   1   89 BE 012A		      mov Z.ArgsB0,StackDi
 04E3   1   C6 86 0082 00	      mov Z.Insert.ArgNum,0
 04E8   1   53			      push bx
 04E9   3   FE 86 0082		     @@:inc Z.Insert.ArgNum
				      Up
 04ED   1   83 C7 08		  1   add StackDi,$StrideV
 04F0   3   E8 0000 E		      call NumDxBx
 04F3  3,1  0F 82 0000 E	      jc Raise40p11
 04F7   1   3B F9		      cmp StackDi,cx
 04F9  3,1  75 EE		      jne @B
 04FB   1   5B			      pop bx
				     ; Actual function is Bcoded.
 04FC   1   BA 0000 E		      mov dx,BifMAX
 04FF   1   84 FF		      test bh,bh
 0501  3,1  75 03		      jne @F
 0503   1   BA 0000 E		      mov dx,BifMIN
 0506   3   E9 0000 E		      @@:jmp LinkBcode

				     if Solid
				     ;$9.3.13
 0509  18			      db $Pad
 050A  04			      db $WholeGE
 050B  99			      ParmsRec <2,1,1001b>
 050C				     BifLEFT:
				     endif
 050C   1   A8 81		      test al,81h
 050E  3,1  74 19		      jz @3p13Two
 0510   3   83 46 06 08		      add Z.Stack,$StrideV
				     ; LEFT(a,b,c) ==> SUBSTR(a,1,b,c)
				     ; SUBSTR with four args, two mandatory.
 0514   1   04 01		      add al,1
				     ; Move pad field one further up, after ensuring it is char.
				     ; Avoid check if Bcode didn't use Bifq$$ all the time.(Best avoided compiletime)
				      Up
 0516   1   83 C7 08		  1   add StackDi,$StrideV
 0519   3   E8 0000 E		      call ToDsSiCx
				      Down
 051C   1   83 EF 08		  1   sub StackDi,$StrideV
 051F   2   8A 4B 08		      mov cl,V2.String
 0522   2   88 4B 10		      mov V3.String,cl
 0525   2   C6 43 17 81		      mov V3.Dtype,$NullString+1
 0529				     @3p13Two:
				     ; LEFT(a,b) ==> SUBSTR(a,1,b)
				     ; SUBSTR with three args, two mandatory.
 0529   1   04 80		      add al,80h
				     ; Move length field one further up.
 052B   2   66| 8B 4B 04	      mov ecx,V.Mantissa
 052F   2   66| 89 4B 0C	      mov V2.Mantissa,ecx
 0533   1   66| 8B 0B		      mov ecx,V.ExpAnd
 0536   2   66| 89 4B 08	      mov V2.ExpAnd,ecx
				     ; Set what was length field to 1.
 053A   2   66| 89 6B 04	      mov V.Mantissa,ebp
 053E   1   66| 89 2B		      mov V.ExpAnd,ebp
 0541   4   FE 43 04		      inc Bptr V.Mantissa
 0544   3   E9 0081		      jmp BifSUBSTR

				     if Solid
				     ;$9.3.16
 0547  08			      db $WholeGT
 0548  9D			      ParmsRec <2,1,1101b>
 0549				     BifPOS:
				     endif
				     ; Start above Haystack above Needle.
 0549   3   E8 0000 E		      call ToDsSiCx
				      Down
 054C   1   83 EF 08		  1   sub StackDi,$StrideV
 054F   1   A8 81		      test al,81h
				      z ax
 0551   1   8B C5		  1           mov ax,bp
 0553  8,5  E3 34		      jcxz @3p16Done
 0555  3,1  79 0E		      jns @3p16Two
				     ; Adjust when start position given.
 0557   2   8B 53 14		      mov dx,V3.MantLow
 055A   1   3B D1		      cmp dx,cx
 055C  3,1  77 2B		      ja @3p16Done
 055E   1   8B C2		      mov ax,dx
 0560   1   48			      dec ax
 0561   1   03 F0		      add si,ax
 0563   1   2B C8		      sub cx,ax
				     ; ax is contribution to result.
 0565				     @3p16Two:
				     ; NYI push ds unsound?
 0565   1   57			      push di
 0566   3   1E			      push ds
 0567   1   56			      push si
 0568   1   51			      push cx
 0569   3   E8 0000 E		      call ToDsSiCx; For Needle
				     ; bx = Hay length. di=Hay pos.  es=Hay seg.
 056C   1   5B			      pop bx
 056D   1   5F			      pop di
 056E   3p  07			      pop es
				      JcxzQ @3p16None
 056F   1   85 C9		  1    test cx,cx
 0571  3,1  74 13		  1    je @3p16None
 0573   1   2B D9		      sub bx,cx
 0575  3,1  72 0F		      jb @3p16None
				     ; ax to be result. Usual registers for repe cmpsb. bx detects end of Haystack.
 0577   1   40			     @3p16loop:inc ax
 0578   1   56			     push si
 0579   1   57			     push di
 057A   1   51			     push cx
 057B   8n  F3/ A6		     repe cmpsb
 057D   1   59			     pop cx
 057E   1   5F			     pop di
 057F   1   5E			     pop si
 0580  3,1  74 06		      je @3p16x
 0582   1   47			      inc di
 0583   1   4B			      dec bx
 0584  3,1  79 F1		      jns @3p16loop
 0586				     @3p16None:z ax
 0586   1   8B C5		  1           mov ax,bp
 0588   1   5F			     @3p16x:pop di
 0589   1   66| 89 2B		     @3p16Done:mov V.ExpAnd,ebp
 058C   2   66| 89 6B 04	      mov V.Mantissa,ebp
 0590   2   89 43 04		      mov V.MantLow,ax
 0593   3   EB 78		      jmp BackEsSi

				     if Solid
				     ;$9.3.17
 0595  4F			      ParmsRec <1,0,1111b>
 0596				     BifREVERSE:
				     endif
				     ; Setup for result loses first argument.
				      Move V2,V,edx
 0596   1   66| 8B 13		  1    mov edx,V.OverExpo
 0599   2   66| 89 53 08	  1    mov V2.OverExpo,edx
 059D   2   66| 8B 53 04	  1    mov edx,V.OverMant
 05A1   2   66| 89 53 0C	  1    mov V2.OverMant,edx
 05A5   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ @9p3p17
 05A8   1   85 C9		  1    test cx,cx
 05AA  3,1  74 16		  1    je @9p3p17
 05AC   3   E8 0000 E		      call ResultSpace
				      xax bx
 05AF   3   93			  1     xchg ax,bx
 05B0   1   03 D9		      add bx,cx
				      Up
 05B2   1   83 C7 08		  1   add StackDi,$StrideV
 05B5   3   E8 0000 E		      call ToDsSiCx
				      Down;
 05B8   1   83 EF 08		  1   sub StackDi,$StrideV
 05BB   5   AC			     @@:lodsb
 05BC   1   4B			      dec bx
 05BD   1   26: 88 07		      mov es:[bx],al
 05C0  2,6  E2 F9		      loop @B
 05C2   3   EB 49		     @9p3p17:jmp BackEsSi

				     if Solid
				     ;$9.3.21
 05C4  18			      db $Pad
 05C5  04			      db $WholeGE
 05C6  08			      db $WholeGT
 05C7  A8			      ParmsRec <2,2,1000b>
 05C8				     BifSUBSTR:
				     endif
				     ; Setup to be  V2 (bx+1) is position, V3 (dx) is length, V4 is pad char, pad
				     ; length ax.
				     if 1
				     ; NYI Bcode to explicitly make number where required?
 05C8   3   F6 43 07 C0		      test V.Dtype,$Test
 05CC  3,1  74 03		      jz @F
 05CE   3   E8 0000 E		      call NumDxBx
 05D1				      @@:
				     endif
 05D1   2   8B 5B 04		      mov bx,V.MantLow
				      Down
 05D4   1   83 EF 08		  1   sub StackDi,$StrideV
 05D7   3   E8 0000 E		      call ToDsSiCx
 05DA   1   4B			      dec bx
				     ; Lower position offset, bx, to within string or at end.
 05DB   1   3B D9		      cmp bx,cx
 05DD  3,1  76 02		      jna @F
 05DF   1   8B D9		      mov bx,cx
 05E1				      @@:
 05E1   1   A8 81		      test al,81h
 05E3  3,1  78 3D		      js @3p21Three
 05E5  3,1  7B 3F		      jpo @3p21Four
				     ; Two arguments. Default length is the rest.
 05E7   1   8B D1		      mov dx,cx
 05E9   1   2B D3		      sub dx,bx
				     ; When there is no padding there will be no need for allocate and move.
 05EB   1   83 FA 07		     @3p21NoPad:cmp dx,7
 05EE  3,1  76 07		     jna @F
 05F0   3   01 1B		      add V.Pt,bx
 05F2   2   89 53 04		      mov V.Len,dx
 05F5   1   5E			      pop CursorSi
				      BackRet
 05F6   5   C3			  1  ret
 05F7   1   03 F3		     @@:add si,bx
 05F9   1   66| 8B 0C		      mov ecx,Dptr[si]
 05FC   1   66| 8B 5C 04	      mov ebx,Dptr[si+4]
 0600   1   66| 89 0B		      mov Dptr(V.String),ecx
 0603   2   66| 89 5B 04	      mov Dptr(V.String+4),ebx
 0607   1   80 C2 80		      add dl,$NullString
 060A   2   88 53 07		      mov V.Dtype,dl
 060D				     BackEsSi:
 060D   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 0610   1   5E			      pop CursorSi
				      BackRet
 0611   5   C3			  1  ret

 0612				     @3p21Alloc:;cx pad length, dx total length, ds:si source.
 0612   3   87 CA		     xchg cx,dx
 0614   3   E8 0000 E		     call AllocateCx_EsAx
 0617   3   87 D1		     xchg dx,cx
 0619  3,1  73 21		     jnc @3p21Move
				     ; Compaction will have invalidated ds:si
 061B   1   51			      push cx
 061C   3   E8 0000 E		      call ToDsSiCx
 061F   1   59			      pop cx
 0620   3   EB 1A		      jmp @3p21Move

				     ; Default pad is ' '
 0622   2   C6 43 18 20		     @3p21Three:mov Bptr(V4.String),' '
 0626				     @3p21Four:
				     ; Arg 3 is known to be binary since if the types were checked at runtime it
				     ; would have been converted then and if the types passed check at compile
				     ; time the constant would be stored as binary.
				     ; (For Bcode there is risk but hopefully they are coded to cope.)
 0626   2   8B 53 14		      mov dx,V3.MantLow
				     ; Data move is necessary only if there is padding. Change cx to amount of pad.
 0629   1   8B C3		      mov ax,bx
 062B   1   03 C2		      add ax,dx
 062D   1   2B C1		      sub ax,cx
 062F  3,1  76 BA		      jna @3p21NoPad
 0631   1   8B C8		      mov cx,ax
				     ; New space not necessary for short results.
 0633   1   83 FA 07		      cmp dx,7
 0636  3,1  77 DA		      ja @3p21Alloc
				      mv es,ds
 0638   3   1E			  1   push ds
 0639   3p  07			  1   pop es
 063A   1   8B C6		      mov ax,si; es:ax is target.
 063C   1   50			     @3p21Move:push ax
 063D   1   2B D1		      sub dx,cx
 063F   3   87 CA		      xchg cx,dx; cx chars from original, dx chars of pad
				     ; Copy it. Direction of move is OK when source is short.
 0641   1   57			      push StackDi
 0642   1   03 F3		      add si,bx
 0644   2   8A 5B 18		      mov bl,V4.String
 0647   1   8B F8		      mov di,ax
				      Repmovsb
 0649   7n  F3/ A4		  1   rep movsb
 064B   1   8A C3		      mov al,bl
 064D   1   8B CA		      mov cx,dx
 064F   5n  F3/ AA		      rep stosb
 0651   1   5F			      pop StackDi
 0652   2   8B 43 14		      mov ax,V3.MantLow
 0655   1   83 F8 07		      cmp ax,7
 0658  3,1  77 09		      ja @3p21Long
 065A   1   04 80		      add al,$NullString
 065C   2   88 43 07		      mov V.Dtype,al
				      PopJunk si
 065F   1   5E			  1    pop si
 0660   3   E9 0000 E		      jmp RetEsSi

 0663   2   89 43 04		     @3p21Long:mov V.Len,ax
 0666   4   8C 43 02		     mov V.Sg,es
 0669   6   8F 03		     pop V.Pt
 066B   3   E8 0000 E		      call Away
 066E   3   E9 0000 E		      jmp RetEsSi

				     if Solid
				     ;$9.3.22
 0671  04			     db $WholeGE
 0672  08			     db $WholeGT
 0673  99			     ParmsRec <2,1,1001b>
 0674				     BifSUBWORD:
				     endif
				      Down
 0674   1   83 EF 08		  1   sub StackDi,$StrideV
 0677   2   88 43 1F		      mov V4.Dtype,al;Just a place to save it.
				     ; V3 is optional, number of words.
 067A   1   A8 81		      test al,81h
 067C  3,1  74 05		      jz @F
 067E   4   FF 4B 14		      dec V3.MantLow
 0681  3,1  78 66		      js @3p22Null
 0683				      @@:
				     ; Address string, move si to first wanted word.
 0683   3   E8 0000 E		      call ToDsSiCx
 0686   3   E8 00A0		      call WordIndex
				      JcxzQ @3p22Null
 0689   1   85 C9		  1    test cx,cx
 068B  3,1  74 5C		  1    je @3p22Null
 068D   1   4E			      dec si
 068E   1   8B D6		      mov dx,si
				     ; Omitted third parameter means all residual string except trailing blanks.
 0690   3   F6 43 1F 81		      test V4.Dtype,81h
 0694  3,1  74 5C		      jz @3p22Clip
				     ; Move on past word that was found.
 0696   5   AC			     @@:lodsb
				     XlatBDLS
 0697   4   2E: D7		  1   xlat Bptr cs:[bx]
 0699   1   A8 C0		  1   test al,0C0h
 069B  3,1  74 05		     jz @F
				     LoopQ @B
 069D   1   49			  1    dec cx
 069E  3,1  75 F6		  1    jnz @B
 06A0   3   EB 1F		     jmp @3p22Done
				     ; Third parameter is count of words. (Already decremented)
 06A2   1   4E			     @@:dec si
 06A3   2   8B 43 14		     mov ax,V3.MantLow
				     TestReg ax
 06A6   1   85 C0		  1         test ax,ax
 06A8  3,1  74 17		     jz @3p22Done
 06AA   2   89 43 0C		     mov V2.MantLow,ax
				     ; Move on to beginning of the last word.
 06AD   3   E8 0079		      call WordIndex
				      JcxzQ @3p22ClipX
 06B0   1   85 C9		  1    test cx,cx
 06B2  3,1  74 3B		  1    je @3p22ClipX
 06B4   1   49			      dec cx
				     ; Move on past that word.
 06B5   5   AC			     @@:lodsb
				     XlatBDLS
 06B6   4   2E: D7		  1   xlat Bptr cs:[bx]
 06B8   1   A8 C0		  1   test al,0C0h
 06BA  3,1  74 04		     jz @F
				     LoopQ @B
 06BC   1   49			  1    dec cx
 06BD  3,1  75 F6		  1    jnz @B
 06BF   1   46			     inc si
 06C0   1   4E			     @@:dec si
				     ; Wanted is from dx up to si.
 06C1   1   8B CE		     @3p22Done:mov cx,si
 06C3   1   8B F2		     mov si,dx
 06C5   1   2B CE		     sub cx,si
 06C7   1   83 F9 07		      cmp cx,7
 06CA  3,1  77 16		      ja @3p22Long
 06CC   1   66| 8B 14		      mov edx,Dptr[si]
 06CF   1   66| 8B 5C 04	      mov ebx,Dptr[si+4]
 06D3   1   66| 89 13		      mov Dptr(V.String),edx
 06D6   2   66| 89 5B 04	      mov Dptr(V.String+4),ebx
 06DA   1   80 C1 80		      add cl,$NullString
 06DD   2   88 4B 07		      mov V.Dtype,cl
 06E0   1   5E			      pop CursorSi
				      BackRet
 06E1   5   C3			  1  ret
				     ; If it is long now it must have been a long source.
 06E2   1   89 33		     @3p22Long:mov V.Pt,si
 06E4   2   89 4B 04		     mov V.Len,cx
 06E7   1   5E			     pop CursorSi
				     BackRet
 06E8   5   C3			  1  ret
 06E9   2   C6 43 07 80		     @3p22Null:mov V.Dtype,$NullString
 06ED   1   5E			     pop CursorSi
				     BackRet
 06EE   5   C3			  1  ret

 06EF				     @3p22ClipX:; Recovery end position.
 06EF   3   E8 0000 E		     call ToDsSiCx
 06F2				     @3p22Clip:; Scan back from far end
 06F2   1   03 F1		     add si,cx
 06F4   1   8A 44 FF		     @@:mov al,Bptr[si-1]
				     XlatBDLS
 06F7   4   2E: D7		  1   xlat Bptr cs:[bx]
 06F9   1   A8 C0		  1   test al,0C0h
 06FB  3,1  75 C4		     jnz @3p22Done
 06FD   1   4E			     dec si
 06FE   3   EB F4		     jmp @B

				     if Solid
				     ;$9.3.25
 0700  08			     db $WholeGT
 0701  8B			     ParmsRec <2,0,1011b>
 0702				     BifWORD:; Set what will be third arg of subword.
				     endif
 0702   2   66| 89 6B 0C	      mov V2.Mantissa,ebp
 0706   2   C6 43 0C 01		      mov Bptr V2.Mantissa,1
 070A   1   B0 80		      mov al,80h; Tell SUBWORD of extra parameter.
 070C   3   E9 FF65		      jmp BifSUBWORD

				     if Solid
				     ;$9.3.26
 070F  08			     db $WholeGT
 0710  8B			     ParmsRec <2,0,1011b>
 0711				     BifWORDINDEX:; Share subroutine with SUBWORD.
				     endif
				      Down
 0711   1   83 EF 08		  1   sub StackDi,$StrideV
 0714   3   E8 0000 E		      call ToDsSiCx; Address the string.
 0717   1   8B D6		      mov dx,si
 0719   3   E8 000D		      call WordIndex
 071C   1   2B F2		      sub si,dx
 071E   2   89 73 04		      mov V.MantLow,si
 0721   1   66| 89 2B		      mov V.ExpAnd,ebp
				      z V.MantHigh
 0724   2   89 6B 06		  1           mov V.MantHigh,bp
 0727   1   5E			      pop CursorSi
				      BackRet
 0728   5   C3			  1  ret

 0729				     WordIndex:; Used on Ds:Si:Cx. If not found si not changed (and cx=0), else
				     ; si one beyond found character (and cx one more than matching si).
				     ; Requires V2.Mantissa as first word count, which is zeroed.
				     ; ax is altered, bx set to the table.
 0729   1   56			      push si
				      JcxzQ @3p26Zero
 072A   1   85 C9		  1    test cx,cx
 072C  3,1  74 22		  1    je @3p26Zero
 072E   1   BB 0000 E		      mov bx,Attributes; Prepare to test AllBlanks.
				     ; Move SI on to nonblank.
 0731   1   46			      inc si
 0732   1   4E			     @3p26LoopX:dec si
 0733   5   AC			     @3p26Loop:lodsb
				      XlatBDLS
 0734   4   2E: D7		  1   xlat Bptr cs:[bx]
 0736   1   A8 C0		  1   test al,0C0h
 0738  3,1  75 05		      jnz @F
				      LoopQ @3p26Loop
 073A   1   49			  1    dec cx
 073B  3,1  75 F6		  1    jnz @3p26Loop
 073D   3   EB 11		      jmp @3p26Zero
				     ; Is this the wanted word?
 073F   4   66| FF 4B 0C	     @@:dec V2.Mantissa
 0743  3,1  74 0D		     jz @3p26
 0745   1   4E			      dec si; Simplest
				     ; Move SI on to blank and cycle.
 0746   5   AC			     @@:lodsb
				     XlatBDLS
 0747   4   2E: D7		  1   xlat Bptr cs:[bx]
 0749   1   A8 C0		  1   test al,0C0h
 074B  3,1  74 E5		     jz @3p26LoopX
				     LoopQ @B
 074D   1   49			  1    dec cx
 074E  3,1  75 F6		  1    jnz @B
 0750   1   5E			     @3p26Zero:pop CursorSi
				     BackRet
 0751   5   C3			  1  ret
 0752   1   58			     @3p26:pop ax
 0753   5   C3			     ret

				     if Solid
				     ;$9.3.30
 0754  18			      db $Pad
 0755  18			      db $Pad
 0756  23			      ParmsRec <0,2,0011b>
 0757				     BifXRANGE:; cl for 'around to', dl for 'first value'.
				     endif
				      z dx
 0757   1   8B D5		  1           mov dx,bp
 0759   1   B9 00FF		      mov cx,0FFh
 075C   1   A8 81		      test al,81h
 075E  3,1  74 0B		      jz @3p30
 0760   2   8A 4B 08		      mov cl,V2.String
 0763  3,1  78 06		      js @3p30
				     ; Two extras present.
 0765   2   8A 53 08		      mov dl,V2.String
 0768   2   8A 4B 10		      mov cl,V3.String
 076B   1   2A CA		     @3p30:sub cl,dl
 076D   1   41			      inc cx
				      Up
 076E   1   83 C7 08		  1   add StackDi,$StrideV
 0771   3   E8 0000 E		      call ResultSpace
				      JcxzQ @3p30ret
 0774   1   85 C9		  1    test cx,cx
 0776  3,1  74 0B		  1    je @3p30ret
 0778   1   57			      push StackDi
 0779   1   8B F8		      mov di,ax
 077B   1   8A C2		      mov al,dl
 077D   5   AA			     @@:stosb
 077E   1   FE C0		      inc al
 0780  2,6  E2 FB		      loop @B
 0782   1   5F			      pop StackDi
 0783				     @3p30ret:
 0783   3   E9 0000 E		      jmp RetEsSi

				     if Solid
				     ;$9.4.1
 0786  0C			      db $Num
 0787  47			      ParmsRec <1,0,0111b>
 0788				     BifABS:
				     endif
 0788   3   E8 0000 E		      call NumDxBx; !! not required when we change constants.
				     ; Longs in bifs !!
 078B   3   80 23 FE		      and V.Sign,0FEh
 078E   1   5E			      pop CursorSi
				      BackRet
 078F   5   C3			  1  ret

				     if Solid
				     ;$9.4.5
 0790  0C			      db $Num
 0791  47			      ParmsRec <1,0,0111b>
 0792				     BifSIGN:
				     endif
 0792   3   E8 0000 E		      call NumDxBx
 0795   1   66| 8B CD		      mov ecx,ebp
 0798   2   F6 03 01		      test V.Sign,1
 079B  3,1  74 06		      jz @F
 079D   1   41			      inc cx
 079E   1   66| 89 0B		      mov V.ExpAnd,ecx
 07A1   3   EB 0A		      jmp @4p5
 07A3				      @@:
 07A3   1   66| 89 2B		      mov V.ExpAnd,ebp
 07A6   3   66| 39 6B 04	      cmp V.Mantissa,ebp
 07AA  3,1  74 01		      jz @4p5
 07AC   1   41			      inc cx
 07AD   2   66| 89 4B 04	     @4p5:mov V.Mantissa,ecx
 07B1   1   5E			      pop CursorSi
				      BackRet
 07B2   5   C3			  1  ret

				     if Solid
				     ;$9.5.1
 07B3  45 49 4E 4F		      db "EINO"
 07B7  FC			      db -@SizeStr(<EINO>)
 07B8  17			      ParmsRec <0,1,0111b>
 07B9				     BifADDRESS:; More to come
				     endif
 07B9   3   E8 0000 E		      call HeritageDi
				     ; L.Active.EnvNumber identifies the address. Jan 00 not decided on where
				     ; actual name is.
 07BC   1   5F			      pop StackDi
				     ; Return "DOS" for now.
				      Up
 07BD   1   83 C7 08		  1   add StackDi,$StrideV
 07C0   1   66| 2E: 8B 4E 3A	      mov ecx,Y.DOS
 07C5   1   66| 89 0B		      mov Dptr(V.String),ecx
 07C8   2   C6 43 07 83		      mov Bptr(V.Dtype),$NullString+3
 07CC   1   5E			      pop CursorSi
				      BackRet
 07CD   5   C3			  1  ret

				     if Solid
				     ;$9.5.2
 07CE  45 4E 4F			      db "ENO"
 07D1  FD			      db -@SizeStr(<ENO>)
 07D2  08			      db $WholeGT
 07D3  23			      ParmsRec <0,2,0011b>
 07D4				     BifARG:
				     endif
				     ; Moot point whether we should have put both ends of arglist in the
				     ; Level block.  (Loses when BifARG not used.)
				     ; Si to be result, most cases.
				      Up
 07D4   1   83 C7 08		  1   add StackDi,$StrideV
 07D7   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 07DA  3,1  74 13		      je @5p2Pcode
				     ; Crude for BCycle bifs.  Only MAX MIN FORMAT use arg() internally.
 07DC   3   0F B6 B6 0129	      movzx si,Z.ArgsB
 07E1   1   46			      inc si
 07E2   1   A8 81		      test al,81h
 07E4  3,1  74 46		      jz @5p2None
				     ; Numeric arg index to bx
 07E6   3   E8 0000 E		      call NumDxBx
 07E9   1   8B 8E 012A		      mov cx,Z.ArgsB0
 07ED   3   EB 4A		      jmp @5p2One

 07EF   1   8B 76 52		     @5p2Pcode:mov si,Z.Level
 07F2   2   8B 4A 06		     mov cx,Lsi.Arg0
 07F5   1   83 EE 7C		     sub si,$StrideL
 07F8   1   2B F1		      sub si,cx
 07FA   2   C1 EE 03		      shr si,$ShiftV; arg()
 07FD   1   A8 81		      test al,81h
 07FF  3,1  74 2B		      jz @5p2None
				     ; Numeric arg index to bx
 0801   3   E8 0000 E		      call NumDxBx
 0804   1   A8 81		      test al,81h
 0806  3,1  78 31		      js @5p2One
				     ; There is an option.
				      Up
 0808   1   83 C7 08		  1   add StackDi,$StrideV
 080B   3   E8 0000 E		      call UpperFirstAh; to ah
				      Down
 080E   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; arg(9999) will be non-existant
 0811   1   3B DE		      cmp bx,si
				      z si
 0813   1   8B F5		  1           mov si,bp
 0815  3,1  77 0D		      ja @5p2Omitted
 0817   2   C1 E3 03		      shl bx,$ShiftV
 081A   1   03 D9		      add bx,cx
 081C   2   36: 80 7F 07 88	      cmp Vbxs.Dtype,$Omitted
 0821  3,1  74 01		      je @F
 0823   1   46			      inc si
 0824				      @@:
 0824   1   80 FC 4F		     @5p2Omitted:cmp ah,'O'
 0827  3,1  75 03		      jne @5p2None
 0829   1   83 F6 01		      xor si,1
 082C				     @5p2None:; Use si as the result.
 082C   1   66| 89 2B		      mov V.ExpAnd,ebp
 082F   3   66| 0F B7 F6	      movzx esi,si
 0833   2   66| 89 73 04	      mov V.Mantissa,esi
 0837   1   5E			     @5p2Ret:pop CursorSi
				      BackRet
 0838   5   C3			  1  ret
 0839   1   3B DE		     @5p2One:cmp bx,si
 083B   2   C6 43 07 80		      mov V.Dtype,$NullString
 083F  3,1  77 F6		      ja @5p2Ret
 0841   2   C1 E3 03		      shl bx,$ShiftV
 0844   1   03 D9		      add bx,cx
				      Move V,Vbxs,edx
 0846   1   66| 36: 8B 17	  1    mov edx,Vbxs.OverExpo
 084A   1   66| 89 13		  1    mov V.OverExpo,edx
 084D   1   66| 36: 8B 57 04	  1    mov edx,Vbxs.OverMant
 0852   2   66| 89 53 04	  1    mov V.OverMant,edx
 0856   3   EB DF		      jmp @5p2Ret

				     if Solid
				     ;$9.5.3
 0858  43 44 45 49 53		      db "CDEIS"
 085D  FB			      db -@SizeStr(<CDEIS>)
 085E  17			      ParmsRec <0,1,0111b>
 085F				     BifCONDITION:
				     endif
				      Up; Arg, will be result.
 085F   1   83 C7 08		  1   add StackDi,$StrideV
 0862   1   A8 81		      test al,81h
 0864  3,1  74 1F		      jz @5p3I; Default is 'I'
 0866   3   E8 0000 E		      call UpperFirstAh
 0869   1   80 FC 44		      cmp ah,'D'
 086C  3,1  75 17		      jne @F
 086E   3   E8 0000 E		      call HeritageDi
 0871   1   8B F7		      mov LevelSi,LevelDi
 0873   1   5F			      pop StackDi
				      Move V,Lsi.ConditionDescription
 0874   2   66| 8B 4A C4	  1     mov ecx,Lsi.ConditionDescription.OverExpo
 0878   1   66| 89 0B		  1     mov V.OverExpo,ecx
 087B   2   66| 8B 42 C8	  1     mov eax,Lsi.ConditionDescription.OverMant
 087F   2   66| 89 43 04	  1     mov V.OverMant,eax
				      RetSi
 0883   1   5E			  1   pop CursorSi
 0884   5   C3			  1   ret
 0885				     @5p3I:
 0885   5p  FF D5		     @@:Error49Bp

				     if Solid
				     ;$9.5.4
 0887  0F			      ParmsRec <0,0,1111b>
 0888				     BifDIGITS:
				     endif
 0888   1   8B 4E 5F		      mov cx,Z.Digits
 088B				     @5p4Like:Up
 088B   1   83 C7 08		  1   add StackDi,$StrideV
				      z V.MantHigh
 088E   2   89 6B 06		  1           mov V.MantHigh,bp
 0891   2   89 4B 04		      mov V.MantLow,cx
 0894   1   66| 89 2B		      mov V.ExpAnd,ebp
 0897   1   5E			      pop CursorSi
				      BackRet
 0898   5   C3			  1  ret
				     if Solid
				     ;$9.5.6
 0899  0F			      ParmsRec <0,0,1111b>
 089A				     BifFORM:
				     endif
 089A   3   E8 0000 E		      call HeritageDi
 089D   2   8A 43 90		      mov al,L.Form
 08A0   1   5F			      pop StackDi
				      Up
 08A1   1   83 C7 08		  1   add StackDi,$StrideV
 08A4   1   BB 00BC		      mov bx,$?S
 08A7   1   3C 53		      cmp al,'S'
 08A9  3,1  74 03		      je @F
 08AB   1   83 C3 F8		      add bx,$?E-$?S
 08AE				      @@:
				      Move V,Vbxe
 08AE   1   66| 26: 8B 0F	  1     mov ecx,Vbxe.OverExpo
 08B2   1   66| 89 0B		  1     mov V.OverExpo,ecx
 08B5   1   66| 26: 8B 47 04	  1     mov eax,Vbxe.OverMant
 08BA   2   66| 89 43 04	  1     mov V.OverMant,eax
 08BE   1   5E			      pop CursorSi
				      BackRet
 08BF   5   C3			  1  ret

				     if Solid
				     ;$9.5.7
 08C0  0F			      ParmsRec <0,0,1111b>
 08C1				     BifFUZZ:
				     endif
 08C1   1   8B 4E 61		      mov cx,Z.Fuzz
 08C4   3   EB C5		      jmp @5p4Like

				     if Solid
				     ;$9.5.8
 08C6  08			      db $WholeGT
 08C7  17			      ParmsRec <0,1,0111b>
 08C8				     BifSOURCELINE:
				     endif
 08C8   6p  C5 5E 3C		      lds bx,Z.SysFile
 08CB   1   66| 8B 4F EA	      mov ecx,F.Lines
 08CF   1   A8 81		      test al,81h
 08D1  3,1  75 09		      jnz @5p8One
				     ; No args - return line count of file.
 08D3   3   E8 0000 E		      call Zero$$
 08D6   2   66| 89 53 04	      mov V.Mantissa,edx
				      RetSi
 08DA   1   5E			  1   pop CursorSi
 08DB   5   C3			  1   ret
 08DC				     @5p8One:; Check against current source file line count.
				      Up
 08DC   1   83 C7 08		  1   add StackDi,$StrideV
 08DF   3   E8 0000 E		      call ToWholeEbx
 08E2   1   66| 3B D9		      cmp ebx,ecx
 08E5   1   B0 22		      mov al,34
 08E7  3,1  0F 87 0000 E	      ja Raise40
 08EB   5p  FF D5		      Error49Bp; NYI

				     if Solid
				     ;$9.5.9
 08ED				     TraceVerb$:
 08ED  41 43 45 46 49 4C 4E 4F	       db "ACEFILNOR?"
	      52 3F
 08F7  F6			       db -@SizeStr(<ACEFILNOR?>)
 08F8  17			       ParmsRec <0,1,0111b>
 08F9				     BifTRACE:
				     endif
				     ; 2011 There is no mandatory argument to TRACE. So the general bif
				     ; mechanism will have set StackDi to reflect no argument and set
				     ; Al to the Pcode byte value, which contains count of the optionals.
				     ; Collect any parameter, setup LevelDi, and note previous trace setting.
				      z si
 08F9   1   8B F5		  1           mov si,bp
 08FB   1   A8 81		      test al,81h
 08FD  3,1  74 09		      jz @F
				      Up
 08FF   1   83 C7 08		  1   add StackDi,$StrideV
 0902   3   E8 0000 E		      call ToDsSiCx
				      Down
 0905   1   83 EF 08		  1   sub StackDi,$StrideV
 0908				      @@:
 0908   3   E8 0000 E		      call HeritageDi
 090B   2   8B 53 99		      mov dx,L.TraceWord
				     ; If there was a parameter, alter trace setting to reflect it.
				      TestReg si
 090E   1   85 F6		  1         test si,si
 0910  3,1  74 2A		      jz @5p9Show
 0912   1   B0 4E		      mov al,'N'
				      JcxzQ @5p9Null
 0914   1   85 C9		  1    test cx,cx
 0916  3,1  74 1D		  1    je @5p9Null
 0918   5   AC			     @@:lodsb
 0919   1   3C 3F		      cmp al,'?'
 091B  3,1  75 0A		      jne @F
 091D   9   0F BA 7B 99 01	      btc L.TraceWord,Interactive
				      LoopQ @B
 0922   1   49			  1    dec cx
 0923  3,1  75 F3		  1    jnz @B
 0925   3   EB 15		      jmp @5p9Show
 0927   1   3C 61		     @@:cmp al,'a'
 0929  3,1  72 06		      jb @F
 092B   1   3C 7A		      cmp al,'z'
 092D  3,1  77 02		      ja @F
 092F   1   24 DF		      and al,0DFh
 0931   1   3C 4F		      @@:cmp al,'O'
 0933  3,1  75 04		      jne @F
 0935				     @5p9Null:Off L.TraceWord,Interactive
 0935   4   80 63 99 FD		  1          and Bptr(L.TraceWord), low not ??0005
 0939   2   88 43 99		      @@:mov L.TraceLetter,al
 093C				     @5p9Show:; Letter or Questionmark letter.
				     ; 2011 Up whether optional or not, to place for result.
				     ; pop StackDiTestReg sijnz @FUp@@:
 093C   1   5F			      pop StackDi
				      Up
 093D   1   83 C7 08		  1   add StackDi,$StrideV
 0940   1   B0 81		      mov al,$NullString+1
				      Qry dh,Interactive
 0942   1   F6 C6 02		  1          test dh, ??0006
 0945  3,1  74 05		      jz @F
 0947   1   40			      inc ax
 0948   1   8A F2		      mov dh,dl
 094A   1   B2 3F		      mov dl,'?'
 094C				      @@:
 094C   1   89 13		      mov Wptr(V.String),dx
 094E   2   88 43 07		      mov V.Dtype,al
				      RetSi
 0951   1   5E			  1   pop CursorSi
 0952   5   C3			  1   ret

 0953   3   E8 0000 E		     Trace$:call ToDsSiCx
 0956   3   E8 0000 E		     call HeritageDi
 0959   1   B0 4E		     mov al,'N'
				     JcxzQ InterOff
 095B   1   85 C9		  1    test cx,cx
 095D  3,1  74 39		  1    je InterOff
 095F   5   AC			     @@:lodsb
 0960   1   3C 3F		     cmp al,'?'
 0962  3,1  75 0A		     jne @F
 0964   9   0F BA 7B 99 01	     btc L.TraceWord,Interactive
				     LoopQ @B
 0969   1   49			  1    dec cx
 096A  3,1  75 F3		  1    jnz @B
 096C   3   EB 31		     jmp TraceRet
 096E   1   3C 61		     @@:cmp al,'a'
 0970  3,1  72 06		     jb @F
 0972   1   3C 7A		     cmp al,'z'
 0974  3,1  77 02		     ja @F
 0976   1   24 DF		     and al,0DFh
 0978				     @@:
				     ; Test match in string.
				      mv ds,cs
 0978   3   0E			  1   push cs
 0979   3p  1F			  1   pop ds
 097A   1   BB 08ED R		      mov SpecsBx,TraceVerb$
 097D   1   B9 0009		      mov cx,@SizeStr(<ACEFILNOR>)
 0980   2   3A 07		     @@:cmp al,Bptr[SpecsBx]
 0982  3,1  74 10		      je TraceOK
 0984   1   43			      inc SpecsBx
 0985  2,6  E2 F9		      loop @B
 0987   1   5F			      pop StackDi
 0988   1   88 03		      mov V.String,al
 098A   1   B8 1801		      mov ax,MkMajMin(24,1)
 098D   2   C6 43 07 81		      mov V.Dtype,$NullString+1
 0991   3   E9 0000 E		      jmp Raise
 0994   1   3C 4F		     TraceOK:cmp al,'O'
 0996  3,1  75 04		      jne @F
 0998				     InterOff:Off L.TraceWord,Interactive
 0998   4   80 63 99 FD		  1          and Bptr(L.TraceWord), low not ??0007
 099C   2   88 43 99		     @@:mov L.TraceLetter,al
 099F   1   5F			     TraceRet:pop StackDi
				      Down
 09A0   1   83 EF 08		  1   sub StackDi,$StrideV
 09A3   1   5E			      pop CursorSi
 09A4   3   E9 0000 E		      jmp DualSwitch

				     ; TRACE verb.
 09A7   1   56			     Trace$$:push CursorSi
				     ; Omitted parameter was supplied at compile time.
 09A8   3   E8 0000 E		      call NumDxBx
 09AB  3,1  72 A6		      jc Trace$
 09AD   3   E8 0000 E		      call ToWholeEbx
 09B0   1   B8 1A07		      mov ax,MkMajMin(26,7)
 09B3  3,1  0F 82 0000 E	      jc Raise
				     ; Z.InhibitTrace Z.InhibitPauses NYI
 09B7   1   5E			      pop CursorSi
 09B8   3   E9 0000 E		      jmp DualSwitch

				     if Solid
				     ;$9.7.1
 09BB  04			      db $WholeGE
 09BC  08			      db $WholeGT
 09BD  20			      db $Stream
 09BE  31			      ParmsRec <0,3,0001b>
 09BF				     BifCHARIN:
				     endif
 09BF   5p  FF D5		      Error49Bp

				     if Solid
				     ;$9.7.2
 09C1  08			      db $WholeGT
 09C2  20			      db $Stream
 09C3  35			      ParmsRec <0,3,0101b>
 09C4				     BifCHAROUT:
				     endif
 09C4   5p  FF D5		      Error49Bp

				     ;MASM..............................
				     if Solid
				     ;$9.7.8
				     ; Further test.
 09C6  43 44 53			      db "CDS"
 09C9  FD			      db -@SizeStr(<CDS>)
 09CA  20			      db $Stream
 09CB  63			      ParmsRec <1,2,0011b>
 09CC				     BifSTREAM:
				     endif
 09CC   5p  FF D5		      Error49Bp

				     if Solid
				     ;$9.8.2
 09CE  0F			      ParmsRec <0,0,1111b>
 09CF				     BifQUEUED:
				     endif
				     ; We also use this one for just loading the value of a Bcode variable the
				     ; stack.
				      Qry Z.Cancel,BcodeInterpret
 09CF   2   F6 46 04 40		  1          test Bptr(Z.Cancel), low ??0008
 09D3  3,1  74 16		      jz @F
				     ; See B4VALUE2
				      Up
 09D5   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Ve[$?OUTCOME]
 09D8   1   66| 26: 8B 4E 44	  1     mov ecx,Ve[$?OUTCOME].OverExpo
 09DD   1   66| 89 0B		  1     mov V.OverExpo,ecx
 09E0   1   66| 26: 8B 46 48	  1     mov eax,Ve[$?OUTCOME].OverMant
 09E5   2   66| 89 43 04	  1     mov V.OverMant,eax
				      RetSi
 09E9   1   5E			  1   pop CursorSi
 09EA   5   C3			  1   ret

				     ; The Rexx queue is in Z.Serial when acted on.
 09EB   1   B0 01		     @@:mov al,$SerialQue
 09ED   3   E8 0000 E		     call Serialize
				     ; Length of aggregate is first word of Z.Serial.
				     ; Items have their length at both ends of the item.
				      z cx
 09F0   1   8B CD		  1           mov cx,bp
				      z si
 09F2   1   8B F5		  1           mov si,bp
 09F4   2   3B B6 01AB		     @@:cmp si,Wptr Z.Serial
 09F8  3,1  73 07		      jnb @F
 09FA   1   41			      inc cx
 09FB   3   03 B2 01AD		      add si,Wptr ss:Z.Serial[si+2]
 09FF   3   EB F3		      jmp @B
 0A01				     @@:Up
 0A01   1   83 C7 08		  1   add StackDi,$StrideV
				      z V.Mantissa
 0A04   2   66| 89 6B 04	  1             mov V.Mantissa,ebp
				      z V.ExpAnd
 0A08   1   66| 89 2B		  1             mov V.ExpAnd,ebp
 0A0B   2   89 4B 04		      mov Wptr V.Mantissa,cx
 0A0E   1   5E			      pop CursorSi
				      BackRet
 0A0F   5   C3			  1  ret

				     if Solid
				     ;$9.8.3
 0A10  04			      db $WholeGE
 0A11  04			      db $WholeGE
 0A12  04			      db $WholeGE
 0A13  31			      ParmsRec <0,3,0001b>
 0A14				     BifRANDOM:
				     endif
				      Up; Adjust to position of result.
 0A14   1   83 C7 08		  1   add StackDi,$StrideV
				     ; set ecx=minimum ebx=maximum
				      z ecx
 0A17   1   66| 8B CD		  1             mov ecx,ebp
 0A1A   1   66| 2E: 8B 5E 10	      mov ebx,Y.N1000
 0A1F   1   66| 4B		      dec ebx
 0A21   1   A8 81		      test al,81h
 0A23  3,1  74 28		      jz @3p8None
 0A25  3,1  7A 12		      jpe @3p8Three
 0A27  3,1  79 10		      jns @3p8Two
 0A29   2   66| 8B 5B 04	      mov ebx,V.Mantissa
 0A2D   2   66| 2E: 3B 5E 18	      cmp ebx,Y.N1e5
 0A32  3,1  76 19		      jbe @3p8None
 0A34   1   B0 1F		      mov al,31
 0A36   3   E9 0000 E		      jmp Raise40
 0A39				     @3p8Three:
 0A39   3   80 7B 07 88		     @3p8Two:cmp V.Dtype,$Omitted
 0A3D  3,1  74 04		      je @F
 0A3F   2   66| 8B 4B 04	      mov ecx,V.Mantissa
 0A43				      @@:
 0A43   3   80 7B 0F 88		      cmp V2.Dtype,$Omitted
 0A47  3,1  74 04		      je @F
 0A49   2   66| 8B 5B 0C	      mov ebx,V2.Mantissa
 0A4D				      @@:
				     ; Put Min and Max down for messages. (And result)
 0A4D   2   66| 89 4B 04	     @3p8None:mov V.Mantissa,ecx
 0A51   1   66| 89 2B		     mov V.ExpAnd,ebp
 0A54   2   66| 89 5B 0C	      mov V2.Mantissa,ebx
 0A58   2   66| 89 6B 08	      mov V2.ExpAnd,ebp
				     ; Change ebx to be the range.
 0A5C   1   66| 2B D9		      sub ebx,ecx
 0A5F  3,1  74 62		      jz @3p8Out
 0A61  3,1  0F 8C 0000 E	      jl Raise40p33
 0A65   2   66| 2E: 3B 5E 18	      cmp ebx,Y.N1e5
 0A6A  3,1  0F 8F 0000 E	      jg Raise40p32
				     ; The rest follows IBM but I don't suppose they will mind since Rick
				     ; told SHARE all about it and inventive part is from Knuth.
 0A6E   1   3C D1		      cmp al,81h+2*$BifRANDOM
 0A70  3,1  75 11		      jne @F
				     ; ConfigRandomSeed
 0A72   2   66| 8B 4B 14	      mov ecx,V3.Mantissa
 0A76   1   66| F7 D1		      not ecx
 0A79   1   66| 89 4E 28	      mov Z.Seed,ecx
				      On Z.Program,RandomSeeded
 0A7D   3   80 4E 03 02		  1          or  Bptr(Z.Program+1), high ??0009
 0A81   3   EB 1B		      jmp Fiddling;
 0A83   8   0F BA 6E 02 09	     @@:bts Z.Program,RandomSeeded
 0A88  3,1  72 1C		      jc Seeded
				     ; Set cx and dx from timer.
 0A8A   1   B4 2C		      mov ah,$DosTime
 0A8C  30   CD 21		      int 21h
 0A8E   1   89 4E 28		      mov Wptr Z.Seed,cx
 0A91   1   89 56 2A		      mov Wptr Z.Seed+2,dx
				     ; Might as well include the date.
 0A94   1   B4 2A		      mov ah,$DosDate
 0A96  30   CD 21		      int 21h
 0A98   3   31 4E 28		      xor Wptr Z.Seed,cx
 0A9B   3   31 56 2A		      xor Wptr Z.Seed+2,dx
 0A9E				     Fiddling:
				     ; Try to remove some non-randomness in relations of bits.
 0A9E   1   B9 000D		      mov cx,13
 0AA1   3   E8 0021		      @@:call Random
 0AA4  2,6  E2 FB		      loop @B
 0AA6   3   E8 001C		     Seeded:call Random
				     ; Convert latest internal to result. First reverse the bits.
 0AA9   1   B9 0020		      mov cx,32
 0AAC   3   66| D1 D0		      @@:rcl eax,1
 0AAF   3   66| D1 DA		      rcr edx,1
 0AB2  2,6  E2 F8		      loop @B
 0AB4   1   66| 8B C2		      mov eax,edx
				     ; Divide by range+1
 0AB7   1   66| 43		      inc ebx
				      z edx
 0AB9   1   66| 8B D5		  1             mov edx,ebp
 0ABC  40   66| F7 F3		      div ebx
 0ABF   4   66| 01 53 04	      add V.Mantissa,edx
 0AC3   1   5E			     @3p8Out:pop CursorSi
				      BackRet
 0AC4   5   C3			  1  ret
 0AC5				     Random:; ConfigRandomNext
 0AC5   1   66| 8B 46 28	      mov eax,Z.Seed
 0AC9  13+  66| 2E: F7 66 2C	      mul Y.N1664525
 0ACE   1   66| 40		      inc eax
 0AD0   1   66| 89 46 28	      mov Z.Seed,eax
 0AD4   5   C3			      ret

				     if Solid
				     ;$9.8.4
 0AD5  4F			      ParmsRec <1,0,1111b>
 0AD6				     BifSYMBOL:
				     endif
 0AD6   3   E8 0000 E		      call ToDsSiCx
				     ; We are not setup to share code with compile time because "next char" at
				     ; compile time can mean detecting end-of-buffer while execution time is
				     ; about a string with length count.
				     ; So we can share amongst SYMBOL & VALUE & VarPool & DROP() & EXPOSE()
				     ; but not much more without a rewrite.
				      JcxzQ IsBad
 0AD9   1   85 C9		  1    test cx,cx
 0ADB  3,1  74 07		  1    je IsBad
 0ADD   3   E8 002D		      call SymbolLook
				      JcxzQ @F
 0AE0   1   85 C9		  1    test cx,cx
 0AE2  3,1  74 09		  1    je @F
 0AE4   1   66| C7 03 20444142	     IsBad:mov Dptr V.String,StringOrder('B','A','D',' ')
 0AEB   3   EB 1A		      jmp RetSym
 0AED   1   85 DB		     @@:test bx,bx
 0AEF  3,1  75 0F		      jnz IsLit
				     ; NYI What nonsense bx is not result of Lookup.
 0AF1   2   80 7F 07 40		      cmp Vbx.Dtype,$Dropped
 0AF5  3,1  74 09		      je IsLit
 0AF7   1   66| C7 03 20524156	      mov Dptr V.String,StringOrder('V','A','R',' ')
 0AFE   3   EB 07		      jmp RetSym
 0B00   1   66| C7 03 2054494C	     IsLit:mov Dptr V.String,StringOrder('L','I','T',' ')
 0B07   2   C6 43 07 83		     RetSym:mov V.Dtype,$NullString+3
 0B0B   1   5E			      pop CursorSi
				      BackRet
 0B0C   5   C3			  1  ret


				     ; DS:SI:CX is the string to scan. Scan ends with string exhausted or end of
				     ; part with symbol syntax. SI & CX are updated.  AX used. DX kept.
				     ; Carry set iff not syntax of symbol.
				     ; bx = 0 for a variable name.
 0B0D				     SymbolLook:; si set to be past symbol.  bx used.
 0B0D   1   52			      push dx
				      JcxzQ SymBad
 0B0E   1   85 C9		  1    test cx,cx
 0B10  3,1  74 2C		  1    je SymBad
 0B12   1   BB 0000 E		      mov bx,Attributes
				      z dx
 0B15   1   8B D5		  1           mov dx,bp
				     ; First character a letter if this is a variable name.
 0B17   1   8A 04		      mov al,[si]
 0B19   1   8A E0		      mov RawCharAh,al
				      XlatBDLS
 0B1B   4   2E: D7		  1   xlat Bptr cs:[bx]
 0B1D   1   A8 C0		  1   test al,0C0h
 0B1F  3,1  7A 1D		      jpe SymBad
 0B21  3,1  79 1E		      jns SymLit
 0B23   1   80 FC 2E		      cmp RawCharAh,'.'
 0B26  3,1  74 19		      je SymLit
				     ; Go to limit of letters and digits.
 0B28   1   42			     SymLoop:inc dx
 0B29   5   AC			     lodsb
				     XlatBDLS
 0B2A   4   2E: D7		  1   xlat Bptr cs:[bx]
 0B2C   1   A8 C0		  1   test al,0C0h
 0B2E  3,1  7A 03		     jpe @F
				     LoopQ SymLoop
 0B30   1   49			  1    dec cx
 0B31  3,1  75 F5		  1    jnz SymLoop
 0B33				     @@:
 0B33   1   81 FA 00FA		      cmp dx,$Limit_Name
 0B37  3,1  77 05		      ja SymBad
				      z bx
 0B39   1   8B DD		  1           mov bx,bp
 0B3B   2   F8			      clc
 0B3C   1   5A			      pop dx
 0B3D   5   C3			      ret
 0B3E   2   F9			     SymBad:stc
 0B3F   1   5A			      pop dx
 0B40   5   C3			      ret

				     ; Scan to distinguish BAD from LIT.
				     SymRec record SRpad:11, HadDigits:1, HadDot:1, NotNumber:1, HadSign:1, HadE:1

 0B41   5   AC			     SymLit:lodsb; At most one dot in a number.
 0B42   1   3C 2E		     cmp RawCharAl,'.'
 0B44  3,1  75 0B		      jne @F
 0B46   1   F6 C2 02		      test dl,mask HadSign
 0B49  3,1  75 F3		      jnz SymBad
 0B4B   6   0F BA EA 03		      bts dx,HadDot
 0B4F  3,1  72 3F		      jc SymNotNum
 0B51				      @@:
				     ; Specials not allowed except +- absorbed by exponent.
				      XlatBDLS
 0B51   4   2E: D7		  1   xlat Bptr cs:[bx]
 0B53   1   A8 C0		  1   test al,0C0h
 0B55  3,1  7A E7		      jpe SymBad
 0B57  3,1  78 05		      js SymLet
 0B59   1   80 CA 10		      or dl,mask HadDigits
 0B5C   3   EB 2C		      jmp SymLoo
 0B5E   1   F6 C2 04		     SymLet:test dl,mask NotNumber
 0B61  3,1  75 27		      jnz SymLoo
				      JcxzQ SymNotNum
 0B63   1   85 C9		  1    test cx,cx
 0B65  3,1  74 29		  1    je SymNotNum
 0B67   1   A8 01		      test al,$Ee
 0B69  3,1  74 25		      jz SymNotNum
 0B6B   1   F6 C2 10		      test dl,mask HadDigits
 0B6E  3,1  74 20		      jz SymNotNum
 0B70   6   0F BA EA 00		      bts dx,HadE
 0B74  3,1  72 1A		      jc SymNotNum
 0B76   2   80 3C 2B		      cmp Bptr[si],'+'
 0B79  3,1  74 05		      je SymSign
 0B7B   2   80 3C 2D		      cmp Bptr[si],'-'
 0B7E  3,1  75 0A		      jne SymLoo
 0B80   1   F6 C2 04		     SymSign:test dl,mask NotNumber
 0B83  3,1  75 B9		      jnz SymBad
 0B85   1   46			      inc si
 0B86   1   49			      dec cx
 0B87   1   80 CA 02		      or dl,mask HadSign
 0B8A				     SymLoo:LoopQ SymLit
 0B8A   1   49			  1    dec cx
 0B8B  3,1  75 B4		  1    jnz SymLit
 0B8D   2   F8			      clc
 0B8E   1   5A			      pop dx
 0B8F   5   C3			      ret

 0B90   1   F6 C2 02		     SymNotNum:test dl,mask HadSign
 0B93  3,1  75 A9		     jnz SymBad
 0B95   1   80 CA 04		     or dl,mask NotNumber
 0B98   3   EB F0		     jmp SymLoo

 0B9A   1   B0 1A		     Raise40p26:mov al,26
 0B9C   3   E9 0000 E		     jmp Raise40

				     if Solid
				     ;$9.8.6
				     ; Could have $Symbol here but better to do that in the routine.
 0B9F  6F			      ParmsRec <1,2,1111b>
 0BA0				     BifVALUE:
				     endif
 0BA0   1   A8 81		      test al,81h
 0BA2  3,1  7F 56		      jg @8p6Three
 0BA4  3,1  75 2F		      jnz @8p6Two
				     ; One argument - return it's value.
				     ; Check it is not a bad symbol before do special interpret to get value.
 0BA6   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ Raise40p26
 0BA9   1   85 C9		  1    test cx,cx
 0BAB  3,1  74 ED		  1    je Raise40p26
				     ; We need a valid symbol and nothing left over.
 0BAD   3   E8 FF5D		      call SymbolLook
 0BB0  3,1  72 E8		      jc Raise40p26
				      TestReg cx
 0BB2   1   85 C9		  1         test cx,cx
 0BB4  3,1  75 E4		      jnz Raise40p26
 0BB6   1   5E			      pop CursorSi
 0BB7   1   BA 0000 E		      mov dx,offset B4VALUE1
 0BBA   3   E8 0000 E		      call LinkBcode
 0BBD   1   89 7E 06		      mov Z.Stack,StackDi
				      Up
 0BC0   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Ve[$?OUTCOME]
 0BC3   1   66| 26: 8B 4E 44	  1     mov ecx,Ve[$?OUTCOME].OverExpo
 0BC8   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0BCB   1   66| 26: 8B 46 48	  1     mov eax,Ve[$?OUTCOME].OverMant
 0BD0   2   66| 89 43 04	  1     mov V.OverMant,eax
 0BD4   5   C3			      ret
 0BD5				     @8p6Two:; Check first is non-constant symbol.
 0BD5   3   E8 0000 E		      call ToDsSiCx
				      JcxzQ Raise40p26
 0BD8   1   85 C9		  1    test cx,cx
 0BDA  3,1  74 BE		  1    je Raise40p26
 0BDC   3   E8 FF2E		      call SymbolLook
 0BDF  3,1  72 B9		      jc Raise40p26
				      TestReg cx
 0BE1   1   85 C9		  1         test cx,cx
 0BE3  3,1  75 B5		      jnz Raise40p26
				      TestReg bx
 0BE5   1   85 DB		  1         test bx,bx
 0BE7   1   B0 2B		      mov al,43
 0BE9  3,1  0F 85 0000 E	      jnz Raise40
				      Up
 0BED   1   83 C7 08		  1   add StackDi,$StrideV
 0BF0   1   5E			      pop CursorSi
 0BF1   1   BA 0000 E		      mov dx,offset B4VALUE2
 0BF4   3   E9 0000 E		      jmp LinkBcode
 0BF7   1   89 7E 06		      mov Z.Stack,StackDi

 0BFA				     @8p6Three:; DOS environment pool.
				     ; Since the code is in the DOS system for Get/Set of these variables it is
				     ; a shame it is not made available. Still, doesn't look like it is.
				     ; !! Check 3rd arg value. "ENVIRONMENT" used by Personal REXX.
				     ; IBM DOS 7 ??
				     ; NYI.  go back 13 bytes for word with para length. 'M' and our CS before.
				     ; Check out the pool name.(NYI - use DosPool & length check)
 0BFA   1   83 C7 10		      add StackDi,2*$StrideV
 0BFD   3   E8 0000 E		      call CONFIG_UPPER$$
 0C00   3   E8 0000 E		      call ToDsSiCx
 0C03   1   B0 25		      mov al,37
				      JcxzQ Raise40
 0C05   1   85 C9		  1    test cx,cx
 0C07  3,1  0F 84 0000 E	  1    je Raise40
				      mv es,cs
 0C0B   3   0E			  1   push cs
 0C0C   3p  07			  1   pop es
 0C0D   1   57			      push di
 0C0E   1   BF 003A		      mov di,Yshape.DOS
 0C11   8n  F3/ A6		      repe cmpsb
 0C13   1   5F			      pop di
 0C14  3,1  0F 85 0000 E	      jne Raise40
				     ; Fold the value's name, even in the environment case.
 0C18   1   83 EF 10		      sub StackDi,2*$StrideV
 0C1B   3   E8 0000 E		      call CONFIG_UPPER$$
 0C1E   3   E8 0000 E		      call ToDsSiCx
				     ; PSP ahead of code.
 0C21   3   8C C8		      mov ax,cs
 0C23   1   83 E8 10		      sub ax,10h
 0C26   3p  8E C0		      mov es,ax
 0C28   3p  26: 8E 06 002C	      mov es,es:[2Ch]
 0C2D   1   57			      push StackDi
				      z di
 0C2E   1   8B FD		  1           mov di,bp
 0C30   2   26: 80 3D 00	     @8p6Env:cmp Bptr es:[di],0
 0C34   1   B0 24		      mov al,36
 0C36  3,1  0F 84 0000 E	      jz Raise40
				     ; Compare this one with given.
				     ; Maybe some chaos if a null in user's string? Or an '='?
 0C3A   1   51			      push cx
 0C3B   1   56			      push si
 0C3C   8n  F3/ A6		      repe cmpsb
 0C3E   1   5E			      pop si
 0C3F   1   59			      pop cx
 0C40  3,1  75 06		      jnz @F
 0C42   2   26: 80 3D 3D	      cmp Bptr es:[di],'='
 0C46  3,1  74 0A		      je @8p6
				     ; Advance to next in environment.
 0C48   2   26: 80 7D FF 00	     @@:cmp Bptr es:[di-1],0
 0C4D  3,1  74 E1		     je @8p6Env
 0C4F   1   47			     inc di
 0C50   3   EB F6		     jmp @B

 0C52				     @8p6:; Value follows after '=' up to null.
 0C52   1   47			      inc di
 0C53   1   B9 FFFF		      mov cx,-1
				      z ax
 0C56   1   8B C5		  1           mov ax,bp
 0C58   6n  F2/ AE		      repne scasb; Find the null
 0C5A   1   F7 D9		      neg cx
 0C5C   1   49			      dec cx
 0C5D   1   8B F7		      mov si,di
 0C5F   1   2B F1		      sub si,cx
 0C61   1   49			      dec cx; SI for CX is result.
				     ; Copy to be result.
				      mv ds,es
 0C62   3   06			  1   push es
 0C63   3p  1F			  1   pop ds
 0C64   1   5F			      pop StackDi
 0C65   3   E8 0000 E		      call ResultSpace
 0C68   1   57			      push StackDi
 0C69   1   8B F8		      mov di,ax
				      Repmovsb
 0C6B   7n  F3/ A4		  1   rep movsb
 0C6D   1   5F			      pop StackDi
 0C6E   3   E9 0000 E		      jmp RetEsSi

				     if Solid
				     ;$9.3.14
 0C71  4F			      ParmsRec <1,0,1111b>
 0C72				     BifLENGTH:
 0C72   5p  FF D5		      Error49Bp; Not done by bif mechanism.
				     endif

 0C74   1   56			     @@:push CursorSi
 0C75   3   E8 0000 E		     call ToDsSiCx
 0C78   1   5E			     pop CursorSi
 0C79   2   8A 4B 07		     Length$$:mov cl,V.Dtype
 0C7C   1   F6 C1 C0		     test cl,$Test
 0C7F  3,1  79 F3		     jns @B
 0C81   1   66| 89 2B		      mov V.ExpAnd,ebp
				      z V.MantHigh
 0C84   2   89 6B 06		  1           mov V.MantHigh,bp
 0C87  3,1  7A 06		      jpe @F
 0C89   1   83 E1 07		      and cx,7
 0C8C   2   89 4B 04		      mov V.MantLow,cx
 0C8F				      @@:BackRet
 0C8F   5   C3			  1  ret

				     if Solid
				     ; Firstly the names, grouped by length for efficient lookup.
 0C90				     Bifs:
 0C90  0CA2 R			      dw Bifs3
 0C92  0CD6 R			      dw Bifs4
 0C94  0CF9 R			      dw Bifs5
 0C96  0D35 R			      dw Bifs6
 0C98  0DC1 R			      dw Bifs7
 0C9A  0E19 R			      dw Bifs8
 0C9C  0E2B R			      dw Bifs9
 0C9E  0E5D R			      dw Bifs10
 0CA0  0E73 R			      dw Bifs11
 0CA2				     BifNames:
 0CA2				     Bifs3:
 0CA2  41 52 47			      db "ARG"
 0CA5  A1			      db $BifTag+$BifARG
 0CA6  42 32 58			      db "B2X"
 0CA9  AD			      db $BifTag+$BifB2X
 0CAA  43 32 44			      db "C2D"
 0CAD  B1			      db $BifTag+$BifC2D
 0CAE  43 32 58			      db "C2X"
 0CB1  AC			      db $BifTag+$BifC2X
 0CB2  44 32 43			      db "D2C"
 0CB5  B2			      db $BifTag+$BifD2C
 0CB6  44 32 58			      db "D2X"
 0CB9  B3			      db $BifTag+$BifD2X
 0CBA  58 32 42			      db "X2B"
 0CBD  AE			      db $BifTag+$BifX2B
 0CBE  58 32 43			      db "X2C"
 0CC1  AF			      db $BifTag+$BifX2C
 0CC2  58 32 44			      db "X2D"
 0CC5  B0			      db $BifTag+$BifX2D
 0CC6  50 4F 53			      db "POS"
 0CC9  BC			      db $BifTag+$BifPOS
 0CCA  41 42 53			      db "ABS"
 0CCD  AA			      db $BifTag+$BifABS
 0CCE  4D 41 58			      db "MAX"
 0CD1  C4			      db $BifTag+$BifMAX
 0CD2  4D 49 4E			      db "MIN"
 0CD5  C5			      db $BifTag+$BifMIN
 0CD6				     Bifs4:
 0CD6  53 49 47 4E		      db "SIGN"
 0CDA  AB			      db $BifTag+$BifSIGN
 0CDB  4C 45 46 54		      db "LEFT"
 0CDF  BD			      db $BifTag+$BifLEFT
 0CE0  57 4F 52 44		      db "WORD"
 0CE4  B9			      db $BifTag+$BifWORD
 0CE5  46 4F 52 4D		      db "FORM"
 0CE9  9E			      db $BifTag+$BifFORM
 0CEA  46 55 5A 5A		      db "FUZZ"
 0CEE  A4			      db $BifTag+$BifFUZZ
 0CEF  44 41 54 45		      db "DATE"
 0CF3  80			      db $BifTag+$BifDATE
 0CF4  54 49 4D 45		      db "TIME"
 0CF8  81			      db $BifTag+$BifTIME
 0CF9				     Bifs5:
 0CF9  52 49 47 48 54		      db "RIGHT"
 0CFE  9A			      db $BifTag+$BifRIGHT
 0CFF  53 50 41 43 45		      db "SPACE"
 0D04  8F			      db $BifTag+$BifSPACE
 0D05  53 54 52 49 50		      db "STRIP"
 0D0A  89			      db $BifTag+$BifSTRIP
 0D0B  57 4F 52 44 53		      db "WORDS"
 0D10  8C			      db $BifTag+$BifWORDS
 0D11  54 52 55 4E 43		      db "TRUNC"
 0D16  8D			      db $BifTag+$BifTRUNC
 0D17  54 52 41 43 45		      db "TRACE"
 0D1C  A3			      db $BifTag+$BifTRACE
 0D1D  42 49 54 4F 52		      db "BITOR"
 0D22  B5			      db $BifTag+$BifBITOR
 0D23  43 48 41 52 53		      db "CHARS"
 0D28  83			      db $BifTag+$BifCHARS
 0D29  4C 49 4E 45 53		      db "LINES"
 0D2E  82			      db $BifTag+$BifLINES
 0D2F  56 41 4C 55 45		      db "VALUE"
 0D34  B7			      db $BifTag+$BifVALUE
 0D35				     Bifs6:
 0D35  41 42 42 52 45 56	      db "ABBREV"
 0D3B  94			      db $BifTag+$BifABBREV
 0D3C  44 49 47 49 54 53	      db "DIGITS"
 0D42  A5			      db $BifTag+$BifDIGITS
 0D43  43 45 4E 54 45 52	      db "CENTER"
 0D49  95			      db $BifTag+$BifCENTER
 0D4A  43 45 4E 54 52 45	      db "CENTRE"
 0D50  96			      db $BifTag+$BifCENTRE
 0D51  43 4F 50 49 45 53	      db "COPIES"
 0D57  B8			      db $BifTag+$BifCOPIES
 0D58  44 45 4C 53 54 52	      db "DELSTR"
 0D5E  98			      db $BifTag+$BifDELSTR
 0D5F  49 4E 53 45 52 54	      db "INSERT"
 0D65  9C			      db $BifTag+$BifINSERT
 0D66  4C 45 4E 47 54 48	      db "LENGTH"
 0D6C  C3			      db $BifTag+$BifLENGTH
 0D6D  53 55 42 53 54 52	      db "SUBSTR"
 0D73  BE			      db $BifTag+$BifSUBSTR
 0D74  56 45 52 49 46 59	      db "VERIFY"
 0D7A  8A			      db $BifTag+$BifVERIFY
 0D7B  53 54 52 45 41 4D	      db "STREAM"
 0D81  88			      db $BifTag+$BifSTREAM
 0D82  51 55 45 55 45 44	      db "QUEUED"
 0D88  BF			      db $BifTag+$BifQUEUED
 0D89  52 41 4E 44 4F 4D	      db "RANDOM"
 0D8F  A8			      db $BifTag+$BifRANDOM
 0D90  58 52 41 4E 47 45	      db "XRANGE"
 0D96  A7			      db $BifTag+$BifXRANGE
 0D97  46 4F 52 4D 41 54	      db "FORMAT"
 0D9D  91			      db $BifTag+$BifFORMAT
 0D9E  42 49 54 41 4E 44	      db "BITAND"
 0DA4  B4			      db $BifTag+$BifBITAND
 0DA5  42 49 54 58 4F 52	      db "BITXOR"
 0DAB  B6			      db $BifTag+$BifBITXOR
 0DAC  43 48 41 52 49 4E	      db "CHARIN"
 0DB2  84			      db $BifTag+$BifCHARIN
 0DB3  4C 49 4E 45 49 4E	      db "LINEIN"
 0DB9  86			      db $BifTag+$BifLINEIN
 0DBA  53 59 4D 42 4F 4C	      db "SYMBOL"
 0DC0  C0			      db $BifTag+$BifSYMBOL
 0DC1				     Bifs7:
 0DC1  43 4F 4D 50 41 52 45	      db "COMPARE"
 0DC8  97			      db $BifTag+$BifCOMPARE
 0DC9  44 45 4C 57 4F 52 44	      db "DELWORD"
 0DD0  99			      db $BifTag+$BifDELWORD
 0DD1  4C 41 53 54 50 4F 53	      db "LASTPOS"
 0DD8  9B			      db $BifTag+$BifLASTPOS
 0DD9  4F 56 45 52 4C 41 59	      db "OVERLAY"
 0DE0  9D			      db $BifTag+$BifOVERLAY
 0DE1  52 45 56 45 52 53 45	      db "REVERSE"
 0DE8  A9			      db $BifTag+$BifREVERSE
 0DE9  53 55 42 57 4F 52 44	      db "SUBWORD"
 0DF0  BB			      db $BifTag+$BifSUBWORD
 0DF1  57 4F 52 44 50 4F 53	      db "WORDPOS"
 0DF8  93			      db $BifTag+$BifWORDPOS
 0DF9  41 44 44 52 45 53 53	      db "ADDRESS"
 0E00  A0			      db $BifTag+$BifADDRESS
 0E01  43 48 41 52 4F 55 54	      db "CHAROUT"
 0E08  85			      db $BifTag+$BifCHAROUT
 0E09  4C 49 4E 45 4F 55 54	      db "LINEOUT"
 0E10  87			      db $BifTag+$BifLINEOUT
 0E11  51 55 41 4C 49 46 59	      db "QUALIFY"
 0E18  8B			      db $BifTag+$BifQUALIFY
 0E19				     Bifs8:
 0E19  43 4F 55 4E 54 53 54 52	      db "COUNTSTR"
 0E21  C1			      db $BifTag+$BifCOUNTSTR
 0E22  44 41 54 41 54 59 50 45	      db "DATATYPE"
 0E2A  9F			      db $BifTag+$BifDATATYPE
 0E2B				     Bifs9:
 0E2B  54 52 41 4E 53 4C 41 54	      db "TRANSLATE"
	      45
 0E34  90			      db $BifTag+$BifTRANSLATE
 0E35  57 4F 52 44 49 4E 44 45	      db "WORDINDEX"
	      58
 0E3E  BA			      db $BifTag+$BifWORDINDEX
 0E3F  43 48 41 4E 47 45 53 54	      db "CHANGESTR"
	      52
 0E48  C2			      db $BifTag+$BifCHANGESTR
 0E49  43 4F 4E 44 49 54 49 4F	      db "CONDITION"
	      4E
 0E52  A2			      db $BifTag+$BifCONDITION
 0E53  45 52 52 4F 52 54 45 58	      db "ERRORTEXT"
	      54
 0E5C  8E			      db $BifTag+$BifERRORTEXT
 0E5D				     Bifs10:
 0E5D  57 4F 52 44 4C 45 4E 47	      db "WORDLENGTH"
	      54 48
 0E67  92			      db $BifTag+$BifWORDLENGTH
 0E68  53 4F 55 52 43 45 4C 49	      db "SOURCELINE"
	      4E 45
 0E72  A6			      db $BifTag+$BifSOURCELINE
 0E73				     Bifs11:
				     endif
				      end
Microsoft (R) Macro Assembler Version 6.11		    01/21/12 18:44:55
bifs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

AllocAppend  . . . . . . . . . . . . .	Proc
BackRet  . . . . . . . . . . . . . . .	Proc
Back . . . . . . . . . . . . . . . . .	Proc
CheckType  . . . . . . . . . . . . . .	Proc
CodeModeR  . . . . . . . . . . . . . .	Proc
DownCare . . . . . . . . . . . . . . .	Proc
Down . . . . . . . . . . . . . . . . .	Proc
EvAh . . . . . . . . . . . . . . . . .	Proc
EvRet  . . . . . . . . . . . . . . . .	Proc
JcxzQ  . . . . . . . . . . . . . . . .	Proc
LoopQ  . . . . . . . . . . . . . . . .	Proc
MkMajMin . . . . . . . . . . . . . . .	Func
Move . . . . . . . . . . . . . . . . .	Proc
Mv . . . . . . . . . . . . . . . . . .	Proc
Off  . . . . . . . . . . . . . . . . .	Proc
On . . . . . . . . . . . . . . . . . .	Proc
OpAl . . . . . . . . . . . . . . . . .	Proc
OpRet  . . . . . . . . . . . . . . . .	Proc
PopJunk  . . . . . . . . . . . . . . .	Proc
Pos  . . . . . . . . . . . . . . . . .	Func
Qry  . . . . . . . . . . . . . . . . .	Proc
Repmovsb . . . . . . . . . . . . . . .	Proc
RetSi  . . . . . . . . . . . . . . . .	Proc
Splat  . . . . . . . . . . . . . . . .	Proc
StringOrder  . . . . . . . . . . . . .	Func
TestReg  . . . . . . . . . . . . . . .	Proc
UnCodeMode . . . . . . . . . . . . . .	Proc
UpCare . . . . . . . . . . . . . . . .	Proc
Up . . . . . . . . . . . . . . . . . .	Proc
XlatBDLS . . . . . . . . . . . . . . .	Proc
dec2 . . . . . . . . . . . . . . . . .	Proc
inc2 . . . . . . . . . . . . . . . . .	Proc
la . . . . . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . . . . .	Proc
mv . . . . . . . . . . . . . . . . . .	Proc
top  . . . . . . . . . . . . . . . . .	Proc
xax  . . . . . . . . . . . . . . . . .	Proc
z  . . . . . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Ashape . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Amount . . . . . . . . . . . . . . .	 0004	     Word
Dshape . . . . . . . . . . . . . . . .	 0028
  TailsAt  . . . . . . . . . . . . . .	 0000	     Word
  Subject  . . . . . . . . . . . . . .	 0000	     QWord
  CVinit . . . . . . . . . . . . . . .	 0000	     QWord
  Reps . . . . . . . . . . . . . . . .	 0000	     QWord
  To . . . . . . . . . . . . . . . . .	 0008	     QWord
  By . . . . . . . . . . . . . . . . .	 0010	     QWord
  ForCount . . . . . . . . . . . . . .	 0018	     QWord
  PcodePos . . . . . . . . . . . . . .	 0020	     Word
  Iteration  . . . . . . . . . . . . .	 0020	     Word
  Leaving  . . . . . . . . . . . . . .	 0022	     Word
  UpDO . . . . . . . . . . . . . . . .	 0024	     Word
  CV . . . . . . . . . . . . . . . . .	 0024	     Word
  Rec  . . . . . . . . . . . . . . . .	 0027	     Byte
EnvBlock . . . . . . . . . . . . . . .	 0008
  EnvNumber  . . . . . . . . . . . . .	 0000	     Word
  EnvResourceI . . . . . . . . . . . .	 0002	     Word
  EnvResourceO . . . . . . . . . . . .	 0004	     Word
  EnvResourceE . . . . . . . . . . . .	 0006	     Word
FarpX  . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
Farp . . . . . . . . . . . . . . . . .	 0004
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
Fshape . . . . . . . . . . . . . . . .	 001A
  Flags  . . . . . . . . . . . . . . .	 0000	     Word
  ToQual . . . . . . . . . . . . . . .	 0002	     Word
  Lines  . . . . . . . . . . . . . . .	 0004	     DWord
  Hand . . . . . . . . . . . . . . . .	 0008	     Word
  Other_Position . . . . . . . . . . .	 000A	     DWord
  Exten  . . . . . . . . . . . . . . .	 000E	     Byte
  TraceWidth . . . . . . . . . . . . .	 000F	     Byte
  Symbols  . . . . . . . . . . . . . .	 0010	     Word
  Code . . . . . . . . . . . . . . . .	 0012	     Word
  Vars . . . . . . . . . . . . . . . .	 0014	     Word
  Consts . . . . . . . . . . . . . . .	 0016	     Word
  ProgScope  . . . . . . . . . . . . .	 0018	     Word
Hshape . . . . . . . . . . . . . . . .	 0010
  Hdw0 . . . . . . . . . . . . . . . .	 0000	     DWord
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  Bump . . . . . . . . . . . . . . . .	 0002	     Word
  Avail  . . . . . . . . . . . . . . .	 0004	     Word
  Trigger  . . . . . . . . . . . . . .	 0006	     Word
  Link . . . . . . . . . . . . . . . .	 0008	     Word
  TreeBin  . . . . . . . . . . . . . .	 000A	     Word
  Original . . . . . . . . . . . . . .	 000A	     Word
  UpPool . . . . . . . . . . . . . . .	 000A	     Word
  Probe  . . . . . . . . . . . . . . .	 000C	     Word
  TreeProg . . . . . . . . . . . . . .	 000E	     Word
  Labels . . . . . . . . . . . . . . .	 000E	     Word
InsBlock . . . . . . . . . . . . . . .	 0015
  MajMin . . . . . . . . . . . . . . .	 0000	     Word
  Minor  . . . . . . . . . . . . . . .	 0000	     Byte
  Major  . . . . . . . . . . . . . . .	 0001	     Byte
  Value  . . . . . . . . . . . . . . .	 0002	     Word
  Named  . . . . . . . . . . . . . . .	 0004	     Word
  Position . . . . . . . . . . . . . .	 0004	     Word
  KeysList . . . . . . . . . . . . . .	 0006	     Word
  ArgNum . . . . . . . . . . . . . . .	 0008	     Byte
  Desc . . . . . . . . . . . . . . . .	 0009	     Byte
  Hex  . . . . . . . . . . . . . . . .	 000A	     Byte
  Char . . . . . . . . . . . . . . . .	 000A	     Byte
  Options  . . . . . . . . . . . . . .	 000B	     Word
  OptsHi . . . . . . . . . . . . . . .	 000D	     Word
  Digits . . . . . . . . . . . . . . .	 000F	     Word
  TokPos . . . . . . . . . . . . . . .	 0011	     Word
  TokLen . . . . . . . . . . . . . . .	 0013	     Word
Jshape . . . . . . . . . . . . . . . .	 000E
  Valued . . . . . . . . . . . . . . .	 0000	     QWord
  Pair . . . . . . . . . . . . . . . .	 0008	     DWord
  Lower  . . . . . . . . . . . . . . .	 0008	     Word
  Higher . . . . . . . . . . . . . . .	 000A	     Word
  KeyLen . . . . . . . . . . . . . . .	 000C	     Word
  Key  . . . . . . . . . . . . . . . .	 000E	     Byte
Lshape . . . . . . . . . . . . . . . .	 007C
  DigitsFuzz . . . . . . . . . . . . .	 0000	     DWord
  Digits . . . . . . . . . . . . . . .	 0000	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0002	     Word
  Form . . . . . . . . . . . . . . . .	 0004	     Byte
  StartTime  . . . . . . . . . . . . .	 0005	     QWord
  TraceLetter  . . . . . . . . . . . .	 000D	     Byte
  TraceWord  . . . . . . . . . . . . .	 000D	     Word
  Active . . . . . . . . . . . . . . .	 000F	     QWord
  Alternate  . . . . . . . . . . . . .	 0017	     QWord
  Syntax . . . . . . . . . . . . . . .	 001F	     Byte
  LostDigits . . . . . . . . . . . . .	 0020	     Byte
  NoValue  . . . . . . . . . . . . . .	 0021	     Byte
  NotReady . . . . . . . . . . . . . .	 0022	     Byte
  Error  . . . . . . . . . . . . . . .	 0023	     Byte
  Failure  . . . . . . . . . . . . . .	 0024	     Byte
  Halt . . . . . . . . . . . . . . . .	 0025	     Byte
  TrapName . . . . . . . . . . . . . .	 0026	     Word
  EventLevel . . . . . . . . . . . . .	 0034	     Word
  Condition  . . . . . . . . . . . . .	 0036	     Word
  ConditionDescription . . . . . . . .	 0038	     QWord
  ConditionExtra . . . . . . . . . . .	 0040	     QWord
  Inherit  . . . . . . . . . . . . . .	 0048	     Byte
  ClauseTime . . . . . . . . . . . . .	 0048	     QWord
  ClauseLocal  . . . . . . . . . . . .	 0050	     QWord
  PendingDescription . . . . . . . . .	 0058	     QWord
  PendingExtra . . . . . . . . . . . .	 0060	     QWord
  LevelDO  . . . . . . . . . . . . . .	 0068	     Word
  StackSave  . . . . . . . . . . . . .	 006A	     DWord
  File . . . . . . . . . . . . . . . .	 006E	     Word
  ProgScope  . . . . . . . . . . . . .	 0070	     Word
  VarScope . . . . . . . . . . . . . .	 0072	     Word
  Access . . . . . . . . . . . . . . .	 0074	     Word
  Flags  . . . . . . . . . . . . . . .	 0074	     Word
  UpLevel  . . . . . . . . . . . . . .	 0076	     Word
  Resume . . . . . . . . . . . . . . .	 0078	     Word
  Arg0 . . . . . . . . . . . . . . . .	 007A	     Word
PushShape  . . . . . . . . . . . . . .	 0010
  di_  . . . . . . . . . . . . . . . .	 0000	     Word
  si_  . . . . . . . . . . . . . . . .	 0002	     Word
  bp_  . . . . . . . . . . . . . . . .	 0004	     Word
  sp_  . . . . . . . . . . . . . . . .	 0006	     Word
  bx_  . . . . . . . . . . . . . . . .	 0008	     Word
  bl_  . . . . . . . . . . . . . . . .	 0008	     Byte
  bh_  . . . . . . . . . . . . . . . .	 0009	     Byte
  dx_  . . . . . . . . . . . . . . . .	 000A	     Word
  dl_  . . . . . . . . . . . . . . . .	 000A	     Byte
  dh_  . . . . . . . . . . . . . . . .	 000B	     Byte
  cx_  . . . . . . . . . . . . . . . .	 000C	     Word
  cl_  . . . . . . . . . . . . . . . .	 000C	     Byte
  ch_  . . . . . . . . . . . . . . . .	 000D	     Byte
  ax_  . . . . . . . . . . . . . . . .	 000E	     Word
  al_  . . . . . . . . . . . . . . . .	 000E	     Byte
  ah_  . . . . . . . . . . . . . . . .	 000F	     Byte
Sshape . . . . . . . . . . . . . . . .	 0010
  State  . . . . . . . . . . . . . . .	 0000	     Word
  Parser . . . . . . . . . . . . . . .	 0002	     Word
  ClauseWas  . . . . . . . . . . . . .	 0004	     Word
  Token  . . . . . . . . . . . . . . .	 0006	     Word
  Operation  . . . . . . . . . . . . .	 0008	     DWord
  Caller . . . . . . . . . . . . . . .	 000C	     Word
  Parms  . . . . . . . . . . . . . . .	 000E	     Word
  JumpSite . . . . . . . . . . . . . .	 0006	     Word
  SoFar  . . . . . . . . . . . . . . .	 0008	     Word
  WhatCV . . . . . . . . . . . . . . .	 0008	     Word
  SelectSite . . . . . . . . . . . . .	 0008	     Word
Vshape . . . . . . . . . . . . . . . .	 0008
  String . . . . . . . . . . . . . . .	 0000	     Byte
  Dtype  . . . . . . . . . . . . . . .	 0007	     Byte
  Sign . . . . . . . . . . . . . . . .	 0000	     Byte
  ExpAnd . . . . . . . . . . . . . . .	 0000	     DWord
  ExpoUses . . . . . . . . . . . . . .	 0000	     Byte
  ExpoSign . . . . . . . . . . . . . .	 0003	     Byte
  Mantissa . . . . . . . . . . . . . .	 0004	     DWord
  MantLow  . . . . . . . . . . . . . .	 0004	     Word
  MantHigh . . . . . . . . . . . . . .	 0006	     Word
  OverExpo . . . . . . . . . . . . . .	 0000	     DWord
  OverMant . . . . . . . . . . . . . .	 0004	     DWord
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
  LabelValue . . . . . . . . . . . . .	 0000	     Word
  LabelType  . . . . . . . . . . . . .	 0006	     Word
  WhichCon . . . . . . . . . . . . . .	 0000	     Word
  PcodePos . . . . . . . . . . . . . .	 0002	     Word
  HeldOver . . . . . . . . . . . . . .	 0000	     Word
  Pair . . . . . . . . . . . . . . . .	 0000	     DWord
  Lower  . . . . . . . . . . . . . . .	 0000	     Word
  Higher . . . . . . . . . . . . . . .	 0002	     Word
  Here . . . . . . . . . . . . . . . .	 0004	     Word
Yshape . . . . . . . . . . . . . . . .	 0053
  N1 . . . . . . . . . . . . . . . . .	 0004	     DWord
  N10  . . . . . . . . . . . . . . . .	 0008	     DWord
  N100 . . . . . . . . . . . . . . . .	 000C	     DWord
  N1000  . . . . . . . . . . . . . . .	 0010	     DWord
  N1e4 . . . . . . . . . . . . . . . .	 0014	     DWord
  N1e5 . . . . . . . . . . . . . . . .	 0018	     DWord
  N1e6 . . . . . . . . . . . . . . . .	 001C	     DWord
  N1e7 . . . . . . . . . . . . . . . .	 0020	     DWord
  N1e8 . . . . . . . . . . . . . . . .	 0024	     DWord
  N1e9 . . . . . . . . . . . . . . . .	 0028	     DWord
  N1664525 . . . . . . . . . . . . . .	 002C	     DWord
  ExponHi  . . . . . . . . . . . . . .	 0030	     DWord
  ExponLo  . . . . . . . . . . . . . .	 0034	     DWord
  Cseg . . . . . . . . . . . . . . . .	 0038	     Word
  DOS  . . . . . . . . . . . . . . . .	 003A	     DWord
  DosPool  . . . . . . . . . . . . . .	 003E	     Byte
  DqCrLf . . . . . . . . . . . . . . .	 004C	     Byte
  CrLf . . . . . . . . . . . . . . . .	 004D	     Byte
  StackSave  . . . . . . . . . . . . .	 004F	     DWord
Zshape . . . . . . . . . . . . . . . .	 137C
  w  . . . . . . . . . . . . . . . . .	 0000	     Word
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  ProgramCancel  . . . . . . . . . . .	 0002	     DWord
  Program  . . . . . . . . . . . . . .	 0002	     Word
  Cancel . . . . . . . . . . . . . . .	 0004	     Word
  Stack  . . . . . . . . . . . . . . .	 0006	     Word
  ClauseLine . . . . . . . . . . . . .	 0008	     Word
  Middles  . . . . . . . . . . . . . .	 000A	     Word
  Clause . . . . . . . . . . . . . . .	 000C	     Word
  Gen  . . . . . . . . . . . . . . . .	 000E	     Word
  KWMiddle . . . . . . . . . . . . . .	 0010	     Word
  KWFound  . . . . . . . . . . . . . .	 0012	     Word
  Stdout . . . . . . . . . . . . . . .	 0014	     Word
  Stderr . . . . . . . . . . . . . . .	 0016	     Word
  SourceHandle . . . . . . . . . . . .	 0018	     Word
  HowInvoked . . . . . . . . . . . . .	 001A	     Word
  Radix  . . . . . . . . . . . . . . .	 001C	     Byte
  AxAsNum  . . . . . . . . . . . . . .	 001D	     Byte
  Tag  . . . . . . . . . . . . . . . .	 0023	     Byte
  Seed . . . . . . . . . . . . . . . .	 0028	     DWord
  ParseResetSp . . . . . . . . . . . .	 002C	     Word
  XCycleResetSp  . . . . . . . . . . .	 002E	     Word
  Dumper . . . . . . . . . . . . . . .	 0030	     Word
  Stash  . . . . . . . . . . . . . . .	 0032	     Word
  Resolved . . . . . . . . . . . . . .	 0034	     Word
  Cursor . . . . . . . . . . . . . . .	 0036	     Word
  Stream . . . . . . . . . . . . . . .	 0038	     Word
  Queue  . . . . . . . . . . . . . . .	 003A	     Word
  InsSource  . . . . . . . . . . . . .	 003C	     DWord
  SysFile  . . . . . . . . . . . . . .	 003C	     DWord
  File . . . . . . . . . . . . . . . .	 003C	     Word
  SysFiles . . . . . . . . . . . . . .	 003E	     Word
  Consts . . . . . . . . . . . . . . .	 0040	     Word
  Vars . . . . . . . . . . . . . . . .	 0042	     Word
  ProgScope  . . . . . . . . . . . . .	 0044	     Word
  VarScope . . . . . . . . . . . . . .	 0046	     Word
  Symbols  . . . . . . . . . . . . . .	 0048	     Word
  Code . . . . . . . . . . . . . . . .	 004A	     Word
  Zone . . . . . . . . . . . . . . . .	 004C	     Word
  Stem . . . . . . . . . . . . . . . .	 004E	     Word
  PoolPool . . . . . . . . . . . . . .	 0050	     Word
  Level  . . . . . . . . . . . . . . .	 0052	     Word
  Base0  . . . . . . . . . . . . . . .	 0054	     Word
  CurrentDO  . . . . . . . . . . . . .	 0056	     Word
  ResumeP  . . . . . . . . . . . . . .	 0058	     Word
  ResumeDF . . . . . . . . . . . . . .	 005A	     DWord
  ResumeD  . . . . . . . . . . . . . .	 005A	     Word
  ResumeF  . . . . . . . . . . . . . .	 005C	     Word
  ResumeS  . . . . . . . . . . . . . .	 005E	     Byte
  DigitsFuzz . . . . . . . . . . . . .	 005F	     DWord
  Digits . . . . . . . . . . . . . . .	 005F	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0061	     Word
  Ceiling  . . . . . . . . . . . . . .	 0063	     DWord
  DivBreak . . . . . . . . . . . . . .	 0067	     DWord
  TwiceDigits  . . . . . . . . . . . .	 006B	     DWord
  UseGeneral . . . . . . . . . . . . .	 006F	     Word
  InsLine  . . . . . . . . . . . . . .	 0071	     Word
  InsBif . . . . . . . . . . . . . . .	 0073	     Byte
  InsOperator  . . . . . . . . . . . .	 0074	     DWord
  InsUnqual  . . . . . . . . . . . . .	 0078	     Word
  Insert . . . . . . . . . . . . . . .	 007A	      0015
  Inserts  . . . . . . . . . . . . . .	 008F	      0015
  SignM  . . . . . . . . . . . . . . .	 00A4	     Byte
  SignE  . . . . . . . . . . . . . . .	 00A5	     Byte
  MantPos  . . . . . . . . . . . . . .	 00A6	     Word
  MantPosZi  . . . . . . . . . . . . .	 00A8	     Word
  ExpPos . . . . . . . . . . . . . . .	 00AA	     Word
  ExpPosZi . . . . . . . . . . . . . .	 00AC	     Word
  ExpSign  . . . . . . . . . . . . . .	 00AE	     Word
  MantSize . . . . . . . . . . . . . .	 00B0	     Word
  OpIs . . . . . . . . . . . . . . . .	 00B2	     Byte
  Flags  . . . . . . . . . . . . . . .	 00B3	     Byte
  BifParmsHi . . . . . . . . . . . . .	 00B4	     Byte
  BifByte  . . . . . . . . . . . . . .	 00B5	     Byte
  TraceAlign . . . . . . . . . . . . .	 00B6	     DWord
  TraceSource  . . . . . . . . . . . .	 00BA	     DWord
  TraceEnds  . . . . . . . . . . . . .	 00BE	     DWord
  TraceSourceColumn  . . . . . . . . .	 00C2	     Word
  TraceEndsColumn  . . . . . . . . . .	 00C4	     Word
  DualCode . . . . . . . . . . . . . .	 00C6	     Word
  TraceOp  . . . . . . . . . . . . . .	 00C8	     Byte
  Relative . . . . . . . . . . . . . .	 00C9	     DWord
  RelativeNow  . . . . . . . . . . . .	 00CD	     DWord
  Continue . . . . . . . . . . . . . .	 00D1	     Word
  StackX . . . . . . . . . . . . . . .	 00D3	     Word
  TraceLine  . . . . . . . . . . . . .	 00D5	     Word
  InhibitTrace . . . . . . . . . . . .	 00D7	     DWord
  InhibitPauses  . . . . . . . . . . .	 00DB	     DWord
  Target . . . . . . . . . . . . . . .	 00DF	     Word
  Scanp  . . . . . . . . . . . . . . .	 00E1	     Word
  EndUsedBuffer  . . . . . . . . . . .	 00E3	     Word
  NearEnd  . . . . . . . . . . . . . .	 00E5	     Word
  CatOp  . . . . . . . . . . . . . . .	 00E7	     Byte
  RadixBadWhite  . . . . . . . . . . .	 00E8	     Byte
  BackExponent . . . . . . . . . . . .	 00E9	     Word
  LastContent  . . . . . . . . . . . .	 00EB	     Word
  CommaLine  . . . . . . . . . . . . .	 00ED	     Word
  Condition  . . . . . . . . . . . . .	 00EF	     Word
  UntilPlace . . . . . . . . . . . . .	 00F1	     Word
  StemSym  . . . . . . . . . . . . . .	 00F3	     Word
  SoFar  . . . . . . . . . . . . . . .	 00F5	     Word
  PcodePos . . . . . . . . . . . . . .	 00F7	     Word
  TraceOnly  . . . . . . . . . . . . .	 00F9	     Word
  CompareAt  . . . . . . . . . . . . .	 00FB	     Word
  StackHi  . . . . . . . . . . . . . .	 00FD	     Word
  StackLo  . . . . . . . . . . . . . .	 00FF	     Word
  OnSoft . . . . . . . . . . . . . . .	 0101	     Word
  Tail . . . . . . . . . . . . . . . .	 0103	     Word
  TokNum . . . . . . . . . . . . . . .	 0105	     Word
  TokNow . . . . . . . . . . . . . . .	 0107	     Word
  TokWas . . . . . . . . . . . . . . .	 0109	     Word
  TokData  . . . . . . . . . . . . . .	 010B	     Word
  Synch  . . . . . . . . . . . . . . .	 010D	     Word
  Lines  . . . . . . . . . . . . . . .	 010F	     Word
  MsgBegin . . . . . . . . . . . . . .	 0111	     Word
  MsgSoFar . . . . . . . . . . . . . .	 0113	     Word
  PreZi  . . . . . . . . . . . . . . .	 0115	     Word
  TargetMajMin . . . . . . . . . . . .	 0117	     Word
  TargetMinor  . . . . . . . . . . . .	 0117	     Byte
  TargetMajor  . . . . . . . . . . . .	 0118	     Byte
  EnvSeg . . . . . . . . . . . . . . .	 0119	     Word
  ForPSP . . . . . . . . . . . . . . .	 011B	     DWord
  Fcb1 . . . . . . . . . . . . . . . .	 011F	     DWord
  Fcb2 . . . . . . . . . . . . . . . .	 0123	     DWord
  AtPause  . . . . . . . . . . . . . .	 0127	     Word
  ArgsB  . . . . . . . . . . . . . . .	 0129	     Byte
  ArgsB0 . . . . . . . . . . . . . . .	 012A	     Word
  Parsee . . . . . . . . . . . . . . .	 012C	     FWord
  ParseeNum  . . . . . . . . . . . . .	 0132	     Word
  PattLenEtc . . . . . . . . . . . . .	 0134	     Word
  BreakStart . . . . . . . . . . . . .	 0136	     Word
  BreakEnd . . . . . . . . . . . . . .	 0138	     Word
  EnvNow . . . . . . . . . . . . . . .	 013A	     QWord
  CatTotal . . . . . . . . . . . . . .	 0142	     Word
  LastTarget . . . . . . . . . . . . .	 0144	     Word
  NewJshape  . . . . . . . . . . . . .	 0146	     Word
  FromDos  . . . . . . . . . . . . . .	 0148	     Word
  FromDosWas . . . . . . . . . . . . .	 014A	     Word
  FromDosZi  . . . . . . . . . . . . .	 014C	     Word
  MemoryTable  . . . . . . . . . . . .	 014E	     FWord
  MemoryTableZi  . . . . . . . . . . .	 018A	     Byte
  Left . . . . . . . . . . . . . . . .	 018A	     Word
  Right  . . . . . . . . . . . . . . .	 018C	     Word
  AllocBase  . . . . . . . . . . . . .	 018E	     DWord
  DsWas  . . . . . . . . . . . . . . .	 0192	     Word
  DsNew  . . . . . . . . . . . . . . .	 0194	     Word
  EsWas  . . . . . . . . . . . . . . .	 0196	     Word
  EsNew  . . . . . . . . . . . . . . .	 0198	     Word
  FsWas  . . . . . . . . . . . . . . .	 019A	     Word
  FsNew  . . . . . . . . . . . . . . .	 019C	     Word
  GsWas  . . . . . . . . . . . . . . .	 019E	     Word
  GsNew  . . . . . . . . . . . . . . .	 01A0	     Word
  DebugStash . . . . . . . . . . . . .	 01A2	     Word
  DebugD . . . . . . . . . . . . . . .	 01A4	     DWord
  DigitCount . . . . . . . . . . . . .	 01A8	     Word
  SerialNow  . . . . . . . . . . . . .	 01AA	     Byte
  Serial . . . . . . . . . . . . . . .	 01AB	     Byte
  CommandArg . . . . . . . . . . . . .	 1374	     QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

CancelRec  . . . . . . . . . . . . . .	 0010	   0010
  Format5  . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  AssignDO . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ForExpose  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FromIterCV . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  ForBIF . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  TokIsValue . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  ExpRange . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Description  . . . . . . . . . . . .	 0008	   0001	     0100     ?
  Compacted  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  BcodeInterpret . . . . . . . . . . .	 0006	   0001	     0040     ?
  MapOnly  . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ParseUpper . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ParseTrace . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  SourceFiles  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  BoolBefore . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  WasDropped . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ClauseRec  . . . . . . . . . . . . . .	 0010	   0010
  WasUpper . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  OffFlag  . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Condition  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  Append . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Signal . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ClauseSet  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  CVar . . . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Repit  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PosEq  . . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NotAssign  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  WasParse . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  InParse  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  Tailed . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  WasTailed  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PosPlus  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PosMinus . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ConditionRec . . . . . . . . . . . . .	 0008	   0005
  Enabling . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  Delayed  . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PendingNow . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  Instruction  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  CRspare  . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ErrorRec . . . . . . . . . . . . . . .	 0010	   0004
  HasShiftOn . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAloneOn . . . . . . . . . . . .	 000E	   0001	     4000     ?
  MajorField . . . . . . . . . . . . .	 0006	   0008	     3FC0     ?
  MinorField . . . . . . . . . . . . .	 0000	   0006	     003F     ?
FRec . . . . . . . . . . . . . . . . .	 0010	   0009
  Qual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Read . . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Open . . . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  BeenRead . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  BeenWrite  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  WriteMode  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  IsSource . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  BeenCompiled . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FFpad  . . . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
GenRec . . . . . . . . . . . . . . . .	 0010	   0005
  Dual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  DualPending  . . . . . . . . . . . .	 000E	   0001	     4000     ?
  DualGen  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  DualOnly . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  GenSpare . . . . . . . . . . . . . .	 0000	   000C	     0FFF     ?
KeyRec . . . . . . . . . . . . . . . .	 0008	   0003
  KeyFlags . . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  EndList  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KeyLen . . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
LevelRecI  . . . . . . . . . . . . . .	 0010	   0003
  LIPad  . . . . . . . . . . . . . . .	 0002	   000E	     FFFC     ?
  Interactive  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ConditionInstruction . . . . . . . .	 0000	   0001	     0001     ?
LevelRec . . . . . . . . . . . . . . .	 0010	   0007
  Lpad . . . . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  InheritDone  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DigitsSet  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IsProcedure  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IsExternal . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IsFunction . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  Lpad2  . . . . . . . . . . . . . . .	 0000	   0003	     0007     ?
LoopsRec . . . . . . . . . . . . . . .	 0008	   0007
  LoopsPad . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  HasDot . . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  HasDots  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HasTo  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  HasFor . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IsInterp . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ByDown . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MiddleRec  . . . . . . . . . . . . . .	 0010	   0010
  NotLabel . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  SemiAfter  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ValueBefore  . . . . . . . . . . . .	 000D	   0001	     2000     ?
  AbutOK . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  NoBlanks . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ModEquals  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  EndClause  . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  ImplicitValue  . . . . . . . . . . .	 0008	   0001	     0100     ?
  CheckDO  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TargetSymbol . . . . . . . . . . . .	 0006	   0001	     0040     ?
  Function . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  TakenConstant  . . . . . . . . . . .	 0004	   0001	     0010     ?
  LookLabel  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LookBin  . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DotOK  . . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  MRspare  . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OperatorRec  . . . . . . . . . . . . .	 0008	   0006
  InTypes  . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ResultType . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  AppendNum  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  AppendRef  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DownOne  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  EndsClause . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ParmsRec . . . . . . . . . . . . . . .	 0008	   0003
  ParmsMin . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ParmsXtr . . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  NonCheck . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ParserRec  . . . . . . . . . . . . . .	 0010	   0005
  ParserPad  . . . . . . . . . . . . .	 0004	   000C	     FFF0     ?
  DoRep  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DoCV . . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  Forever  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DoDataHost . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ProgramRec . . . . . . . . . . . . . .	 0010	   000B
  API_Enabled  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Repass . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  LabelsBad  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FirstBetween . . . . . . . . . . . .	 000C	   0001	     1000     ?
  EndSource  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  BifCheck . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  RandomSeeded . . . . . . . . . . . .	 0009	   0001	     0200     ?
  NotS9  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  TraceIF  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ShowELSE . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PRSpare  . . . . . . . . . . . . . .	 0000	   0006	     003F     ?
RedRec . . . . . . . . . . . . . . . .	 0010	   0005
  HasShiftOff  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  HasAction  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PruneCt  . . . . . . . . . . . . . .	 000C	   0002	     3000     ?
  Rtype  . . . . . . . . . . . . . . .	 000A	   0002	     0C00     ?
  Rstate . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
ShiftRec . . . . . . . . . . . . . . .	 0010	   0008
  HasShift . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAlone . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  CatFlag  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  HasKeys  . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Reference  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  Direct . . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  Indexb . . . . . . . . . . . . . . .	 0005	   0005	     03E0     ?
  Index  . . . . . . . . . . . . . . .	 0000	   0005	     001F     ?
SymRec . . . . . . . . . . . . . . . .	 0010	   0006
  SRpad  . . . . . . . . . . . . . . .	 0005	   000B	     FFE0     ?
  HadDigits  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HadDot . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  NotNumber  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  HadSign  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  HadE . . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
TokRec . . . . . . . . . . . . . . . .	 0010	   0003
  X02  . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  NdxbT  . . . . . . . . . . . . . . .	 000A	   0005	     7C00     ?
  Aim  . . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
TokVal . . . . . . . . . . . . . . . .	 0008	   0002
  GrpNdx . . . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SubNum . . . . . . . . . . . . . . .	 0000	   0002	     0003     ?


Types:

                N a m e                  Size     Attr

Boolp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
Bool . . . . . . . . . . . . . . . . .	 0001	  Byte 
Handlep  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Handle . . . . . . . . . . . . . . . .	 0002	  Word 
Segp . . . . . . . . . . . . . . . . .	 0002	  Word 
Ulong  . . . . . . . . . . . . . . . .	 0004	  DWord 
Ushortp  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Ushort . . . . . . . . . . . . . . . .	 0002	  Word 
bytep  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
charfp . . . . . . . . . . . . . . . .	 0004	  FarPTR Byte 
charp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
char . . . . . . . . . . . . . . . . .	 0001	  Byte 
shortp . . . . . . . . . . . . . . . .	 0002	  PTR Word 
short  . . . . . . . . . . . . . . . .	 0002	  Word 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
MyGroup  . . . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . . . . .	16 Bit	 0E73	  Word	  Public  'CODE'	
BifSeg . . . . . . . . . . . . . . . .	16 Bit	 0050	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

$0 . . . . . . . . . . . . . . . . . .	Number	 0000h	 
$10  . . . . . . . . . . . . . . . . .	Number	 0007h	 
$11  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$12  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$15  . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$16  . . . . . . . . . . . . . . . . .	Number	 0017h	 
$17  . . . . . . . . . . . . . . . . .	Number	 0019h	 
$18  . . . . . . . . . . . . . . . . .	Number	 0018h	 
$19  . . . . . . . . . . . . . . . . .	Number	 001Ah	 
$1 . . . . . . . . . . . . . . . . . .	Number	 0013h	 
$21  . . . . . . . . . . . . . . . . .	Number	 0016h	 
$23  . . . . . . . . . . . . . . . . .	Number	 001Eh	 
$28  . . . . . . . . . . . . . . . . .	Number	 0012h	 
$2 . . . . . . . . . . . . . . . . . .	Number	 0015h	 
$3 . . . . . . . . . . . . . . . . . .	Number	 0004h	 
$5 . . . . . . . . . . . . . . . . . .	Number	 0006h	 
$6 . . . . . . . . . . . . . . . . . .	Number	 0003h	 
$7 . . . . . . . . . . . . . . . . . .	Number	 000Eh	 
$8 . . . . . . . . . . . . . . . . . .	Number	 0014h	 
$9 . . . . . . . . . . . . . . . . . .	Number	 0009h	 
$?BIF  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$?CLAUSELOCAL  . . . . . . . . . . . .	Number	 007Ch	 
$?CLAUSETIME . . . . . . . . . . . . .	Number	 0074h	 
$?Discard  . . . . . . . . . . . . . .	Number	 0010h	 
$?E  . . . . . . . . . . . . . . . . .	Number	 00B4h	 
$?LINEIN_POSITION  . . . . . . . . . .	Number	 006Ch	 
$?MN . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$?MONTHS . . . . . . . . . . . . . . .	Number	 0084h	 
$?Nine . . . . . . . . . . . . . . . .	Number	 009Ch	 
$?Null . . . . . . . . . . . . . . . .	Number	 00ACh	 
$?OUTCOME  . . . . . . . . . . . . . .	Number	 0044h	 
$?Omitted  . . . . . . . . . . . . . .	Number	 0014h	 
$?RCx  . . . . . . . . . . . . . . . .	Number	 0028h	 
$?RC . . . . . . . . . . . . . . . . .	Number	 0034h	 
$?RESPONSE . . . . . . . . . . . . . .	Number	 0064h	 
$?RESULTx  . . . . . . . . . . . . . .	Number	 0020h	 
$?RESULT . . . . . . . . . . . . . . .	Number	 002Ch	 
$?RS . . . . . . . . . . . . . . . . .	Number	 0024h	 
$?SIGLx  . . . . . . . . . . . . . . .	Number	 0030h	 
$?SIGL . . . . . . . . . . . . . . . .	Number	 003Ch	 
$?STARTTIME  . . . . . . . . . . . . .	Number	 0094h	 
$?STREAMSTATE  . . . . . . . . . . . .	Number	 005Ch	 
$?STREAM . . . . . . . . . . . . . . .	Number	 0054h	 
$?SysVars  . . . . . . . . . . . . . .	Number	 0044h	 
$?S  . . . . . . . . . . . . . . . . .	Number	 00BCh	 
$?WEEKDAYS . . . . . . . . . . . . . .	Number	 008Ch	 
$?Zero . . . . . . . . . . . . . . . .	Number	 00A4h	 
$ADDRESS . . . . . . . . . . . . . . .	Number	 008Ch	 
$APPEND  . . . . . . . . . . . . . . .	Number	 0090h	 
$ARG . . . . . . . . . . . . . . . . .	Number	 0088h	 
$Abut  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$And . . . . . . . . . . . . . . . . .	Number	 0018h	 
$Ashapes . . . . . . . . . . . . . . .	Number	 000Ah	 
$Assign  . . . . . . . . . . . . . . .	Number	 0054h	 
$Asterisk  . . . . . . . . . . . . . .	Number	 0011h	 
$AttribAnd . . . . . . . . . . . . . .	Number	 00D8h	 
$AttribComma . . . . . . . . . . . . .	Number	 00DCh	 
$AttribEq  . . . . . . . . . . . . . .	Number	 00EBh	 
$AttribGt  . . . . . . . . . . . . . .	Number	 00F0h	 
$AttribLine  . . . . . . . . . . . . .	Number	 00E7h	 
$AttribLt  . . . . . . . . . . . . . .	Number	 00EDh	 
$AttribMinus . . . . . . . . . . . . .	Number	 00E4h	 
$AttribOr  . . . . . . . . . . . . . .	Number	 00D5h	 
$AttribPlus  . . . . . . . . . . . . .	Number	 00E5h	 
$AttribSlash . . . . . . . . . . . . .	Number	 00D2h	 
$AttribStar  . . . . . . . . . . . . .	Number	 00D1h	 
$AwayString  . . . . . . . . . . . . .	Number	 00C0h	 
$BPcodesCeil . . . . . . . . . . . . .	Number	 005Dh	 
$BY  . . . . . . . . . . . . . . . . .	Number	 006Ch	 
$Bb  . . . . . . . . . . . . . . . . .	Number	 0004h	 
$BcodesBase  . . . . . . . . . . . . .	Number	 00B3h	 
$BifABBREV . . . . . . . . . . . . . .	Number	 0014h	 
$BifABS  . . . . . . . . . . . . . . .	Number	 002Ah	 
$BifADDRESS  . . . . . . . . . . . . .	Number	 0020h	 
$BifARG  . . . . . . . . . . . . . . .	Number	 0021h	 
$BifB2X  . . . . . . . . . . . . . . .	Number	 002Dh	 
$BifBITAND . . . . . . . . . . . . . .	Number	 0034h	 
$BifBITOR  . . . . . . . . . . . . . .	Number	 0035h	 
$BifBITXOR . . . . . . . . . . . . . .	Number	 0036h	 
$BifBase . . . . . . . . . . . . . . .	Number	 FFB9h	 
$BifC2D  . . . . . . . . . . . . . . .	Number	 0031h	 
$BifC2X  . . . . . . . . . . . . . . .	Number	 002Ch	 
$BifCENTER . . . . . . . . . . . . . .	Number	 0015h	 
$BifCENTRE . . . . . . . . . . . . . .	Number	 0016h	 
$BifCHANGESTR  . . . . . . . . . . . .	Number	 0042h	 
$BifCHARIN . . . . . . . . . . . . . .	Number	 0004h	 
$BifCHAROUT  . . . . . . . . . . . . .	Number	 0005h	 
$BifCHARS  . . . . . . . . . . . . . .	Number	 0003h	 
$BifCOMPARE  . . . . . . . . . . . . .	Number	 0017h	 
$BifCONDITION  . . . . . . . . . . . .	Number	 0022h	 
$BifCOPIES . . . . . . . . . . . . . .	Number	 0038h	 
$BifCOUNTSTR . . . . . . . . . . . . .	Number	 0041h	 
$BifD2C  . . . . . . . . . . . . . . .	Number	 0032h	 
$BifD2X  . . . . . . . . . . . . . . .	Number	 0033h	 
$BifDATATYPE . . . . . . . . . . . . .	Number	 001Fh	 
$BifDATE . . . . . . . . . . . . . . .	Number	 0000h	 
$BifDELSTR . . . . . . . . . . . . . .	Number	 0018h	 
$BifDELWORD  . . . . . . . . . . . . .	Number	 0019h	 
$BifDIGITS . . . . . . . . . . . . . .	Number	 0025h	 
$BifERRORTEXT  . . . . . . . . . . . .	Number	 000Eh	 
$BifFORMAT . . . . . . . . . . . . . .	Number	 0011h	 
$BifFORM . . . . . . . . . . . . . . .	Number	 001Eh	 
$BifFUZZ . . . . . . . . . . . . . . .	Number	 0024h	 
$BifINSERT . . . . . . . . . . . . . .	Number	 001Ch	 
$BifLASTPOS  . . . . . . . . . . . . .	Number	 001Bh	 
$BifLEFT . . . . . . . . . . . . . . .	Number	 003Dh	 
$BifLENGTH . . . . . . . . . . . . . .	Number	 0043h	 
$BifLINEIN . . . . . . . . . . . . . .	Number	 0006h	 
$BifLINEOUT  . . . . . . . . . . . . .	Number	 0007h	 
$BifLINES  . . . . . . . . . . . . . .	Number	 0002h	 
$BifMAX  . . . . . . . . . . . . . . .	Number	 0044h	 
$BifMIN  . . . . . . . . . . . . . . .	Number	 0045h	 
$BifOVERLAY  . . . . . . . . . . . . .	Number	 001Dh	 
$BifPOS  . . . . . . . . . . . . . . .	Number	 003Ch	 
$BifQUALIFY  . . . . . . . . . . . . .	Number	 000Bh	 
$BifQUEUED . . . . . . . . . . . . . .	Number	 003Fh	 
$BifRANDOM . . . . . . . . . . . . . .	Number	 0028h	 
$BifREVERSE  . . . . . . . . . . . . .	Number	 0029h	 
$BifRIGHT  . . . . . . . . . . . . . .	Number	 001Ah	 
$BifSIGN . . . . . . . . . . . . . . .	Number	 002Bh	 
$BifSOURCELINE . . . . . . . . . . . .	Number	 0026h	 
$BifSPACE  . . . . . . . . . . . . . .	Number	 000Fh	 
$BifSTREAM . . . . . . . . . . . . . .	Number	 0008h	 
$BifSTRIP  . . . . . . . . . . . . . .	Number	 0009h	 
$BifSUBSTR . . . . . . . . . . . . . .	Number	 003Eh	 
$BifSUBWORD  . . . . . . . . . . . . .	Number	 003Bh	 
$BifSYMBOL . . . . . . . . . . . . . .	Number	 0040h	 
$BifSpecial  . . . . . . . . . . . . .	Number	 003Fh	 
$BifTIME . . . . . . . . . . . . . . .	Number	 0001h	 
$BifTRACE  . . . . . . . . . . . . . .	Number	 0023h	 
$BifTRANSLATE  . . . . . . . . . . . .	Number	 0010h	 
$BifTRUNC  . . . . . . . . . . . . . .	Number	 000Dh	 
$BifTag  . . . . . . . . . . . . . . .	Number	 0080h	 
$BifVALUE  . . . . . . . . . . . . . .	Number	 0037h	 
$BifVERIFY . . . . . . . . . . . . . .	Number	 000Ah	 
$BifWORDINDEX  . . . . . . . . . . . .	Number	 003Ah	 
$BifWORDLENGTH . . . . . . . . . . . .	Number	 0012h	 
$BifWORDPOS  . . . . . . . . . . . . .	Number	 0013h	 
$BifWORDS  . . . . . . . . . . . . . .	Number	 000Ch	 
$BifWORD . . . . . . . . . . . . . . .	Number	 0039h	 
$BifX2B  . . . . . . . . . . . . . . .	Number	 002Eh	 
$BifX2C  . . . . . . . . . . . . . . .	Number	 002Fh	 
$BifX2D  . . . . . . . . . . . . . . .	Number	 0030h	 
$BifXRANGE . . . . . . . . . . . . . .	Number	 0027h	 
$Bin . . . . . . . . . . . . . . . . .	Number	 0024h	 
$CALL  . . . . . . . . . . . . . . . .	Number	 0094h	 
$CONST_SYMBOL  . . . . . . . . . . . .	Number	 0040h	 
$CaseTarget  . . . . . . . . . . . . .	Number	 0006h	 
$Cat . . . . . . . . . . . . . . . . .	Number	 004Dh	 
$Colon . . . . . . . . . . . . . . . .	Number	 000Ah	 
$Comma . . . . . . . . . . . . . . . .	Number	 001Ch	 
$Constant  . . . . . . . . . . . . . .	Number	 008Ah	 
$Cr  . . . . . . . . . . . . . . . . .	Text   	 0dh
$DIGITS  . . . . . . . . . . . . . . .	Number	 00E4h	 
$DO  . . . . . . . . . . . . . . . . .	Number	 0098h	 
$DROP  . . . . . . . . . . . . . . . .	Number	 00B8h	 
$Desc59H . . . . . . . . . . . . . . .	Number	 000Bh	 
$DescArgs  . . . . . . . . . . . . . .	Number	 000Ah	 
$DescFiles . . . . . . . . . . . . . .	Number	 000Ch	 
$DescQueue . . . . . . . . . . . . . .	Number	 000Dh	 
$DescString  . . . . . . . . . . . . .	Number	 0005h	 
$Descriptions  . . . . . . . . . . . .	Number	 0037h	 
$Digit . . . . . . . . . . . . . . . .	Number	 0040h	 
$DosAllocate . . . . . . . . . . . . .	Number	 0048h	 
$DosChmod  . . . . . . . . . . . . . .	Number	 0043h	 
$DosClose  . . . . . . . . . . . . . .	Number	 003Eh	 
$DosCreate . . . . . . . . . . . . . .	Number	 003Ch	 
$DosDate . . . . . . . . . . . . . . .	Number	 002Ah	 
$DosDelete . . . . . . . . . . . . . .	Number	 0041h	 
$DosDisk . . . . . . . . . . . . . . .	Number	 0019h	 
$DosExecute  . . . . . . . . . . . . .	Number	 004Bh	 
$DosExit . . . . . . . . . . . . . . .	Number	 004Ch	 
$DosFree . . . . . . . . . . . . . . .	Number	 0049h	 
$DosGetError . . . . . . . . . . . . .	Number	 0059h	 
$DosModifyAllocated  . . . . . . . . .	Number	 004Ah	 
$DosOpen . . . . . . . . . . . . . . .	Number	 003Dh	 
$DosPSP  . . . . . . . . . . . . . . .	Number	 0062h	 
$DosPath . . . . . . . . . . . . . . .	Number	 0047h	 
$DosRead . . . . . . . . . . . . . . .	Number	 003Fh	 
$DosReturnCode . . . . . . . . . . . .	Number	 004Dh	 
$DosSeek . . . . . . . . . . . . . . .	Number	 0042h	 
$DosTime . . . . . . . . . . . . . . .	Number	 002Ch	 
$DosWrite  . . . . . . . . . . . . . .	Number	 0040h	 
$Dropped . . . . . . . . . . . . . . .	Number	 0040h	 
$ELSE  . . . . . . . . . . . . . . . .	Number	 009Ch	 
$END . . . . . . . . . . . . . . . . .	Number	 005Ch	 
$ENGINEERING . . . . . . . . . . . . .	Number	 00ECh	 
$ERROR . . . . . . . . . . . . . . . .	Number	 00CCh	 
$EXIT  . . . . . . . . . . . . . . . .	Number	 00A8h	 
$EXPOSE  . . . . . . . . . . . . . . .	Number	 00BCh	 
$Ee  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$EndBuffer . . . . . . . . . . . . . .	Number	 000Ah	 
$Eof . . . . . . . . . . . . . . . . .	Text   	 1ah
$Eos . . . . . . . . . . . . . . . . .	Number	 0000h	 
$Eq  . . . . . . . . . . . . . . . . .	Number	 002Bh	 
$Exposed . . . . . . . . . . . . . . .	Number	 0050h	 
$FAILURE . . . . . . . . . . . . . . .	Number	 00C9h	 
$FOREVER . . . . . . . . . . . . . . .	Number	 0118h	 
$FORM  . . . . . . . . . . . . . . . .	Number	 00E8h	 
$FOR . . . . . . . . . . . . . . . . .	Number	 0064h	 
$FUZZ  . . . . . . . . . . . . . . . .	Number	 00E5h	 
$FileBufferSize  . . . . . . . . . . .	Number	 0400h	 
$Ge  . . . . . . . . . . . . . . . . .	Number	 002Fh	 
$Group . . . . . . . . . . . . . . . .	Number	 00FCh	 
$Gt  . . . . . . . . . . . . . . . . .	Number	 0030h	 
$HALT  . . . . . . . . . . . . . . . .	Number	 00CAh	 
$Hex . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$IF  . . . . . . . . . . . . . . . . .	Number	 00D4h	 
$INPUT . . . . . . . . . . . . . . . .	Number	 00D8h	 
$INTERPRET . . . . . . . . . . . . . .	Number	 00A4h	 
$ITERATE . . . . . . . . . . . . . . .	Number	 00B5h	 
$InitStackSize . . . . . . . . . . . .	Number	 2000h	 
$Invalid . . . . . . . . . . . . . . .	Number	 0009h	 
$LEAVE . . . . . . . . . . . . . . . .	Number	 00B4h	 
$LINEIN  . . . . . . . . . . . . . . .	Number	 007Ch	 
$LOSTDIGITS  . . . . . . . . . . . . .	Number	 00C5h	 
$Label . . . . . . . . . . . . . . . .	Number	 008Bh	 
$Leeway  . . . . . . . . . . . . . . .	Number	 0003h	 
$Letter  . . . . . . . . . . . . . . .	Number	 0080h	 
$Le  . . . . . . . . . . . . . . . . .	Number	 002Eh	 
$Lf  . . . . . . . . . . . . . . . . .	Text   	 0ah
$Limit_Digits  . . . . . . . . . . . .	Number	 270Fh	 
$Limit_EnvironmentName . . . . . . . .	Number	 000Ah	 
$Limit_ExponentDigits  . . . . . . . .	Number	 0009h	 
$Limit_Insert  . . . . . . . . . . . .	Number	 0032h	 
$Limit_Literal . . . . . . . . . . . .	Number	 00FAh	 
$Limit_Major . . . . . . . . . . . . .	Number	 0036h	 
$Limit_Name  . . . . . . . . . . . . .	Number	 00FAh	 
$Limit_String  . . . . . . . . . . . .	Number	 C350h	 
$LineFeed  . . . . . . . . . . . . . .	Number	 0027h	 
$Lowercase . . . . . . . . . . . . . .	Number	 0048h	 
$Lparen  . . . . . . . . . . . . . . .	Number	 000Ch	 
$Lt  . . . . . . . . . . . . . . . . .	Number	 002Dh	 
$M090  . . . . . . . . . . . . . . . .	Number	 0010h	 
$MaxParms  . . . . . . . . . . . . . .	Number	 0064h	 
$MaxPreInsert  . . . . . . . . . . . .	Number	 00AFh	 
$Minus . . . . . . . . . . . . . . . .	Number	 0024h	 
$MsgChunk  . . . . . . . . . . . . . .	Number	 0050h	 
$MsgNum  . . . . . . . . . . . . . . .	Number	 0044h	 
$MsgRoom . . . . . . . . . . . . . . .	Number	 00C8h	 
$NAME  . . . . . . . . . . . . . . . .	Number	 00DCh	 
$NOP . . . . . . . . . . . . . . . . .	Number	 00A0h	 
$NORMAL  . . . . . . . . . . . . . . .	Number	 0114h	 
$NOTREADY  . . . . . . . . . . . . . .	Number	 00C8h	 
$NOVALUE . . . . . . . . . . . . . . .	Number	 00C6h	 
$NUMBER  . . . . . . . . . . . . . . .	Number	 0044h	 
$NUMERIC . . . . . . . . . . . . . . .	Number	 00E0h	 
$Ne  . . . . . . . . . . . . . . . . .	Number	 002Ch	 
$NoMatch . . . . . . . . . . . . . . .	Number	 00FFh	 
$NonUpable . . . . . . . . . . . . . .	Number	 0008h	 
$Not . . . . . . . . . . . . . . . . .	Number	 0020h	 
$NullString  . . . . . . . . . . . . .	Number	 0080h	 
$Num . . . . . . . . . . . . . . . . .	Number	 000Ch	 
$OFF . . . . . . . . . . . . . . . . .	Number	 011Ch	 
$OKb . . . . . . . . . . . . . . . . .	Number	 0020h	 
$OKx . . . . . . . . . . . . . . . . .	Number	 0010h	 
$ON  . . . . . . . . . . . . . . . . .	Number	 0120h	 
$OPTIONS . . . . . . . . . . . . . . .	Number	 00A5h	 
$OTHERWISE . . . . . . . . . . . . . .	Number	 00F0h	 
$OUTPUT  . . . . . . . . . . . . . . .	Number	 00F4h	 
$Omitted . . . . . . . . . . . . . . .	Number	 0088h	 
$Or  . . . . . . . . . . . . . . . . .	Number	 0015h	 
$PARSE . . . . . . . . . . . . . . . .	Number	 00F8h	 
$PROCEDURE . . . . . . . . . . . . . .	Number	 00FCh	 
$PULL  . . . . . . . . . . . . . . . .	Number	 0080h	 
$PUSH  . . . . . . . . . . . . . . . .	Number	 00A9h	 
$Pad . . . . . . . . . . . . . . . . .	Number	 0018h	 
$PcodesBase  . . . . . . . . . . . . .	Number	 0001h	 
$PcodesCeil  . . . . . . . . . . . . .	Number	 00C5h	 
$Percent . . . . . . . . . . . . . . .	Number	 0010h	 
$PjumpBase . . . . . . . . . . . . . .	Number	 0057h	 
$PjumpCeil . . . . . . . . . . . . . .	Number	 0089h	 
$PlusMinus . . . . . . . . . . . . . .	Text   	 $AttribPlus and $Group
$Plus  . . . . . . . . . . . . . . . .	Number	 0025h	 
$Power . . . . . . . . . . . . . . . .	Number	 0050h	 
$QUEUE . . . . . . . . . . . . . . . .	Number	 00AAh	 
$REPLACE . . . . . . . . . . . . . . .	Number	 0108h	 
$RETURN  . . . . . . . . . . . . . . .	Number	 00ABh	 
$Rem . . . . . . . . . . . . . . . . .	Number	 0013h	 
$Rparen  . . . . . . . . . . . . . . .	Number	 0038h	 
$SAY . . . . . . . . . . . . . . . . .	Number	 00ACh	 
$SCIENTIFIC  . . . . . . . . . . . . .	Number	 00EDh	 
$SELECT  . . . . . . . . . . . . . . .	Number	 0100h	 
$SIGNAL  . . . . . . . . . . . . . . .	Number	 00C0h	 
$SOURCE  . . . . . . . . . . . . . . .	Number	 007Dh	 
$STEM  . . . . . . . . . . . . . . . .	Number	 010Ch	 
$STREAM  . . . . . . . . . . . . . . .	Number	 0110h	 
$STRING  . . . . . . . . . . . . . . .	Number	 003Ch	 
$SYNTAX  . . . . . . . . . . . . . . .	Number	 00C4h	 
$Semi  . . . . . . . . . . . . . . . .	Number	 0004h	 
$Seq . . . . . . . . . . . . . . . . .	Number	 0031h	 
$SerialCompaction  . . . . . . . . . .	Number	 0002h	 
$SerialInterpret . . . . . . . . . . .	Number	 0003h	 
$SerialNone  . . . . . . . . . . . . .	Number	 0000h	 
$SerialQue . . . . . . . . . . . . . .	Number	 0001h	 
$SerialSource  . . . . . . . . . . . .	Number	 0004h	 
$Sge . . . . . . . . . . . . . . . . .	Number	 0035h	 
$Sgt . . . . . . . . . . . . . . . . .	Number	 0036h	 
$ShiftV  . . . . . . . . . . . . . . .	Number	 0003h	 
$Sigl  . . . . . . . . . . . . . . . .	Number	 0048h	 
$SizeConstsHeader  . . . . . . . . . .	Number	 0014h	 
$Slash . . . . . . . . . . . . . . . .	Number	 0012h	 
$Sle . . . . . . . . . . . . . . . . .	Number	 0034h	 
$Slt . . . . . . . . . . . . . . . . .	Number	 0033h	 
$Sne . . . . . . . . . . . . . . . . .	Number	 0032h	 
$SourceBufferSize  . . . . . . . . . .	Number	 11C8h	 
$Special . . . . . . . . . . . . . . .	Number	 00C0h	 
$Stem  . . . . . . . . . . . . . . . .	Number	 0060h	 
$Stream  . . . . . . . . . . . . . . .	Number	 0020h	 
$StrideA . . . . . . . . . . . . . . .	Number	 0006h	 
$StrideD . . . . . . . . . . . . . . .	Number	 0028h	 
$StrideF . . . . . . . . . . . . . . .	Number	 001Ah	 
$StrideH . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideJ . . . . . . . . . . . . . . .	Number	 000Eh	 
$StrideL . . . . . . . . . . . . . . .	Number	 007Ch	 
$StrideS . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideV . . . . . . . . . . . . . . .	Number	 0008h	 
$Symbol  . . . . . . . . . . . . . . .	Number	 0028h	 
$SysCount  . . . . . . . . . . . . . .	Number	 000Bh	 
$THEN  . . . . . . . . . . . . . . . .	Number	 0060h	 
$TO  . . . . . . . . . . . . . . . . .	Number	 0068h	 
$TRACE . . . . . . . . . . . . . . . .	Number	 00B0h	 
$Test  . . . . . . . . . . . . . . . .	Number	 00C0h	 
$TraceAssign . . . . . . . . . . . . .	Number	 0000h	 
$TraceBY . . . . . . . . . . . . . . .	Number	 0002h	 
$TraceBack . . . . . . . . . . . . . .	Number	 001Ah	 
$TraceClause . . . . . . . . . . . . .	Number	 0004h	 
$TraceCompound . . . . . . . . . . . .	Number	 0006h	 
$TraceDot  . . . . . . . . . . . . . .	Number	 0008h	 
$TraceEndClause  . . . . . . . . . . .	Number	 001Eh	 
$TraceError  . . . . . . . . . . . . .	Number	 000Ah	 
$TraceExpr . . . . . . . . . . . . . .	Number	 000Ch	 
$TraceFailure  . . . . . . . . . . . .	Number	 000Eh	 
$TraceFunction . . . . . . . . . . . .	Number	 0010h	 
$TraceLit  . . . . . . . . . . . . . .	Number	 0016h	 
$TraceOperator . . . . . . . . . . . .	Number	 0012h	 
$TraceParse  . . . . . . . . . . . . .	Number	 001Ch	 
$TracePrefix . . . . . . . . . . . . .	Number	 0014h	 
$TraceVar  . . . . . . . . . . . . . .	Number	 0018h	 
$UNTIL . . . . . . . . . . . . . . . .	Number	 0070h	 
$UPPER . . . . . . . . . . . . . . . .	Number	 00D0h	 
$UnAccept  . . . . . . . . . . . . . .	Number	 0008h	 
$VALUE . . . . . . . . . . . . . . . .	Number	 0058h	 
$VAR_SYMBOL  . . . . . . . . . . . . .	Number	 0048h	 
$VAR . . . . . . . . . . . . . . . . .	Number	 0084h	 
$VERSION . . . . . . . . . . . . . . .	Number	 007Eh	 
$Variable  . . . . . . . . . . . . . .	Number	 0089h	 
$WHEN  . . . . . . . . . . . . . . . .	Number	 0104h	 
$WHILE . . . . . . . . . . . . . . . .	Number	 0074h	 
$WITH  . . . . . . . . . . . . . . . .	Number	 0078h	 
$White . . . . . . . . . . . . . . . .	Number	 0000h	 
$WholeGE . . . . . . . . . . . . . . .	Number	 0004h	 
$WholeGT . . . . . . . . . . . . . . .	Number	 0008h	 
$WholeNum  . . . . . . . . . . . . . .	Number	 0014h	 
$Whole . . . . . . . . . . . . . . . .	Number	 0000h	 
$Xor . . . . . . . . . . . . . . . . .	Number	 0014h	 
$Xx  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$mParseEnd . . . . . . . . . . . . . .	Number	 001Ah	 
$mParseEscape  . . . . . . . . . . . .	Number	 0012h	 
$mPattern  . . . . . . . . . . . . . .	Number	 002Ah	 
$mPosEq  . . . . . . . . . . . . . . .	Number	 0032h	 
$mPosMinus . . . . . . . . . . . . . .	Number	 0042h	 
$mPosPlus  . . . . . . . . . . . . . .	Number	 003Ah	 
$mPosRest  . . . . . . . . . . . . . .	Number	 0022h	 
$mRepTail  . . . . . . . . . . . . . .	Number	 0002h	 
$mTemplateComma  . . . . . . . . . . .	Number	 004Ah	 
$mUpper  . . . . . . . . . . . . . . .	Number	 000Ah	 
$n17p1 . . . . . . . . . . . . . . . .	Number	 0002h	 
$n40p3 . . . . . . . . . . . . . . . .	Number	 0004h	 
$n40p4 . . . . . . . . . . . . . . . .	Number	 0006h	 
$n40p5 . . . . . . . . . . . . . . . .	Number	 0008h	 
$n7p3  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nArg  . . . . . . . . . . . . . . . .	Number	 0004h	 
$nDigits . . . . . . . . . . . . . . .	Number	 0000h	 
$nForm . . . . . . . . . . . . . . . .	Number	 0004h	 
$nFuzz . . . . . . . . . . . . . . . .	Number	 0002h	 
$nLineIn . . . . . . . . . . . . . . .	Number	 0006h	 
$nNormal . . . . . . . . . . . . . . .	Number	 0040h	 
$nPull . . . . . . . . . . . . . . . .	Number	 0008h	 
$nSource . . . . . . . . . . . . . . .	Number	 000Ah	 
$nStem . . . . . . . . . . . . . . . .	Number	 0000h	 
$nStream . . . . . . . . . . . . . . .	Number	 0020h	 
$nVar  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nVersion  . . . . . . . . . . . . . .	Number	 000Ch	 
$nWith . . . . . . . . . . . . . . . .	Number	 0002h	 
$pAbut . . . . . . . . . . . . . . . .	Number	 0001h	 
$pAddress  . . . . . . . . . . . . . .	Number	 00A5h	 
$pAdd  . . . . . . . . . . . . . . . .	Number	 003Fh	 
$pAnd  . . . . . . . . . . . . . . . .	Number	 0035h	 
$pAssignConst  . . . . . . . . . . . .	Number	 0099h	 
$pAssignDotsP  . . . . . . . . . . . .	Number	 0007h	 
$pAssignDots . . . . . . . . . . . . .	Number	 0097h	 
$pAssignStem . . . . . . . . . . . . .	Number	 0095h	 
$pAssign . . . . . . . . . . . . . . .	Number	 0093h	 
$pBifGroup . . . . . . . . . . . . . .	Number	 00ADh	 
$pBifq . . . . . . . . . . . . . . . .	Number	 002Bh	 
$pBif  . . . . . . . . . . . . . . . .	Number	 00ABh	 
$pBool . . . . . . . . . . . . . . . .	Number	 00A1h	 
$pBy . . . . . . . . . . . . . . . . .	Number	 0011h	 
$pCallOn . . . . . . . . . . . . . . .	Number	 008Fh	 
$pCall . . . . . . . . . . . . . . . .	Number	 0055h	 
$pCat  . . . . . . . . . . . . . . . .	Number	 0003h	 
$pCeq  . . . . . . . . . . . . . . . .	Number	 007Dh	 
$pCge  . . . . . . . . . . . . . . . .	Number	 0085h	 
$pCgt  . . . . . . . . . . . . . . . .	Number	 0087h	 
$pCle  . . . . . . . . . . . . . . . .	Number	 0083h	 
$pClt  . . . . . . . . . . . . . . . .	Number	 0081h	 
$pCne  . . . . . . . . . . . . . . . .	Number	 007Fh	 
$pCommandEnv . . . . . . . . . . . . .	Number	 00A7h	 
$pCommand  . . . . . . . . . . . . . .	Number	 004Dh	 
$pControlVar . . . . . . . . . . . . .	Number	 005Bh	 
$pDivide . . . . . . . . . . . . . . .	Number	 0045h	 
$pDotControlVar  . . . . . . . . . . .	Number	 005Dh	 
$pDots . . . . . . . . . . . . . . . .	Number	 0091h	 
$pDropList . . . . . . . . . . . . . .	Number	 00B7h	 
$pDrop . . . . . . . . . . . . . . . .	Number	 009Dh	 
$pEnvName  . . . . . . . . . . . . . .	Number	 00A9h	 
$pEq . . . . . . . . . . . . . . . . .	Number	 0065h	 
$pExit . . . . . . . . . . . . . . . .	Number	 0027h	 
$pExposeList . . . . . . . . . . . . .	Number	 00B9h	 
$pExpose . . . . . . . . . . . . . . .	Number	 009Fh	 
$pFor  . . . . . . . . . . . . . . . .	Number	 0013h	 
$pGe . . . . . . . . . . . . . . . . .	Number	 006Dh	 
$pGt . . . . . . . . . . . . . . . . .	Number	 006Fh	 
$pIntDivide  . . . . . . . . . . . . .	Number	 0047h	 
$pInterpEnd  . . . . . . . . . . . . .	Number	 0089h	 
$pInterpret  . . . . . . . . . . . . .	Number	 004Fh	 
$pInvoke . . . . . . . . . . . . . . .	Number	 0053h	 
$pIterCV . . . . . . . . . . . . . . .	Number	 00A3h	 
$pIterRep  . . . . . . . . . . . . . .	Number	 0019h	 
$pIterate  . . . . . . . . . . . . . .	Number	 001Bh	 
$pJump . . . . . . . . . . . . . . . .	Number	 0063h	 
$pLeave  . . . . . . . . . . . . . . .	Number	 001Dh	 
$pLength . . . . . . . . . . . . . . .	Number	 002Dh	 
$pLe . . . . . . . . . . . . . . . . .	Number	 006Bh	 
$pLt . . . . . . . . . . . . . . . . .	Number	 0069h	 
$pMax  . . . . . . . . . . . . . . . .	Number	 002Fh	 
$pMin  . . . . . . . . . . . . . . . .	Number	 0031h	 
$pMultiply . . . . . . . . . . . . . .	Number	 0043h	 
$pNegate . . . . . . . . . . . . . . .	Number	 003Dh	 
$pNe . . . . . . . . . . . . . . . . .	Number	 0067h	 
$pNop  . . . . . . . . . . . . . . . .	Number	 0005h	 
$pNot  . . . . . . . . . . . . . . . .	Number	 0033h	 
$pNumber . . . . . . . . . . . . . . .	Number	 000Dh	 
$pNumeric  . . . . . . . . . . . . . .	Number	 0051h	 
$pOptions  . . . . . . . . . . . . . .	Number	 00C3h	 
$pOr . . . . . . . . . . . . . . . . .	Number	 0037h	 
$pParse  . . . . . . . . . . . . . . .	Number	 0009h	 
$pPositive . . . . . . . . . . . . . .	Number	 003Bh	 
$pPower  . . . . . . . . . . . . . . .	Number	 004Bh	 
$pPush . . . . . . . . . . . . . . . .	Number	 00BBh	 
$pQueue  . . . . . . . . . . . . . . .	Number	 00BDh	 
$pRaise  . . . . . . . . . . . . . . .	Number	 00AFh	 
$pRemainder  . . . . . . . . . . . . .	Number	 0049h	 
$pRepEver  . . . . . . . . . . . . . .	Number	 0059h	 
$pRep  . . . . . . . . . . . . . . . .	Number	 0057h	 
$pResult . . . . . . . . . . . . . . .	Number	 0021h	 
$pResumeParse  . . . . . . . . . . . .	Number	 000Bh	 
$pReturns  . . . . . . . . . . . . . .	Number	 0025h	 
$pReturn . . . . . . . . . . . . . . .	Number	 0023h	 
$pSay  . . . . . . . . . . . . . . . .	Number	 0029h	 
$pSeq  . . . . . . . . . . . . . . . .	Number	 0071h	 
$pSge  . . . . . . . . . . . . . . . .	Number	 0079h	 
$pSgt  . . . . . . . . . . . . . . . .	Number	 007Bh	 
$pSignalOff  . . . . . . . . . . . . .	Number	 00B1h	 
$pSignalOn . . . . . . . . . . . . . .	Number	 008Dh	 
$pSignalV  . . . . . . . . . . . . . .	Number	 00B3h	 
$pSignal . . . . . . . . . . . . . . .	Number	 008Bh	 
$pSle  . . . . . . . . . . . . . . . .	Number	 0077h	 
$pSlt  . . . . . . . . . . . . . . . .	Number	 0075h	 
$pSne  . . . . . . . . . . . . . . . .	Number	 0073h	 
$pSubtract . . . . . . . . . . . . . .	Number	 0041h	 
$pSysVar . . . . . . . . . . . . . . .	Number	 00B5h	 
$pThen . . . . . . . . . . . . . . . .	Number	 005Fh	 
$pTo . . . . . . . . . . . . . . . . .	Number	 000Fh	 
$pTraceEvent . . . . . . . . . . . . .	Number	 00C1h	 
$pTrace  . . . . . . . . . . . . . . .	Number	 00BFh	 
$pUnDo . . . . . . . . . . . . . . . .	Number	 001Fh	 
$pUnstore  . . . . . . . . . . . . . .	Number	 009Bh	 
$pUntil  . . . . . . . . . . . . . . .	Number	 0017h	 
$pWhen . . . . . . . . . . . . . . . .	Number	 0061h	 
$pWhile  . . . . . . . . . . . . . . .	Number	 0015h	 
$pXor  . . . . . . . . . . . . . . . .	Number	 0039h	 
$ret . . . . . . . . . . . . . . . . .	Number	 00C3h	 
$sAddress  . . . . . . . . . . . . . .	Number	 002Dh	 
$sDigits . . . . . . . . . . . . . . .	Number	 0027h	 
$sDropList . . . . . . . . . . . . . .	Number	 000Bh	 
$sDrop . . . . . . . . . . . . . . . .	Number	 0006h	 
$sEq . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$sExit . . . . . . . . . . . . . . . .	Number	 0032h	 
$sForm . . . . . . . . . . . . . . . .	Number	 002Bh	 
$sIterate  . . . . . . . . . . . . . .	Number	 003Fh	 
$sLeave  . . . . . . . . . . . . . . .	Number	 003Eh	 
$sLength . . . . . . . . . . . . . . .	Number	 0017h	 
$sMinus  . . . . . . . . . . . . . . .	Number	 0014h	 
$sNegate . . . . . . . . . . . . . . .	Number	 0030h	 
$sNop  . . . . . . . . . . . . . . . .	Number	 002Ah	 
$sNumber . . . . . . . . . . . . . . .	Number	 0037h	 
$sPercent  . . . . . . . . . . . . . .	Number	 0000h	 
$sPositive . . . . . . . . . . . . . .	Number	 0031h	 
$sRaise  . . . . . . . . . . . . . . .	Number	 0039h	 
$sReturns  . . . . . . . . . . . . . .	Number	 0035h	 
$sSeq  . . . . . . . . . . . . . . . .	Number	 0021h	 
$sStem . . . . . . . . . . . . . . . .	Number	 0009h	 
$sWith . . . . . . . . . . . . . . . .	Number	 000Ah	 
$tBinary . . . . . . . . . . . . . . .	Number	 00FDh	 
$tChar . . . . . . . . . . . . . . . .	Number	 00FFh	 
$tLabel  . . . . . . . . . . . . . . .	Number	 00FEh	 
??0000 . . . . . . . . . . . . . . . .	Number	 0200h	 
??0001 . . . . . . . . . . . . . . . .	Number	 0400h	 
??0002 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0003 . . . . . . . . . . . . . . . .	Number	 8000h	 
??0005 . . . . . . . . . . . . . . . .	Number	 0002h	 
??0006 . . . . . . . . . . . . . . . .	Number	 0002h	 
??0007 . . . . . . . . . . . . . . . .	Number	 0002h	 
??0008 . . . . . . . . . . . . . . . .	Number	 0040h	 
??0009 . . . . . . . . . . . . . . . .	Number	 0200h	 
?BIF . . . . . . . . . . . . . . . . .	Number	 0002h	 
?CLAUSELOCAL . . . . . . . . . . . . .	Number	 000Eh	 
?CLAUSETIME  . . . . . . . . . . . . .	Number	 000Ch	 
?LINEIN_POSITION . . . . . . . . . . .	Number	 000Ah	 
?MONTHS  . . . . . . . . . . . . . . .	Number	 0010h	 
?OUTCOME . . . . . . . . . . . . . . .	Number	 0000h	 
?RESPONSE  . . . . . . . . . . . . . .	Number	 0008h	 
?STARTTIME . . . . . . . . . . . . . .	Number	 0014h	 
?STREAMSTATE . . . . . . . . . . . . .	Number	 0006h	 
?STREAM  . . . . . . . . . . . . . . .	Number	 0004h	 
?WEEKDAYS  . . . . . . . . . . . . . .	Number	 0012h	 
@3p13Two . . . . . . . . . . . . . . .	L Near	 0529	  _TEXT	
@3p16Done  . . . . . . . . . . . . . .	L Near	 0589	  _TEXT	
@3p16None  . . . . . . . . . . . . . .	L Near	 0586	  _TEXT	
@3p16Two . . . . . . . . . . . . . . .	L Near	 0565	  _TEXT	
@3p16loop  . . . . . . . . . . . . . .	L Near	 0577	  _TEXT	
@3p16x . . . . . . . . . . . . . . . .	L Near	 0588	  _TEXT	
@3p21Alloc . . . . . . . . . . . . . .	L Near	 0612	  _TEXT	
@3p21Four  . . . . . . . . . . . . . .	L Near	 0626	  _TEXT	
@3p21Long  . . . . . . . . . . . . . .	L Near	 0663	  _TEXT	
@3p21Move  . . . . . . . . . . . . . .	L Near	 063C	  _TEXT	
@3p21NoPad . . . . . . . . . . . . . .	L Near	 05EB	  _TEXT	
@3p21Three . . . . . . . . . . . . . .	L Near	 0622	  _TEXT	
@3p22ClipX . . . . . . . . . . . . . .	L Near	 06EF	  _TEXT	
@3p22Clip  . . . . . . . . . . . . . .	L Near	 06F2	  _TEXT	
@3p22Done  . . . . . . . . . . . . . .	L Near	 06C1	  _TEXT	
@3p22Long  . . . . . . . . . . . . . .	L Near	 06E2	  _TEXT	
@3p22Null  . . . . . . . . . . . . . .	L Near	 06E9	  _TEXT	
@3p26LoopX . . . . . . . . . . . . . .	L Near	 0732	  _TEXT	
@3p26Loop  . . . . . . . . . . . . . .	L Near	 0733	  _TEXT	
@3p26Zero  . . . . . . . . . . . . . .	L Near	 0750	  _TEXT	
@3p26  . . . . . . . . . . . . . . . .	L Near	 0752	  _TEXT	
@3p30ret . . . . . . . . . . . . . . .	L Near	 0783	  _TEXT	
@3p30  . . . . . . . . . . . . . . . .	L Near	 076B	  _TEXT	
@3p6ret  . . . . . . . . . . . . . . .	L Near	 037A	  _TEXT	
@3p8None . . . . . . . . . . . . . . .	L Near	 0A4D	  _TEXT	
@3p8Out  . . . . . . . . . . . . . . .	L Near	 0AC3	  _TEXT	
@3p8Three  . . . . . . . . . . . . . .	L Near	 0A39	  _TEXT	
@3p8Two  . . . . . . . . . . . . . . .	L Near	 0A39	  _TEXT	
@4p5 . . . . . . . . . . . . . . . . .	L Near	 07AD	  _TEXT	
@5p2None . . . . . . . . . . . . . . .	L Near	 082C	  _TEXT	
@5p2Omitted  . . . . . . . . . . . . .	L Near	 0824	  _TEXT	
@5p2One  . . . . . . . . . . . . . . .	L Near	 0839	  _TEXT	
@5p2Pcode  . . . . . . . . . . . . . .	L Near	 07EF	  _TEXT	
@5p2Ret  . . . . . . . . . . . . . . .	L Near	 0837	  _TEXT	
@5p3I  . . . . . . . . . . . . . . . .	L Near	 0885	  _TEXT	
@5p4Like . . . . . . . . . . . . . . .	L Near	 088B	  _TEXT	
@5p8One  . . . . . . . . . . . . . . .	L Near	 08DC	  _TEXT	
@5p9Null . . . . . . . . . . . . . . .	L Near	 0935	  _TEXT	
@5p9Show . . . . . . . . . . . . . . .	L Near	 093C	  _TEXT	
@8p6Env  . . . . . . . . . . . . . . .	L Near	 0C30	  _TEXT	
@8p6Three  . . . . . . . . . . . . . .	L Near	 0BFA	  _TEXT	
@8p6Two  . . . . . . . . . . . . . . .	L Near	 0BD5	  _TEXT	
@8p6 . . . . . . . . . . . . . . . . .	L Near	 0C52	  _TEXT	
@9p3p17  . . . . . . . . . . . . . . .	L Near	 05C2	  _TEXT	
@CodeSize  . . . . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . . . . .	Text   	 DGROUP
AfterCheck . . . . . . . . . . . . . .	L Near	 0276	  _TEXT	Public
AllocateCx_EsAx  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AnyRet . . . . . . . . . . . . . . . .	L Near	 00FF	  _TEXT	
ArrayBx  . . . . . . . . . . . . . . .	Text   	 bx
ArraySi  . . . . . . . . . . . . . . .	Text   	 si
Assert . . . . . . . . . . . . . . . .	Text   	 .erre
AssignExposed  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AssureSiPlus . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AttribAl . . . . . . . . . . . . . . .	Text   	 al
Attributes . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AwayEsAxCx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Away . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ax2DsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
A  . . . . . . . . . . . . . . . . . .	Text   	 (Ashape ptr[bp+si])
B4VALUE1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
B4VALUE2 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BackEsSi . . . . . . . . . . . . . . .	L Near	 060D	  _TEXT	
Bif$$  . . . . . . . . . . . . . . . .	L Near	 01F0	  _TEXT	Public
BifABS . . . . . . . . . . . . . . . .	L Near	 0788	  _TEXT	
BifADDRESS . . . . . . . . . . . . . .	L Near	 07B9	  _TEXT	
BifARG . . . . . . . . . . . . . . . .	L Near	 07D4	  _TEXT	
BifArgPad  . . . . . . . . . . . . . .	L Near	 032A	  _TEXT	
BifB2X . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifBITAND  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifBITOR . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifBITXOR  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifBcoded  . . . . . . . . . . . . . .	L Near	 02B3	  _TEXT	
BifBound . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifC2D . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifC2X . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifCHANGESTR . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifCHARIN  . . . . . . . . . . . . . .	L Near	 09BF	  _TEXT	Public
BifCHAROUT . . . . . . . . . . . . . .	L Near	 09C4	  _TEXT	Public
BifCONDITION . . . . . . . . . . . . .	L Near	 085F	  _TEXT	
BifCOPIES  . . . . . . . . . . . . . .	L Near	 0333	  _TEXT	
BifCOUNTSTR  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifD2C . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifD2X . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifDATATYPE  . . . . . . . . . . . . .	L Near	 0388	  _TEXT	
BifDIGITS  . . . . . . . . . . . . . .	L Near	 0888	  _TEXT	
BifDret  . . . . . . . . . . . . . . .	L Near	 03CA	  _TEXT	
BifFORM  . . . . . . . . . . . . . . .	L Near	 089A	  _TEXT	
BifFUZZ  . . . . . . . . . . . . . . .	L Near	 08C1	  _TEXT	
BifGroup$$ . . . . . . . . . . . . . .	L Near	 01D2	  _TEXT	Public
BifGroup . . . . . . . . . . . . . . .	L Near	 00A0	  _TEXT	
BifLEFT  . . . . . . . . . . . . . . .	L Near	 050C	  _TEXT	
BifLENGTH  . . . . . . . . . . . . . .	L Near	 0C72	  _TEXT	
BifMAX . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifMIN . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifNames . . . . . . . . . . . . . . .	L Near	 0CA2	  _TEXT	Public
BifPOS . . . . . . . . . . . . . . . .	L Near	 0549	  _TEXT	
BifPlain . . . . . . . . . . . . . . .	L Near	 00AC	  _TEXT	
BifQUEUED  . . . . . . . . . . . . . .	L Near	 09CF	  _TEXT	
BifRANDOM  . . . . . . . . . . . . . .	L Near	 0A14	  _TEXT	
BifREVERSE . . . . . . . . . . . . . .	L Near	 0596	  _TEXT	
BifSIGN  . . . . . . . . . . . . . . .	L Near	 0792	  _TEXT	
BifSOURCELINE  . . . . . . . . . . . .	L Near	 08C8	  _TEXT	
BifSTREAM  . . . . . . . . . . . . . .	L Near	 09CC	  _TEXT	Public
BifSUBSTR  . . . . . . . . . . . . . .	L Near	 05C8	  _TEXT	
BifSUBWORD . . . . . . . . . . . . . .	L Near	 0674	  _TEXT	
BifSYMBOL  . . . . . . . . . . . . . .	L Near	 0AD6	  _TEXT	
BifTRACE . . . . . . . . . . . . . . .	L Near	 08F9	  _TEXT	
BifTypes . . . . . . . . . . . . . . .	L Near	 0219	  _TEXT	
BifUsual . . . . . . . . . . . . . . .	L Near	 030E	  _TEXT	
BifVALUE . . . . . . . . . . . . . . .	L Near	 0BA0	  _TEXT	
BifWORDINDEX . . . . . . . . . . . . .	L Near	 0711	  _TEXT	
BifWORD  . . . . . . . . . . . . . . .	L Near	 0702	  _TEXT	
BifX2B . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifX2C . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifX2D . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifXRANGE  . . . . . . . . . . . . . .	L Near	 0757	  _TEXT	
Bifq$$ . . . . . . . . . . . . . . . .	L Near	 0294	  _TEXT	Public
Bifs10 . . . . . . . . . . . . . . . .	L Near	 0E5D	  _TEXT	
Bifs11 . . . . . . . . . . . . . . . .	L Near	 0E73	  _TEXT	
Bifs3  . . . . . . . . . . . . . . . .	L Near	 0CA2	  _TEXT	
Bifs4  . . . . . . . . . . . . . . . .	L Near	 0CD6	  _TEXT	
Bifs5  . . . . . . . . . . . . . . . .	L Near	 0CF9	  _TEXT	
Bifs6  . . . . . . . . . . . . . . . .	L Near	 0D35	  _TEXT	
Bifs7  . . . . . . . . . . . . . . . .	L Near	 0DC1	  _TEXT	
Bifs8  . . . . . . . . . . . . . . . .	L Near	 0E19	  _TEXT	
Bifs9  . . . . . . . . . . . . . . . .	L Near	 0E2B	  _TEXT	
Bifs . . . . . . . . . . . . . . . . .	L Near	 0C90	  _TEXT	Public
BooleryRejumps . . . . . . . . . . . .	Number	 0000h	 External
Boolery  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BoundsDl . . . . . . . . . . . . . . .	Text   	 dl
Bptr . . . . . . . . . . . . . . . . .	Text   	 byte ptr
Bswitch  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CD . . . . . . . . . . . . . . . . . .	Number	 0000h	 
CONFIG_ARITH . . . . . . . . . . . . .	Number	 00FFh	 
CONFIG_B2C . . . . . . . . . . . . . .	Number	 00E9h	 
CONFIG_C2B . . . . . . . . . . . . . .	Number	 00E7h	 
CONFIG_MSG . . . . . . . . . . . . . .	Number	 00E5h	 
CONFIG_RAISE40$$ . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_RAISE40 . . . . . . . . . . . .	Number	 00E1h	 
CONFIG_RAISE . . . . . . . . . . . . .	Number	 00DFh	 
CONFIG_STREAM_CHARIN . . . . . . . . .	Number	 00EDh	 
CONFIG_STREAM_CHAROUT  . . . . . . . .	Number	 00F3h	 
CONFIG_STREAM_CLOSE  . . . . . . . . .	Number	 00F1h	 
CONFIG_STREAM_COMMAND  . . . . . . . .	Number	 00F9h	 
CONFIG_STREAM_COUNT  . . . . . . . . .	Number	 00F5h	 
CONFIG_STREAM_POSITION . . . . . . . .	Number	 00EBh	 
CONFIG_STREAM_QUALIFIED  . . . . . . .	Number	 00F7h	 
CONFIG_STREAM_QUERY  . . . . . . . . .	Number	 00EFh	 
CONFIG_STREAM_STATE  . . . . . . . . .	Number	 00FBh	 
CONFIG_TIME  . . . . . . . . . . . . .	Number	 00FDh	 
CONFIG_UPPER$$ . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_UPPER . . . . . . . . . . . . .	Number	 00E3h	 
ClauseSourceEnd  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Command  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiler . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiling  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Consist  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValueX  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValue . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Create4Dump  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CursorBx . . . . . . . . . . . . . . .	Text   	 bx
CursorSi . . . . . . . . . . . . . . .	Text   	 si
D1 . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD])
DNotA  . . . . . . . . . . . . . . . .	L Near	 0430	  _TEXT	
DNotB  . . . . . . . . . . . . . . . .	L Near	 0439	  _TEXT	
DNotL  . . . . . . . . . . . . . . . .	L Near	 044E	  _TEXT	
DNotM  . . . . . . . . . . . . . . . .	L Near	 0461	  _TEXT	
DNotN  . . . . . . . . . . . . . . . .	L Near	 03F8	  _TEXT	
DNotS  . . . . . . . . . . . . . . . .	L Near	 0476	  _TEXT	
DNotU  . . . . . . . . . . . . . . . .	L Near	 0487	  _TEXT	
DNotW  . . . . . . . . . . . . . . . .	L Near	 0406	  _TEXT	
DNotX  . . . . . . . . . . . . . . . .	L Near	 04C4	  _TEXT	
DNotZ  . . . . . . . . . . . . . . . .	L Near	 04CA	  _TEXT	
DataType . . . . . . . . . . . . . . .	L Near	 03CC	  _TEXT	
Debug  . . . . . . . . . . . . . . . .	Number	 0001h	 
DelayedRaise . . . . . . . . . . . . .	L Near	 00A5	  _TEXT	
DepthBl  . . . . . . . . . . . . . . .	Text   	 bl
DepthBx  . . . . . . . . . . . . . . .	Text   	 bx
DigitsChange . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DosMemCheck  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsExposed  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSiX  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSi . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dptr . . . . . . . . . . . . . . . . .	Text   	 dword ptr
DualSwitch . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dumper . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
D  . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD+$StrideV])
ErrDl  . . . . . . . . . . . . . . . .	Text   	 dl
Error49Bp  . . . . . . . . . . . . . .	Text   	 call bp
ExposedFs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Failed . . . . . . . . . . . . . . . .	L Near	 01B7	  _TEXT	
Fiddling . . . . . . . . . . . . . . .	L Near	 0A9E	  _TEXT	
FileBx . . . . . . . . . . . . . . . .	Text   	 bx
ForBcode . . . . . . . . . . . . . . .	Number	 0000h	 
ForBig . . . . . . . . . . . . . . . .	Number	 0000h	 
Format5n . . . . . . . . . . . . . . .	L Near	 031C	  _TEXT	
Formatn  . . . . . . . . . . . . . . .	L Near	 0318	  _TEXT	
FromBifGroup . . . . . . . . . . . . .	L Near	 029C	  _TEXT	
FromB  . . . . . . . . . . . . . . . .	L Near	 048E	  _TEXT	
FromFORMAT5  . . . . . . . . . . . . .	L Near	 01FE	  _TEXT	
F  . . . . . . . . . . . . . . . . . .	Text   	 (Fshape ptr[bx-$StrideF])
GiveDosMem . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Hang . . . . . . . . . . . . . . . . .	Text   	 jmp $
Hd . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr ds:[0])
HeritageDi . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
He . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr es:[bp])
Hf . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr fs:[bp])
Hg . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr gs:[bp])
HighDi . . . . . . . . . . . . . . . .	Text   	 di
H  . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr[si])
InitMemory . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InitSegDs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InterOff . . . . . . . . . . . . . . .	L Near	 0998	  _TEXT	
IsBad  . . . . . . . . . . . . . . . .	L Near	 0AE4	  _TEXT	
IsLit  . . . . . . . . . . . . . . . .	L Near	 0B00	  _TEXT	
Jbx  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[bx])
Jdi  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[di])
J  . . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[si])
KeyListCx  . . . . . . . . . . . . . .	Text   	 cx
KeysBase . . . . . . . . . . . . . . .	Number	 0028h	 
KeywordOffsetCx  . . . . . . . . . . .	Text   	 cx
Lbx  . . . . . . . . . . . . . . . . .	Text   	 ss:(Lshape ptr[bx-$StrideL+$StrideV])
Length$$ . . . . . . . . . . . . . . .	L Near	 0C79	  _TEXT	Public
LengthAtBx . . . . . . . . . . . . . .	Text   	 bx
LetterList . . . . . . . . . . . . . .	L Near	 012B	  _TEXT	
LevelDi  . . . . . . . . . . . . . . .	Text   	 di
LevelSi  . . . . . . . . . . . . . . .	Text   	 si
LinkBcodeX . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LinkBcode  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookFileDsBx . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookupSi . . . . . . . . . . . . . . .	Text   	 si
Lookup . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LowPartLenCl . . . . . . . . . . . . .	Text   	 cl
LowSi  . . . . . . . . . . . . . . . .	Text   	 si
Lsi  . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+si-$StrideL+$StrideV])
L  . . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+di-$StrideL+$StrideV])
M090$  . . . . . . . . . . . . . . . .	L Near	 0115	  _TEXT	
MajMinDx . . . . . . . . . . . . . . .	Text   	 dx
MajorDh  . . . . . . . . . . . . . . .	Text   	 dh
Max$$  . . . . . . . . . . . . . . . .	L Near	 04CE	  _TEXT	Public
MaxAl  . . . . . . . . . . . . . . . .	Text   	 al
MemCheck . . . . . . . . . . . . . . .	Number	 0001h	 
Min$$  . . . . . . . . . . . . . . . .	L Near	 04D0	  _TEXT	Public
MinAh  . . . . . . . . . . . . . . . .	Text   	 ah
MinorDl  . . . . . . . . . . . . . . .	Text   	 dl
MinorDx  . . . . . . . . . . . . . . .	Text   	 dx
MoreSpaceEs  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Name2File  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NoLetter . . . . . . . . . . . . . . .	L Near	 01B0	  _TEXT	
NonWhi . . . . . . . . . . . . . . . .	L Near	 04B5	  _TEXT	
NotPresent . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Null . . . . . . . . . . . . . . . . .	Number	 00B7h	 
NumDxBx  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
One  . . . . . . . . . . . . . . . . .	Number	 00B5h	 
OpAppendCl . . . . . . . . . . . . . .	Text   	 cl
OpAppendCx . . . . . . . . . . . . . .	Text   	 cx
OpFlags  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OperandBl  . . . . . . . . . . . . . .	Text   	 bl
OperandBx  . . . . . . . . . . . . . .	Text   	 bx
Overlay  . . . . . . . . . . . . . . .	Text   	 0 dup(?)
Pad$ . . . . . . . . . . . . . . . . .	L Near	 00F5	  _TEXT	
ParaAllocAx  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ParmLoop . . . . . . . . . . . . . . .	L Near	 022D	  _TEXT	
ParmsCl  . . . . . . . . . . . . . . .	Text   	 cl
ParmsCx  . . . . . . . . . . . . . . .	Text   	 cx
ParseDot . . . . . . . . . . . . . . .	Number	 00FEh	 
ParseDx  . . . . . . . . . . . . . . .	Text   	 dx
ParseSi  . . . . . . . . . . . . . . .	Text   	 si
PartLenCx  . . . . . . . . . . . . . .	Text   	 cx
Pcode1 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Pcode2 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeArg . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeBif . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	Public
PcodeGapBx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeOp  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PostSubstr . . . . . . . . . . . . . .	L Near	 0164	  _TEXT	
PostTrace  . . . . . . . . . . . . . .	L Near	 0167	  _TEXT	
ProbeBx  . . . . . . . . . . . . . . .	Text   	 bx
ProgEs . . . . . . . . . . . . . . . .	Text   	 es
Qdrop  . . . . . . . . . . . . . . . .	L Near	 0140	  _TEXT	
RadiLoop . . . . . . . . . . . . . . .	L Near	 04A6	  _TEXT	
RadixTypeDl  . . . . . . . . . . . . .	Text   	 dl
Raise40p11 . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise40p26 . . . . . . . . . . . . . .	L Near	 0B9A	  _TEXT	
Raise40p32 . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise40p33 . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise40  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1d  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Random . . . . . . . . . . . . . . . .	L Near	 0AC5	  _TEXT	
RawCharAh  . . . . . . . . . . . . . .	Text   	 ah
RawCharAl  . . . . . . . . . . . . . .	Text   	 al
RawChar  . . . . . . . . . . . . . . .	Text   	 byte ptr ss:[si+bp]
Rejumps  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResultSpace  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResumeP$ . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RetEsSi  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RetSym . . . . . . . . . . . . . . . .	L Near	 0B07	  _TEXT	
RtypeAh  . . . . . . . . . . . . . . .	Text   	 ah
S1 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+$StrideS])
S2 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+2*$StrideS])
Say$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ScanSi . . . . . . . . . . . . . . . .	Text   	 si
ScannerSi  . . . . . . . . . . . . . .	Text   	 si
Scode  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Seeded . . . . . . . . . . . . . . . .	L Near	 0AA6	  _TEXT	
SegOffDi . . . . . . . . . . . . . . .	Text   	 di
Serialize  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetInherit . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetStack . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetSymLenJa  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Solid  . . . . . . . . . . . . . . . .	Number	 0001h	 
SortSpaceSS  . . . . . . . . . . . . .	Number	 0001h	 
SpecsBx  . . . . . . . . . . . . . . .	Text   	 bx
StackDi  . . . . . . . . . . . . . . .	Text   	 di
StackDx  . . . . . . . . . . . . . . .	Text   	 dx
StackSafe  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StackSi  . . . . . . . . . . . . . . .	Text   	 si
StartExecutionY  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StartExecution . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StateBx  . . . . . . . . . . . . . . .	Text   	 bx
StateDi  . . . . . . . . . . . . . . .	Text   	 di
StateSi  . . . . . . . . . . . . . . .	Text   	 si
StemBx . . . . . . . . . . . . . . . .	Text   	 bx
StemEs . . . . . . . . . . . . . . . .	Text   	 es
String1  . . . . . . . . . . . . . . .	Number	 00BBh	 
String2  . . . . . . . . . . . . . . .	Number	 00BDh	 
String . . . . . . . . . . . . . . . .	Number	 00B9h	 
SymBad . . . . . . . . . . . . . . . .	L Near	 0B3E	  _TEXT	
SymLet . . . . . . . . . . . . . . . .	L Near	 0B5E	  _TEXT	
SymLit . . . . . . . . . . . . . . . .	L Near	 0B41	  _TEXT	
SymLoop  . . . . . . . . . . . . . . .	L Near	 0B28	  _TEXT	
SymLoo . . . . . . . . . . . . . . . .	L Near	 0B8A	  _TEXT	
SymNotNum  . . . . . . . . . . . . . .	L Near	 0B90	  _TEXT	
SymSign  . . . . . . . . . . . . . . .	L Near	 0B80	  _TEXT	
SymbolLook . . . . . . . . . . . . . .	L Near	 0B0D	  _TEXT	Public
SymbolsEs  . . . . . . . . . . . . . .	Text   	 es
SymbolsSafe  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymsZiDx . . . . . . . . . . . . . . .	Text   	 dx
S  . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si])
TailSi . . . . . . . . . . . . . . . .	Text   	 si
Terminate  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TestOmitted  . . . . . . . . . . . . .	L Near	 0076	  _TEXT	
TheMsgBh . . . . . . . . . . . . . . .	Text   	 bh
Then$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToDsSiCx . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToFindDx . . . . . . . . . . . . . . .	Text   	 dx
ToFindLenAx  . . . . . . . . . . . . .	Text   	 ax
ToWholeEbx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TokNowCh . . . . . . . . . . . . . . .	Text   	 ch
TokNumAh . . . . . . . . . . . . . . .	Text   	 ah
TqFail . . . . . . . . . . . . . . . .	L Near	 04C6	  _TEXT	
TqNonNull  . . . . . . . . . . . . . .	L Near	 03E6	  _TEXT	
TqOK . . . . . . . . . . . . . . . . .	L Near	 04CA	  _TEXT	
Trace$$  . . . . . . . . . . . . . . .	L Near	 09A7	  _TEXT	Public
Trace$ . . . . . . . . . . . . . . . .	L Near	 0953	  _TEXT	
TraceOK  . . . . . . . . . . . . . . .	L Near	 0994	  _TEXT	
TraceRet . . . . . . . . . . . . . . .	L Near	 099F	  _TEXT	
TraceVerb$ . . . . . . . . . . . . . .	L Near	 08ED	  _TEXT	
Trial  . . . . . . . . . . . . . . . .	Number	 0000h	 
UpStack  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperFirstAh . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
V00  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-2*$StrideV])
V0 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-$StrideV])
V2 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+$StrideV])
V3 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+2*$StrideV])
V4 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+3*$StrideV])
VasDsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Vbxe . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bx])
Vbxf2  . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx+$StrideV])
Vbxf . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx])
Vbxs . . . . . . . . . . . . . . . . .	Text   	 ss:(Vshape ptr[bx])
Vbxt . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx-$CaseTarget])
Vbx  . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[bx])
Vdid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[di])
Ve . . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bp])
Vf . . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bp])
Vsid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[si])
Vsif . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[si])
Vsi  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+si])
V  . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di])
WhichCheck . . . . . . . . . . . . . .	L Near	 00C9	  _TEXT	
WholeGE$ . . . . . . . . . . . . . . .	L Near	 010B	  _TEXT	
WholeGT$ . . . . . . . . . . . . . . .	L Near	 0100	  _TEXT	
WholeNum$  . . . . . . . . . . . . . .	L Near	 0118	  _TEXT	
WithLetter . . . . . . . . . . . . . .	L Near	 039D	  _TEXT	
WordIndex  . . . . . . . . . . . . . .	L Near	 0729	  _TEXT	
Wptr . . . . . . . . . . . . . . . . .	Text   	 word ptr
XCycle . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ycx2 . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[2*ecx+ebp])
Ysi  . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[si])
Y  . . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[bp])
Zero$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZeroBp . . . . . . . . . . . . . . . .	Text   	 bp
Zero . . . . . . . . . . . . . . . . .	Number	 00B3h	 
ZoneNumerics . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZoneToLevel  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Z  . . . . . . . . . . . . . . . . . .	Text   	 (Zshape ptr[bp])
_Eq  . . . . . . . . . . . . . . . . .	Number	 00CDh	 
_Exists  . . . . . . . . . . . . . . .	Number	 00C7h	 
_Ge  . . . . . . . . . . . . . . . . .	Number	 00D5h	 
_Gt  . . . . . . . . . . . . . . . . .	Number	 00D7h	 
_IterCV  . . . . . . . . . . . . . . .	Number	 00C5h	 
_Jump  . . . . . . . . . . . . . . . .	Number	 00CBh	 
_Le  . . . . . . . . . . . . . . . . .	Number	 00D3h	 
_Lt  . . . . . . . . . . . . . . . . .	Number	 00D1h	 
_Ne  . . . . . . . . . . . . . . . . .	Number	 00CFh	 
_RetBc . . . . . . . . . . . . . . . .	Number	 00BFh	 
_RetB  . . . . . . . . . . . . . . . .	Number	 00C1h	 
_RetF  . . . . . . . . . . . . . . . .	Number	 00C3h	 
_Seq . . . . . . . . . . . . . . . . .	Number	 00D9h	 
_Slt . . . . . . . . . . . . . . . . .	Number	 00DDh	 
_Sne . . . . . . . . . . . . . . . . .	Number	 00DBh	 
_Then  . . . . . . . . . . . . . . . .	Number	 00C9h	 
is . . . . . . . . . . . . . . . . . .	Text   	 textequ

	   0 Warnings
	   0 Errors
