Microsoft (R) Macro Assembler Version 6.11		    01/21/12 18:44:27
syntax.asm						     Page 1 - 1


				     ; Copyright Formcroft Ltd 1997-1999
				      .model small
				      .486
 0000				      .code
				     ;------------------------------------------------------------------------------
				     ; Literal and numeric replacements
				     ;------------------------------------------------------------------------------
 = textequ			     is textequ <textequ>
 = byte ptr			     Bptr  is <byte ptr>
 = word ptr			     Wptr  is <word ptr>
 = dword ptr			     Dptr  is <dword ptr>
 = jmp $			     Hang  is <jmp $>
 = 0dh				     $Cr   is <0dh>
 = 0ah				     $Lf   is <0ah>
 = 1ah				     $Eof  is <1ah>
 = 0 dup(?)			     Overlay is <0 dup(?)>
 = .erre			     Assert is <.erre>
				     ;------------------------------------------------------------------------------
				     ; Typedefs. MASMs pointers are offsets in a segment.
				     ; Some of this is to indicate the purpose to the reader rather than MASM,
				     ; ie CHAR v BYTE since both are unsigned 8 bits.
				     ; However, pointerness is worth saying for words containing offsets since
				     ; debugger will take note.
				     ; WORD will tend not to get used since a word is either an integer (USHORT)
				     ; or an offset.
				     ; I haven't yet found the penalty in giving up SHORT as a keyword so as to
				     ; use it in the 'C' sense.
				     ;------------------------------------------------------------------------------
				       option nokeyword:<short>
				       option nokeyword:<C>
				     ; One byte target:
				     char   typedef byte
				     Bool   typedef byte
				     bytep  typedef ptr byte
				     charp  typedef ptr byte
				     charfp  typedef far ptr byte
				     Boolp  typedef ptr byte
				     ; Two byte
				     Ushort typedef word
				     Ushortp typedef ptr word
				     short typedef sword
				     shortp typedef ptr sword
				     Handle typedef word
				     Handlep typedef ptr word
				     Segp typedef word; Slightly different sense.
				     ; Four byte
				     Ulong typedef dword
 0004				     Farp struc; For les,lds
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
				     Farp ends

				     ;------------------------------------------------------------------------------
				     ; Macros
				     ;------------------------------------------------------------------------------

				     MkMajMin macro Maj:req, Min:req
				      
; Makes parts of msg number into one number.
				      exitm %(256*Maj+Min)
				     endm

				     StringOrder macro a:req, b:req, c, d
				      
; Load so that a store puts them in the written order.
				      ifnb <d>
				       exitm %(256*256*256*(d)+256*256*(c)+256*(b)+(a))
				      endif
				      exitm %(256*(b)+(a))
				     endm

				     ; Splat makes a visual 'noise' on the output.
				     Splat macro It:=<'*'>
				      mov dl,It
				      mov ah,02h
				      int 21h
				     endm

				     LoopQ macro tgt:req
				     
; Faster than single loop instruction
				       dec cx
				       jnz tgt
				     endm

				     JcxzQ macro tgt:req
				     
; jcxz is written only where retaining flags matters, else JcxzQ
				     
; JcxzQ can be rendered in way that can do long jump. (And maybe faster)
				       test cx,cx
				       je tgt
				     endm

				     Pos macro Needle:req, Hay:req
				      exitm % @InStr(1,Hay,Needle)
				     endm

				     ; As provided in MASM readme, plus fixing:
				      la macro Dest:req, Symbol:req
				     ; This can go wrong because replacement in operand occurs later.
				     ; Page 583 of Waite suggests we can test this but...
				      if (opattr(Symbol)) and 20h
				        if (opattr(Symbol)) and 08h
				          mov Dest, offset Symbol
				        else
				          lea Dest, Symbol
				        endif
				      else
				        ; Assume MOV if errors
				        mov Dest, offset Symbol
				      endif
				      endm

				     ; Having bp=0 makes a difference to zeroing.
				     ; XOR is no better than MOV of 0, and disturbs flags so this is just shorthand.
				     ; XOR faster than MOV of 0 on some machines?
				     ; Actually XOR is better for accum, but macro can't distinquish accum.
				     ; If Ax is positive CWD is better for DX, but macro doesn't do that.
				      z macro Dest:req
				     ; Drop this bit because XOR never better than register move.
				          if (type Dest) eq 1
				            mov Dest,0
				          else
				            if (type Dest) eq 2
				              mov Dest,bp
				            else
				              if (type Dest) eq 4
				                mov Dest,ebp
				              else
				                Whoops
				              endif
				            endif
				          endif
				      endm

				     ; Illuminate special use of test to set flags.
				     TestReg macro arg:req
				            test arg,arg
				     endm

				     ; Illuminate pop that discards.
				     PopJunk  macro arg:req
				       pop arg
				     endm

				     ; Setting bits in records.
				     ; I'm having trouble with MASM. If arg is complicated, it uses two byte
				     ; offsets where one would do. (Cured by overlay of word on record)
				     ; I cannot get MASM to put what I want on the listing. I would like the
				     ; values computed to show in the listed expansion but MASM will only show
				     ; the macro variable names there.  A % at the beginning of the line returned
				     ; by the macro does nothing. A % before the macro variable name in it is seen
				     ; as a syntax error. Short of conditional generation returning lines with
				     ; only the macro arguments in (these do get replaced on the listing), I don't
				     ; see a solution.

				     On      macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             or  arg,masksum
				       else
				         if masksum gt 255
				             or  Bptr(arg+1), high masksum
				         else
				             or  Bptr(arg), low masksum
				         endif
				       endif
				     endm
				     Off     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             and arg, not masksum
				       else
				         if masksum gt 255
				             and Bptr(arg+1), high not masksum
				         else
				             and Bptr(arg), low not masksum
				         endif
				       endif
				     endm
				     Qry     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             test arg, masksum
				       else
				         if masksum gt 255
				           if @SizeStr("&arg") gt 4
				             test Bptr(arg+1), high masksum
				           else
				             if "cx" ne "&arg"
				               test Bptr(arg+1), high masksum
				             else
				               test ch, high masksum
				             endif
				           endif
				         else
				             test Bptr(arg), low masksum
				         endif
				       endif
				     endm

				     mv   macro To:req,From:req
				     ; Used for segment moves
				      push From
				      pop To
				     endm

				     xax macro To:req
				     ; Used for ax moves when xchg saves a byte. (At expense of cycles)
				     ; Don't use xax form if exchange is "real" exchange.
				      if (type To) eq 2
				        xchg ax,To
				      else
				        xchg eax,To
				      endif
				     endm

				     inc2 macro Subj:req
				     ; Shorter than add Subj,2 when non-acc 16 bit reg.
				      inc Subj
				      inc Subj
				     endm

				     dec2 macro Subj:req
				     ; Shorter than dec Subj,2 when non-acc 16 bit reg.
				      dec Subj
				      dec Subj
				     endm

				     top macro To:req
				     ; Top element of hardware stack without disturbing it.
				      pop To
				      push To
				     endm

				     move macro To:req,From:req,Via
				     ; Memory to memory with arguments in same order as a mov.
				      ifb <Via>
				       if (type To) eq 2
				         mov ax,From
				         mov To,ax
				       elseif (type To) eq 1
				         mov al,From
				         mov To,al
				       else
				         mov eax,From
				         mov To,eax
				       endif
				      else
				       mov Via,From
				       mov To,Via
				      endif
				     endm

				     ;------------------------------------------------------------------------------
				     ; Shapes of structures for based addressing.
				     ;------------------------------------------------------------------------------
				     ; If we PUSHA and then copy SP to BP the caller's
				     ; registers have become locals accessible on [BP].
				     ; Structure PushShape holds the shape for this.
 0010				     PushShape struct
 0000  0000			      di_ word ?
 0002  0000			      si_ word ?
 0004  0000			      bp_ word ?
 0006  0000			      sp_ word ?
 0008	    0000 [		      bx_ word Overlay
	     0000
	    ]
 0008  00			      bl_ byte ?
 0009  00			      bh_ byte ?
 000A	    0000 [		      dx_ word Overlay
	     0000
	    ]
 000A  00			      dl_ byte ?
 000B  00			      dh_ byte ?
 000C	    0000 [		      cx_ word Overlay
	     0000
	    ]
 000C  00			      cl_ byte ?
 000D  00			      ch_ byte ?
 000E	    0000 [		      ax_ word Overlay
	     0000
	    ]
 000E  00			      al_ byte ?
 000F  00			      ah_ byte ?
				     PushShape ends
				     ; Build characteristics:
 = 0000				      CD equ 0; On when dump of compaction activity needed. See CD.REXX
 = 0001				      Debug equ 1; On for normal checks detecting internal flaws early.
 = 0001				      MemCheck equ 1; On for DOS memory checks.
 = 0000				      ForBcode equ 0; When making code that will be turned to BCode.
 = 0000				      ForBig equ 0; When making code that will be turned into one big assembly.
 = 0001				      SortSpaceSS equ 1; Design has compaction list under SS.
 = 0000				      Trial equ 0; Design change experiment.
 = 0001				      Solid equ 1; Always 1, used to mark sensitive areas for ForBig technology.
				     ;(Solid section with following label is assumed not to fall through.)
				     if ForBig
				      endif
				     if Debug
				     CheckType macro
				      test V.Dtype,$Test
				      jz @F
				      cmp V.Dtype,$AwayString
				      je @F
				      cmp V.Dtype,$NullString
				      je @F
				      cmp V.Dtype,$NullString+1
				      je @F
				      cmp V.Dtype,$NullString+2
				      je @F
				      cmp V.Dtype,$NullString+3
				      je @F
				      cmp V.Dtype,$NullString+4
				      je @F
				      cmp V.Dtype,$NullString+5
				      je @F
				      cmp V.Dtype,$NullString+6
				      je @F
				      cmp V.Dtype,$NullString+7
				      je @F
				     endm
				     endif
				      EXTERNDEF ToWholeEbx:near; Converts from Rexx variable to integer in EBX.
				      EXTERNDEF Zero$$:near; Puts zero on the stack.
				      EXTERNDEF Then$$:near; Execution of THEN
				      EXTERNDEF DigitsChange:near; Called at places where Digits() setting may change.
				      EXTERNDEF ZoneNumerics:near; Updates Zone for fast access to numeric settings.
				      EXTERNDEF SetInherit:near; Inherit, for an external routine.
				      EXTERNDEF Compiling:near; To start compiling something.
				      EXTERNDEF Compiler:near; To start compiling something.
				      EXTERNDEF StartExecution:near; To start executing made Pcode.
				      EXTERNDEF StartExecutionY:near; To start executing made Pcode.
				      EXTERNDEF ResumeP$:near; To start executing Pcode after Bcode.
				      EXTERNDEF Command:near; To start compiling source named on a command.
				      EXTERNDEF AssureSiPlus:near
				      EXTERNDEF AssignExposed:near
				      EXTERNDEF Name2File:near
				      EXTERNDEF ZoneToLevel:near
				      EXTERNDEF BifBound:near; A place separating code on basis of address
				      EXTERNDEF ConstValue:near
				      EXTERNDEF ConstValueX:near
				      EXTERNDEF Terminate:near
				      EXTERNDEF UpperFirstAh:near
				      EXTERNDEF NotPresent:near
				      EXTERNDEF Consist:near
				      EXTERNDEF Serialize:near
				      EXTERNDEF RetEsSi:near
				      EXTERNDEF ExposedFs:near, DotsExposed:near
				     ; Make the memory services available to all modules.
				      EXTERNDEF InitMemory:near, AllocateCx_EsAx:near, InitSegDs:near
				      EXTERNDEF MoreSpaceEs:near,GiveDosMem:near
				      EXTERNDEF ParaAllocAx:near, Raise5p1:near, Raise5p1d:near
				      EXTERNDEF StackSafe:near, SetStack:near, UpStack:near
				     ; Most modules need to load values from Rexx variables to registers.
				      EXTERNDEF ToDsSiCx:near, NumDxBx:near
				     ; Many modules create pseudo-code, test operator attributes..
				      EXTERNDEF Scode:near, Pcode1:near, Pcode2:near, PcodeArg:near
				      EXTERNDEF PcodeGapBx:near, PcodeOp:near, OpFlags:near
				     ; Lookup things may be needed in execution, eg for DROP (abc)
				      EXTERNDEF Lookup:near,SymbolsSafe:near,SetSymLenJa:near,SymbolLook:near
				      EXTERNDEF VasDsSiCx:near
				     ; And a few more in common use.
				      EXTERNDEF Ax2DsSiCx:near,HeritageDi:near, Raise:near
				      EXTERNDEF Attributes:near; Table for uppercasing, etc.
				      EXTERNDEF ResultSpace:near, AwayEsAxCx:near
				      EXTERNDEF LinkBcode:near, LinkBcodeX:near
				      EXTERNDEF CONFIG_UPPER$$:near
				      EXTERNDEF CONFIG_RAISE40$$:near
				      EXTERNDEF PcodesBase$:near
				      EXTERNDEF DotsFsBxDsSi:near
				      EXTERNDEF DotsFsBxDsSiX:near
				      EXTERNDEF XCycle:near,Rejumps:near,Boolery:near,BooleryRejumps:abs
				      EXTERNDEF LookFileDsBx:near
				      EXTERNDEF Away:near
				      EXTERNDEF ClauseSourceEnd:near
				      EXTERNDEF DualSwitch:near
				     if Debug
				      EXTERNDEF Say$$:near ; only for Consist debug
				      EXTERNDEF DosMemCheck:near
				      EXTERNDEF Create4Dump:near
				      EXTERNDEF Dumper:near
				     endif

 = 0001				     $PcodesBase equ 01h
 = 005D				     $BPcodesCeil equ 05Dh
 = 00C5				     $PcodesCeil equ 0C5h
 = 0057				     $PjumpBase equ 057h
 = 0089				     $PjumpCeil equ 089h
 = 0001				     $pAbut equ 01h
 = 0003				     $pCat equ 03h
 = 0005				     $pNop equ 05h
 = 0007				     $pAssignDotsP equ 07h
 = 0009				     $pParse equ 09h
 = 000B				     $pResumeParse equ 0Bh
 = 000D				     $pNumber equ 0Dh
 = 000F				     $pTo equ 0Fh
 = 0011				     $pBy equ 011h
 = 0013				     $pFor equ 013h
 = 0015				     $pWhile equ 015h
 = 0017				     $pUntil equ 017h
 = 0019				     $pIterRep equ 019h
 = 001B				     $pIterate equ 01Bh
 = 001D				     $pLeave equ 01Dh
 = 001F				     $pUnDo equ 01Fh
 = 0021				     $pResult equ 021h
 = 0023				     $pReturn equ 023h
 = 0025				     $pReturns equ 025h
 = 0027				     $pExit equ 027h
 = 0029				     $pSay equ 029h
 = 002B				     $pBifq equ 02Bh
 = 002D				     $pLength equ 02Dh
 = 002F				     $pMax equ 02Fh
 = 0031				     $pMin equ 031h
 = 0033				     $pNot equ 033h
 = 0035				     $pAnd equ 035h
 = 0037				     $pOr equ 037h
 = 0039				     $pXor equ 039h
 = 003B				     $pPositive equ 03Bh
 = 003D				     $pNegate equ 03Dh
 = 003F				     $pAdd equ 03Fh
 = 0041				     $pSubtract equ 041h
 = 0043				     $pMultiply equ 043h
 = 0045				     $pDivide equ 045h
 = 0047				     $pIntDivide equ 047h
 = 0049				     $pRemainder equ 049h
 = 004B				     $pPower equ 04Bh
 = 004D				     $pCommand equ 04Dh
 = 004F				     $pInterpret equ 04Fh
 = 0051				     $pNumeric equ 051h
 = 0053				     $pInvoke equ 053h
 = 0055				     $pCall equ 055h
 = 0057				     $pRep equ 057h
 = 0059				     $pRepEver equ 059h
 = 005B				     $pControlVar equ 05Bh
 = 005D				     $pDotControlVar equ 05Dh
 = 005F				     $pThen equ 05Fh
 = 0061				     $pWhen equ 061h
 = 0063				     $pJump equ 063h
 = 0065				     $pEq equ 065h
 = 0067				     $pNe equ 067h
 = 0069				     $pLt equ 069h
 = 006B				     $pLe equ 06Bh
 = 006D				     $pGe equ 06Dh
 = 006F				     $pGt equ 06Fh
 = 0071				     $pSeq equ 071h
 = 0073				     $pSne equ 073h
 = 0075				     $pSlt equ 075h
 = 0077				     $pSle equ 077h
 = 0079				     $pSge equ 079h
 = 007B				     $pSgt equ 07Bh
 = 007D				     $pCeq equ 07Dh
 = 007F				     $pCne equ 07Fh
 = 0081				     $pClt equ 081h
 = 0083				     $pCle equ 083h
 = 0085				     $pCge equ 085h
 = 0087				     $pCgt equ 087h
 = 0089				     $pInterpEnd equ 089h
 = 008B				     $pSignal equ 08Bh
 = 008D				     $pSignalOn equ 08Dh
 = 008F				     $pCallOn equ 08Fh
 = 0091				     $pDots equ 091h
 = 0093				     $pAssign equ 093h
 = 0095				     $pAssignStem equ 095h
 = 0097				     $pAssignDots equ 097h
 = 0099				     $pAssignConst equ 099h
 = 009B				     $pUnstore equ 09Bh
 = 009D				     $pDrop equ 09Dh
 = 009F				     $pExpose equ 09Fh
 = 00A1				     $pBool equ 0A1h
 = 00A3				     $pIterCV equ 0A3h
 = 00A5				     $pAddress equ 0A5h
 = 00A7				     $pCommandEnv equ 0A7h
 = 00A9				     $pEnvName equ 0A9h
 = 00AB				     $pBif equ 0ABh
 = 00AD				     $pBifGroup equ 0ADh
 = 00AF				     $pRaise equ 0AFh
 = 00B1				     $pSignalOff equ 0B1h
 = 00B3				     $pSignalV equ 0B3h
 = 00B5				     $pSysVar equ 0B5h
 = 00B7				     $pDropList equ 0B7h
 = 00B9				     $pExposeList equ 0B9h
 = 00BB				     $pPush equ 0BBh
 = 00BD				     $pQueue equ 0BDh
 = 00BF				     $pTrace equ 0BFh
 = 00C1				     $pTraceEvent equ 0C1h
 = 00C3				     $pOptions equ 0C3h
 = 0000				     $BifDATE equ 0
 = 0001				     $BifTIME equ 1
 = 0002				     $BifLINES equ 2
 = 0003				     $BifCHARS equ 3
 = 0004				     $BifCHARIN equ 4
 = 0005				     $BifCHAROUT equ 5
 = 0006				     $BifLINEIN equ 6
 = 0007				     $BifLINEOUT equ 7
 = 0008				     $BifSTREAM equ 8
 = 0009				     $BifSTRIP equ 9
 = 000A				     $BifVERIFY equ 10
 = 000B				     $BifQUALIFY equ 11
 = 000C				     $BifWORDS equ 12
 = 000D				     $BifTRUNC equ 13
 = 000E				     $BifERRORTEXT equ 14
 = 000F				     $BifSPACE equ 15
 = 0010				     $BifTRANSLATE equ 16
 = 0011				     $BifFORMAT equ 17
 = 0012				     $BifWORDLENGTH equ 18
 = 0013				     $BifWORDPOS equ 19
 = 0014				     $BifABBREV equ 20
 = 0015				     $BifCENTER equ 21
 = 0016				     $BifCENTRE equ 22
 = 0017				     $BifCOMPARE equ 23
 = 0018				     $BifDELSTR equ 24
 = 0019				     $BifDELWORD equ 25
 = 001A				     $BifRIGHT equ 26
 = 001B				     $BifLASTPOS equ 27
 = 001C				     $BifINSERT equ 28
 = 001D				     $BifOVERLAY equ 29
 = 001E				     $BifFORM equ 30
 = 001F				     $BifDATATYPE equ 31
 = 0020				     $BifADDRESS equ 32
 = 0021				     $BifARG equ 33
 = 0022				     $BifCONDITION equ 34
 = 0023				     $BifTRACE equ 35
 = 0024				     $BifFUZZ equ 36
 = 0025				     $BifDIGITS equ 37
 = 0026				     $BifSOURCELINE equ 38
 = 0027				     $BifXRANGE equ 39
 = 0028				     $BifRANDOM equ 40
 = 0029				     $BifREVERSE equ 41
 = 002A				     $BifABS equ 42
 = 002B				     $BifSIGN equ 43
 = 002C				     $BifC2X equ 44
 = 002D				     $BifB2X equ 45
 = 002E				     $BifX2B equ 46
 = 002F				     $BifX2C equ 47
 = 0030				     $BifX2D equ 48
 = 0031				     $BifC2D equ 49
 = 0032				     $BifD2C equ 50
 = 0033				     $BifD2X equ 51
 = 0034				     $BifBITAND equ 52
 = 0035				     $BifBITOR equ 53
 = 0036				     $BifBITXOR equ 54
 = 0037				     $BifVALUE equ 55
 = 0038				     $BifCOPIES equ 56
 = 0039				     $BifWORD equ 57
 = 003A				     $BifWORDINDEX equ 58
 = 003B				     $BifSUBWORD equ 59
 = 003C				     $BifPOS equ 60
 = 003D				     $BifLEFT equ 61
 = 003E				     $BifSUBSTR equ 62
 = 003F				     $BifQUEUED equ 63
 = 0040				     $BifSYMBOL equ 64
 = 0041				     $BifCOUNTSTR equ 65
 = 0042				     $BifCHANGESTR equ 66
 = 0043				     $BifLENGTH equ 67
 = 0044				     $BifMAX equ 68
 = 0045				     $BifMIN equ 69
 = 00B3				     $BcodesBase equ 0B3h
 = 00B3				     Zero equ 0B3h
 = 00B5				     One equ 0B5h
 = 00B7				     Null equ 0B7h
 = 00B9				     String equ 0B9h
 = 00BB				     String1 equ 0BBh
 = 00BD				     String2 equ 0BDh
 = 00BF				     _RetBc equ 0BFh
 = 00C1				     _RetB equ 0C1h
 = 00C3				     _RetF equ 0C3h
 = 00C5				     _IterCV equ 0C5h
 = 00C7				     _Exists equ 0C7h
 = 00C9				     _Then equ 0C9h
 = 00CB				     _Jump equ 0CBh
 = 00CD				     _Eq equ 0CDh
 = 00CF				     _Ne equ 0CFh
 = 00D1				     _Lt equ 0D1h
 = 00D3				     _Le equ 0D3h
 = 00D5				     _Ge equ 0D5h
 = 00D7				     _Gt equ 0D7h
 = 00D9				     _Seq equ 0D9h
 = 00DB				     _Sne equ 0DBh
 = 00DD				     _Slt equ 0DDh
 = 00DF				     CONFIG_RAISE equ 0DFh
 = 00E1				     CONFIG_RAISE40 equ 0E1h
 = 00E3				     CONFIG_UPPER equ 0E3h
 = 00E5				     CONFIG_MSG equ 0E5h
 = 00E7				     CONFIG_C2B equ 0E7h
 = 00E9				     CONFIG_B2C equ 0E9h
 = 00EB				     CONFIG_STREAM_POSITION equ 0EBh
 = 00ED				     CONFIG_STREAM_CHARIN equ 0EDh
 = 00EF				     CONFIG_STREAM_QUERY equ 0EFh
 = 00F1				     CONFIG_STREAM_CLOSE equ 0F1h
 = 00F3				     CONFIG_STREAM_CHAROUT equ 0F3h
 = 00F5				     CONFIG_STREAM_COUNT equ 0F5h
 = 00F7				     CONFIG_STREAM_QUALIFIED equ 0F7h
 = 00F9				     CONFIG_STREAM_COMMAND equ 0F9h
 = 00FB				     CONFIG_STREAM_STATE equ 0FBh
 = 00FD				     CONFIG_TIME equ 0FDh
 = 00FF				     CONFIG_ARITH equ 0FFh
 = 0000				     $0 equ 0
 = 0000				     $Eos equ 0*4
 = 0001				     $12 equ 1
 = 0004				     $Semi equ 1*4
 = 0002				     $11 equ 2
 = 0008				     $UnAccept equ 2*4
 = 0003				     $6 equ 3
 = 000C				     $Lparen equ 3*4
 = 0004				     $3 equ 4
 = 0010				     $Percent equ 4*4
 = 0011				     $Asterisk equ 4*(5-1) + 1
 = 0012				     $Slash equ 4*(5-1) + 2
 = 0013				     $Rem equ 4*(5-1) + 3
 = 0014				     $Xor equ 5*4
 = 0015				     $Or equ 4*(6-1) + 1
 = 0006				     $5 equ 6
 = 0018				     $And equ 6*4
 = 0007				     $10 equ 7
 = 001C				     $Comma equ 7*4
 = 0020				     $Not equ 8*4
 = 0009				     $9 equ 9
 = 0024				     $Minus equ 9*4
 = 0025				     $Plus equ 4*(10-1) + 1
 = 002B				     $Eq equ 10*4+3
 = 002C				     $Ne equ 11*4
 = 002D				     $Lt equ 4*(12-1) + 1
 = 002E				     $Le equ 4*(12-1) + 2
 = 002F				     $Ge equ 4*(12-1) + 3
 = 0030				     $Gt equ 12*4
 = 0031				     $Seq equ 4*(13-1) + 1
 = 0032				     $Sne equ 4*(13-1) + 2
 = 0033				     $Slt equ 4*(13-1) + 3
 = 0034				     $Sle equ 13*4
 = 0035				     $Sge equ 4*(14-1) + 1
 = 0036				     $Sgt equ 4*(14-1) + 2
 = 000E				     $7 equ 14
 = 0038				     $Rparen equ 14*4
 = 003C				     $STRING equ 15*4
 = 0040				     $CONST_SYMBOL equ 16*4
 = 0044				     $NUMBER equ 17*4
 = 0012				     $28 equ 18
 = 0048				     $VAR_SYMBOL equ 18*4
 = 0013				     $1 equ 19
 = 004C				     $Abut equ 19*4
 = 004D				     $Cat equ 4*(20-1) + 1
 = 0014				     $8 equ 20
 = 0050				     $Power equ 20*4
 = 0015				     $2 equ 21
 = 0054				     $Assign equ 21*4
 = 0016				     $21 equ 22
 = 0058				     $VALUE equ 22*4
 = 0017				     $16 equ 23
 = 005C				     $END equ 23*4
 = 0018				     $18 equ 24
 = 0060				     $THEN equ 24*4
 = 0019				     $17 equ 25
 = 0064				     $FOR equ 25*4
 = 001A				     $19 equ 26
 = 0068				     $TO equ 26*4
 = 001B				     $15 equ 27
 = 006C				     $BY equ 27*4
 = 0070				     $UNTIL equ 28*4
 = 0074				     $WHILE equ 29*4
 = 001E				     $23 equ 30
 = 0078				     $WITH equ 30*4
 = 007C				     $LINEIN equ 31*4
 = 007D				     $SOURCE equ 4*(32-1) + 1
 = 007E				     $VERSION equ 4*(32-1) + 2
 = 0080				     $PULL equ 32*4
 = 0084				     $VAR equ 33*4
 = 0088				     $ARG equ 34*4
 = 008C				     $ADDRESS equ 35*4
 = 0090				     $APPEND equ 36*4
 = 0094				     $CALL equ 37*4
 = 0098				     $DO equ 38*4
 = 009C				     $ELSE equ 39*4
 = 00A0				     $NOP equ 40*4
 = 00A4				     $INTERPRET equ 41*4
 = 00A5				     $OPTIONS equ 4*(42-1) + 1
 = 00A8				     $EXIT equ 42*4
 = 00A9				     $PUSH equ 4*(43-1) + 1
 = 00AA				     $QUEUE equ 4*(43-1) + 2
 = 00AB				     $RETURN equ 4*(43-1) + 3
 = 00AC				     $SAY equ 43*4
 = 00B0				     $TRACE equ 44*4
 = 00B4				     $LEAVE equ 45*4
 = 00B5				     $ITERATE equ 4*(46-1) + 1
 = 00B8				     $DROP equ 46*4
 = 00BC				     $EXPOSE equ 47*4
 = 00C0				     $SIGNAL equ 48*4
 = 00C4				     $SYNTAX equ 49*4
 = 00C5				     $LOSTDIGITS equ 4*(50-1) + 1
 = 00C6				     $NOVALUE equ 4*(50-1) + 2
 = 00C8				     $NOTREADY equ 50*4
 = 00C9				     $FAILURE equ 4*(51-1) + 1
 = 00CA				     $HALT equ 4*(51-1) + 2
 = 00CC				     $ERROR equ 51*4
 = 00D0				     $UPPER equ 52*4
 = 00D4				     $IF equ 53*4
 = 00D8				     $INPUT equ 54*4
 = 00DC				     $NAME equ 55*4
 = 00E0				     $NUMERIC equ 56*4
 = 00E4				     $DIGITS equ 57*4
 = 00E5				     $FUZZ equ 4*(58-1) + 1
 = 00E8				     $FORM equ 58*4
 = 00EC				     $ENGINEERING equ 59*4
 = 00ED				     $SCIENTIFIC equ 4*(60-1) + 1
 = 00F0				     $OTHERWISE equ 60*4
 = 00F4				     $OUTPUT equ 61*4
 = 00F8				     $PARSE equ 62*4
 = 00FC				     $PROCEDURE equ 63*4
 = 0100				     $SELECT equ 64*4
 = 0104				     $WHEN equ 65*4
 = 0108				     $REPLACE equ 66*4
 = 010C				     $STEM equ 67*4
 = 0110				     $STREAM equ 68*4
 = 0114				     $NORMAL equ 69*4
 = 0118				     $FOREVER equ 70*4
 = 011C				     $OFF equ 71*4
 = 0120				     $ON equ 72*4
 = 0000				     $sPercent equ 0
 = 0006				     $sDrop equ 6
 = 0009				     $sStem equ 9
 = 000A				     $sWith equ 10
 = 000B				     $sDropList equ 11
 = 0014				     $sMinus equ 20
 = 0017				     $sLength equ 23
 = 001B				     $sEq equ 27
 = 0021				     $sSeq equ 33
 = 0027				     $sDigits equ 39
 = 002A				     $sNop equ 42
 = 002B				     $sForm equ 43
 = 002D				     $sAddress equ 45
 = 0030				     $sNegate equ 48
 = 0031				     $sPositive equ 49
 = 0032				     $sExit equ 50
 = 0035				     $sReturns equ 53
 = 0037				     $sNumber equ 55
 = 0039				     $sRaise equ 57
 = 003E				     $sLeave equ 62
 = 003F				     $sIterate equ 63
 = 00FE				     ParseDot equ 254; A non-operator Bcode value otherwise unused.
 = 0028				     KeysBase equ 4*10; Manual
				     ; Here are some symbolic names of registers, used for readability of this code.
 = bp				     ZeroBp is <bp>
 = di				     StackDi is <di>      ; The soft stack pointer.
 = si				     StackSi is <si>      ; Another soft stack pointer.
 = dx				     StackDx is <dx>      ; Limit of range on soft stack.
 = bx				     ArrayBx is <bx>      ; To an element of Vshape.
 = bx				     StemBx is <bx>       ; When the subject is a stem.
 = si				     TailSi is <si>       ; When the subject is a tailed variable.
 = bx				     FileBx is <bx>       ; To an element of Fshape.
 = si				     ArraySi is <si>      ; To an element of Vshape.
 = bx				     OperandBx is <bx>    ; A pointer to an operand in one of the arrays of Vshapes.
 = bl				     OperandBl is <bl>    ;
 = bx				     ProbeBx is <bx>      ; Used when searching a binary tree for a stemmed variable.
 = si				     LowSi is <si>        ; Used when searching a binary tree.
 = di				     HighDi is <di>       ; Used when searching a binary tree.
 = ax				     ToFindLenAx is <ax>  ; Used when searching a binary tree.
 = dx				     ToFindDx is <dx>     ; Used when searching a binary tree.
 = cx				     KeyListCx is <cx>;   ; Parameter to keyword lookup.
 = ch				     TokNowCh is <ch>;    ; One of the places numbers for tokens are held.
 = si				     StateSi is <si>      ; The state in parsing.
 = si				     ParseSi is <si>      ; Parse state pushed on hard stack.
 = di				     StateDi is <di>      ; Address first word of the state.
 = bx				     StateBx is <bx>      ; Often distance from StateOrig to some state data.
 = dx				     ParseDx is <dx>      ; Token data in form the parser uses.
 = ah				     RtypeAh is <ah>      ; Type of reduction done in Cycle.
 = ah				     TokNumAh is <ah>     ; Where next token is returned, becoming TokNum.
 = si				     LookupSi is <si>     ; Where Lookup finds unresolved compound symbol.
 = si				     LevelSi is <si>      ; To block for this invocation level.
 = di				     LevelDi is <di>
 = si				     CursorSi is <si>     ; Offset in Pcode.
 = bx				     CursorBx is <bx>     ; Offset in Pcode.
 = cx				     OpAppendCx is <cx>   ; Numeric argument to PcodeOp routine.
 = si				     ScanSi is <si>       ; Scanning the user's source program.
 = cl				     OpAppendCl is <cl>
 = al				     RawCharAl is <al>
 = ah				     RawCharAh is <ah>
 = al				     AttribAl is <al>
 = dl				     RadixTypeDl is <dl>
 = cx				     ParmsCx is <cx>
 = cl				     ParmsCl is <cl>
 = bx				     LengthAtBx is <bx>
 = dx				     SymsZiDx is <dx>
 = di				     SegOffDi is <di> ; Offset in Zone of a segment pointer.
				     ; Special use of bp for two-byte call.
 = call bp			     Error49Bp is <call bp>
				     ; Shorthand for current byte of input.
 = byte ptr ss:[si+bp]		     RawChar is <byte ptr ss:[si+bp]>
				     ; These for making messages.
 = bl				     DepthBl is <bl>; of recursion.
 = bx				     DepthBx is <bx>; Bug if inc/dec affects bh.
 = bh				     TheMsgBh is <bh>; on when scanning the target.
 = cx				     PartLenCx is <cx>; Amount of compressed to expand.
 = cl				     LowPartLenCl is <cl>
 = cx				     KeywordOffsetCx is <cx>
 = dx				     MajMinDx is <dx>
 = dh				     MajorDh is <dh>
 = dl				     MinorDl is <dl>
 = dx				     MinorDx is <dx>; inc/dec
 = si				     ScannerSi is <si>; SI the address in table. (LODS used)
				     ; For segment registers.
				     ; ES has some transient uses (particularly because it cannot be overridden
				     ; in movsb) but mainly it is set to the symbols segment during compilation
				     ; and the program scope segment during execution.  Tailed variable references
				     ; also use it (transiently) because each stem variable has it's own segment.
 = es				     SymbolsEs is <es>
 = es				     ProgEs is <es>
 = es				     StemEs is <es>

 = 0019				     $DosDisk equ 19h
 = 002A				     $DosDate equ 2Ah
 = 002C				     $DosTime equ 2Ch
 = 003C				     $DosCreate equ 3Ch
 = 003D				     $DosOpen equ 3Dh
 = 003E				     $DosClose equ 3Eh
 = 003F				     $DosRead equ 3Fh
 = 0040				     $DosWrite equ 40h
 = 0041				     $DosDelete equ 41h
 = 0042				     $DosSeek equ 42h
 = 0043				     $DosChmod equ 43h
 = 0047				     $DosPath equ 47h
 = 0048				     $DosAllocate equ 48h
 = 0049				     $DosFree equ 49h
 = 004A				     $DosModifyAllocated equ 4Ah
 = 004B				     $DosExecute equ 4Bh
 = 004C				     $DosExit equ 4Ch
 = 004D				     $DosReturnCode equ 4Dh
 = 0059				     $DosGetError equ 59h
 = 0062				     $DosPSP equ 62h
				     ; As allowed by the Standard:
 = 000A				     $Limit_EnvironmentName equ 10
 = C350				     $Limit_String equ 50000
 = 00FA				     $Limit_Literal equ 250
 = 00FA				     $Limit_Name equ 250
 = 270F				     $Limit_Digits equ 9999; Note Msg33.2 must be generated to match.
 = 0009				     $Limit_ExponentDigits equ 9
 = 0032				     $Limit_Insert equ 50; Longest insert.
				     ; Ours
 = 0036				     $Limit_Major equ 54; Highest message user sees.
 = 0037				     $Descriptions equ 55; A place in the message numbering for oddment prose.
 = 00C8				     $MsgRoom equ 4*$Limit_Insert
 = 00AF				     $MaxPreInsert equ 175; Chars in message.
 = 0050				     $MsgChunk equ 80; Strictly, ANSI says leave chunking to system.
 = 0064				     $MaxParms equ 100; Per invokation. (Or temporary results within an expression)
 = 0400				     $FileBufferSize equ 1024
 = 0003				     $Leeway equ 3
				     ; Data types within symbols segment:
 = 00FF				     $tChar equ 0FFh
 = 00FE				     $tLabel equ 0FEh
 = 00FD				     $tBinary equ 0FDh
				     ; Minor bits on an operand reference.
 = 0006				     $CaseTarget equ 6
				     ; Subcodes to Pcodes.
				     ; These are used by the utility. Avoid putting semicolon abutting the "h".
				     ; These markers share values with Sysvar references in Bcode but we don't
				     ; parse into sysvars in our Bcode.
				     ; If we want to detect presence/absence of these they need to be 2 modulo 8.
				     ; However if they always follow something known, any value will do.
				     ; In practice we sometimes use the modulo 8 approach (even at the expense of
				     ; a shift when they are used) so as to make scanning of Pcode simpler.
 = 0002				     $mRepTail equ 02h        ; Used when $pDotControlVar addresses tails.
 = 000A				     $mUpper equ 0Ah          ; Modifier on parse source.
 = 0012				     $mParseEscape equ 12h    ; Parse part too complex to handle as single action.
 = 001A				     $mParseEnd equ 1Ah       ; Parse ends.
 = 0022				     $mPosRest equ 22h        ; Parse trigger
 = 002A				     $mPattern equ 2Ah        ; Parse trigger after operand
 = 0032				     $mPosEq equ 32h          ; Parse trigger after operand
 = 003A				     $mPosPlus equ 3Ah        ; Parse trigger after operand
 = 0042				     $mPosMinus equ 42h       ; Parse trigger after operand
 = 004A				     $mTemplateComma equ 4Ah  ; Parse trigger
				     ; These in number field of $pParse:
 = 0000				     $nVar equ 0              ; These
 = 0002				     $nWith equ 2             ;       two lowest of parse sources.
 = 0004				     $nArg equ 4
 = 0006				     $nLineIn equ 6
 = 0008				     $nPull equ 8
 = 000A				     $nSource equ 10
 = 000C				     $nVersion equ 12
				     ; These in number field of $pCommandEnv
 = 0000				     $nStem equ 00h
 = 0020				     $nStream equ 20h
 = 0040				     $nNormal equ 40h
				     ; These in number field of $pNumeric
 = 0000				     $nDigits equ 00h
 = 0002				     $nFuzz equ 02h
 = 0004				     $nForm equ 04h
				     ; These in number field of $pRaise
 = 0000				     $n7p3 equ 0
 = 0002				     $n17p1 equ 2
 = 0004				     $n40p3 equ 4
 = 0006				     $n40p4 equ 6
 = 0008				     $n40p5 equ 8
				     ; Types for things in Z.Serial
				     ; $SerialNone is also used for message building.
				     ; $SerialSource is qualified by Z.RelativeNow - what part of source file.
				     ; These are modals except for $SerialCompaction which saves/restores previous.
 = 0000				     $SerialNone equ 0
 = 0001				     $SerialQue equ 1
 = 0002				     $SerialCompaction equ 2
 = 0003				     $SerialInterpret equ 3
 = 0004				     $SerialSource equ 4
				     ; Trace events. (Order unexploited except for highest.)
 = 0000				     $TraceAssign equ 0
 = 0002				     $TraceBY equ 1*2
 = 0004				     $TraceClause equ 2*2
 = 0006				     $TraceCompound equ 3*2
 = 0008				     $TraceDot equ 4*2
 = 000A				     $TraceError equ 5*2
 = 000C				     $TraceExpr equ 6*2
 = 000E				     $TraceFailure equ 7*2
 = 0010				     $TraceFunction equ 8*2
 = 0012				     $TraceOperator equ 9*2
 = 0014				     $TracePrefix equ 10*2
 = 0016				     $TraceLit equ 11*2
 = 0018				     $TraceVar equ 12*2
 = 001A				     $TraceBack equ 13*2; Highest for $TrEv.
 = 001C				     $TraceParse equ 14*2; Only sets flag.
 = 001E				     $TraceEndClause equ 15*2; Compiled at end of a traced clause.
				     ; Descriptions on messages.    See OverfullMem for some.
				     Assert Zshape.SysFiles-Zshape.SysFiles eq 2*1-2
				     Assert Zshape.Consts-Zshape.SysFiles eq 2*2-2
				     Assert Zshape.Vars-Zshape.SysFiles eq 2*3-2
				     Assert Zshape.ProgScope-Zshape.SysFiles eq 2*4-2 ; Used for 'memory' msg.
				     Assert Zshape.VarScope-Zshape.SysFiles eq 2*5-2 ; Used for 'string length'
				     Assert Zshape.Symbols-Zshape.SysFiles eq 2*6-2
				     Assert Zshape.Code-Zshape.SysFiles eq 2*7-2
				     Assert Zshape.Zone-Zshape.SysFiles eq 2*8-2
				     Assert Zshape.Stem-Zshape.SysFiles eq 2*9-2
 = 0005				     $DescString equ 5
 = 000A				     $DescArgs   equ 10
 = 000B				     $Desc59H    equ 11
 = 000C				     $DescFiles  equ 12
 = 000D				     $DescQueue  equ 13
 = 0080				     $BifTag equ 80h; Helps with reverse lookup
				     ; As well as source coming from a file, there are the cases of INTERPRET,
				     ; VALUE, and SYMBOL where some compiling is needed.  Also VarPool cases.
				     ; Even if only Lookup is needed, it can be simplest to compile and pick
				     ; the answer up from the generated code.
 = 11C8				     $SourceBufferSize equ 4552; Allows for long bit literal.
 = 2000				     $InitStackSize equ 8192
 = 0000				      $White equ 0
 = 0040				      $Digit equ 64
 = 0080				      $Letter equ 128
 = 00C0				      $Special equ 192
 = 0008				      $NonUpable equ 8
 = 0004				      $Bb equ 4
 = 0002				      $Xx equ 2
 = 0001				      $Ee equ 1
 = 0048				      $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; Constants for Bifs.
 = FFB9				     $BifBase equ 65535-70; 68 bifs at high numbers.
				     ; The equates for pseudo code operations are with the P switch.
				     ; (See also $Reserved)
 = 00C0				     $Test       equ 11000000b; To test the most vital bits.
 = 0080				     $NullString equ 10000000b; 01000nnn for 0-7 length strings.
 = 0088				     $Omitted    equ 10001000b; Value of omitted is null string.
 = 0089				     $Variable   equ 10001001b; Only used at compile time.
 = 008A				     $Constant   equ 10001010b; Only used at compile time. (Untyped constant.)
 = 008B				     $Label      equ 10001011b;
 = 00C0				     $AwayString equ 11000000b;
				     ; NYI $AwayNumber equ 11110000b;
				     ; The 01 tags don't reach the runtime stack.
				     ; (That avoids a test when type checking operands now and allows future use.)
 = 0040				     $Dropped    equ 01000000b;
 = 0050				     $Exposed    equ 01010000b;
 = 0060				     $Stem       equ 01100000b;
 = 0044				     $MsgNum     equ 01000100b; Msg number in Major/Minor form.
 = 0048				     $Sigl       equ 01001000b; Jump point still as code offset.
				     ; Not to be confused with the bits from the table of characters:
				     XlatBDLS macro ;; 0=Blanks 1=Digits 2=Letters 3=Special
				      
; Picks up attributes of current char and sets flags.
				      xlat Bptr cs:[bx]
				      test al,0C0h
				     endm
				     Down macro
				      sub StackDi,$StrideV
				     endm
				     Up macro
				      add StackDi,$StrideV
				     endm
				     DownCare macro
				      lea StackDi,(-$StrideV)[StackDi]
				     endm
				     UpCare macro
				      lea StackDi,$StrideV[StackDi]
				     endm
				     ; Hard & soft cursors return.
				     RetSi macro
				      pop CursorSi
				      ret
				     endm
				     ; Macros for some common idioms in Pcode making.
				     OpAl macro $p
				       mov al,$p
				       call PcodeOp
				     endm
				     OpRet macro $p
				       mov al,$p
				       jmp PcodeOp
				     endm
				     EvAh macro $p
				       mov ah,$p
				       call TraceEvent
				     endm
				     EvRet macro $p
				       mov ah,$p
				       jmp TraceEvent
				     endm

				     ; Macros are used to make that clear where code is run out of the interpreter
				     ; loop, and to allow experiments in how the return is made.
				     ; These experiments never worked out because of the difficulty in having some
				     ; operations that needed to be routines (eg Assign as part of ControlVar) and
				     ; some that didn't.  Changing code to achieve sometimes-routine is a speed
				     ; killer.

				     Back macro
				     jmp XCycle
				     endm
				     BackRet macro
				     ret
				     endm

				     ; When all the operations end with a jump to XCycle we can turn them into
				     ; callable routines by sticking a ret instruction the code at XCycle.
				     ; Performance killer so rarely used.
 = 00C3				     $ret equ 0C3h
				     CodeModeR macro
				      push Wptr cs:XCycle
				      mov Bptr cs:XCycle,$ret
				     endm
				     UnCodeMode macro
				      pop Wptr cs:XCycle
				     endm

				     Repmovsb macro
				     local IsEven
				     if 1
				      rep movsb
				     endif
				     if 0
				     ; This ought to be faster but didn't seem to be. Perhaps jnc high cost.
				      shr cx,1
				      rep movsw
				      jnc IsEven
				      movsb
				      IsEven:
				     endif
				     endm

				     ; There is a "mv" macro that moves registers by push & pop.
				     ; There is a "move" that saves typing when memory-to-memory.
				     ; Here is "Mv" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by push & pop.
				     ; Here is "Move" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by shuffling through general registers.
				     Mv macro To,From
				     ; "Move" is faster than "Mv" and no bigger, if there is a spare register.
				        pushd From.OverExpo
				        pop To.OverExpo
				        pushd From.OverMant
				        pop To.OverMant
				     endm

				     Move macro To,From,Via
				     ; Move of a Rexx value. Convention is to use ecx:eax
				      ifb <To>
				     ; No target means load usual registers.
				        mov ecx,From.OverExpo
				        mov eax,From.OverMant
				      elseifb <From>
				     ; No source means store from usual registers.
				        mov To.OverExpo,ecx
				        mov To.OverMant,eax
				      elseifb <Via>
				     ; Copy via usual registers.
				        mov ecx,From.OverExpo
				        mov To.OverExpo,ecx
				        mov eax,From.OverMant
				        mov To.OverMant,eax
				      else
				     ; Copy via specified register.
				       mov Via,From.OverExpo
				       mov To.OverExpo,Via
				       mov Via,From.OverMant
				       mov To.OverMant,Via
				      endif
				     endm

 0006				     FarpX struc
 0000	    0000 [		      Fr dword Overlay
	     00000000
	    ]
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
 0004	    0000 [		      Limit word Overlay
	     0000
	    ]
 0004  0000			      Len word 0
				     FarpX ends


 0008				     Vshape union
				      struc; When containing a short string.
 0000	    0007 [		       String db 7 dup(?)
	     00
	    ]
 0007  00			       Dtype db ?                        ; Whether string or not and used length.
				      ends
				      struc; When binary number
				       Sign byte Overlay     ; Odd means negative mantissa.
				       ExpAnd dword Overlay  ; Exponent and sign of mantissa.
				        ExpoUses db 3 dup(?)
				        ExpoSign db ?        ; Sign of exponent.
				       Mantissa dword Overlay
				        MantLow word ?
				        MantHigh word ?
				      ends
				      struc; When treated as just bytes.
				       OverExpo dword ?
				       OverMant dword ?
				      ends
				      struc; When referencing a long string.
				       FarpX <>
				       dw ?                              ; Covers Dtype.
				      ends
				      struc; When referencing label information
				       LabelValue word ?                 ; Offset in Pcode.
				       dword ?
				       LabelType word Overlay
				       byte ?                            ; 0 = normal, 1 = TraceOnly
				       db ?                              ; Covers Dtype. Will be $Label.
				      ends
				      struc; When compile time stack item for a constant.
				       WhichCon word ?                  ; Offset under ProgScope.
				       PcodePos word ?                  ; Where it will be in Pcode.
				       db 4 dup(?)                       ; Covers Dtype. Will be $Constant.
				      ends
				      struc; When compile time stack item for a resolved target.
				       HeldOver word ?                   ; To go in Pcode eventually.
				       db 6 dup(?)                       ; Covers Dtype. Will be $NullString
				      ends
				      struc ; When used to look up symbols.  Dtype not relevant then.
				     ; Moot whether this is really a Vshape but pretending it is allows use of Vbx.
				       Pair dd 0 dup(?)                  ; Next two together.
				        Lower Ushortp ?                  ; a subtree.
				        Higher Ushortp ?                 ; a subtree
				       Here charp ?                      ; to the symbol.
				      ends
				     Vshape ends
				     ; V. is for Vshape objects addressed by [di+bp]; eg variables on the stack.
 = (Vshape ptr[bp+di])		     V is <(Vshape ptr[bp+di])>
				     ; 1-origin numbers for the parameters of bif, but V is used for V1 (and result).
				     ; So lhs and rhs of binary operation are V and V2, result overlays V.
				     ; Of course, changing di by $StrideV is an alternative to using different Vn.
 = 0008				     $StrideV equ size Vshape
 = 0003				     $ShiftV equ 3
 = (Vshape ptr[bp+di-$StrideV])	     V0 is <(Vshape ptr[bp+di-$StrideV])>
 = (Vshape ptr[bp+di-2*$StrideV]     V00 is <(Vshape ptr[bp+di-2*$StrideV])>
   )
 = (Vshape ptr[bp+di+$StrideV])	     V2 is <(Vshape ptr[bp+di+$StrideV])>
 = (Vshape ptr[bp+di+2*$StrideV]     V3 is <(Vshape ptr[bp+di+2*$StrideV])>
   )
 = (Vshape ptr[bp+di+3*$StrideV]     V4 is <(Vshape ptr[bp+di+3*$StrideV])>
   )
				     ; Vsi. is for Vshape objects addressed by [si+bp]; variables on the stack.
 = (Vshape ptr[bp+si])		     Vsi is <(Vshape ptr[bp+si])>
				     ;Vsif. is for Vshape objects addressed by fs:[si]; Variables of procedure.
 = fs:(Vshape ptr[si])		     Vsif is <fs:(Vshape ptr[si])>
				     ; Vdid. is for Vshape objects addressed by ds:[di]
 = ds:(Vshape ptr[di])		     Vdid is <ds:(Vshape ptr[di])>
				     ; Vsid. is for Vshape objects addressed by ds:[si]
 = ds:(Vshape ptr[si])		     Vsid is <ds:(Vshape ptr[si])>
				     ;Vbx. is for Vshape objects addressed by ds:[bx]
 = ds:(Vshape ptr[bx])		     Vbx is <ds:(Vshape ptr[bx])>
				     ;Vbxf. is for Vshape objects addressed by fs:[bx]; Variables of procedure.
 = fs:(Vshape ptr[bx])		     Vbxf is <fs:(Vshape ptr[bx])>
 = fs:(Vshape ptr[bx-$CaseTarget     Vbxt is <fs:(Vshape ptr[bx-$CaseTarget])>
   ])
 = fs:(Vshape ptr[bx+$StrideV])	     Vbxf2 is <fs:(Vshape ptr[bx+$StrideV])>
				     ;Vbxs. is for Vshape objects addressed by ss:[bx]; Variables on the stack.
 = ss:(Vshape ptr[bx])		     Vbxs is <ss:(Vshape ptr[bx])>
				     ;Ve. is for Vshape objects addressed by es:[bp]; (Saves a byte sometimes)
 = es:(Vshape ptr[bp])		     Ve is <es:(Vshape ptr[bp])>
 = fs:(Vshape ptr[bp])		     Vf is <fs:(Vshape ptr[bp])>
				     ;Vbxe. is for Vshape objects addressed by es:[bx]
 = es:(Vshape ptr[bx])		     Vbxe is <es:(Vshape ptr[bx])>
				     if 0
				     endif
 0028				     Dshape struc; The elements of soft stack for DO loops.    (And INTERPRET)
				     ; Here the n of "DO n;" will wind up.
				     ; Also x of DO j=x...  We don't need to retain that through the DO-END, but
				     ; harmless to do so. (Overlaid when DO A.K=....)
 0000	    0000 [		      TailsAt word Overlay; Where the pcode to reload tails is.
	     0000
	    ]
 0000	    0000 [		      Subject Vshape 0 dup(<>); When block is for an INTERPRET.
	     0007 [
	      00 00
	     ]
 0000	     0000 [		      CVinit Vshape 0 dup(<>)
	      0007 [
	       00 00
	      ]
 0000	      0007 [		      Reps Vshape <>
	       00
	      ] 00
 0008	      0007 [		      To Vshape <>
	       00
	      ] 00
 0010	      0007 [		      By Vshape <>
	       00
	      ] 00
 0018	      0007 [		      ForCount Vshape <>
	       00
	      ] 00
				     ; The rest is made similar to a Vshape so that Bcode can overlay Dshape as
				     ; variables.
 0020	      0000 [		      PcodePos charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0020  0000			      Iteration charp ?; Where to branch on ITERATE
 0022  0000			      Leaving charp ?  ; Where to branch on LEAVE
 0024	      0000 [		      UpDO charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0024  0000			      CV charp ?; Offset of the control variable.
 0026  00			      byte ?
 0027  00			      Rec byte ?;  MASM confused when LoopsRec<> used.
				     Dshape ends
 = 0028				     $StrideD equ size Dshape
				     ; D. is for Dshape objects addressed by [di+bp]; the DO nesting.
				     ; These objects are addressed from partway through them.  This is because the
				     ; XCycle loop benefits from moving StackDi over the "previous operand" when
				     ; loading the latest operand. But the "previous operand" may actually have
				     ; been one of these DO control blocks.
				     ; Use D1 to address the DO block when StackDi has been upped to indicate
				     ; there is a value stacked later than the DO block.
 = (Dshape ptr[bp+di-$StrideD+$S     D is <(Dshape ptr[bp+di-$StrideD+$StrideV])>
   trideV])
 = (Dshape ptr[bp+di-$StrideD])	     D1 is <(Dshape ptr[bp+di-$StrideD])>

				      FRec record Qual:1,Read:1,Open:1,BeenRead:1,BeenWrite:1,
				                  WriteMode:1,IsSource:1,BeenCompiled:1,FFpad:8
 001A				     Fshape struct ; Data for a file, the key is the file name.
 0000  0000			       Flags FRec <>
 0002  0000			       ToQual word ? ; To item for fully qualified name.
 0004  00000000			       Lines Ulong ?
 0008  0000			       Hand Handle ?
 000A  00000000			       Other_Position Ulong ? ; A position on the file, provided by DOS.
 000E  00			       Exten byte ?; 1=REX/CMD 2=COM 3=EXE 4=BAT
 000F  00			       TraceWidth byte ?; How many chars in a clause identifier.
 0010  0000			       Symbols Segp ? ; Saved from Zone when file inactive.
 0012  0000			       Code Segp ?
 0014  0000			       Vars Segp ?
 0016  0000			       Consts Segp ?
 0018  0000			       ProgScope Segp ?
				     Fshape ends
 = 001A				     $StrideF equ size Fshape
				     ; F. is for Fshape objects addressed by [bx]; a file.
				     ; An Fshape is put ahead of a Jshape.
 = (Fshape ptr[bx-$StrideF])	     F is <(Fshape ptr[bx-$StrideF])>

 0008				     EnvBlock struc 2
 0000  0000			      EnvNumber    word ?
 0002  0000			      EnvResourceI word ?
 0004  0000			      EnvResourceO word ?
 0006  0000			      EnvResourceE word ?
				     EnvBlock ends
				     if 1; Private to memory object
 0006				     Ashape struc; Describe pieces of memory got from Dos, and part of them used.
 0000  0000 0000		      Fr Farp <>
 0004  0000			      Amount Ushort 0
				     Ashape ends
				     ; A. is for Ashape objects addressed by [si+bp]; For memory allocation.
 = (Ashape ptr[bp+si])		     A is <(Ashape ptr[bp+si])>
 = 0006				     $StrideA equ size Ashape
				     endif
 0015				     InsBlock struc;  Used by issuing of messages, to deduce inserts.
 0000	      0000 [		      MajMin word Overlay    ; This is an error detected.
	       0000
	      ]
 0000  00			       Minor byte ?
 0001  00			       Major byte ?
 0002  0000			      Value word ?           ; Soft stack offset of value.
 0004	      0000 [		      Named Ushort Overlay
	       0000
	      ]
 0004  0000			      Position Ushort ?
 0006  0000			      KeysList charp ?       ; Yields keyword list
 0008  00			      ArgNum byte ?
 0009  00			      Desc byte ?            ; To find text of <Description>
 000A	      0000 [		      Hex byte Overlay
	       00
	      ]
 000A  00			      Char byte ?
 000B  0000			      Options charp ?        ; Msg 40.28
 000D  0000			      OptsHi charp ?         ; Msg 40.28
 000F  0000			      Digits word ?          ; Msgs 26.1 and 33.1  Don't overlay, zero meaningful.
 0011  0000			      TokPos charp ?         ; Position of token within segment holding source.
 0013  0000			      TokLen Ushort ?        ; Ushort although inserts have low limit length.
				     InsBlock ends

				     ; "Interacting" is a bug for "Interactive" ?. Pad 8 makes byte offset zero.
				     LevelRec record Lpad:8,InheritDone:1,DigitsSet:1,IsProcedure:1,IsExternal:1,
				         IsFunction:1,Lpad2:3

				     LevelRecI record LIPad:14,Interactive:1,ConditionInstruction:1
				     ; Instruction.Condition and ConditionInstruction are the same value.

				     ConditionRec record Enabling:1,Delayed:1,PendingNow:1,Instruction:1,CRspare:4

 007C				     Lshape struc; The elements of soft stack for invocations.
				     ; The part inherited from the level above. (When there is one.)
				      align 4; We move the inherited bit using doublewords.
 0000	      0000 [		       DigitsFuzz dword Overlay
	       00000000
	      ]
 0000  0000			       Digits Ushort ?
 0002  0000			       Fuzz Ushort ?
 0004  00			       Form char ?
 0005  0000000000000000		       StartTime qword ?
 000D	      0000 [		       TraceLetter char Overlay
	       00
	      ]
 000D  0000			       TraceWord word ?; LevelRecI <>.
 000F  0000 0000 0000 0000	       Active EnvBlock <>
 0017  0000 0000 0000 0000	       Alternate EnvBlock <>
 001F  00			       Syntax ConditionRec <>
 0020  00			       LostDigits ConditionRec <>
 0021  00			       NoValue ConditionRec <>
 0022  00			       NotReady ConditionRec <>
 0023  00			       Error ConditionRec <>
 0024  00			       Failure ConditionRec <>
 0025  00			       Halt ConditionRec <>
 0026	      0007 [		       TrapName word 7 dup(?)
	       0000
	      ]
 0034  0000			       EventLevel word ?   ; Only used for Halt.
 0036  0000			       Condition word ?    ; As CONDITION bif result(C)
 0038	      0007 [		       ConditionDescription Vshape <>; As CONDITION bif result(D)
	       00
	      ] 00
 0040	      0007 [		       ConditionExtra Vshape <>; As CONDITION bif result(E)
	       00
	      ] 00
				      align 4; We move the inherited bit using doublewords.
 0048	      0000 [		       Inherit char Overlay; End of inherited.
	       00
	      ]
 0048  0000000000000000		      ClauseTime qword ?
 0050  0000000000000000		      ClauseLocal qword ?
 0058  0000000000000000		      PendingDescription qword ?
 0060  0000000000000000		      PendingExtra qword ?
 0068  0000			      LevelDO charp ?;  Level's CurrentDO held over call.
 006A  0000 0000		      StackSave Farp <>; To make save over DosExecute recursive.
 006E  0000			      File charp ?     ; Save which external file is source when external call made.
 0070  0000			      ProgScope Segp ? ; Saved values of constants, when external call.
 0072  0000			      VarScope Segp ?  ; Saved values of variables, when external call.
				      align 4
				     ;The Lshape is normally addressed a few bytes ($StrideV) down from its high end.
 0074	      0000 [		      Access word Overlay; MASM gets confused if this is attached to the LevelRec.
	       0000
	      ]
 0074  0000			      Flags LevelRec <>
 0076  0000			      UpLevel charp ?; Invoker's block.
 0078  0000			      Resume charp ? ; On return from invoke from here.
 007A  0000			      Arg0 charp ?   ; Parameters to this invoke.
				     Lshape ends
 = 007C				      $StrideL equ size Lshape
				     ; L. is for Lshape objects addressed by ss:[di+bp]; the level of the execution.
 = (Lshape ptr[bp+di-$StrideL+$S     L is <(Lshape ptr[bp+di-$StrideL+$StrideV])>
   trideV])
				     ; Lsi. is for Lshape objects addressed by ss:[si+bp]
 = (Lshape ptr[bp+si-$StrideL+$S     Lsi is <(Lshape ptr[bp+si-$StrideL+$StrideV])>
   trideV])
				     ; Lbx. is for Lshape objects addressed by ss:[bx]; the level of the execution.
 = ss:(Lshape ptr[bx-$StrideL+$S     Lbx is <ss:(Lshape ptr[bx-$StrideL+$StrideV])>
   trideV])

				     ; LoopsRec is used only in Dshape.
				     ;HasDot:1,      ; When DO X.=
				     ;HasDots:1,     ; When DO X.Y =
				     ;HasTo:1,
				     ;HasFor:1,
				     ;ByDown:1,      ; When control variable values are going down.
				     ;IsInterp:1     ; When block is for INTERPRET, not DO.
				     LoopsRec record LoopsPad:2,HasDot:1,HasDots:1,HasTo:1,HasFor:1,IsInterp:1,
				                     ByDown:1; ByDown last - see use in CompareTo

				     ; API_Enabled:1,   Controls "Variable Pool" interface.
				     ; NoSource:1,      $5.10.11, but no need to implement.
				     ; RandomSeeded:1,  Has the seed been initialized?
				     ; NotS9:1,         Off if numerics are 9 digit SCIENTIFIC.
				     ; The following are to do with compiling - they are off in execution.
				     ; LabelsBad:1,     On when the compile is of text from INTERPRET.
				     ; Repass:1,        When user overides Bif name.
				     ; FirstBetween:1,  On when parsing should start with a Between call.
				     ; EndSource:1,     Helps parser detect end-of-source.
				     ; BifCheck:1,      Tells whether Bif check failed, for compile time .
				     ; TraceIF:1,       Controls trace output.
				     ; ShowELSE:1,      Controls trace output.
				     ProgramRec record API_Enabled:1,
				        Repass:1,
				        LabelsBad:1,
				        FirstBetween:1,
				        EndSource:1,
				        BifCheck:1,RandomSeeded:1,NotS9:1,TraceIF:1,ShowELSE:1,PRSpare:6

				     ; InTypes:2     What are the types of the input operand(s)?
				     ; ResultType:2  Mark result on stack with its type.
				     ; AppendNum:1   When opcode is followed by a number.
				     ; AppendRef:1   When opcode (plus maybe number) is followed by a reference.
				     ; DownOne:1     On if operator leaves stack down one on when it started.
				     ; EndsClause:1  On if operator ends a clause. (Only for internal checks)
				     OperatorRec record InTypes:2,ResultType:2,AppendNum:1,AppendRef:1,DownOne:1,
				                        EndsClause:1

				     ; The Dtype byte is too complex to describe as individual flags. See equates.

 000E				     Jshape struc
 0000	      0007 [		      Valued Vshape <>                  ; Will be addressable Vsid. and J.
	       00
	      ] 00
 0008	      0000 [		      Pair dd 0 dup(?)                  ; Next two together.
	       00000000
	      ]
 0008  0000			      Lower Ushortp ?                   ; a subtree.
 000A  0000			      Higher Ushortp ?                  ; a subtree
 000C  0000			      KeyLen word ?                     ; Always a word of length. Chars may follow.
 000E	      0000 [		      Key char 0 dup(?)
	       00
	      ]
				     Jshape ends
 = 000E				     $StrideJ equ size Jshape
				     ; J. is for Jshape objects addressed by [si]; To look up tails.
 = (Jshape ptr[si])		     J is <(Jshape ptr[si])>
				     ; Jbx. is for Jshape objects addressed by [bx]; To look up tails.
 = (Jshape ptr[bx])		     Jbx is <(Jshape ptr[bx])>
				     ; Jdi. is for Jshape objects addressed by [di]; To look up tails.
 = (Jshape ptr[di])		     Jdi is <(Jshape ptr[di])>

				     TokVal record  GrpNdx:6,SubNum:2; Shape of $name
				     TokRec record X02:1, NdxbT:5, Aim:10
				     KeyRec record KeyFlags:3,EndList:1, KeyLen:4
				     ; Shapes for interpreting syntax tables. Ensure match with table generator.
				     ShiftRec record HasShift:1, ErrorAlone:1, CatFlag:1, HasKeys:1, Reference:1,
				                     Direct:1,Indexb:5, Index:5
				     ErrorRec record HasShiftOn:1, ErrorAloneOn:1, MajorField:8, MinorField:6
				     RedRec record HasShiftOff:1, HasAction:1, PruneCt:2, Rtype:2, Rstate:10
				     ; Every element on the parser stack will have the same size but the contents
				     ; are not always the same, except for State which is the reference state
				     ; needed by the parser mechanism.  The other fields are used for error
				     ; message data, and code generation.
				     ; Field order of Sshape is sensitive, matched to pushes that create an item.
				     ParserRec record ParserPad:12,DoRep:1,DoCV:1,Forever:1,DoDataHost:1
 0010				     Sshape struc
 0000  0000			      State word ?
 0002	      0000 [		      Parser word Overlay
	       0000
	      ]
 0002  0000			      ParserRec <>
				     ; Some of these fields could logically be overlaid but they are not, so that
				     ; logic is avoided in deciding what to push. (They are all pushed)
				     ; Actually that applies to just ClauseWas.
 0004  0000			      ClauseWas  word ?; Line number for message 10.n and 7.n
				      union
				       struct; This one for an operation. Element is made on basis that it is this.
 0006  0000			        Token Ushort ?; Numeric coding of the operation.
 0008  00000000			        Operation dword ?; ASCII coding with length ahead, eg 3,">>=".
 000C  0000			        Caller word ?; Resolved reference to what is to be invoked.
 000E  0000			        Parms Ushort ?; To compute how many arguments there are.
				       ends
				       struct; This overlay for info on a SELECT structure. (Also IF & DO)
				        JumpSite word ?; Records how Pcode jumps from WHEN test to WHEN test.
				                       ; (Also used by IF-ELSE)
				        SoFar charp Overlay; For TraceOnly
				        WhatCV charp Overlay; Control variable identification.
				        SelectSite word ?; Records how Pcode jumps from end of WHENs to end SELECT.
				       ends
				      ends
				     Sshape ends
				     ; S. is for Sshape objects addressed by [si+bp]; the parser stack.
 = (Sshape ptr[bp+si])		     S is <(Sshape ptr[bp+si])>
 = 0010				     $StrideS equ size Sshape
 = (Sshape ptr[bp+si+$StrideS])	     S1 is <(Sshape ptr[bp+si+$StrideS])>
 = (Sshape ptr[bp+si+2*$StrideS]     S2 is <(Sshape ptr[bp+si+2*$StrideS])>
   )
				     ParmsRec record ParmsMin:2,ParmsXtr:2,NonCheck:4
				     MiddleRec record NotLabel:1,SemiAfter:1,ValueBefore:1,
				       AbutOK:1,NoBlanks:1,ModEquals:1,EndClause:1,ImplicitValue:1,
				       CheckDO:1,TargetSymbol:1,Function:1,TakenConstant:1,LookLabel:1,
				       LookBin:1,DotOK:1,MRspare:1

				     ; More flags for clause level.
				     ; NotAssign:1,     Off includes DO j=
				     ; ClauseSet:1,     On when ClauseLine set.
				     ; Tailed:1,        Tells Lookup that compound name is on stack.
				     ; WasTailed:1,     Last Lookup was of tailed.
				     ; WasUpper:1,      Remembers UPPER option on PARSE.
				     ; OffFlag:1,       Remembers OFF of CALL OFF.
				     ; Condition:1,     Remembers there was a condition on CALL ON or SIGNAL ON.
				     ; Append:1,        Remembers there is APPEND during ADDRESS.
				     ; Signal:1,        Remembers when the verb was SIGNAL
				     ; CVar:1,          Remembers when there is a control variable on DO.
				     ; Repit:1,         Remembers when there is repetition part in DO.
				     ; PosEq:1,         Grouped with PosPlus & PosMinus - triggers in PARSE.
				     ; InParse:1,       On during Parse instruction. (Off when escape)
				     ; WasParse:1,      On during Parse instruction.
				       ClauseRec record WasUpper:1,OffFlag:1,Condition:1,Append:1,Signal:1,
				       ClauseSet:1,CVar:1,Repit:1,PosEq:1,NotAssign:1,
				       WasParse:1,InParse:1,Tailed:1,WasTailed:1,
				       PosPlus:1,PosMinus:1; Using 5-gap of PosEq and PosPlus.

				     ; Format5:1,       On for FORMAT bif with five args.
				     ; AssignDO:1,      On when assignment is for DO.
				     ; ForExpose:1,     On while executing EXPOSE.
				     ; FromIterCV:1,    Used when DO loop execution has dotted control variable.
				     ; ForBIF:1,        TargetMsg without expanding inserts. Needed for ERRORTEXT.
				     ; TokIsValue:1     Conditions error message insert.
				     ; ExpRange:1,      Number failure due to exponent oversize.
				     ; Description:1,   Used in msg production.
				     ; Compacted:1,     Used to detect a loop within Compaction.
				     ; BcodeInterpret:1, On when INTERPRET executing on behalf of Bcode.
				     ; MapOnly:1,       Used by Debug for when to fill allocations.
				     ; ParseUpper:1,    On when PARSE has UPPER, in execution.
				     ; ParseTrace:1,    On when PARSE tracing, in execution.
				     ; SourceFiles:1, On when source files rather than ordinary data files relevant.
				     ; BoolBefore:1,    On to prevent code generated for trace making undue prefix.
				     ; WasDropped:1     On to tell us that last load of variable found it dropped.
				     CancelRec record Format5:1,AssignDO:1,ForExpose:1,FromIterCV:1,
				      ForBIF:1,TokIsValue:1, ExpRange:1, Description:1, Compacted:1,
				      BcodeInterpret:1, MapOnly:1, ParseUpper:1, ParseTrace:1, SourceFiles:1,
				      BoolBefore:1, WasDropped:1

				     ; Dual:1,          On when the purpose of compiling is clause by clause run.
				     ; DualPending:1,   On when DualGen is to be set later.
				     ; DualGen:1,       On when Pcode for trace events is being made.
				     ; DualOnly:1,      On when Pcode for Dual differs from original.
				     GenRec record Dual:1,DualPending:1,DualGen:1,DualOnly:1,
				      GenSpare:12

				     ; Experience may show how many allocations the Dos space will be in.
 = 000A				     $Ashapes equ 10
				     ; Shortest code for addressing Header fields is varied. If mov with ax, then
				     ; 2-byte offset is reasonable because there are dedicated opcodes. Else it
				     ; will usually pay to specify indexing with a zero-value index because that
				     ; uses a one byte offset. The index can be bp when there is segment override.
				     ; Otherwise it may pay to zero si especially for the purpose.
 0010				     Hshape struct
 0000	      0000 [		      Hdw0 dword Overlay; This and next dword used when making a copy of a segment.
	       00000000
	      ]
 0000  0000			      SegSize Ushort ?  ; Bytes including our header.
				     ; The segments for different purposes need different subsets of these fields.
				     ; They all need SegSize because Compaction uses it.
				     ; The stack segment needs only SegSize because it has its own routine for
				     ; expansion on demand.
				     ; The pool-type segments only need SegSize&Bump; their size changes only when
				     ; the relevant Vars or Consts segment changes size.
 0002  0000			      Bump Ushort ?   ; Number of new bytes added each expansion
				     ; Things that grow independently (Symbols, Vars, Consts, SysFiles, and each
				     ; compound variable) need Avail and Trigger.
 0004  0000			      Avail Ushort ?  ; Place, below Trigger, for new-stuff-at-end.
 0006  0000			      Trigger Ushort ?; Limit before extension.
				     ; Link identifies the type of segment and allows Zone updates.
 0008  0000			      Link Ushort ?   ; To find slot in Zone that addresses this segment.
 000A	      0000 [		      TreeBin Ushort Overlay ; Field reused in the constants lookup segment.
	       0000
	      ]
 000A	      0000 [		      Original Ushort Overlay ; Field reused in the Pcode segment.
	       0000
	      ]
				                              ; (End of original Pcode.)
 000A  0000			      UpPool Segp ?   ; When segment is a pool. (Also used as chain of free ones)
 000C  0000			      Probe Ushort ?  ; Place to start search if this is a lookup type segment.
 000E	      0000 [		      TreeProg Ushort Overlay ; Field reused as root for source file names lookup.
	       0000
	      ]
 000E  0000			      Labels Ushort ? ; Alternative needed since label and constant trees same seg.
				     Hshape ends
 = 0010				     $StrideH equ size Hshape
				     ; H. is for Hshape objects addressed by [si]; Headers on segments (si=0).
 = (Hshape ptr[si])		     H is <(Hshape ptr[si])>
				     ; Hd. is for Hshape objects addressed by ds:; Headers on segments.
 = (Hshape ptr ds:[0])		     Hd is <(Hshape ptr ds:[0])>
				     ; He. is for Hshape objects addressed by es:[bp]; Headers on segments.
 = (Hshape ptr es:[bp])		     He is <(Hshape ptr es:[bp])>
				     ; Hf. is for Hshape objects addressed by fs:[bp]; Headers on segments.
 = (Hshape ptr fs:[bp])		     Hf is <(Hshape ptr fs:[bp])>
				     ; Hg. is for Hshape objects addressed by gs:[bp]; Headers on segments.
 = (Hshape ptr gs:[bp])		     Hg is <(Hshape ptr gs:[bp])>

				     ; Zshape is resized by StackSafe, not by MoreSpaceEs, so doesn't need all
				     ; the Hshape header. It does need SegSize in correct location though because
				     ; Compaction treats it like a headed segment.
 137C				     Zshape struc
 0000	      0000 [		      w word Overlay       ; Not used in this position - always used like Z.w[index]
	       0000
	      ]
 0000  0000			      SegSize word ?       ; Bytes.
 0002	      0000 [		      ProgramCancel dword Overlay; Used for zeroing.
	       00000000
	      ]
 0002  0000			      Program ProgramRec <>; Program flags
 0004  0000			      Cancel CancelRec <>  ; Flags for transient logic.
 0006  0000			      Stack word ? ; Current variable for Compaction. (Top of soft stack-$StrideV)
 0008  0000			      ClauseLine Ushort ?  ; Line this clause starts on. (First token)
 000A  0000			      Middles MiddleRec <> ; Extension of Clause. Keep with Clause for zeroing.
 000C  0000			      Clause ClauseRec <>  ; Compile time clause flags
 000E  0000			      Gen GenRec <>        ; Flags for control of what gets compiled.
 0010  0000			      KWMiddle charp ?     ; List of search keywords.
 0012  0000			      KWFound Ushort ?     ; Latest keyword found.
 0014  0000			      Stdout Handle ?      ; A constant but potential redirection.
 0016  0000			      Stderr Handle ?      ; A constant but potential redirection.
 0018  0000			      SourceHandle Handle ?
 001A  0000			      HowInvoked Ushort ?  ; Length of COMMAND/FUNCTION/SUBROUTINE.
 001C  00			      Radix byte ?         ; Normally has value 10.
 001D	      0006 [		      AxAsNum char 6 dup(?); For result of Ax2DsSiCx
	       00
	      ]
 0023	      0005 [		      Tag char 5 dup(?)    ; For trace. Joined to AxAsNum
	       00
	      ]
 0028  00000000			      Seed dword ?         ; For Random bif.
 002C  0000			      ParseResetSp charp ? ; Where the parser started work on the hard stack.
 002E  0000			      XCycleResetSp charp ?; Where the execution started work on the hard stack.
 0030  0000			      Dumper word ?        ; Handle when we are writing Pcode to disk.
 0032  0000			      Stash word ?         ; Various
 0034  0000			      Resolved charp ?     ; Result of Lookup.
 0036  0000			      Cursor charp ?       ; Offset into code. (Compile time)
 0038  0000			      Stream charp ?       ; The current stream.  In SysFiles segment.
 003A  0000			      Queue  charp ?       ; The FileBx for CRXREXX.QUE in SysFiles segment.
				     ; Compaction exploits these Segp things being adjacent.
 003C	      0000 [		      InsSource dword Overlay
	       00000000
	      ]
 003C	      0000 [		      SysFile dword Overlay
	       00000000
	      ]
 003C  0000			      File charp ?         ; Current external file of source.
 003E  0000			      SysFiles Segp ?      ; DOS interface
 0040  0000			      Consts Segp ?        ; To an array, fixed size per constant.
 0042  0000			      Vars Segp ?          ; To an array, fixed size per variable.
 0044  0000			      ProgScope Segp ?     ; Shadow of Consts. Order is exploited, see MoreSpaceEs.
 0046  0000			      VarScope Segp ?      ; Shadow of Vars.
 0048  0000			      Symbols Segp ?       ; To a write-once for names and constants.
 004A  0000			      Code Segp ?          ; To the internal code.
 004C  0000			      Zone Segp ?          ; Convenient place for Compaction to find address.
				     ; End of section organised for Compaction.
 004E  0000			      Stem Segp ?          ; Used when a stem wants MoreSpaceEs.
 0050  0000			      PoolPool Segp ?      ; Spare VarScope copies.
 0052  0000			      Level charp ?        ; Latest level of invocation.
 0054  0000			      Base0 charp ?        ; Parser time, for checking how many operands pushed.
 0056  0000			      CurrentDO charp ?    ; Junction of DO blocks and stacked values.
 0058  0000			      ResumeP word ?       ; Save Pcode address while Bcode execution.
 005A	      0000 [		      ResumeDF dword Overlay
	       00000000
	      ]
 005A  0000			      ResumeD word ?       ; Digits() preserved over Bcode execution.
 005C  0000			      ResumeF word ?       ; Fuzz() preserved over Bcode execution.
 005E  00			      ResumeS char ?       ; S/E mode preserved over Bcode execution.
				     ; Section set by ZoneNumerics.  (cf NotS9)
 005F	      0000 [		      DigitsFuzz dword Overlay
	       00000000
	      ]
 005F  0000			      Digits Ushort ?      ; Current digits().
 0061  0000			      Fuzz Ushort ?        ; Current fuzz().
 0063  00000000			      Ceiling dword ?      ; 1eN where N is current digits().
 0067  00000000			      DivBreak dword ?     ; To test for enough digits made in division.
 006B  00000000			      TwiceDigits dword ?  ; 2*N where N is current digits().
 006F  0000			      UseGeneral Ushort ?  ; On for mandatory use of ArithGeneral
				     ; end section set by ZoneNumerics.
				     ; Inserts for messages are divided into (a) those that stay constant or which
				     ; we always want to set when compiling, and (b) those that might be undesirably
				     ; changed when we rescan during execution to find the line number for a message.
				     ; The latter are in a block for save/restore.
				     ; "Ins..." is used as help to identify.
 0071  0000			      InsLine Ushort ?     ; Value for insert
 0073  00			      InsBif byte ?        ; Bif offset.
 0074  00000000			      InsOperator dword ?  ; Actual chars.
 0078  0000			      InsUnqual charp ?    ; Offset in SysFiles. For <source> insert, msg 43.1
 007A	      0000 [		      Insert InsBlock <>   ; For message. The saved copy is Inserts.
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 008F	      0000 [		      Inserts InsBlock <>
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 00A4  00			      SignM byte ?         ; Of mantissa
 00A5  00			      SignE byte ?         ; Of exponent
 00A6  0000			      MantPos charp ?      ; Where mantissa starts.
 00A8  0000			      MantPosZi charp ?    ; Beyond end
 00AA  0000			      ExpPos charp ?       ; Where exponent starts.
 00AC  0000			      ExpPosZi charp ?     ; Beyond end
 00AE  0000			      ExpSign word ?
 00B0  0000			      MantSize word ?
 00B2  00			      OpIs byte ?          ; Remembers operator in execution of it.
 00B3  00			      Flags byte ?         ; In BifTypes
 00B4  00			      BifParmsHi byte ?    ; For Bifs to test how many parameters on instance.
 00B5  00			      BifByte byte ?       ; Combines bif number and a parms count.
				     ; Trace section
 00B6  00000000			      TraceAlign dword ?; Beginning of line of source as offset on source file.
 00BA  00000000			      TraceSource dword ?; Beginning of section of source to be shown.
 00BE  00000000			      TraceEnds dword ?; End of section of source to be shown.
 00C2  0000			      TraceSourceColumn word ?
 00C4  0000			      TraceEndsColumn word ?
 00C6  0000			      DualCode charp ?; Beginning of Pcode for one clause.
 00C8  00			      TraceOp byte ?   ; Trace info for current Pcode operation.
 00C9  00000000			      Relative dword ?; Adjustment between position on file and position in buffer.
 00CD  00000000			      RelativeNow dword ?; Used when Serial contains section of source.
 00D1  0000			      Continue word ?; Pcode offset of next clause.
 00D3  0000			      StackX word ?; Hold StackDi over parsing.
 00D5  0000			      TraceLine word ?; Last shown ClauseLine.
 00D7  00000000			      InhibitTrace dword ?
 00DB  00000000			      InhibitPauses dword ?
 00DF  0000			      Target word ?; Used to carry branch value from original pcode to dual.
				     ; Trace section end
				     ; Main also [ Tokens
 00E1  0000			        Scanp charp ?        ; Where the scan has reached. Zero when executing.
 00E3  0000			        EndUsedBuffer charp ?; Where marker to interrupt scan is placed.
 00E5  0000			        NearEnd charp ?      ; Towards end of buffer.
				     ;]
 00E7  00			        CatOp byte ?         ; $pCat or $pAbut
 00E8  00			        RadixBadWhite byte ?
 00E9  0000			        BackExponent charp ?
 00EB  0000			        LastContent charp ?
 00ED  0000			        CommaLine word ?; NonZero if previous line ended with non-continuation comma.
 00EF  0000			        Condition Ushort ?   ; Latest condition keyword.
 00F1  0000			        UntilPlace Ushort ?  ; Place in Pcode. Held just over UNTIL expression.
 00F3  0000			        StemSym charp ?      ; Temp for A.B.C type Lookup
 00F5  0000			        SoFar word ?         ; Temp for A.B.C type Lookup
 00F7  0000			        PcodePos word ?      ; Used by ConstValue
 00F9  0000			        TraceOnly word ?     ; Used to detect 'trace only' labels.
 00FB  0000			      CompareAt word ?       ; For detecting compare Pcode optimizing.
 00FD  0000			      StackHi charp ?        ; Used for compound lookup.
 00FF  0000			      StackLo charp ?        ; Also for function arguments.
 0101  0000			      OnSoft charp ?         ; Where stacked target symbols start. PARSE compiletime.
				                             ; Tokens tells Pcode.
 0103  0000			      Tail charp ?           ; Work when Pcode made for tailed.
 0105  0000			      TokNum word ?          ; As tokenizer makes, parser sees.
 0107  0000			      TokNow word ?
 0109  0000			      TokWas word ?
 010B  0000			        TokData word ?       ; Data for parser derived from TokNum
 010D  0000			        Synch charp ?        ; Instruction pointer, into Pcode, for synching.
 010F  0000			        Lines Ushort ?       ; Count of lines
 0111  0000			        MsgBegin charp ?     ; Where sub-messages concatenated.
 0113  0000			        MsgSoFar charp ?     ; As sub-messages concatenated.
 0115  0000			        PreZi charp ?        ; End of message before expanding insertions.
 0117	      0000 [		        TargetMajMin word Overlay; This is message being output.
	       0000
	      ]
 0117  00			         TargetMinor byte ?
 0118  00			         TargetMajor byte ?
				        struc                ; See DOS command 4Bh
 0119  0000			         EnvSeg Segp ?
 011B  0000 0000		         ForPSP Farp <>
 011F  0000 0000		         Fcb1 Farp <>
 0123  0000 0000		         Fcb2 Farp <>
				        ends
 0127  0000			        AtPause charp ?       ; NYI
 0129  00			        ArgsB byte ?; For Arg() of BCycle bif.
 012A  0000			        ArgsB0 charp ?; For Arg(exp) of BCycle bif.
				     ; Workspace for the verbs can be shared.
				        struct; For Parse
 012C	      0000 [		         Parsee FarpX <>
	       00000000
	      ] 0000 0000
	      0000 [
	       0000
	      ] 0000
 0132  0000			         ParseeNum Ushort ?; Counts arguments for commas in parsing template.
 0134  0000			         PattLenEtc Ushort ?  ; Length of pattern. Temp for cursor.
 0136  0000			         BreakStart charp ?; Beginning of previous section delimiter.
 0138  0000			         BreakEnd charp ?  ; End of previous section delimiter.
				        ends
 013A  0000 0000 0000 0000	        EnvNow EnvBlock <> ; Used to execute ADDRESS
 0142  0000			      CatTotal word ?      ; Used by Abut$$ & Cat$$
 0144  0000			      LastTarget word ?    ; For detecting when to make $pUnstore.
 0146  0000			      NewJshape charp ?    ; Used by FindKey.
 0148  0000			      FromDos charp ?; A slot addressing a segment DOS gave us. (Cat optim. uses)
 014A  0000			      FromDosWas word ?; To test for cycled through them.
 014C  0000			      FromDosZi charp ?; Bound for FromDos
 014E	      000A [		      MemoryTable Ashape $Ashapes dup(<>)
	       0000 0000 0000
	      ]
 018A	      0000 [		      MemoryTableZi byte Overlay; Just used as an offset.
	       00
	      ]
 018A  0000			      Left charp ?     ; For compaction.
 018C  0000			      Right charp ?    ; For compaction.
 018E  00000000			      AllocBase dword ?; For compaction.
				     ; Grouping matters here.
 0192  0000			      DsWas Segp ?
 0194  0000			      DsNew Segp ?
 0196  0000			      EsWas Segp ?
 0198  0000			      EsNew Segp ?     ; Sometimes reloaded from.
 019A  0000			      FsWas Segp ?
 019C  0000			      FsNew Segp ?
 019E  0000			      GsWas Segp ?
 01A0  0000			      GsNew Segp ?
				     if Debug
 01A2  0000			      DebugStash word ?
 01A4  00000000			      DebugD dword ?
				     endif
 01A8  0000			      DigitCount Ushort ?  ; Checking radix string, Compile and execute.
				     ; Byte before Serial better not accidentally look like $Eof.
 01AA  00			      SerialNow byte ? ; Indicates what is in Serial.
 01AB	      11C8 [		      Serial char $SourceBufferSize dup(?)
	       00
	      ]
				      align 4
 1374	      0007 [		      CommandArg Vshape <>; Parameters from Command line.
	       00
	      ] 00
				     Zshape ends
				     ; Z. is for Zshape objects addressed by [bp]; the Zone
 = (Zshape ptr[bp])		     Z is <(Zshape ptr[bp])>

 0053				     Yshape struc
 0000  00000000			      dword ?; Overlays jmp.
 0004  00000001			      N1 dword 1
 0008  0000000A			      N10 dword 10
 000C  00000064			      N100 dword 100
 0010  000003E8			      N1000 dword 1000
 0014  00002710			      N1e4 dword 10000
 0018  000186A0			      N1e5 dword 100000
 001C  000F4240			      N1e6  dword 1000000
 0020  00989680			      N1e7 dword 10000000
 0024  05F5E100			      N1e8 dword 100000000
 0028  3B9ACA00			      N1e9 dword 1000000000
 002C  0019660D			      N1664525 dword 1664525; For Random
				      Assert $Limit_ExponentDigits eq 9
 0030  3B9AA2F1			      ExponHi dword 1000000000-$Limit_Digits
 0034  C4653602			      ExponLo dword -1000000000+2
 0038  0000			      Cseg Segp ?          ; To be where the machine code is.
 003A	      0000 [		      DOS dword Overlay; Default ADDRESS
	       00000000
	      ]
 003A	      0001 [		       db "DOS "
	       44 4F 53 20
	      ]
 003E	      0001 [		      DosPool db "ENVIRONMENT"; Pool name
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
 0049	      0001 [		       db "..."; Joined to following CrLf
	       2E 2E 2E
	      ]
 004C  22			      DqCrLf db '"'
 004D  0D 0A			      CrLf db 13,10
 004F  0000 0000		      StackSave Farp <>    ; To recover when only CS:IP survives.
				     Yshape ends
				     ; Y. is for Yshape objects addressed by [bp]; the constants.
 = (Yshape ptr cs:[bp])		     Y is <(Yshape ptr cs:[bp])>
 = (Yshape ptr cs:[2*ecx+ebp])	     Ycx2 is <(Yshape ptr cs:[2*ecx+ebp])>
 = (Yshape ptr cs:[si])		     Ysi is <(Yshape ptr cs:[si])>

				     ; These equs should follow the declares of shapes they depend on.
 = 0014				     $SizeConstsHeader equ $StrideH+4
				     ; Configuration variables (used by the implementation but not seen by the user's
				     ; program) are in the order the utility that makes Bcode has numbered them. The
				     ; $Reserved string matches.
				     ; Also constants & reserved variables that are always in ProgScope area.
 = 0014				     $?Omitted equ $SizeConstsHeader
 = 001C				     $?MN equ $?Omitted+$StrideV
 = 0024				     $?RS equ $?MN+$StrideV
 = 002C				     $?RESULT equ $?RS+$StrideV
 = 0034				     $?RC equ $?RESULT+$StrideV
 = 003C				     $?SIGL equ $?RC+$StrideV
 = 0044				     $?SysVars equ $?SIGL+$StrideV
				     ; See $Reserved for number of vars here.
 = 000B				     $SysCount equ 11
 = 0000				     ?OUTCOME equ 0; These are the numbers used in Bcode references.
 = 0044				     $?OUTCOME equ $?SysVars; These are the offsets used in machine code references.
				     ; ie where the system variables are in the ProgScope segment.
 = 0002				     ?BIF equ 2
 = 004C				     $?BIF equ $?SysVars+$StrideV
 = 0004				     ?STREAM equ 4
 = 0054				     $?STREAM equ $?SysVars+2*$StrideV
 = 0006				     ?STREAMSTATE equ 6
 = 005C				     $?STREAMSTATE equ $?SysVars+3*$StrideV
 = 0008				     ?RESPONSE equ 8
 = 0064				     $?RESPONSE equ $?SysVars+4*$StrideV
 = 000A				     ?LINEIN_POSITION equ 10
 = 006C				     $?LINEIN_POSITION equ $?SysVars+5*$StrideV
 = 000C				     ?CLAUSETIME equ 12
 = 0074				     $?CLAUSETIME equ $?SysVars+6*$StrideV
 = 000E				     ?CLAUSELOCAL equ 14
 = 007C				     $?CLAUSELOCAL equ $?SysVars+7*$StrideV
 = 0010				     ?MONTHS equ 16
 = 0084				     $?MONTHS equ $?SysVars+8*$StrideV
 = 0012				     ?WEEKDAYS equ 18
 = 008C				     $?WEEKDAYS equ $?SysVars+9*$StrideV
 = 0014				     ?STARTTIME equ 20
 = 0094				     $?STARTTIME equ $?SysVars+10*$StrideV
 = 009C				     $?Nine equ $?SysVars+11*$StrideV
 = 00A4				     $?Zero equ $?Nine+$StrideV
 = 00AC				     $?Null equ $?Zero+$StrideV
 = 00B4				     $?E equ $?Null+$StrideV
 = 00BC				     $?S equ $?E+$StrideV
				     ; These are variables that are always in current VarScope area.
 = 0010				     $?Discard equ $StrideH; Takes two because ends in dot.
 = 0020				     $?RESULTx equ $?Discard+2*$StrideV
 = 0028				     $?RCx equ $?RESULTx+$StrideV
 = 0030				     $?SIGLx equ $?RCx+$StrideV
				     ; Not in the table, but we need to use some character as an end-used-buffer
				     ; mark. (Saves checking address repeatedly) Using Linefeed helps comment scan.
 = 000A				     $EndBuffer equ $Lf
 = 0000				     $Whole     equ 0
 = 0004				     $WholeGE   equ 4
 = 0008				     $WholeGT   equ 8
 = 000C				     $Num       equ 12
 = 0010				     $M090      equ 16
 = 0014				     $WholeNum  equ 20
 = 0018				     $Pad       equ 24
 = 001C				     $Hex       equ 28
 = 0020				     $Stream    equ 32
 = 0024				     $Bin       equ 36
 = 0028				     $Symbol    equ 40

				     AllocAppend macro Goes:req
				      push si
				      mov si,Z.FromDos; The current allocation source.
				      mov ax,A.Fr.Pt
				      sub ax,V.Len
				      cmp ax,V.Pt
				      jne Goes
				     ; Here if offset fits. Also need to check same segment.
				      mov ax,V.Sg
				      cmp ax,A.Fr.Sg
				      jne Goes
				      mov es,ax
				     ; The segment could be full, but if possible take the extra.
				      mov ax,V.Pt
				      add ax,cx
				      jc Goes
				      cmp ax,A.Amount
				      ja Goes
				      mov A.Fr.Pt,ax
				      sub ax,cx
				      mov V.Len,cx
				      endm
				     ; Here are the numbers which go in the Attributes table.
				     ; Most of this is just for compiling but some equates are relevant to
				     ; execution so those have been put in declares.inc
				     ; First two bits for quick test of Whitespace, Letter, Digit, Special
				     ; $White equ 0 $Digit equ 64 $Letter equ 128 $Special equ 192
				     ; When it is not Special, the remaining bits can be flags.
				     ; When it is Special, there is a switch indexed by the rest of the byte.
				     ; This corresponds to the right six bits of TokVal so we can test in groups.
				     ; In practice it is "+ or -" that gets tested this way.
 = 00FC				      $Group equ 0FCh
 = $AttribPlus and $Group	      $PlusMinus equ $AttribPlus and $Group
				     ; The bits to the right of $White are free, and we could distinquish the
				     ; reak blank from blank equivalents but there seems no reason to do so.
				     ; We are short of a bit for letters. It would be nice to have flags for
				     ; conveniently testing "Ee", "Xx", "Bb", "01", ok as hex digit, having upper
				     ; case, and real-letter, as well as $Letter for the purposes of a symbol.
				     ; Something has to be left out, and real-letter would only be used in
				     ; DATATYPE().
				     ; We are short of a bit for digits. It is highly desirable to be able to scan
				     ; a number using lods and not have to refer to the value before xlat (since
				     ; xlat overwrites al). So we would like to have the value of the digit in the
				     ; low order of the attribute, as opposed to subtracting character '0' from the
				     ; raw character. That leaves two, which gives us difficulty if we want
				     ; OK-for-radix-B, OK-for-radix-X, and a Lower-case-letter. (Since we would
				     ; like to test the latter in the symbol recognition loop without distinquishing
				     ; letter/digit first.)
				     ; The solution seems to be to invert the lowercase flag. Then with blanks and
				     ; specials out of the way (jpe), the upperableness can be tested as zeroness
				     ; of Digit flag and NonUpable flag, together.
				     ; So the scheme for Letter-or-Digit is to make the right nibble dependent on
				     ; whether letter or digit, leaving two bits for OK-for-radix.
 = 0020				      $OKb equ 32
 = 0010				      $OKx equ 16
				     ; For letters:
				     ; $NonUpable equ 8 $Bb equ 4 $Xx equ 2 $Ee equ 1
				     ; $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; These values above $STRING go through switching like specials but are not
				     ; seen by the parser.
 = 0027				     $LineFeed equ $Eq-4
 = 0009				     $Invalid equ $UnAccept+1
 = 000A				     $Colon equ $UnAccept+2
 = 00D8				     $AttribAnd equ $Special+$And
 = 00D5				     $AttribOr equ $Special+$Or
 = 00EB				     $AttribEq equ $Special+$Eq
 = 00E4				     $AttribMinus equ $Special+$Minus
 = 00ED				     $AttribLt equ $Special+$Lt
 = 00F0				     $AttribGt equ $Special+$Gt
 = 00D2				     $AttribSlash equ $Special+$Slash
 = 00DC				     $AttribComma equ $Special+$Comma
 = 00E7				     $AttribLine equ $Special+$LineFeed
 = 00E5				     $AttribPlus equ $Special+$Plus
 = 00D1				     $AttribStar equ $Special+$Asterisk
 = 00FF				     $NoMatch equ $Special+63; No character has these attributes.

				     ;------------------------------------------------------------------------------
				     ; This code is in the mode ds=cs because it works with read-only tables
				     ; that are assembled with the code. Control leaves this module to determine
				     ; the next thing in the source (NextToken) and for Actions (such as adding
				     ; to the pseudo-code) to be taken. On return from these, ds=cs is
				     ; re-established.
				     ; ES is Z.Symbols, only needed in QueryKey.
				     ; FS and GS are not used in this mode.
				     ; On call-out from here (Action0, Actioning, NextToken) the module saves
				     ; what it needs and sets StackDi from Z.Stack.
				     ;------------------------------------------------------------------------------
				     ; Some keyword lookups are lexical, as when THEN or WITH ends an expression.
				     ; Keyword lookups for verbs, options... are a syntax requirement.
				     ; We keep the keyword table here to satisfy references from the syntax tables.
				      PUBLIC Keys; Table of keywords.  (Used for message creation)
				      PUBLIC $WithKey; Part of table needed by lexical work.
				      PUBLIC $ThenKey; Part of table needed by lexical work.
				      PUBLIC $CondKeys; Part of table needed by lexical work.
				      PUBLIC $DoKeys; Part of table needed by lexical work.
				      PUBLIC QueryKey; To look up keywords.
				      EXTERN NextToken:near; To identify next token in the source.
				     ; The decorated BNF says what actions are to be taken when certain syntax
				     ; constructions are encountered.
				      EXTERN Action0:near;   the action for an operand. (Not numbered in the BNF)
				      EXTERN Action1:near;   assignment at =
				      EXTERN Action2:near;   end of keyword instruction
				      EXTERN Action3:near;   end of command
				      EXTERN Action6:near;   PARSE VALUE
				      EXTERN Action10:near;   a binary op
				      EXTERN Action11:near;   a prefix
				      EXTERN Action12:near;   comparisons
				      EXTERN Action18:near;   a function name or after CALL
				      EXTERN Action20:near;   at THEN
				      EXTERN Action21:near;   at ELSE
				      EXTERN Action22:near;   end of if
				      EXTERN Action23:near;   end of select
				      EXTERN Action24:near;   end of otherwise
				      EXTERN Action25:near;   end of when
				      EXTERN Action26:near;   PROCEDURE
				      EXTERN Action28:near;   ITERATE/LEAVE, no VAR
				      EXTERN Action29:near;   ITERATE/LEAVE with VAR
				      EXTERN Action30:near;   do-end without var after.
				      EXTERN Action31:near;   var after do-end
				      EXTERN Action32:near;   end of do.
				      EXTERN Action33:near;   dorep done
				      EXTERN Action34:near;   While
				      EXTERN Action35:near;   Until
				      EXTERN Action36:near;   FOREVER
				      EXTERN Action37:near;   WHILE/UNTIL
				      EXTERN Action381:near;   TO
				      EXTERN Action382:near;   BY
				      EXTERN Action383:near;   FOR
				      EXTERN Action41:near;   missing expressions in a list
				      EXTERN Action43:near;   a function completes
				      EXTERN Action44:near;   CALL Ftn without expression list
				      EXTERN Action45:near;   CALL Ftn with expression list
				      EXTERN Action50:near;   after the subject of PARSE
				      EXTERN Action51:near;   ARG verb
				      EXTERN Action52:near;   PULL verb
				      EXTERN Action53:near;   Trigger
				      EXTERN Action55:near;   +-=
				      EXTERN Action56:near;   UPPER
				      EXTERN Action57:near;   after template
				      EXTERN Action58:near;   comma in template
				      EXTERN Action60:near;   callon spec.
				      EXTERN Action61:near;   after condition
				      EXTERN Action62:near;   OFF
				      EXTERN Action70:near;   ADDRESS instruction
				      EXTERN Action71:near;   INPUT resources
				      EXTERN Action72:near;   OUTPUT resources
				      EXTERN Action73:near;   ERROR resources
				      EXTERN Action74:near;   APPEND
				      EXTERN Action75:near;   Environment name
				      EXTERN Action80:near;   after numeric.
				      EXTERN Action90:near;   Expression ends
				      EXTERN Action91:near;   Clause ends
				     ; Constants for interpreting syntax tables. Ensure match with table generator.
 = 0000				     $ReferR   equ 0; Says reduction test is two word.
 = 0001				     $DirectR  equ 1; Says reduction goes without further test. (One word)
 = 0002				     $SubsetR  equ 2; Says reduction is like some other state's.(One word)
 = 0003				     $ArithR   equ 3; In second word, says two word is to target by arithmetic.
 = 0000				     $EqTest   equ 0; In second word, says if Reference = x then reduce to y.
 = 0001				     $GeTest   equ 1; In second word, says if Reference >= x then reduce to y.
				     ;------------------------------------------------------------------------------
				     ; Here is the "compile time" loop, Cycle.
				     ;------------------------------------------------------------------------------
				     ; The syntax utility makes syn.inc and a groups list. The latter is put in
				     ; prefered order by hand (see groups.inc) then processed for synequ.inc and
				     ; TokData
				     if Solid
 0000				     TokData word Overlay
 0000  0744			      dw ($Grp0ndxb shl NdxbT)+$Grp0ndx+$Needed/2
 0002  2345			      dw ($Grp12ndxb shl NdxbT)+$Grp12ndx+$Needed/2
 0004  0800			      dw ($Grp11ndxb shl NdxbT)+$Grp11Aim
 0006  1340			      dw ($Grp6ndxb shl NdxbT)+$Grp6ndx+$Needed/2
 0008  09C4			      dw ($Grp3ndxb shl NdxbT)+$Grp3Aim
 000A  0D87			      dw ($Grp4ndxb shl NdxbT)+$Grp4Aim
 000C  08B7			      dw ($Grp5ndxb shl NdxbT)+$Grp5Aim
 000E  1F47			      dw ($Grp10ndxb shl NdxbT)+$Grp10ndx+$Needed/2
 0010  4825			      dw ($Grp24ndxb shl NdxbT)+$Grp24Aim
 0012  1B43			      dw ($Grp9ndxb shl NdxbT)+$Grp9ndx+$Needed/2
 0014  2B4F			      dw ($Grp14ndxb shl NdxbT)+$Grp14ndx+$Needed/2
 0016  2568			      dw ($Grp13ndxb shl NdxbT)+$Grp13Aim
 0018  2568			      dw ($Grp13ndxb shl NdxbT)+$Grp13Aim
 001A  2568			      dw ($Grp13ndxb shl NdxbT)+$Grp13Aim
 001C  174E			      dw ($Grp7ndxb shl NdxbT)+$Grp7ndx+$Needed/2
 001E  5742			      dw ($Grp27ndxb shl NdxbT)+$Grp27ndx+$Needed/2
 0020  4F41			      dw ($Grp25ndxb shl NdxbT)+$Grp25ndx+$Needed/2
 0022  5341			      dw ($Grp26ndxb shl NdxbT)+$Grp26ndx+$Needed/2
 0024  5B3F			      dw ($Grp28ndxb shl NdxbT)+$Grp28ndx+$Needed/2
 0026  08BB			      dw ($Grp1ndxb shl NdxbT)+$Grp1Aim
 0028  0852			      dw ($Grp8ndxb shl NdxbT)+$Grp8Aim
 002A  09C5			      dw ($Grp2ndxb shl NdxbT)+$Grp2Aim
 002C  4346			      dw ($Grp21ndxb shl NdxbT)+$Grp21ndx+$Needed/2
 002E  0748			      dw ($Grp16ndxb shl NdxbT)+$Grp16ndx+$Needed/2
 0030  3746			      dw ($Grp18ndxb shl NdxbT)+$Grp18ndx+$Needed/2
 0032  31C9			      dw ($Grp17ndxb shl NdxbT)+$Grp17Aim
 0034  39CF			      dw ($Grp19ndxb shl NdxbT)+$Grp19Aim
 0036  2DD9			      dw ($Grp15ndxb shl NdxbT)+$Grp15Aim
 0038  3EFA			      dw ($Grp20ndxb shl NdxbT)+$Grp20Aim
 003A  3EFC			      dw ($Grp22ndxb shl NdxbT)+$Grp22Aim
 003C  4750			      dw ($Grp23ndxb shl NdxbT)+$Grp23ndx+$Needed/2
 003E  0125			      dw ($Grp48ndxb shl NdxbT)+$Grp48Aim
 0040  034C			      dw ($Grp60ndxb shl NdxbT)+$Grp60ndx+$Needed/2
 0042  01CD			      dw ($Grp68ndxb shl NdxbT)+$Grp68Aim
 0044  0349			      dw ($Grp31ndxb shl NdxbT)+$Grp31ndx+$Needed/2
 0046  0136			      dw ($Grp29ndxb shl NdxbT)+$Grp29Aim
 0048  032E			      dw ($Grp30ndxb shl NdxbT)+$Grp30Aim
 004A  00CE			      dw ($Grp32ndxb shl NdxbT)+$Grp32Aim
 004C  01B3			      dw ($Grp34ndxb shl NdxbT)+$Grp34Aim
 004E  034A			      dw ($Grp36ndxb shl NdxbT)+$Grp36ndx+$Needed/2
 0050  025D			      dw ($Grp51ndxb shl NdxbT)+$Grp51Aim
 0052  0274			      dw ($Grp46ndxb shl NdxbT)+$Grp46Aim
 0054  0271			      dw ($Grp39ndxb shl NdxbT)+$Grp39Aim
 0056  0271			      dw ($Grp39ndxb shl NdxbT)+$Grp39Aim
 0058  0196			      dw ($Grp66ndxb shl NdxbT)+$Grp66Aim
 005A  0193			      dw ($Grp47ndxb shl NdxbT)+$Grp47Aim
 005C  01BD			      dw ($Grp35ndxb shl NdxbT)+$Grp35Aim
 005E  01BD			      dw ($Grp40ndxb shl NdxbT)+$Grp40Aim
 0060  00E3			      dw ($Grp63ndxb shl NdxbT)+$Grp63Aim
 0062  0324			      dw ($Grp49ndxb shl NdxbT)+$Grp49Aim
 0064  020A			      dw ($Grp41ndxb shl NdxbT)+$Grp41Aim
 0066  0351			      dw ($Grp38ndxb shl NdxbT)+$Grp38ndx+$Needed/2
 0068  0302			      dw ($Grp67ndxb shl NdxbT)+$Grp67Aim
 006A  01D3			      dw ($Grp44ndxb shl NdxbT)+$Grp44Aim
 006C  008F			      dw ($Grp45ndxb shl NdxbT)+$Grp45Aim
 006E  0352			      dw ($Grp50ndxb shl NdxbT)+$Grp50ndx+$Needed/2
 0070  0237			      dw ($Grp53ndxb shl NdxbT)+$Grp53Aim
 0072  01B7			      dw ($Grp33ndxb shl NdxbT)+$Grp33Aim
 0074  0103			      dw ($Grp43ndxb shl NdxbT)+$Grp43Aim
 0076  021D			      dw ($Grp37ndxb shl NdxbT)+$Grp37Aim
 0078  034B			      dw ($Grp56ndxb shl NdxbT)+$Grp56ndx+$Needed/2
 007A  00B0			      dw ($Grp57ndxb shl NdxbT)+$Grp57Aim
 007C  021A			      dw ($Grp58ndxb shl NdxbT)+$Grp58Aim
 007E  027C			      dw ($Grp59ndxb shl NdxbT)+$Grp59Aim
 0080  0173			      dw ($Grp62ndxb shl NdxbT)+$Grp62Aim
 0082  034D			      dw ($Grp69ndxb shl NdxbT)+$Grp69ndx+$Needed/2
 0084  0147			      dw ($Grp61ndxb shl NdxbT)+$Grp61Aim
 0086  032F			      dw ($Grp64ndxb shl NdxbT)+$Grp64Aim
 0088  0331			      dw ($Grp65ndxb shl NdxbT)+$Grp65Aim
 008A  0353			      dw ($Grp52ndxb shl NdxbT)+$Grp52ndx+$Needed/2
 008C  02F8			      dw ($Grp42ndxb shl NdxbT)+$Grp42Aim
 008E  02F5			      dw ($Grp54ndxb shl NdxbT)+$Grp54Aim
 0090  0344			      dw ($Grp55ndxb shl NdxbT)+$Grp55ndx+$Needed/2
				     ;------------------------------------------------------------------------------
				     ; Table that picks up a byte of data on the latest character.
				     ;------------------------------------------------------------------------------
				     if Solid
 0092				     Attributes:
 0092	      0100 [		       byte 256 dup($Special+$Invalid); Default
	       C9
	      ]
				     ; Ignored whitespace. Linefeed is active whitespace
				       org Attributes+9
 009B  00			       byte $White; HT
				       org Attributes+11
 009D  00			       byte $White
 009E  00			       byte $White
 009F  00			       byte $White; VT FF CR
				       org Attributes+' '
 00B2  00			       byte $White
				     ; Letters
				       org Attributes+'#'
 00B5  88			       byte $Letter+$NonUpable
				       org Attributes+'$'
 00B6  88			       byte $Letter+$NonUpable
				       org Attributes+'@'
 00D2  88			       byte $Letter+$NonUpable
				       org Attributes+'!'
 00B3  88			       byte $Letter+$NonUpable
				       org Attributes+'?'
 00D1  88			       byte $Letter+$NonUpable
				       org Attributes+'_'
 00F1  88			       byte $Letter+$NonUpable
				       org Attributes+'A'
 00D3  98			       byte $Letter+$NonUpable+$OKx
				       org Attributes+'B'
 00D4  9C			       byte $Letter+$NonUpable+$Bb+$OKx
				       org Attributes+'C'
 00D5	      0002 [		       byte 2 dup($Letter+$NonUpable+$OKx)
	       98
	      ]
				       org Attributes+'E'
 00D7  99			       byte $Letter+$NonUpable+$Ee+$OKx
				       org Attributes+'F'
 00D8  98			       byte $Letter+$NonUpable+$OKx
				       org Attributes+'G'
 00D9	      0011 [		       byte 17 dup($Letter+$NonUpable)
	       88
	      ]
				       org Attributes+'X'
 00EA  8A			       byte $Letter+$NonUpable+$Xx
				       org Attributes+'Y'
 00EB	      0002 [		       byte 2 dup($Letter+$NonUpable)
	       88
	      ]
				       org Attributes+'a'
 00F3  90			       byte $Letter+$OKx
				       org Attributes+'b'
 00F4  94			       byte $Letter+$Bb+$OKx
				       org Attributes+'c'
 00F5	      0002 [		       byte 2 dup($Letter+$OKx)
	       90
	      ]
				       org Attributes+'e'
 00F7  91			       byte $Letter+$Ee+$OKx
				       org Attributes+'f'
 00F8  90			       byte $Letter+$OKx
				       org Attributes+'g'
 00F9	      0011 [		       byte 17 dup($Letter)
	       80
	      ]
				       org Attributes+'x'
 010A  82			       byte $Letter+$Xx
				       org Attributes+'y'
 010B	      0002 [		       byte 2 dup($Letter)
	       80
	      ]
				     ; Constant starts.
				       org Attributes+'0'
 00C2  70			       byte $Digit+$OKb+$OKx
				       org Attributes+'1'
 00C3  71			       byte $Digit+$OKb+$OKx+1
				       org Attributes+'2'
 00C4  52			       byte $Digit+$OKx+2
				       org Attributes+'3'
 00C5  53			       byte $Digit+$OKx+3
				       org Attributes+'4'
 00C6  54			       byte $Digit+$OKx+4
				       org Attributes+'5'
 00C7  55			       byte $Digit+$OKx+5
				       org Attributes+'6'
 00C8  56			       byte $Digit+$OKx+6
				       org Attributes+'7'
 00C9  57			       byte $Digit+$OKx+7
				       org Attributes+'8'
 00CA  58			       byte $Digit+$OKx+8
				       org Attributes+'9'
 00CB  59			       byte $Digit+$OKx+9
				     ; Dot is special in a template but can be part of a number, or a reserved.
				     ; I have tried as digit, as special, as letter, and least bad is letter, maybe.
				       org Attributes+"."
 00C0  88			       byte $Letter+$NonUpable
				       org Attributes+':'
 00CC  CA			       byte $Special+$Colon
				     ; Specials, see also SpSwitch.
				     ; These match initial groups.inc
				       org Attributes+$Eof
 00AC  C0			       byte $Special+$Eos
				       org Attributes+';'
 00CD  C4			       byte $Special+$Semi
				       org Attributes+'('
 00BA  CC			       byte $Special+$Lparen
				       org Attributes+')'
 00BB  F8			       byte $Special+$Rparen
				       org Attributes+'%'
 00B7  D0			       byte $Special+$Percent
				       org Attributes+'-'
 00BF  E4			       byte $Special+$Minus
				       org Attributes+"="
 00CF  EB			       byte $Special+$Eq
				       org Attributes+"'"
 00B9  FC			       byte $Special+$STRING
				       org Attributes+'"'
 00B4  FC			       byte $Special+$STRING
				       org Attributes+"<"
 00CE  ED			       byte $Special+$Lt
				       org Attributes+'\'
 00EE  E0			       byte $Special+$Not
				       org Attributes+"|"
 010E  D5			       byte $Special+$Or
				       org Attributes+"&"
 00B8  D8			       byte $Special+$And
				       org Attributes+">"
 00D0  F0			       byte $Special+$Gt
				       org Attributes+"/"
 00C1  D2			       byte $Special+$Slash
				       org Attributes+","
 00BE  DC			       byte $Special+$Comma
				       org Attributes+$Lf
 009C  E7			       byte $Special+$LineFeed
				       org Attributes+"+"
 00BD  E5			       byte $Special+$Plus
				       org Attributes+"*"
 00BC  D1			       byte $Special+$Asterisk
				       org Attributes+256; Attributes end
				     endif
				     ; Syntax table. Not first since addressed with -4 offset. Not edited.

				     ;Generated matrix for accept-by-this-state, state*token. 30*22
 0192				     AcceptBits dword 0 dup(?)
 0192  20000201			      dword 00100000000000000000001000000001y;  0
 0196  00000000			      dword 00000000000000000000000000000000y;  1
 019A  01001000			      dword 00000001000000000001000000000000y;  2
 019E  02D1A673			      dword 00000010110100011010011001110011y;  3
 01A2  02003000			      dword 00000010000000000011000000000000y;  4
 01A6  0241A653			      dword 00000010010000011010011001010011y;  5
 01AA  03013400			      dword 00000011000000010011010000000000y;  6
 01AE  0235C4D5			      dword 00000010001101011100010011010101y;  7
 01B2  00000800			      dword 00000000000000000000100000000000y;  8
 01B6  00000C00			      dword 00000000000000000000110000000000y;  9
 01BA  18020000			      dword 00011000000000100000000000000000y;  10
 01BE  14020000			      dword 00010100000000100000000000000000y;  11
 01C2  00004201			      dword 00000000000000000100001000000001y;  12
 01C6  0C020000			      dword 00001100000000100000000000000000y;  13
 01CA  000C0010			      dword 00000000000011000000000000010000y;  14
 01CE  00200104			      dword 00000000001000000000000100000100y;  15
 01D2  00408000			      dword 00000000010000001000000000000000y;  16
 01D6  0241A253			      dword 00000010010000011010001001010011y;  17
 01DA  0241A35F			      dword 00000010010000011010001101011111y;  18
 01DE  02C1A75F			      dword 00000010110000011010011101011111y;  19
 01E2  0241A75F			      dword 00000010010000011010011101011111y;  20
 01E6  0251A7FF			      dword 00000010010100011010011111111111y;  21
				     ;Equates for which token groups use which row.
 = 0001				     $Grp0ndxb equ 1
 = 0002				     $Grp1ndxb equ 2
 = 0002				     $Grp2ndxb equ 2
 = 0002				     $Grp3ndxb equ 2
 = 0003				     $Grp4ndxb equ 3
 = 0002				     $Grp5ndxb equ 2
 = 0004				     $Grp6ndxb equ 4
 = 0005				     $Grp7ndxb equ 5
 = 0002				     $Grp8ndxb equ 2
 = 0006				     $Grp9ndxb equ 6
 = 0007				     $Grp10ndxb equ 7
 = 0002				     $Grp11ndxb equ 2
 = 0008				     $Grp12ndxb equ 8
 = 0009				     $Grp13ndxb equ 9
 = 000A				     $Grp14ndxb equ 10
 = 000B				     $Grp15ndxb equ 11
 = 0001				     $Grp16ndxb equ 1
 = 000C				     $Grp17ndxb equ 12
 = 000D				     $Grp18ndxb equ 13
 = 000E				     $Grp19ndxb equ 14
 = 000F				     $Grp20ndxb equ 15
 = 0010				     $Grp21ndxb equ 16
 = 000F				     $Grp22ndxb equ 15
 = 0011				     $Grp23ndxb equ 17
 = 0012				     $Grp24ndxb equ 18
 = 0013				     $Grp25ndxb equ 19
 = 0014				     $Grp26ndxb equ 20
 = 0015				     $Grp27ndxb equ 21
 = 0016				     $Grp28ndxb equ 22
 = 0000				     $Grp29ndxb equ 0
 = 0000				     $Grp30ndxb equ 0
 = 0000				     $Grp31ndxb equ 0
 = 0000				     $Grp32ndxb equ 0
 = 0000				     $Grp33ndxb equ 0
 = 0000				     $Grp34ndxb equ 0
 = 0000				     $Grp35ndxb equ 0
 = 0000				     $Grp36ndxb equ 0
 = 0000				     $Grp37ndxb equ 0
 = 0000				     $Grp38ndxb equ 0
 = 0000				     $Grp39ndxb equ 0
 = 0000				     $Grp40ndxb equ 0
 = 0000				     $Grp41ndxb equ 0
 = 0000				     $Grp42ndxb equ 0
 = 0000				     $Grp43ndxb equ 0
 = 0000				     $Grp44ndxb equ 0
 = 0000				     $Grp45ndxb equ 0
 = 0000				     $Grp46ndxb equ 0
 = 0000				     $Grp47ndxb equ 0
 = 0000				     $Grp48ndxb equ 0
 = 0000				     $Grp49ndxb equ 0
 = 0000				     $Grp50ndxb equ 0
 = 0000				     $Grp51ndxb equ 0
 = 0000				     $Grp52ndxb equ 0
 = 0000				     $Grp53ndxb equ 0
 = 0000				     $Grp54ndxb equ 0
 = 0000				     $Grp55ndxb equ 0
 = 0000				     $Grp56ndxb equ 0
 = 0000				     $Grp57ndxb equ 0
 = 0000				     $Grp58ndxb equ 0
 = 0000				     $Grp59ndxb equ 0
 = 0000				     $Grp60ndxb equ 0
 = 0000				     $Grp61ndxb equ 0
 = 0000				     $Grp62ndxb equ 0
 = 0000				     $Grp63ndxb equ 0
 = 0000				     $Grp64ndxb equ 0
 = 0000				     $Grp65ndxb equ 0
 = 0000				     $Grp66ndxb equ 0
 = 0000				     $Grp67ndxb equ 0
 = 0000				     $Grp68ndxb equ 0
 = 0000				     $Grp69ndxb equ 0
				     ;Equates for which token groups use which column of sparse.
 = 0005				     $Grp0ndx equ 5
 = 0000				     $Grp1ndx equ 0
 = 0000				     $Grp2ndx equ 0
 = 0000				     $Grp3ndx equ 0
 = 0000				     $Grp4ndx equ 0
 = 0000				     $Grp5ndx equ 0
 = 0001				     $Grp6ndx equ 1
 = 000F				     $Grp7ndx equ 15
 = 0000				     $Grp8ndx equ 0
 = 0004				     $Grp9ndx equ 4
 = 0008				     $Grp10ndx equ 8
 = 0000				     $Grp11ndx equ 0
 = 0006				     $Grp12ndx equ 6
 = 0000				     $Grp13ndx equ 0
 = 0010				     $Grp14ndx equ 16
 = 0000				     $Grp15ndx equ 0
 = 0009				     $Grp16ndx equ 9
 = 0000				     $Grp17ndx equ 0
 = 0007				     $Grp18ndx equ 7
 = 0000				     $Grp19ndx equ 0
 = 0000				     $Grp20ndx equ 0
 = 0007				     $Grp21ndx equ 7
 = 0000				     $Grp22ndx equ 0
 = 0011				     $Grp23ndx equ 17
 = 0000				     $Grp24ndx equ 0
 = 0002				     $Grp25ndx equ 2
 = 0002				     $Grp26ndx equ 2
 = 0003				     $Grp27ndx equ 3
 = 0000				     $Grp28ndx equ 0
 = 0000				     $Grp29ndx equ 0
 = 0000				     $Grp30ndx equ 0
 = 000A				     $Grp31ndx equ 10
 = 0000				     $Grp32ndx equ 0
 = 0000				     $Grp33ndx equ 0
 = 0000				     $Grp34ndx equ 0
 = 0000				     $Grp35ndx equ 0
 = 000B				     $Grp36ndx equ 11
 = 0000				     $Grp37ndx equ 0
 = 0012				     $Grp38ndx equ 18
 = 0000				     $Grp39ndx equ 0
 = 0000				     $Grp40ndx equ 0
 = 0000				     $Grp41ndx equ 0
 = 0000				     $Grp42ndx equ 0
 = 0000				     $Grp43ndx equ 0
 = 0000				     $Grp44ndx equ 0
 = 0000				     $Grp45ndx equ 0
 = 0000				     $Grp46ndx equ 0
 = 0000				     $Grp47ndx equ 0
 = 0000				     $Grp48ndx equ 0
 = 0000				     $Grp49ndx equ 0
 = 0013				     $Grp50ndx equ 19
 = 0000				     $Grp51ndx equ 0
 = 0014				     $Grp52ndx equ 20
 = 0000				     $Grp53ndx equ 0
 = 0000				     $Grp54ndx equ 0
 = 0005				     $Grp55ndx equ 5
 = 000C				     $Grp56ndx equ 12
 = 0000				     $Grp57ndx equ 0
 = 0000				     $Grp58ndx equ 0
 = 0000				     $Grp59ndx equ 0
 = 000D				     $Grp60ndx equ 13
 = 0000				     $Grp61ndx equ 0
 = 0000				     $Grp62ndx equ 0
 = 0000				     $Grp63ndx equ 0
 = 0000				     $Grp64ndx equ 0
 = 0000				     $Grp65ndx equ 0
 = 0000				     $Grp66ndx equ 0
 = 0000				     $Grp67ndx equ 0
 = 0000				     $Grp68ndx equ 0
 = 000E				     $Grp69ndx equ 14

				     ;States merged with sparse shift array.
 = 0012				     StatesDim equ 18
 = 0015				     TokensDim equ 21
 = 067E				     $Needed equ 2*831
 = 0001				     $Grp0Only equ 1
 = 00BB				     $Grp1Aim equ 187;S134
 = 0001				     $Grp1Only equ 1
 = 01C5				     $Grp2Aim equ 453;S116
 = 0001				     $Grp2Only equ 1
 = 01C4				     $Grp3Aim equ 452;S154
 = 0001				     $Grp3Only equ 1
 = 0187				     $Grp4Aim equ 391;S138
 = 00B7				     $Grp5Aim equ 183;S120
 = 0001				     $Grp5Only equ 1
 = 0001				     $Grp6Only equ 1
 = 0001				     $Grp7Only equ 1
 = 0052				     $Grp8Aim equ 82;S157
 = 0001				     $Grp8Only equ 1
 = 0001				     $Grp9Only equ 1
 = 0001				     $Grp10Only equ 1
 = 0000				     $Grp11Aim equ 0;S67
 = 0001				     $Grp11Only equ 1
 = 0001				     $Grp12Only equ 1
 = 0168				     $Grp13Aim equ 360;S132
 = 01D9				     $Grp15Aim equ 473;S168
 = 0001				     $Grp15Only equ 1
 = 0001				     $Grp16Only equ 1
 = 01C9				     $Grp17Aim equ 457;S169
 = 0001				     $Grp17Only equ 1
 = 0001				     $Grp18Only equ 1
 = 01CF				     $Grp19Aim equ 463;S170
 = 0001				     $Grp19Only equ 1
 = 02FA				     $Grp20Aim equ 762;S84
 = 0001				     $Grp21Only equ 1
 = 02FC				     $Grp22Aim equ 764;S85
 = 0001				     $Grp23Only equ 1
 = 0025				     $Grp24Aim equ 37;S3
 = 0001				     $Grp28Only equ 1
 = 0136				     $Grp29Aim equ 310;S5
 = 032E				     $Grp30Aim equ 814;S260
 = 00CE				     $Grp32Aim equ 206;S7
 = 01B7				     $Grp33Aim equ 439;S101
 = 01B3				     $Grp34Aim equ 435;S8
 = 01BD				     $Grp35Aim equ 445;S9
 = 021D				     $Grp37Aim equ 541;S181
 = 0271				     $Grp39Aim equ 625;S12
 = 01BD				     $Grp40Aim equ 445;S9
 = 020A				     $Grp41Aim equ 522;S164
 = 02F8				     $Grp42Aim equ 760;S83
 = 0103				     $Grp43Aim equ 259;S102
 = 01D3				     $Grp44Aim equ 467;S13
 = 008F				     $Grp45Aim equ 143;S219
 = 0274				     $Grp46Aim equ 628;S14
 = 0193				     $Grp47Aim equ 403;S15
 = 0125				     $Grp48Aim equ 293;S104
 = 0324				     $Grp49Aim equ 804;S190
 = 025D				     $Grp51Aim equ 605;S16
 = 0237				     $Grp53Aim equ 567;S17
 = 02F5				     $Grp54Aim equ 757;S77
 = 00B0				     $Grp57Aim equ 176;S220
 = 021A				     $Grp58Aim equ 538;S19
 = 027C				     $Grp59Aim equ 636;S20
 = 0147				     $Grp61Aim equ 327;S262
 = 0173				     $Grp62Aim equ 371;S22
 = 00E3				     $Grp63Aim equ 227;S23
 = 032F				     $Grp64Aim equ 815;S263
 = 0331				     $Grp65Aim equ 817;S264
 = 0196				     $Grp66Aim equ 406;S25
 = 0302				     $Grp67Aim equ 770;S105
 = 01CD				     $Grp68Aim equ 461;S107
 01EA				     StateOrig word Overlay
 01EA  0546			      word 675*2;  At 0,element 0,0
 01EC  0166			      word 179*2;  At 1,element 0,1
 01EE  0124			      word 146*2;  At 2,element 0,2
 01F0  0508			      word 644*2;  At 3,element 0,3
 01F2  004A			      word 37*2;   At 4,element 0,4
 01F4  0074			      word 58*2;   At 5,element 0,5
 01F6  008A			      word 69*2;   At 6,element 0,6
 01F8  0108			      word 132*2;  At 7,element 0,7
 01FA  0342			      word 417*2;  At 8,element 0,8
 01FC  00B8			      word 92*2;   At 9,element 0,9
 01FE  047C			      word 574*2;  At 10,element 0,10
 0200  00B4			      word 90*2;   At 11,element 0,11
 0202  00E2			      word 113*2;  At 12,element 0,12
 0204  0504			      word 642*2;  At 13,element 0,13
 0206  010C			      word 134*2;  At 14,element 0,14
 0208  0334			      word 410*2;  At 15,element 0,15
 020A  02D0			      word 360*2;  At 16,element 0,16
 020C  04EC			      word 630*2;  At 17,element 0,17
 020E  0414			      word 522*2;  At 18,element 0,18
 0210  01EC			      word 246*2;  At 19,element 0,19
 0212  0676			      word 827*2;  At 20,element 0,20
 0214  0546			      word 675*2;  At 21,element 1,0
 0216  0166			      word 179*2;  At 22,element 1,1
 0218  0124			      word 146*2;  At 23,element 1,2
 021A  0508			      word 644*2;  At 24,element 1,3
 021C  004A			      word 37*2;   At 25,element 1,4
 021E  0000			      word 0*2;    At 26,element 1,5
 0220  0000			      word 0*2;    At 27,element 1,6
 0222  0108			      word 132*2;  At 28,element 1,7
 0224  0342			      word 417*2;  At 29,element 1,8
 0226  0000			      word 0*2;    At 30,element 1,9
 0228  047C			      word 574*2;  At 31,element 1,10
 022A  00B4			      word 90*2;   At 32,element 1,11
 022C  00E2			      word 113*2;  At 33,element 1,12
 022E  0504			      word 642*2;  At 34,element 1,13
 0230  010C			      word 134*2;  At 35,element 1,14
 0232  049C			      word 590*2;  At 36,element 1,15
 0234  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S3@37
 0236  C8C1			      ErrorRec{1,1,35,1}
 0238  014A			      word 165*2;  At 39,element 1,18
 023A  02EE			      word 375*2;  At 40,element 1,19
 023C  03A4			      word 466*2;  At 41,element 1,20
 023E  01F6			      word 251*2;  At 42,element 2,0
 0240  0166			      word 179*2;  At 43,element 2,1
 0242  0124			      word 146*2;  At 44,element 2,2
 0244  0508			      word 644*2;  At 45,element 2,3
 0246  004A			      word 37*2;   At 46,element 2,4
 0248  066C			      word 822*2;  At 47,element 2,5
 024A  0000			      word 0*2;    At 48,element 2,6
 024C  0608			      word 772*2;  At 49,element 2,7
 024E  0634			      word 794*2;  At 50,element 2,8
 0250  05AC			      word 726*2;  At 51,element 2,9
 0252  024A			      word 293*2;  At 52,element 2,10
 0254  063C			      word 798*2;  At 53,element 2,11
 0256  0658			      word 812*2;  At 54,element 2,12
 0258  024A			      word 293*2;  At 55,element 2,13
 025A  03B6			      word 475*2;  At 56,element 2,14
 025C  0000			      word 0*2;    At 57,element 2,15
 025E  8440			      ShiftRec{1,0,0,0,0,1,$11,0};           S1@58
 0260  04DC			      word 622*2;  At 59,element 2,17
 0262  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S78@60
 0264  099C R			      word Keys78;295
 0266  C641			      ErrorRec{1,1,25,1}
 0268  0546			      word 675*2;  At 63,element 3,0
 026A  0166			      word 179*2;  At 64,element 3,1
 026C  0124			      word 146*2;  At 65,element 3,2
 026E  0508			      word 644*2;  At 66,element 3,3
 0270  004A			      word 37*2;   At 67,element 3,4
 0272  0000			      word 0*2;    At 68,element 3,5
 0274  06AF			      RedRec{0,0,0,$DirectR,687}; S30        S4@69
 0276  0108			      word 132*2;  At 70,element 3,7
 0278  0282			      word 321*2;  At 71,element 3,8
 027A  00B8			      word 92*2;   At 72,element 3,9
 027C  047C			      word 574*2;  At 73,element 3,10
 027E  00B4			      word 90*2;   At 74,element 3,11
 0280  00E2			      word 113*2;  At 75,element 3,12
 0282  0504			      word 642*2;  At 76,element 3,13
 0284  010C			      word 134*2;  At 77,element 3,14
 0286  066A			      word 821*2;  At 78,element 3,15
 0288  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S81@79
 028A  099C R			      word Keys81;295
 028C  C642			      ErrorRec{1,1,25,2}
 028E  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S157@82
 0290  C8C1			      ErrorRec{1,1,35,1}
 0292  0546			      word 675*2;  At 84,element 4,0
 0294  0166			      word 179*2;  At 85,element 4,1
 0296  0124			      word 146*2;  At 86,element 4,2
 0298  0508			      word 644*2;  At 87,element 4,3
 029A  004A			      word 37*2;   At 88,element 4,4
 029C  0616			      word 779*2;  At 89,element 4,5
 029E  C202			      ErrorRec{1,1,8,2};                     S10@90
 02A0  0108			      word 132*2;  At 91,element 4,7
 02A2  C281			      ErrorRec{1,1,10,1};                    S11@92
 02A4  0650			      word 808*2;  At 93,element 4,9
 02A6  047C			      word 574*2;  At 94,element 4,10
 02A8  00B4			      word 90*2;   At 95,element 4,11
 02AA  00E2			      word 113*2;  At 96,element 4,12
 02AC  0504			      word 642*2;  At 97,element 4,13
 02AE  010C			      word 134*2;  At 98,element 4,14
 02B0  05B0			      word 728*2;  At 99,element 4,15
 02B2  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S114@100
 02B4  097F R			      word Keys114;266
 02B6  C644			      ErrorRec{1,1,25,4}
 02B8  0000 E			      word Action45
 02BA  5579			      RedRec{0,1,1,$DirectR,377}; S80        S166@104
 02BC  0546			      word 675*2;  At 105,element 5,0
 02BE  0166			      word 179*2;  At 106,element 5,1
 02C0  0124			      word 146*2;  At 107,element 5,2
 02C2  0508			      word 644*2;  At 108,element 5,3
 02C4  004A			      word 37*2;   At 109,element 5,4
 02C6  066E			      word 823*2;  At 110,element 5,5
 02C8  1A06			      RedRec{0,0,1,$SubsetR,518}; S144       S212@111
 02CA  0108			      word 132*2;  At 112,element 5,7
 02CC  C242			      ErrorRec{1,1,9,2};                     S18@113
 02CE  0670			      word 824*2;  At 114,element 5,9
 02D0  047C			      word 574*2;  At 115,element 5,10
 02D2  00B4			      word 90*2;   At 116,element 5,11
 02D4  00E2			      word 113*2;  At 117,element 5,12
 02D6  0504			      word 642*2;  At 118,element 5,13
 02D8  010C			      word 134*2;  At 119,element 5,14
 02DA  85C7			      ShiftRec{1,0,0,0,0,1,$7,7};            S145@120
 02DC  C900			      ErrorRec{1,1,36,0}
 02DE  0000 E			      word Action60
 02E0  97E0			      ShiftRec{1,0,0,1,0,1,$31,0};           S165@123
 02E2  0A42 R			      word Keys165;461
 02E4  5579			      RedRec{0,1,1,$DirectR,377}; S80
 02E6  0546			      word 675*2;  At 126,element 6,0
 02E8  0166			      word 179*2;  At 127,element 6,1
 02EA  0124			      word 146*2;  At 128,element 6,2
 02EC  0508			      word 644*2;  At 129,element 6,3
 02EE  004A			      word 37*2;   At 130,element 6,4
 02F0  0672			      word 825*2;  At 131,element 6,5
 02F2  C201			      ErrorRec{1,1,8,1};                     S24@132
 02F4  0108			      word 132*2;  At 133,element 6,7
 02F6  C241			      ErrorRec{1,1,9,1};                     S26@134
 02F8  0674			      word 826*2;  At 135,element 6,9
 02FA  047C			      word 574*2;  At 136,element 6,10
 02FC  00B4			      word 90*2;   At 137,element 6,11
 02FE  00E2			      word 113*2;  At 138,element 6,12
 0300  0504			      word 642*2;  At 139,element 6,13
 0302  010C			      word 134*2;  At 140,element 6,14
 0304  0000 E			      word Action60
 0306  5579			      RedRec{0,1,1,$DirectR,377}; S80        S167@142
 0308  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S219@143
 030A  09CD R			      word Keys219;344
 030C  C646			      ErrorRec{1,1,25,6}
 030E  0684			      RedRec{0,0,0,$DirectR,644}; S28        S27@146
 0310  01F6			      word 251*2;  At 147,element 7,0
 0312  0166			      word 179*2;  At 148,element 7,1
 0314  0124			      word 146*2;  At 149,element 7,2
 0316  0508			      word 644*2;  At 150,element 7,3
 0318  004A			      word 37*2;   At 151,element 7,4
 031A  06F2			      RedRec{0,0,0,$DirectR,754}; S41        S40@152
 031C  008A			      word 69*2;   At 153,element 7,6
 031E  0638			      word 796*2;  At 154,element 7,7
 0320  0634			      word 794*2;  At 155,element 7,8
 0322  8180			      ShiftRec{1,0,0,0,0,0,12,0};            S42@156
 0324  028E			      RedRec{0,0,0,$ReferR,654}; S31
 0326  06BE			      RedRec{0,0,0,$GeTest,702}; S43
 0328  0271			      RedRec{0,0,0,$ReferR,625}; S12
 032A  0579			      RedRec{0,0,0,$GeTest,377}; S80
 032C  0E98			      RedRec{0,0,0,$ArithR,664};
 032E  0630			      word 792*2;  At 162,element 7,15
 0330  0648			      RedRec{0,0,0,$DirectR,584}; S65        S44@163
 0332  05EC			      word 758*2;  At 164,element 7,17
 0334  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S218@165
 0336  09BC R			      word Keys218;327
 0338  C64E			      ErrorRec{1,1,25,14}
 033A  0496			      word 587*2;  At 168,element 8,0
 033C  0610			      word 776*2;  At 169,element 8,1
 033E  0496			      word 587*2;  At 170,element 8,2
 0340  0496			      word 587*2;  At 171,element 8,3
 0342  0274			      word 314*2;  At 172,element 8,4
 0344  0308			      word 388*2;  At 173,element 8,5
 0346  0000			      word 0*2;    At 174,element 8,6
 0348  037E			      word 447*2;  At 175,element 8,7
 034A  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S220@176
 034C  09BC R			      word Keys220;327
 034E  C647			      ErrorRec{1,1,25,7}
 0350  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S2@179
 0352  C8C1			      ErrorRec{1,1,35,1}
 0354  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S119@181
 0356  C8C1			      ErrorRec{1,1,35,1}
 0358  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S120@183
 035A  C8C1			      ErrorRec{1,1,35,1}
 035C  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S133@185
 035E  C8C1			      ErrorRec{1,1,35,1}
 0360  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S134@187
 0362  C8C1			      ErrorRec{1,1,35,1}
 0364  04D4			      word 618*2;  At 189,element 9,0
 0366  0612			      word 777*2;  At 190,element 9,1
 0368  02C0			      word 352*2;  At 191,element 9,2
 036A  02C0			      word 352*2;  At 192,element 9,3
 036C  061C			      word 782*2;  At 193,element 9,4
 036E  0642			      RedRec{0,0,0,$DirectR,578}; S46        S47@194
 0370  0000			      word 0*2;    At 195,element 9,6
 0372  068E			      RedRec{0,0,0,$DirectR,654}; S31        S50@196
 0374  03FC			      word 510*2;  At 197,element 9,8
 0376  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S141@198
 0378  C8C1			      ErrorRec{1,1,35,1}
 037A  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S155@200
 037C  C8C1			      ErrorRec{1,1,35,1}
 037E  0000 E			      word Action32
 0380  663B			      RedRec{0,1,2,$DirectR,571}; S38        S207@203
 0382  169A			      RedRec{0,0,1,$DirectR,666}; S187       S246@204
 0384  061C			      word 782*2;  At 205,element 9,16
 0386  986B			      ShiftRec{1,0,0,1,1,0,3,11};            S7@206
 0388  0A15 R			      word Keys7;416
 038A  C4C2			      ErrorRec{1,1,19,2}
 038C  269A			      RedRec{0,0,2,$DirectR,666}; S187       S284@209
 038E  04D4			      word 618*2;  At 210,element 10,0
 0390  0612			      word 777*2;  At 211,element 10,1
 0392  02C0			      word 352*2;  At 212,element 10,2
 0394  02C0			      word 352*2;  At 213,element 10,3
 0396  061C			      word 782*2;  At 214,element 10,4
 0398  065D			      RedRec{0,0,0,$DirectR,605}; S16        S52@215
 039A  0000			      word 0*2;    At 216,element 10,6
 039C  09E6			      RedRec{0,0,0,$SubsetR,486}; S53        S59@217
 039E  0000			      word 0*2;    At 218,element 10,8
 03A0  0000 E			      word Action90
 03A2  84C0			      ShiftRec{1,0,0,0,0,1,$5,0};            S33@220
 03A4  41AF			      RedRec{0,1,0,$ReferR,431}; S73
 03A6  049C			      RedRec{0,0,0,$GeTest,156}; S42
 03A8  013D			      RedRec{0,0,0,$ReferR,317}; S79
 03AA  0605			      RedRec{0,0,0,$GeTest,517}; S144
 03AC  0D0E			      RedRec{0,0,0,$ArithR,270};
 03AE  061C			      word 782*2;  At 226,element 10,16
 03B0  9908			      ShiftRec{1,0,0,1,1,0,8,8};             S23@227
 03B2  0A0E R			      word Keys23;409
 03B4  C4C4			      ErrorRec{1,1,19,4}
 03B6  09A7			      RedRec{0,0,0,$SubsetR,423}; S36        S60@230
 03B8  0496			      word 587*2;  At 231,element 11,0
 03BA  09DE			      RedRec{0,0,0,$SubsetR,478}; S37        S61@232
 03BC  0496			      word 587*2;  At 233,element 11,2
 03BE  0496			      word 587*2;  At 234,element 11,3
 03C0  099E			      RedRec{0,0,0,$SubsetR,414}; S32        S62@235
 03C2  0078			      word 60*2;   At 236,element 11,5
 03C4  97E1			      ShiftRec{1,0,0,1,0,1,$31,1};           S192@237
 03C6  0A42 R			      word Keys192;461
 03C8  1579			      RedRec{0,0,1,$DirectR,377}; S80
 03CA  96E0			      ShiftRec{1,0,0,1,0,1,$16,0};           S156@240
 03CC  0A48 R			      word Keys156;467
 03CE  16C5			      RedRec{0,0,1,$DirectR,709}; S58
 03D0  09EA			      RedRec{0,0,0,$SubsetR,490}; S55        S63@243
 03D2  0000 E			      word Action24
 03D4  6E83			      RedRec{0,1,2,$ArithR,643};             S294@245
 03D6  8868			      ShiftRec{1,0,0,0,1,0,3,8};             S226@246
 03D8  C4C3			      ErrorRec{1,1,19,3}
 03DA  96E0			      ShiftRec{1,0,0,1,0,1,$16,0};           S51@248
 03DC  0A48 R			      word Keys51;467
 03DE  06C5			      RedRec{0,0,0,$DirectR,709}; S58
 03E0  0684			      RedRec{0,0,0,$DirectR,644}; S28        S68@251
 03E2  05FC			      word 766*2;  At 252,element 12,0
 03E4  0612			      word 777*2;  At 253,element 12,1
 03E6  0592			      word 713*2;  At 254,element 12,2
 03E8  9BA4			      ShiftRec{1,0,0,1,1,0,29,4};            S208@255
 03EA  0A48 R			      word Keys208;467
 03EC  C8C1			      ErrorRec{1,1,35,1}
 03EE  0000			      word 0*2;    At 258,element 12,6
 03F0  9AA8			      ShiftRec{1,0,0,1,1,0,21,8};            S102@259
 03F2  0A87 R			      word Keys102;530
 03F4  C64B			      ErrorRec{1,1,25,11}
 03F6  0700			      RedRec{0,0,0,$DirectR,768}; S103
 03F8  0000 E			      word Action70
 03FA  97C2			      ShiftRec{1,0,0,1,0,1,$23,2};           S162@264
 03FC  0A3C R			      word Keys162;455
 03FE  665D			      RedRec{0,1,2,$DirectR,605}; S16
 0400  0000 E			      word Action33
 0402  4651			      RedRec{0,1,0,$DirectR,593}; S89        S93@268
 0404  8949			      ShiftRec{1,0,0,0,1,0,10,9};            S34@269
 0406  C981			      ErrorRec{1,1,38,1}
 0408  065D			      RedRec{0,0,0,$DirectR,605}; S16
 040A  1700			      RedRec{0,0,1,$DirectR,768}; S103       S180@272
 040C  04C8			      word 612*2;  At 273,element 13,0
 040E  038E			      word 455*2;  At 274,element 13,1
 0410  97C7			      ShiftRec{1,0,0,1,0,1,$23,7};           S184@275
 0412  0A3C R			      word Keys184;455
 0414  C983			      ErrorRec{1,1,38,3}
 0416  1498			      RedRec{0,0,1,$DirectR,152}; S40        S87@278
 0418  0000			      word 0*2;    At 279,element 13,6
 041A  10E3			      RedRec{0,0,1,$ReferR,227}; S23         S160@280
 041C  0179			      RedRec{0,0,0,$EqTest,377}; S80
 041E  0196			      RedRec{0,0,0,$ReferR,406}; S25
 0420  0179			      RedRec{0,0,0,$EqTest,377}; S80
 0422  0D1A			      RedRec{0,0,0,$ArithR,282};
 0424  0000 E			      word Action1
 0426  51B3			      RedRec{0,1,1,$ReferR,435}; S8          S194@286
 0428  01F6			      RedRec{0,0,0,$EqTest,502}; S86
 042A  06B9			      RedRec{0,0,0,$DirectR,697}; S35
 042C  0000 E			      word Action383
 042E  51F6			      RedRec{0,1,1,$ReferR,502}; S86         S228@290
 0430  022A			      RedRec{0,0,0,$EqTest,554}; S173
 0432  0C0F			      RedRec{0,0,0,$ArithR,15};
 0434  0706			      RedRec{0,0,0,$DirectR,774}; S108       S104@293
 0436  062C			      word 790*2;  At 294,element 14,0
 0438  0000 E			      word Action381
 043A  51F6			      RedRec{0,1,1,$ReferR,502}; S86         S229@296
 043C  0230			      RedRec{0,0,0,$EqTest,560}; S174
 043E  0C03			      RedRec{0,0,0,$ArithR,3};
 0440  0000 E			      word Action91
 0442  5559			      RedRec{0,1,1,$DirectR,345}; S48        S99@300
 0444  0000 E			      word Action35
 0446  5661			      RedRec{0,1,1,$DirectR,609}; S90        S176@302
 0448  0000 E			      word Action34
 044A  5661			      RedRec{0,1,1,$DirectR,609}; S90        S177@304
 044C  0000 E			      word Action382
 044E  5C2E			      RedRec{0,1,1,$ArithR,46};              S227@306
 0450  0000 E			      word Action91
 0452  555C			      RedRec{0,1,1,$DirectR,348}; S189       S239@308
 0454  0000 E			      word Action70
 0456  9848			      ShiftRec{1,0,0,1,1,0,2,8};             S5@310
 0458  0978 R			      word Keys5;259
 045A  C4C1			      ErrorRec{1,1,19,1}
 045C  465D			      RedRec{0,1,0,$DirectR,605}; S16
 045E  04B5			      RedRec{0,0,0,$DirectR,181}; S119       S118@314
 0460  064A			      word 805*2;  At 315,element 15,0
 0462  0000 E			      word Action44
 0464  8A02			      ShiftRec{1,0,0,0,1,0,16,2};            S79@317
 0466  C8C1			      ErrorRec{1,1,35,1}
 0468  4579			      RedRec{0,1,0,$DirectR,377}; S80
 046A  0000 E			      word Action41
 046C  8B22			      ShiftRec{1,0,0,0,1,0,25,2};            S210@321
 046E  C8C1			      ErrorRec{1,1,35,1}
 0470  4733			      RedRec{0,1,0,$DirectR,819}; S211
 0472  8B22			      ShiftRec{1,0,0,0,1,0,25,2};            S146@324
 0474  C8C1			      ErrorRec{1,1,35,1}
 0476  0A06			      RedRec{0,0,0,$SubsetR,518}; S144
 0478  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S262@327
 047A  09D5 R			      word Keys262;352
 047C  C649			      ErrorRec{1,1,25,9}
 047E  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S265@330
 0480  09D5 R			      word Keys265;352
 0482  C648			      ErrorRec{1,1,25,8}
 0484  89A7			      ShiftRec{1,0,0,0,1,0,13,7};            S45@333
 0486  C8C1			      ErrorRec{1,1,35,1}
 0488  1A42			      RedRec{0,0,1,$SubsetR,578}; S46        S158@335
 048A  067A			      word 829*2;  At 336,element 16,0
 048C  9F07			      ShiftRec{1,0,0,1,1,1,$18,7};           S148@337
 048E  0A53 R			      word Keys148;478
 0490  C481			      ErrorRec{1,1,18,1}
 0492  9F07			      ShiftRec{1,0,0,1,1,1,$18,7};           S248@340
 0494  0A53 R			      word Keys248;478
 0496  C482			      ErrorRec{1,1,18,2}
 0498  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S66@343
 049A  C541			      ErrorRec{1,1,21,1}
 049C  99C7			      ShiftRec{1,0,0,1,1,0,14,7};            S48@345
 049E  0A53 R			      word Keys48;478
 04A0  C481			      ErrorRec{1,1,18,1}
 04A2  99C7			      ShiftRec{1,0,0,1,1,0,14,7};            S189@348
 04A4  0A53 R			      word Keys189;478
 04A6  C482			      ErrorRec{1,1,18,2}
 04A8  25E2			      RedRec{0,0,2,$DirectR,482}; S49        S213@351
 04AA  0710			      RedRec{0,0,0,$DirectR,784}; S128       S124@352
 04AC  0000 E			      word Action25
 04AE  6C1D			      RedRec{0,1,2,$ArithR,29};              S287@354
 04B0  0000 E			      word Action18
 04B2  453D			      RedRec{0,1,0,$DirectR,317}; S79        S82@356
 04B4  02FE			      word 383*2;  At 357,element 17,0
 04B6  0602			      RedRec{0,0,0,$DirectR,514}; S127       S126@358
 04B8  15E2			      RedRec{0,0,1,$DirectR,482}; S49        S149@359
 04BA  04B9			      RedRec{0,0,0,$DirectR,185}; S133       S132@360
 04BC  0000 E			      word Action25
 04BE  5C1D			      RedRec{0,1,1,$ArithR,29};              S249@362
 04C0  9FE2			      ShiftRec{1,0,0,1,1,1,$31,2};           S112@363
 04C2  0942 R			      word Keys112;205
 04C4  C1C1			      ErrorRec{1,1,7,1}
 04C6  126E			      RedRec{0,0,1,$ReferR,622}; S161        S269@366
 04C8  028B			      RedRec{0,0,0,$EqTest,651}; S223
 04CA  0276			      RedRec{0,0,0,$ReferR,630}; S163
 04CC  028B			      RedRec{0,0,0,$EqTest,651}; S223
 04CE  0C23			      RedRec{0,0,0,$ArithR,35};
 04D0  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S22@371
 04D2  C541			      ErrorRec{1,1,21,1}
 04D4  0000 E			      word Action11
 04D6  5648			      RedRec{0,1,1,$DirectR,584}; S65        S70@374
 04D8  8868			      ShiftRec{1,0,0,0,1,0,3,8};             S250@375
 04DA  C4C3			      ErrorRec{1,1,19,3}
 04DC  165D			      RedRec{0,0,1,$DirectR,605}; S16        S80@377
 04DE  126E			      RedRec{0,0,1,$ReferR,622}; S161        S270@378
 04E0  0297			      RedRec{0,0,0,$EqTest,663}; S224
 04E2  0276			      RedRec{0,0,0,$ReferR,630}; S163
 04E4  0297			      RedRec{0,0,0,$EqTest,663}; S224
 04E6  0C09			      RedRec{0,0,0,$ArithR,9};
 04E8  0147			      RedRec{0,0,0,$ReferR,327}; S262        S290@383
 04EA  073E			      RedRec{0,0,0,$GeTest,830}; S289
 04EC  00A5			      RedRec{0,0,0,$ReferR,165}; S218
 04EE  073B			      RedRec{0,0,0,$GeTest,827}; S261
 04F0  0D43			      RedRec{0,0,0,$ArithR,323};
 04F2  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S113@388
 04F4  097F R			      word Keys113;266
 04F6  C643			      ErrorRec{1,1,25,3}
 04F8  04C6			      RedRec{0,0,0,$DirectR,198}; S141       S138@391
 04FA  9FE2			      ShiftRec{1,0,0,1,1,1,$31,2};           S188@392
 04FC  0937 R			      word Keys188;194
 04FE  069A			      RedRec{0,0,0,$DirectR,666}; S187
 0500  0000 E			      word Action60
 0502  6579			      RedRec{0,1,2,$DirectR,377}; S80        S279@396
 0504  9FE2			      ShiftRec{1,0,0,1,1,1,$31,2};           S244@397
 0506  0937 R			      word Keys244;194
 0508  169A			      RedRec{0,0,1,$DirectR,666}; S187
 050A  0000 E			      word Action73
 050C  46ED			      RedRec{0,1,0,$DirectR,749}; S266       S267@401
 050E  0000 E			      word Action28
 0510  80EC			      ShiftRec{1,0,0,0,0,0,7,12};            S15@403
 0512  C502			      ErrorRec{1,1,20,2}
 0514  44D7			      RedRec{0,1,0,$DirectR,215}; S52
 0516  9848			      ShiftRec{1,0,0,1,1,0,2,8};             S25@406
 0518  0978 R			      word Keys25;259
 051A  C4C6			      ErrorRec{1,1,19,6}
 051C  065D			      RedRec{0,0,0,$DirectR,605}; S16
 051E  C942			      ErrorRec{1,1,37,2};                    S139@410
 0520  0000 E			      word Action72
 0522  457A			      RedRec{0,1,0,$DirectR,378}; S270       S271@412
 0524  A528			      ShiftRec{1,0,1,0,0,1,$9,8};            S32@413
 0526  00B9			      RedRec{0,0,0,$ReferR,185}; S133
 0528  02A9			      RedRec{0,0,0,$EqTest,681}; S203
 052A  05DD			      RedRec{0,0,0,$DirectR,477}; S37
 052C  C941			      ErrorRec{1,1,37,1};                    S140@417
 052E  0000 E			      word Action10
 0530  5A48			      RedRec{0,1,1,$SubsetR,584}; S65        S217@419
 0532  1642			      RedRec{0,0,1,$DirectR,578}; S46        S136@420
 0534  058D			      RedRec{0,0,0,$DirectR,397}; S244       S247@421
 0536  8160			      ShiftRec{1,0,0,0,0,0,11,0};            S36@422
 0538  00C6			      RedRec{0,0,0,$ReferR,198}; S141
 053A  02CD			      RedRec{0,0,0,$EqTest,717}; S209
 053C  04DC			      RedRec{0,0,0,$DirectR,220}; S33
 053E  158D			      RedRec{0,0,1,$DirectR,397}; S244       S285@426
 0540  0667			      RedRec{0,0,0,$DirectR,615}; S97        S96@427
 0542  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S39@428
 0544  C541			      ErrorRec{1,1,21,1}
 0546  0000 E			      word Action70
 0548  99E2			      ShiftRec{1,0,0,1,1,0,15,2};            S73@431
 054A  0A3C R			      word Keys73;455
 054C  C8C1			      ErrorRec{1,1,35,1}
 054E  565D			      RedRec{0,1,1,$DirectR,605}; S16
 0550  9881			      ShiftRec{1,0,0,1,1,0,4,1};             S8@435
 0552  09E3 R			      word Keys8;366
 0554  C8C1			      ErrorRec{1,1,35,1}
 0556  06F2			      RedRec{0,0,0,$DirectR,754}; S41
 0558  88C2			      ShiftRec{1,0,0,0,1,0,6,2};             S101@439
 055A  C8C1			      ErrorRec{1,1,35,1}
 055C  0700			      RedRec{0,0,0,$DirectR,768}; S103
 055E  9AC7			      ShiftRec{1,0,0,1,1,0,22,7};            S110@442
 0560  0A3C R			      word Keys110;455
 0562  C8C1			      ErrorRec{1,1,35,1}
 0564  88AD			      ShiftRec{1,0,0,0,1,0,5,13};            S9@445
 0566  C501			      ErrorRec{1,1,20,1}
 0568  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S71@447
 056A  C8C1			      ErrorRec{1,1,35,1}
 056C  8181			      ShiftRec{1,0,0,0,0,0,12,1};            S69@449
 056E  C900			      ErrorRec{1,1,36,0}
 0570  0EA8			      RedRec{0,0,0,$ArithR,680};             S191@451
 0572  04C8			      RedRec{0,0,0,$DirectR,200}; S155       S154@452
 0574  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S116@453
 0576  C8C1			      ErrorRec{1,1,35,1}
 0578  8E4D			      ShiftRec{1,0,0,0,1,1,$28,13};          S94@455
 057A  C501			      ErrorRec{1,1,20,1}
 057C  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S169@457
 057E  C8C1			      ErrorRec{1,1,35,1}
 0580  0000 E			      word Action75
 0582  45AF			      RedRec{0,1,0,$DirectR,431}; S73        S75@460
 0584  8E4D			      ShiftRec{1,0,0,0,1,1,$28,13};          S107@461
 0586  C501			      ErrorRec{1,1,20,1}
 0588  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S170@463
 058A  C8C1			      ErrorRec{1,1,35,1}
 058C  0000 E			      word Action71
 058E  456E			      RedRec{0,1,0,$DirectR,366}; S269       S268@466
 0590  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S13@467
 0592  C8C1			      ErrorRec{1,1,35,1}
 0594  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S91@469
 0596  C8C1			      ErrorRec{1,1,35,1}
 0598  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S92@471
 059A  C8C1			      ErrorRec{1,1,35,1}
 059C  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S168@473
 059E  C8C1			      ErrorRec{1,1,35,1}
 05A0  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S186@475
 05A2  C8C1			      ErrorRec{1,1,35,1}
 05A4  A660			      ShiftRec{1,0,1,0,0,1,$1,0};            S37@477
 05A6  00B7			      RedRec{0,0,0,$ReferR,183}; S120
 05A8  02A1			      RedRec{0,0,0,$EqTest,673}; S196
 05AA  05A6			      RedRec{0,0,0,$DirectR,422}; S36
 05AC  0000 E			      word Action22
 05AE  97E2			      ShiftRec{1,0,0,1,0,1,$31,2};           S49@482
 05B0  0A4D R			      word Keys49;472
 05B2  44C2			      RedRec{0,1,0,$DirectR,194}; S47
 05B4  A480			      ShiftRec{1,0,1,0,0,1,$3,0};            S53@485
 05B6  00BB			      RedRec{0,0,0,$ReferR,187}; S134
 05B8  02B6			      RedRec{0,0,0,$EqTest,694}; S204
 05BA  059D			      RedRec{0,0,0,$DirectR,413}; S32
 05BC  A680			      ShiftRec{1,0,1,0,0,1,$8,0};            S55@489
 05BE  00B5			      RedRec{0,0,0,$ReferR,181}; S119
 05C0  029E			      RedRec{0,0,0,$EqTest,670}; S195
 05C2  05E5			      RedRec{0,0,0,$DirectR,485}; S53
 05C4  9421			      ShiftRec{1,0,0,1,0,1,$12,1};           S57@493
 05C6  0A34 R			      word Keys57;447
 05C8  C651			      ErrorRec{1,1,25,17}
 05CA  065D			      RedRec{0,0,0,$DirectR,605}; S16
 05CC  0000 E			      word Action70
 05CE  97C0			      ShiftRec{1,0,0,1,0,1,$23,0};           S74@498
 05D0  0A3C R			      word Keys74;455
 05D2  565D			      RedRec{0,1,1,$DirectR,605}; S16
 05D4  0000 E			      word Action33
 05D6  9A20			      ShiftRec{1,0,0,1,1,0,17,0};            S86@502
 05D8  0876 R			      word Keys86;1
 05DA  4651			      RedRec{0,1,0,$DirectR,593}; S89
 05DC  9A41			      ShiftRec{1,0,0,1,1,0,18,1};            S88@505
 05DE  09EC R			      word Keys88;375
 05E0  C650			      ErrorRec{1,1,25,16}
 05E2  1498			      RedRec{0,0,1,$DirectR,152}; S40
 05E4  0000 E			      word Action58
 05E6  4313			      RedRec{0,1,0,$ReferR,787}; S130        S123@510
 05E8  0217			      RedRec{0,0,0,$EqTest,535}; S201
 05EA  0611			      RedRec{0,0,0,$DirectR,529}; S131
 05EC  0000 E			      word Action57
 05EE  894A			      ShiftRec{1,0,0,0,1,0,10,10};           S127@514
 05F0  C981			      ErrorRec{1,1,38,1}
 05F2  4713			      RedRec{0,1,0,$DirectR,787}; S130
 05F4  8303			      ShiftRec{1,0,0,0,0,0,24,3};            S144@517
 05F6  0141			      RedRec{0,0,0,$ReferR,321}; S210
 05F8  006F			      RedRec{0,0,0,$EqTest,111}; S212
 05FA  0E6A			      RedRec{0,0,0,$ArithR,618};
 05FC  0000 E			      word Action61
 05FE  4064			      RedRec{0,1,0,$ReferR,100}; S114        S164@522
 0600  01C3			      RedRec{0,0,0,$EqTest,451}; S191
 0602  0C3F			      RedRec{0,0,0,$ArithR,63};
 0604  2579			      RedRec{0,0,2,$DirectR,377}; S80        S288@525
 0606  8949			      ShiftRec{1,0,0,0,1,0,10,9};            S109@526
 0608  C981			      ErrorRec{1,1,38,1}
 060A  165D			      RedRec{0,0,1,$DirectR,605}; S16
 060C  8949			      ShiftRec{1,0,0,0,1,0,10,9};            S131@529
 060E  C981			      ErrorRec{1,1,38,1}
 0610  0C6C			      RedRec{0,0,0,$ArithR,108};
 0612  8949			      ShiftRec{1,0,0,0,1,0,10,9};            S185@532
 0614  C981			      ErrorRec{1,1,38,1}
 0616  265D			      RedRec{0,0,2,$DirectR,605}; S16
 0618  8949			      ShiftRec{1,0,0,0,1,0,10,9};            S201@535
 061A  C981			      ErrorRec{1,1,38,1}
 061C  1C6C			      RedRec{0,0,1,$ArithR,108};
 061E  9EC2			      ShiftRec{1,0,0,1,1,1,$21,2};           S19@538
 0620  0948 R			      word Keys19;211
 0622  C64C			      ErrorRec{1,1,25,12}
 0624  0510			      RedRec{0,0,0,$DirectR,272}; S180       S181@541
 0626  0000 E			      word Action32
 0628  763B			      RedRec{0,1,3,$DirectR,571}; S38        S253@543
 062A  9EC2			      ShiftRec{1,0,0,1,1,1,$21,2};           S111@544
 062C  094F R			      word Keys111;218
 062E  C64D			      ErrorRec{1,1,25,13}
 0630  168E			      RedRec{0,0,1,$DirectR,654}; S31        S117@547
 0632  9B40			      ShiftRec{1,0,0,1,1,0,26,0};            S171@548
 0634  087A R			      word Keys171;5
 0636  0722			      RedRec{0,0,0,$DirectR,802}; S172
 0638  9F20			      ShiftRec{1,0,0,1,1,1,$17,0};           S231@551
 063A  0A7A R			      word Keys231;517
 063C  0734			      RedRec{0,0,0,$DirectR,820}; S232
 063E  9B60			      ShiftRec{1,0,0,1,1,0,27,0};            S173@554
 0640  0A7F R			      word Keys173;522
 0642  0722			      RedRec{0,0,0,$DirectR,802}; S172
 0644  9F60			      ShiftRec{1,0,0,1,1,1,$15,0};           S234@557
 0646  0A83 R			      word Keys234;526
 0648  0734			      RedRec{0,0,0,$DirectR,820}; S232
 064A  9B80			      ShiftRec{1,0,0,1,1,0,28,0};            S174@560
 064C  0A76 R			      word Keys174;513
 064E  0722			      RedRec{0,0,0,$DirectR,802}; S172
 0650  9F40			      ShiftRec{1,0,0,1,1,1,$19,0};           S230@563
 0652  087F R			      word Keys230;10
 0654  0734			      RedRec{0,0,0,$DirectR,820}; S232
 0656  1734			      RedRec{0,0,1,$DirectR,820}; S232       S280@566
 0658  97E0			      ShiftRec{1,0,0,1,0,1,$31,0};           S17@567
 065A  09FA R			      word Keys17;389
 065C  C64F			      ErrorRec{1,1,25,15}
 065E  0000 E			      word Action30
 0660  864E			      ShiftRec{1,0,0,0,0,1,$28,14};          S38@571
 0662  45AC			      RedRec{0,1,0,$DirectR,428}; S39
 0664  0000 E			      word Action51
 0666  450D			      RedRec{0,1,0,$DirectR,269}; S34        S6@574
 0668  9F60			      ShiftRec{1,0,0,1,1,1,$15,0};           S236@575
 066A  0A83 R			      word Keys236;526
 066C  0734			      RedRec{0,0,0,$DirectR,820}; S232
 066E  02DB			      RedRec{0,0,0,$ReferR,731}; S54         S46@578
 0670  04C4			      RedRec{0,0,0,$GeTest,196}; S50
 0672  0ED4			      RedRec{0,0,0,$ArithR,724};
 0674  00C8			      RedRec{0,0,0,$ReferR,200}; S155        S56@581
 0676  02D0			      RedRec{0,0,0,$EqTest,720}; S216
 0678  05E9			      RedRec{0,0,0,$DirectR,489}; S55
 067A  00B3			      RedRec{0,0,0,$ReferR,179}; S2          S65@584
 067C  0645			      RedRec{0,0,0,$GeTest,581}; S56
 067E  0D51			      RedRec{0,0,0,$ArithR,337};
 0680  0196			      RedRec{0,0,0,$ReferR,406}; S25         S72@587
 0682  0179			      RedRec{0,0,0,$EqTest,377}; S80
 0684  0C96			      RedRec{0,0,0,$ArithR,150};
 0686  1648			      RedRec{0,0,1,$DirectR,584}; S65        S159@590
 0688  0000 E			      word Action75
 068A  45F2			      RedRec{0,1,0,$DirectR,498}; S74        S76@592
 068C  9A60			      ShiftRec{1,0,0,1,1,0,19,0};            S89@593
 068E  09EC R			      word Keys89;375
 0690  1498			      RedRec{0,0,1,$DirectR,152}; S40
 0692  2C0E			      RedRec{0,0,2,$ArithR,14};              S256@596
 0694  1667			      RedRec{0,0,1,$DirectR,615}; S97        S179@597
 0696  2498			      RedRec{0,0,2,$DirectR,152}; S40        S175@598
 0698  2720			      RedRec{0,0,2,$DirectR,800}; S152       S259@599
 069A  9F40			      ShiftRec{1,0,0,1,1,1,$19,0};           S233@600
 069C  087F R			      word Keys233;10
 069E  0734			      RedRec{0,0,0,$DirectR,820}; S232
 06A0  1734			      RedRec{0,0,1,$DirectR,820}; S232       S281@603
 06A2  0000 E			      word Action2
 06A4  46B9			      RedRec{0,1,0,$DirectR,697}; S35        S16@605
 06A6  9F20			      ShiftRec{1,0,0,1,1,1,$17,0};           S235@606
 06A8  0A7A R			      word Keys235;517
 06AA  0734			      RedRec{0,0,0,$DirectR,820}; S232
 06AC  01B3			      RedRec{0,0,0,$ReferR,435}; S8          S90@609
 06AE  0116			      RedRec{0,0,0,$EqTest,278}; S87
 06B0  0656			      RedRec{0,0,0,$DirectR,598}; S175
 06B2  0267			      RedRec{0,0,0,$ReferR,615}; S97         S95@612
 06B4  02E6			      RedRec{0,0,0,$EqTest,742}; S98
 06B6  0D29			      RedRec{0,0,0,$ArithR,297};
 06B8  8A8D			      ShiftRec{1,0,0,0,1,0,20,13};           S97@615
 06BA  C501			      ErrorRec{1,1,20,1}
 06BC  0579			      RedRec{0,0,0,$DirectR,377}; S80
 06BE  0202			      RedRec{0,0,0,$ReferR,514}; S127        S125@618
 06C0  0279			      RedRec{0,0,0,$EqTest,633}; S198
 06C2  0566			      RedRec{0,0,0,$DirectR,358}; S126
 06C4  1734			      RedRec{0,0,1,$DirectR,820}; S232       S282@621
 06C6  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S161@622
 06C8  0A1E R			      word Keys161;425
 06CA  C645			      ErrorRec{1,1,25,5}
 06CC  88C2			      ShiftRec{1,0,0,0,1,0,6,2};             S12@625
 06CE  C8C1			      ErrorRec{1,1,35,1}
 06D0  065D			      RedRec{0,0,0,$DirectR,605}; S16
 06D2  8822			      ShiftRec{1,0,0,0,1,0,1,2};             S14@628
 06D4  C8C1			      ErrorRec{1,1,35,1}
 06D6  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S163@630
 06D8  0A1E R			      word Keys163;425
 06DA  C645			      ErrorRec{1,1,25,5}
 06DC  1602			      RedRec{0,0,1,$DirectR,514}; S127       S198@633
 06DE  265D			      RedRec{0,0,2,$DirectR,605}; S16        S183@634
 06E0  0000 E			      word Action26
 06E2  45ED			      RedRec{0,1,0,$DirectR,493}; S57        S20@636
 06E4  1C6C			      RedRec{0,0,1,$ArithR,108};             S202@637
 06E6  0000 E			      word Action70
 06E8  765D			      RedRec{0,1,3,$DirectR,605}; S16        S221@639
 06EA  365D			      RedRec{0,0,3,$DirectR,605}; S16        S238@640
 06EC  0000 E			      word Action52
 06EE  450D			      RedRec{0,1,0,$DirectR,269}; S34        S21@642
 06F0  2C6C			      RedRec{0,0,2,$ArithR,108};             S252@643
 06F2  A468			      ShiftRec{1,0,1,0,0,1,$6,8};            S28@644
 06F4  0648			      RedRec{0,0,0,$DirectR,584}; S65
 06F6  0000 E			      word Action70
 06F8  665D			      RedRec{0,1,2,$DirectR,605}; S16        S225@647
 06FA  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S222@648
 06FC  0A25 R			      word Keys222;432
 06FE  0C11			      RedRec{0,0,0,$ArithR,17};
 0700  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S223@651
 0702  0A67 R			      word Keys223;498
 0704  0C11			      RedRec{0,0,0,$ArithR,17};
 0706  9921			      ShiftRec{1,0,0,1,1,0,9,1};             S31@654
 0708  0883 R			      word Keys31;14
 070A  0D54			      RedRec{0,0,0,$ArithR,340};
 070C  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S274@657
 070E  0A60 R			      word Keys274;491
 0710  073C			      RedRec{0,0,0,$DirectR,828}; S272
 0712  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S276@660
 0714  09B5 R			      word Keys276;320
 0716  073C			      RedRec{0,0,0,$DirectR,828}; S272
 0718  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S224@663
 071A  0A59 R			      word Keys224;484
 071C  0C11			      RedRec{0,0,0,$ArithR,17};
 071E  93A2			      ShiftRec{1,0,0,1,0,0,29,2};            S187@666
 0720  0A48 R			      word Keys187;467
 0722  C1C2			      ErrorRec{1,1,7,2}
 0724  0000 E			      word Action10
 0726  A480			      ShiftRec{1,0,1,0,0,1,$3,0};            S195@670
 0728  54D9			      RedRec{0,1,1,$DirectR,217}; S59
 072A  0000 E			      word Action10
 072C  8160			      ShiftRec{1,0,0,0,0,0,11,0};            S196@673
 072E  54E6			      RedRec{0,1,1,$DirectR,230}; S60
 0730  A6A0			      ShiftRec{1,0,1,0,0,1,$2,0};            S29@675
 0732  0684			      RedRec{0,0,0,$DirectR,644}; S28
 0734  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S275@677
 0736  0A2C R			      word Keys275;439
 0738  073C			      RedRec{0,0,0,$DirectR,828}; S272
 073A  0000 E			      word Action12
 073C  A660			      ShiftRec{1,0,1,0,0,1,$1,0};            S203@681
 073E  54E8			      RedRec{0,1,1,$DirectR,232}; S61
 0740  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S273@683
 0742  0A2C R			      word Keys273;439
 0744  073C			      RedRec{0,0,0,$DirectR,828}; S272
 0746  173C			      RedRec{0,0,1,$DirectR,828}; S272       S292@686
 0748  8420			      ShiftRec{1,0,0,0,0,1,$12,0};           S30@687
 074A  0F37			      RedRec{0,0,0,$ArithR,823};
 074C  9FE0			      ShiftRec{1,0,0,1,1,1,$31,0};           S277@689
 074E  0A60 R			      word Keys277;491
 0750  073C			      RedRec{0,0,0,$DirectR,828}; S272
 0752  173C			      RedRec{0,0,1,$DirectR,828}; S272       S291@692
 0754  0000 E			      word Action10
 0756  A528			      ShiftRec{1,0,1,0,0,1,$9,8};            S204@694
 0758  54EB			      RedRec{0,1,1,$DirectR,235}; S62
 075A  0000 E			      word Action91
 075C  4557			      RedRec{0,1,0,$DirectR,343}; S66        S35@697
 075E  9FE1			      ShiftRec{1,0,0,1,1,1,$31,1};           S278@698
 0760  09B5 R			      word Keys278;320
 0762  073C			      RedRec{0,0,0,$DirectR,828}; S272
 0764  0000 E			      word Action3
 0766  46B9			      RedRec{0,1,0,$DirectR,697}; S35        S43@702
 0768  9925			      ShiftRec{1,0,0,1,1,0,9,5};             S214@703
 076A  0883 R			      word Keys214;14
 076C  C8C1			      ErrorRec{1,1,35,1}
 076E  9926			      ShiftRec{1,0,0,1,1,0,9,6};             S215@706
 0770  0883 R			      word Keys215;14
 0772  C8C1			      ErrorRec{1,1,35,1}
 0774  8400			      ShiftRec{1,0,0,0,0,1,$0,0};            S58@709
 0776  C8C1			      ErrorRec{1,1,35,1}
 0778  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S150@711
 077A  C541			      ErrorRec{1,1,21,1}
 077C  06E7			      RedRec{0,0,0,$DirectR,743}; S200       S199@713
 077E  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S153@714
 0780  C541			      ErrorRec{1,1,21,1}
 0782  0000 E			      word Action10
 0784  84C0			      ShiftRec{1,0,0,0,0,1,$5,0};            S209@717
 0786  56D3			      RedRec{0,1,1,$DirectR,723}; S64
 0788  0000 E			      word Action10
 078A  A680			      ShiftRec{1,0,1,0,0,1,$8,0};            S216@720
 078C  54F3			      RedRec{0,1,1,$DirectR,243}; S63
 078E  0000 E			      word Action90
 0790  48DD			      RedRec{0,1,0,$SubsetR,221}; S33        S64@723
 0792  173C			      RedRec{0,0,1,$DirectR,828}; S272       S293@724
 0794  0000 E			      word Action91
 0796  8650			      ShiftRec{1,0,0,0,0,1,$28,16};          S241@726
 0798  472A			      RedRec{0,1,0,$DirectR,810}; S242
 079A  0311			      RedRec{0,0,0,$ReferR,785}; S129        S251@728
 079C  02C9			      RedRec{0,0,0,$EqTest,713}; S199
 079E  0560			      RedRec{0,0,0,$DirectR,352}; S124
 07A0  9923			      ShiftRec{1,0,0,1,1,0,9,3};             S54@731
 07A2  0883 R			      word Keys54;14
 07A4  C8C1			      ErrorRec{1,1,35,1}
 07A6  06C5			      RedRec{0,0,0,$DirectR,709}; S58
 07A8  0000 E			      word Action24
 07AA  9921			      ShiftRec{1,0,0,1,1,0,9,1};             S286@736
 07AC  0883 R			      word Keys286;14
 07AE  5E83			      RedRec{0,1,1,$ArithR,643};
 = 05C6				     State0 equ 2*739
 07B0  9800			      ShiftRec{1,0,0,1,1,0,0,0};             S0@739
 07B2  0883 R			      word Keys0;14
 07B4  C8C1			      ErrorRec{1,1,35,1}
 07B6  0F2D			      RedRec{0,0,0,$ArithR,813};             S98@742
 07B8  1710			      RedRec{0,0,1,$DirectR,784}; S128       S200@743
 07BA  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S245@744
 07BC  C541			      ErrorRec{1,1,21,1}
 07BE  9924			      ShiftRec{1,0,0,1,1,0,9,4};             S137@746
 07C0  0883 R			      word Keys137;14
 07C2  C8C1			      ErrorRec{1,1,35,1}
 07C4  1276			      RedRec{0,0,1,$ReferR,630}; S163        S266@749
 07C6  0288			      RedRec{0,0,0,$EqTest,648}; S222
 07C8  0C1A			      RedRec{0,0,0,$ArithR,26};
 07CA  85C3			      ShiftRec{1,0,0,0,0,1,$7,3};            S178@752
 07CC  CB81			      ErrorRec{1,1,46,1}
 07CE  8C20			      ShiftRec{1,0,0,0,1,1,$12,0};           S41@754
 07D0  C6C1			      ErrorRec{1,1,27,1}
 07D2  0000 E			      word Action62
 07D4  4EC0			      RedRec{0,1,0,$ArithR,704};             S77@757
 07D6  1706			      RedRec{0,0,1,$DirectR,774}; S108       S182@758
 07D8  0000 E			      word Action36
 07DA  45F9			      RedRec{0,1,0,$DirectR,505}; S88        S83@760
 07DC  0000 E			      word Action37
 07DE  45D5			      RedRec{0,1,0,$DirectR,469}; S91        S84@762
 07E0  0000 E			      word Action37
 07E2  45D7			      RedRec{0,1,0,$DirectR,471}; S92        S85@764
 07E4  0000 E			      word Action29
 07E6  44D7			      RedRec{0,1,0,$DirectR,215}; S52        S100@766
 07E8  0000 E			      word Action80
 07EA  465D			      RedRec{0,1,0,$DirectR,605}; S16        S103@768
 07EC  0000 E			      word Action56
 07EE  4620			      RedRec{0,1,0,$DirectR,544}; S111       S105@770
 07F0  0000 E			      word Action6
 07F2  45BA			      RedRec{0,1,0,$DirectR,442}; S110       S106@772
 07F4  0000 E			      word Action50
 07F6  4F33			      RedRec{0,1,0,$ArithR,819};             S108@774
 07F8  0000 E			      word Action18
 07FA  454D			      RedRec{0,1,0,$DirectR,333}; S45        S115@776
 07FC  864F			      ShiftRec{1,0,0,0,0,1,$28,15};          S121@777
 07FE  C4C7			      ErrorRec{1,1,19,7}
 0800  C381			      ErrorRec{1,1,14,1};                    S205@779
 0802  1579			      RedRec{0,0,1,$DirectR,377}; S80        S193@780
 0804  0000 E			      word Action55
 0806  4711			      RedRec{0,1,0,$DirectR,785}; S129       S122@782
 0808  0000 E			      word Action53
 080A  466A			      RedRec{0,1,0,$DirectR,618}; S125       S128@784
 080C  8AEC			      ShiftRec{1,0,0,0,1,0,23,12};           S129@785
 080E  C982			      ErrorRec{1,1,38,2}
 0810  8CE9			      ShiftRec{1,0,0,0,1,1,$10,9};           S130@787
 0812  0C6C			      RedRec{0,0,0,$ArithR,108};
 0814  0000 E			      word Action31
 0816  45AC			      RedRec{0,1,0,$DirectR,428}; S39        S135@790
 0818  0000 E			      word Action43
 081A  54A3			      RedRec{0,1,1,$DirectR,163}; S44        S142@792
 081C  0000 E			      word Action41
 081E  4544			      RedRec{0,1,0,$DirectR,324}; S146       S143@794
 0820  0000 E			      word Action20
 0822  46C7			      RedRec{0,1,0,$DirectR,711}; S150       S147@796
 0824  0000 E			      word Action21
 0826  46CA			      RedRec{0,1,0,$DirectR,714}; S153       S151@798
 0828  0000 E			      word Action22
 082A  44C2			      RedRec{0,1,0,$DirectR,194}; S47        S152@800
 082C  0000 E			      word Action33
 082E  5651			      RedRec{0,1,1,$DirectR,593}; S89        S172@802
 0830  0000 E			      word Action61
 0832  4A0A			      RedRec{0,1,0,$SubsetR,522}; S164       S190@804
 0834  85C4			      ShiftRec{1,0,0,0,0,1,$7,4};            S197@805
 0836  CB81			      ErrorRec{1,1,46,1}
 0838  0000 E			      word Action91
 083A  4D20			      RedRec{0,1,0,$ArithR,288};             S206@808
 083C  0000 E			      word Action23
 083E  65AC			      RedRec{0,1,2,$DirectR,428}; S39        S242@810
 0840  0000 E			      word Action91
 0842  46E8			      RedRec{0,1,0,$DirectR,744}; S245       S243@812
 0844  0000 E			      word Action74
 0846  454A			      RedRec{0,1,0,$DirectR,330}; S265       S260@814
 0848  8651			      ShiftRec{1,0,0,0,0,1,$28,17};          S263@815
 084A  CD42			      ErrorRec{1,1,53,2}
 084C  8651			      ShiftRec{1,0,0,0,0,1,$28,17};          S264@817
 084E  CD41			      ErrorRec{1,1,53,1}
 0850  0A06			      RedRec{0,0,0,$SubsetR,518}; S144       S211@819
 0852  1722			      RedRec{0,0,1,$DirectR,802}; S172       S232@820
 0854  1A64			      RedRec{0,0,1,$SubsetR,612}; S95        S237@821
 0856  C382			      ErrorRec{1,1,14,2};                    S240@822
 0858  C383			      ErrorRec{1,1,14,3};                    S254@823
 085A  C285			      ErrorRec{1,1,10,5};                    S255@824
 085C  C384			      ErrorRec{1,1,14,4};                    S257@825
 085E  C286			      ErrorRec{1,1,10,6};                    S258@826
 0860  0CEC			      RedRec{0,0,0,$ArithR,236};             S261@827
 0862  1C11			      RedRec{0,0,1,$ArithR,17};              S272@828
 0864  C284			      ErrorRec{1,1,10,4};                    S283@829
 0866  1CEC			      RedRec{0,0,1,$ArithR,236};             S289@830

				     ; Avoid first offset in keyword table being zero. Not edited.
 0868				     $DoKeys:
 0868  48 05 55 4E 54 49 4C	      db $UNTIL-KeysBase,5,"UNTIL"
 086F  4C 05 57 48 49 4C 45	      db $WHILE-KeysBase,5,"WHILE"
 0876				     Keys86:;1
 0876 44 02 42 59		     Keys char $BY-KeysBase,2,"BY"
 087A				     Keys171:;5
 087A  3C 03 46 4F 52		      db $FOR-KeysBase,3,"FOR"
 087F				     Keys230:;10
 087F				     Keys233:;10
 087F  40 12 54 4F		      db $TO-KeysBase,18,"TO"
 0883				     Keys215:;14
 0883				     Keys214:;14
 0883				     Keys137:;14
 0883				     Keys54:;14
 0883				     Keys0:;14
 0883				     Keys286:;14
 0883				     Keys31:;14
 0883  64 A7 41 44 44 52 45 53	      db $ADDRESS-KeysBase,167,"ADDRESS",$ARG-KeysBase,3,"ARG"
	      53 60 03 41 52
	      47
 0891  6C E4 43 41 4C 4C 70 42	      db $CALL-KeysBase,228,"CALL",$DO-KeysBase,66,"DO"
	      44 4F
 089B  90 04 44 52 4F 50 74 84	      db $DROP-KeysBase,4,"DROP",$ELSE-KeysBase,132,"ELSE"
	      45 4C 53 45
 08A7  34 63 45 4E 44 80 04 45	      db $END-KeysBase,99,"END",$EXIT-KeysBase,4,"EXIT"
	      58 49 54
 08B2  AC 22 49 46 7C 09 49 4E	      db $IF-KeysBase,34,"IF",$INTERPRET-KeysBase,9,"INTERPRET"
	      54 45 52 50 52
	      45 54
 08C1  8D 67 49 54 45 52 41 54	      db $ITERATE-KeysBase,103,"ITERATE",$LEAVE-KeysBase,101,"LEAVE"
	      45 8C 65 4C 45
	      41 56 45
 08D1  78 03 4E 4F 50 B8 07 4E	      db $NOP-KeysBase,3,"NOP",$NUMERIC-KeysBase,7,"NUMERIC"
	      55 4D 45 52 49
	      43
 08DF  7D 07 4F 50 54 49 4F 4E	      db $OPTIONS-KeysBase,7,"OPTIONS",$TRACE-KeysBase,197,"TRACE"
	      53 88 C5 54 52
	      41 43 45
 08EF  D0 05 50 41 52 53 45 D4	      db $PARSE-KeysBase,5,"PARSE",$PROCEDURE-KeysBase,9,"PROCEDURE"
	      09 50 52 4F 43
	      45 44 55 52 45
 0901  58 04 50 55 4C 4C 81 04	      db $PULL-KeysBase,4,"PULL",$PUSH-KeysBase,4,"PUSH"
	      50 55 53 48
 090D  82 05 51 55 45 55 45 83	      db $QUEUE-KeysBase,5,"QUEUE",$RETURN-KeysBase,6,"RETURN"
	      06 52 45 54 55
	      52 4E
 091C  84 03 53 41 59 D8 06 53	      db $SAY-KeysBase,3,"SAY",$SELECT-KeysBase,6,"SELECT"
	      45 4C 45 43 54
 0929  98 C6 53 49 47 4E 41 4C	      db $SIGNAL-KeysBase,198,"SIGNAL",$THEN-KeysBase,132,"THEN"
	      38 84 54 48 45
	      4E
 0937				     Keys188:;194
 0937				     Keys244:;194
 0937  C8 89 4F 54 48 45 52 57	      db $OTHERWISE-KeysBase,137,"OTHERWISE"
	      49 53 45
 0942				     Keys112:;205
 0942  DC 34 57 48 45 4E	      db $WHEN-KeysBase,52,"WHEN"
 0948				     Keys19:;211
 0948  A8 05 55 50 50 45 52	      db $UPPER-KeysBase,5,"UPPER"
 094F				     Keys111:;218
 094F  60 03 41 52 47 54 06 4C	      db $ARG-KeysBase,3,"ARG",$LINEIN-KeysBase,6,"LINEIN"
	      49 4E 45 49 4E
 095C  58 04 50 55 4C 4C 55 06	      db $PULL-KeysBase,4,"PULL",$SOURCE-KeysBase,6,"SOURCE"
	      53 4F 55 52 43
	      45
 096A  56 07 56 45 52 53 49 4F	      db $VERSION-KeysBase,7,"VERSION",$VAR-KeysBase,3,"VAR"
	      4E 5C 03 56 41
	      52
 0978				     Keys5:;259
 0978				     Keys25:;259
 0978  30 15 56 41 4C 55 45	      db $VALUE-KeysBase,21,"VALUE"
 097F				     Keys114:;266
 097F				     Keys113:;266
 097F  9D 0A 4C 4F 53 54 44 49	      db $LOSTDIGITS-KeysBase,10,"LOSTDIGITS",$SYNTAX-KeysBase,6,"SYNTAX"
	      47 49 54 53 9C
	      06 53 59 4E 54
	      41 58
 0993  9E 07 4E 4F 56 41 4C 55	      db $NOVALUE-KeysBase,7,"NOVALUE"
	      45
 099C				     Keys78:;295
 099C				     Keys81:;295
 099C  A0 08 4E 4F 54 52 45 41	      db $NOTREADY-KeysBase,8,"NOTREADY",$FAILURE-KeysBase,7,"FAILURE"
	      44 59 A1 07 46
	      41 49 4C 55 52
	      45
 09AF  A2 04 48 41 4C 54	      db $HALT-KeysBase,4,"HALT"
 09B5				     Keys276:;320
 09B5				     Keys278:;320
 09B5  A4 15 45 52 52 4F 52	      db $ERROR-KeysBase,21,"ERROR"
 09BC				     Keys220:;327
 09BC				     Keys218:;327
 09BC  68 06 41 50 50 45 4E 44	      db $APPEND-KeysBase,6,"APPEND",$REPLACE-KeysBase,7,"REPLACE"
	      E0 07 52 45 50
	      4C 41 43 45
 09CD				     Keys219:;344
 09CD  EC 06 4E 4F 52 4D 41 4C	      db $NORMAL-KeysBase,6,"NORMAL"
 09D5				     Keys262:;352
 09D5				     Keys265:;352
 09D5  E4 04 53 54 45 4D E8 16	      db $STEM-KeysBase,4,"STEM",$STREAM-KeysBase,22,"STREAM"
	      53 54 52 45 41
	      4D
 09E3				     Keys8:;366
 09E3  F0 07 46 4F 52 45 56 45	      db $FOREVER-KeysBase,7,"FOREVER"
	      52
 09EC				     Keys88:;375
 09EC				     Keys89:;375
 09EC				     $CondKeys:
 09EC  48 05 55 4E 54 49 4C 4C	      db $UNTIL-KeysBase,5,"UNTIL",$WHILE-KeysBase,21,"WHILE"
	      15 57 48 49 4C
	      45
 09FA				     Keys17:;389
 09FA  BC 06 44 49 47 49 54 53	      db $DIGITS-KeysBase,6,"DIGITS",$FORM-KeysBase,196,"FORM"
	      C0 C4 46 4F 52
	      4D
 0A08  BD 14 46 55 5A 5A	      db $FUZZ-KeysBase,20,"FUZZ"
 0A0E				     Keys23:;409
 0A0E  30 05 56 41 4C 55 45	      db $VALUE-KeysBase,5,"VALUE"
 0A15				     Keys7:;416
 0A15  F4 03 4F 46 46 F8 12 4F	      db $OFF-KeysBase,3,"OFF",$ON-KeysBase,18,"ON"
	      4E
 0A1E				     Keys163:;425
 0A1E				     Keys161:;425
 0A1E  A4 05 45 52 52 4F 52	      db $ERROR-KeysBase,5,"ERROR"
 0A25				     Keys222:;432
 0A25  B0 05 49 4E 50 55 54	      db $INPUT-KeysBase,5,"INPUT"
 0A2C				     Keys273:;439
 0A2C				     Keys275:;439
 0A2C  CC 16 4F 55 54 50 55 54	      db $OUTPUT-KeysBase,22,"OUTPUT"
 0A34				     Keys57:;447
 0A34  94 16 45 58 50 4F 53 45	      db $EXPOSE-KeysBase,22,"EXPOSE"
 0A3C				     Keys184:;455
 0A3C				     Keys162:;455
 0A3C				     Keys110:;455
 0A3C				     Keys74:;455
 0A3C				     Keys73:;455
 0A3C				     $WithKey:
 0A3C  50 74 57 49 54 48	      db $WITH-KeysBase,116,"WITH"
 0A42				     Keys192:;461
 0A42				     Keys165:;461
 0A42  B4 F4 4E 41 4D 45	      db $NAME-KeysBase,244,"NAME"
 0A48				     Keys208:;467
 0A48				     Keys187:;467
 0A48				     Keys156:;467
 0A48				     Keys51:;467
 0A48  34 73 45 4E 44		      db $END-KeysBase,115,"END"
 0A4D				     Keys49:;472
 0A4D  74 94 45 4C 53 45	      db $ELSE-KeysBase,148,"ELSE"
 0A53				     Keys248:;478
 0A53				     Keys189:;478
 0A53				     Keys148:;478
 0A53				     Keys48:;478
 0A53				     $ThenKey:
 0A53  38 94 54 48 45 4E	      db $THEN-KeysBase,148,"THEN"
 0A59				     Keys224:;484
 0A59  A4 05 45 52 52 4F 52	      db $ERROR-KeysBase,5,"ERROR"
 0A60				     Keys274:;491
 0A60				     Keys277:;491
 0A60  B0 15 49 4E 50 55 54	      db $INPUT-KeysBase,21,"INPUT"
 0A67				     Keys223:;498
 0A67  A4 05 45 52 52 4F 52 CC	      db $ERROR-KeysBase,5,"ERROR",$OUTPUT-KeysBase,22,"OUTPUT"
	      16 4F 55 54 50
	      55 54
 0A76				     Keys174:;513
 0A76  44 02 42 59		      db $BY-KeysBase,2,"BY"
 0A7A				     Keys231:;517
 0A7A				     Keys235:;517
 0A7A  3C 13 46 4F 52		      db $FOR-KeysBase,19,"FOR"
 0A7F				     Keys173:;522
 0A7F  40 02 54 4F		      db $TO-KeysBase,2,"TO"
 0A83				     Keys234:;526
 0A83				     Keys236:;526
 0A83  44 12 42 59		      db $BY-KeysBase,18,"BY"
 0A87				     Keys102:;530
 0A87  C4 0B 45 4E 47 49 4E 45	      db $ENGINEERING-KeysBase,11,"ENGINEERING"
	      45 52 49 4E 47
 0A94  C5 0A 53 43 49 45 4E 54	      db $SCIENTIFIC-KeysBase,10,"SCIENTIFIC",$VALUE-KeysBase,21,"VALUE",0,16
	      49 46 49 43 30
	      15 56 41 4C 55
	      45 00 10
				     endif

 0AA9				     Compiling:
 0AA9   1   89 66 2C		      mov Z.ParseResetSp,sp; Allows tidying of the parser stack when syntax errors.
				     ; Z.Scanp indicates the subject source.
				     ; Z.Synch indicates the synch point. Zero if making code.
				     ; Z.Cursor indicates offset to start on code.
				      move Z.Base0,Z.Stack
 0AAC   1   8B 46 06		  1      mov ax,Z.Stack
 0AAF   1   89 46 54		  1      mov Z.Base0,ax
 0AB2   3p  8E 6E 4A		      mov gs,Z.Code
				     ; Initialize compiler flags.
				      z Dptr Z.Middles; does z Z.Clause
 0AB5   1   66| 89 6E 0A	  1             mov Dptr Z.Middles,ebp
				      z Dptr Z.KWMiddle; does z Z.KWFound
 0AB9   1   66| 89 6E 10	  1             mov Dptr Z.KWMiddle,ebp
				      z Z.LastTarget
 0ABD   1   89 AE 0144		  1           mov Z.LastTarget,bp
				     ; In the Interpret case the source is already in Z.Serial, at Z.Scanp.
 0AC1   2   39 AE 00E1		      cmp Z.Scanp,ZeroBp
 0AC5  3,1  75 29		      jne @F
				     ; All-of-file case.
 0AC7   1   C7 86 010F 0001	      mov Z.Lines,1
				      z Z.TraceEnds
 0ACD   1   66| 89 AE 00BE	  1             mov Z.TraceEnds,ebp
				      z Z.TraceEndsColumn
 0AD2   1   89 AE 00C4		  1           mov Z.TraceEndsColumn,bp
				      z Z.TraceAlign
 0AD6   1   66| 89 AE 00B6	  1             mov Z.TraceAlign,ebp
				      z Z.Relative
 0ADB   1   66| 89 AE 00C9	  1             mov Z.Relative,ebp
				     ; Source will be read using the Serial buffer.
 0AE0   1   BE 01AB		      mov ScanSi,Zshape.Serial
 0AE3   1   89 B6 00E1		      mov Z.Scanp,ScanSi
 0AE7   1   89 B6 008B		      mov Z.Insert.TokPos,ScanSi
 0AEB   1   B0 04		      mov al,$SerialSource
 0AED   3   E8 0000 E		      call Serialize
 0AF0				     @@:
				     ; Prepare to read tables, record symbols.
				      mv ds,cs
 0AF0   3   0E			  1   push cs
 0AF1   3p  1F			  1   pop ds
 0AF2   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
				      z ParseDx
 0AF5   1   8B D5		  1           mov ParseDx,bp
 0AF7   1   55			      push ZeroBp; Marker on parse stack
				      On Z.Program,FirstBetween
 0AF8   3   80 4E 03 10		  1          or  Bptr(Z.Program+1), high ??0000
				      Off Z.Program,EndSource
 0AFC   3   80 66 03 F7		  1          and Bptr(Z.Program+1), high not ??0001
 0B00   1   BB 05C6		      mov StateBx,State0
				     ; After here to Compiled or Raise. (If latter, msg maybe)
				     ; The parser method is explained elsehwere. (Aoe method)
				     ; The group number comes from the listing output of the table generator.
 0B03   1+  8D B7 01EA R	     Cycle:lea StateSi,StateOrig[StateBx]
 0B07   1   8B FB		     mov StateDi,StateBx
 0B09   1   8B 04		     mov ax,[StateSi]
				     ; As long as no chance of a shift, keep recognising. (Reducing)
				      Assert HasShift eq 15
 0B0B   1   03 C0		      add ax,ax; S^...
 0B0D  3,1  72 73		      jc HasShiftL
				     ; Do the reduction that is at StateSi, maybe partway through state data.
				     ; Test for associated action.
 0B0F				     Reduction:Qry Wptr[StateSi],HasAction
 0B0F   2   F6 44 01 40		  1          test Bptr(Wptr[StateSi]+1), high ??0002
 0B13  3,1  74 14		     jz NoAction
 0B15   1   8B C4		      mov ax,sp
 0B17   1   52			      push ParseDx
 0B18   1   56			      push StateSi
 0B19   1   8B F0		      mov ParseSi,ax
 0B1B				     Actioning:; Just a debugging label.
 0B1B   1   2E: 8B 9D 01E8 R	      mov bx,Wptr(StateOrig-2)[StateDi]
 0B20   1   8B 7E 06		      mov StackDi,Z.Stack
 0B23   5p  FF D3		      call bx
 0B25   1   5E			      pop StateSi
 0B26   1   5A			      pop ParseDx
				      mv ds,cs
 0B27   3   0E			  1   push cs
 0B28   3p  1F			  1   pop ds
 0B29				     NoAction:; Prune stack.
 0B29   1   8B 04		      mov ax,[StateSi]
 0B2B   2   C1 E8 0C		      shr ax,PruneCt
 0B2E   1   24 03		      and al,3
 0B30   1   B4 10		      mov ah,$StrideS
 0B32  13+  F6 E4		      mul ah
 0B34   1   03 E0		      add sp,ax
				     ; Here for each test, deciding where to reduce to, with si as cursor on tests.
				     ; Setup StateBx as the state given in this word.
 0B36   1   8B 1C		     CycleTest:mov StateBx,[StateSi]
 0B38   1   8A E7		     mov RtypeAh,bh
 0B3A   1   81 E3 03FF		      and StateBx,mask Rstate
 0B3E   1   03 DB		      add StateBx,StateBx
 0B40   1   80 E4 0C		      and RtypeAh,high mask Rtype
 0B43  3,1  75 20		      jnz NotRefer
				     ; Rtype $ReferR says this is not a one-word reduction. The first word has
				     ; to be checked against the stack to see if the second word applies.
 0B45   1   58			      pop ax
 0B46   1   50			      push ax; Reference state
 0B47   1   46			      inc StateSi
 0B48   1   46			      inc StateSi
 0B49   2   F6 44 01 0C		      test Bptr[StateSi+1],high mask Rtype; Rtype in second word.
 0B4D  3,1  74 0E		      jz EqTest
				     ; GeTest. Reduce to second word only if reference >= to criteria.
 0B4F   1   3B C3		      cmp ax,StateBx
 0B51  3,1  7C 0E		      jl NextTest
 0B53				     ReferMatch:
 0B53   1   8B 1C		      mov StateBx,[StateSi]
 0B55   1   81 E3 03FF		      and StateBx,mask Rstate
 0B59   1   03 DB		      add StateBx,StateBx
 0B5B   3   EB A6		      jmp Cycle
				     ; EqTest. Reduce to second word only if reference == to criteria.
 0B5D   1   3B C3		     EqTest:cmp ax,StateBx
 0B5F  3,1  74 F2		     je ReferMatch
 0B61   1   46			     NextTest:inc StateSi
 0B62   1   46			     inc StateSi
 0B63   3   EB D1		     jmp CycleTest
				     ; The rest of the reductions are one word only types.
 0B65  3,1  7A 0B		     NotRefer:jpe Arith
 0B67   1   80 FC 08		     cmp RtypeAh,high ($SubsetR shl Rtype)
 0B6A  3,1  75 97		      jnz Cycle; $DirectR just contains the new state.
				     ; $SubsetR is a space saver. The reduction code is shared with another state.
 0B6C   1+  8D B7 01EA R	      lea StateSi,StateOrig[StateBx]
 0B70  3,1  74 C4		      jz CycleTest
 0B72				     Arith:; Add to get new state, with wrap-around.
 0B72   1   58			      pop ax
 0B73   1   50			      push ax; Reference state
 0B74   1   03 D8		      add StateBx,ax
 0B76   1   81 FB 067E		      cmp StateBx,$Needed
 0B7A  3,1  7C 87		      jl Cycle
 0B7C   1   81 EB 067E		      sub StateBx,$Needed
 0B80   3   EB 81		      jmp Cycle
				     ; Deal here with word that describes shift/error part of AOE algorithm.
 0B82				     HasShiftL:; Leftmost bit of ax now indicates error alone.
				      Assert ErrorAlone eq 14
 0B82   1   03 C0		      add ax,ax; 1E^...
 0B84  3,1  73 0A		      jnc @F
 0B86				     IssueError:; Issue error message.
				     ; Ax has been moved left 2 bits in detecting this case.  Now have 8 & 6 bits
				     ; for the Major and Minor error numbers.
				     ; StateSi used to pass position of keywords message insert.
 0B86   1   89 B6 0080		      mov Z.Insert.KeysList,StateSi
 0B8A   2   C0 E8 02		      shr al,2
 0B8D   3   E9 0000 E		      jmp Raise
				     ; We need to know where abuttal is an implied operator.
 0B90				     @@:Assert CatFlag eq 13
				     Off Z.Middles,AbutOK
 0B90   3   80 66 0B EF		  1          and Bptr(Z.Middles+1), high not ??0003
 0B94   1   03 C0		     add ax,ax; 1EC^...
 0B96  3,1  73 04		     jnc @F
				      On Z.Middles,AbutOK
 0B98   3   80 4E 0B 10		  1          or  Bptr(Z.Middles+1), high ??0004
				     ; Cannot do more until we know what the next token is.
 0B9C				     @@:TestReg ParseDx
 0B9C   1   85 D2		  1         test ParseDx,ParseDx
 0B9E  3,1  75 3F		     jnz ParseKl
 0BA0   1   50			     push ax
				     ; Record for stacking later.
 0BA1   1   8B 86 0107		      mov ax,Z.TokNow
 0BA5   1   89 86 0109		      mov Z.TokWas,ax
 0BA9   1   8B 9E 008B		      mov bx,Z.Insert.TokPos
 0BAD   1   4B			      dec bx
 0BAE  3,1  78 0C		      js @F
 0BB0   1   66| 36: 8B 17	      mov edx,ss:Dptr[bx]
 0BB4   1   8A 96 008D		      mov dl,Bptr Z.Insert.TokLen
 0BB8   1   66| 89 56 74	      mov Z.InsOperator,edx
 0BBC   1   56			     @@:push si
 0BBD   1   57			      push di
 0BBE   1   8B 7E 06		      mov StackDi,Z.Stack
 0BC1   3   E8 0000 E		      call NextToken
 0BC4   1   5F			      pop di
 0BC5   1   5E			      pop si
				      mv ds,cs
 0BC6   3   0E			  1   push cs
 0BC7   3p  1F			  1   pop ds
 0BC8   2   C1 E8 08		      shr ax,8
 0BCB   1   89 86 0107		      mov Z.TokNow,ax
				     ; Use TokNow as index to TokData
 0BCF   2   C1 E8 02		      shr ax,GrpNdx
 0BD2   1   03 C0		      add ax,ax
				      xax bx
 0BD4   3   93			  1     xchg ax,bx
 0BD5   1   2E: 8B 97 0000 R	      mov ParseDx,TokData[bx]
				     ; ParseDx may change later if token is found to be an acceptable keyword.
 0BDA   1   89 96 010B		      mov Z.TokData,ParseDx
 0BDE   1   58			      pop ax
 0BDF				     ParseKl:Assert HasKeys eq 12
 0BDF   1   03 C0		      add ax,ax; 1ECK^...
 0BE1  3,1  73 2D		      jnc @F
				     ; State allows keywords.
 0BE3   1   46			      inc StateSi
 0BE4   1   46			      inc StateSi
 0BE5   2   83 BE 0107 48	      cmp Z.TokNow,$VAR_SYMBOL
 0BEA  3,1  75 24		      jne @F
				      Qry Z.Middles,ModEquals
 0BEC   2   F6 46 0B 04		  1          test Bptr(Z.Middles+1), high ??0005
 0BF0  3,1  75 1E		      jnz @F
 0BF2   1   8B 0C		      mov KeyListCx,[StateSi]
 0BF4   3   E8 00D8		      call QueryKey; Which will set carry (and set bx) if acceptable keyword.
 0BF7  3,1  73 17		      jnc @F
				     ; Set token data to the keyword values.
 0BF9   1   89 9E 0107		      mov Z.TokNow,bx; Relevant when token is END
 0BFD   2   C1 EB 02		      shr bx,GrpNdx
 0C00   1   03 DB		      add bx,bx
 0C02   1   2E: 8B 97 0000 R	      mov ParseDx,TokData[bx]
 0C07   1   89 96 010B		      mov Z.TokData,ParseDx
 0C0B   2   C1 E0 02		      shl ax,2; Reference & Direct bits not tested.
 0C0E   3   EB 3E		      jmp Accept
				     ; Is this token one dealt with in this State?
				     ; Bit after Reference bit indicates 'Direct' test.
 0C10   2   C1 E0 02		     @@:shl ax,2; 10CKRD^Indexb...
 0C13  3,1  73 1D		     jnc BitAccept
				     ; We need to line up Indexb with main group number, without disturbing ax.
				     ; Keywords don't come this way, except those detected by middle, so we
				     ; can be sure TokNow is low range.
 = 001F				     $31 equ 31; Used when no non-keyword is acceptable.
				     ; Isolate what the acceptable token needs to be.
 0C15   1   8A AE 0107		      mov TokNowCh,Bptr Z.TokNow
 0C19   3   D0 E5		      shl TokNowCh,1
				     ; TokNow doubled means 3 bits unwanted at right.
 0C1B   1   32 EC		      xor TokNowCh,ah
 0C1D   1   80 E5 F8		      and ch,0F8h; Discount ID (doubled) within group value.
 0C20  3,1  74 2C		      jz Accept
				     ; Must now reduce or is in error. (If both use error; reduction by mock shift)
 0C22   1   46			     NonAccept:inc StateSi
 0C23   1   46			     inc StateSi
 0C24   2   F6 44 01 80		      test Bptr[StateSi+1],high mask HasShift
 0C28  3,1  74 5D		      jz JmpReduction
 0C2A   1   8B 04		      mov ax,[StateSi]
 0C2C   2   C1 E0 02		      shl ax,2
 0C2F   3   E9 FF54		      jmp IssueError
				     ; Take relevant five bit index from state data.
				     ; 10CKR0^Indexb...
 0C32   1   8B C8		     BitAccept:mov cx,ax
 0C34   2   C1 E9 0B		     shr cx,11; Indexb
				     ; Take relevant bit index from token data.
 0C37   1   8B DA		      mov bx,ParseDx
 0C39   1   80 E7 7C		      and bh,high mask NdxbT
 0C3C  3,1  74 10		      jz Accept
 0C3E   2   C1 EB 08		      shr bx,(width Aim)-2; AcceptBits element is 4 bytes.
				     ; One would hope the bt would wrap the ecx value around at 32 but it doesn't.
 0C41   3   66| 0F B7 C9	      movzx ecx,cx
 0C45   8   66| 2E: 0F A3 8F	      bt AcceptBits[bx-4],ecx
	      018E R
 0C4C  3,1  73 D4		      jnc NonAccept
				     ; We are going to do a shift. (Or explicit reduce). Deduce which state to go to.
				     ; Take a field from the TokData
 0C4E   1   8B DA		     Accept:mov bx,ParseDx
 0C50   1   80 E7 03		     and bh,high mask Aim
				     ; If this is a state number, it is the one to go to.
 0C53   1   03 DB		      add StateBx,bx
 0C55   1   81 FB 067E		      cmp StateBx,$Needed
 0C59  3,1  7C 14		      jl HaveTarget
 0C5B   1   81 EB 067E		      sub StateBx,$Needed; It is an array index, now doubled.
				     ; Take relevant bit Index from state data.
 0C5F   2   C1 E8 06		      shr ax,6; Cancels the add ax,ax shifts we made for flag testing.
 0C62   1   24 1F		      and al,mask Index
 0C64   1   B4 2A		      mov ah,2*TokensDim
 0C66  13+  F6 E4		      mul ah; Multiply by suitable stride
 0C68   1   03 D8		      add bx,ax; Add in token index.
 0C6A   1   2E: 8B 9F 01EA R	      mov StateBx,StateOrig[bx]; Pick up target.
				     ; There is a special case where the target is 0.  This means that it is
				     ; not really a shift, but a reduce of the sort that happens on particular
				     ; tokens rather than by reason of non-shift.
				     ; This mechanism is also used to ensure keyword END is looked for before
				     ; a shift on $VAR_SYMBOL.
 0C6F				     HaveTarget:TestReg StateBx
 0C6F   1   85 DB		  1         test StateBx,StateBx
 0C71  3,1  75 17		     jnz RealShift
				     ; If Eos has proved acceptable, maybe we are done.
				      Assert $Eos eq 0
 0C73   2   39 AE 0105		      cmp Z.TokNum,ZeroBp
 0C77  3,1  75 04		      jnz @F
				      On Z.Program,EndSource
 0C79   3   80 4E 03 08		  1          or  Bptr(Z.Program+1), high ??0006
				     ; Advance over current word, and error number if necessary.
 0C7D   1   46			     @@:inc StateSi
 0C7E   1   46			     inc StateSi
 0C7F   2   F6 44 01 80		      test Bptr[StateSi+1],high mask HasShift
 0C83  3,1  74 02		      jz JmpReduction
 0C85   1   46			      inc StateSi
 0C86   1   46			      inc StateSi
 0C87   3   E9 FE85		     JmpReduction:jmp Reduction
				     ; Moving from StateDi to StateBx
				     ; If this token still says $VAR_SYMBOL, it can be looked up. (Was
				     ; delayed in case it was a keyword.)
				     ; The parser doesn't care what it is shifting, but we choose to detect
				     ; things for Lookup now.
 0C8A   1   8A A6 0107		     RealShift:mov TokNumAh,Bptr Z.TokNow
				     ; End-of-source marker is the last thing we shift.
				      Qry Z.Program,EndSource
 0C8E   2   F6 46 03 08		  1          test Bptr(Z.Program+1), high ??0007
 0C92  3,1  0F 85 0000 E	      jnz Terminate
				     ; Some things will not be operands.
 0C96   1   80 FC 3C		      cmp TokNumAh,$STRING
 0C99  3,1  72 11		      jb NotOperand
 0C9B   1   80 FC 48		      cmp TokNumAh,$VAR_SYMBOL
 0C9E  3,1  77 0C		      ja NotOperand
 0CA0   1   57			      push StateDi
 0CA1   1   53			      push StateBx
 0CA2   1   8B 7E 06		      mov StackDi,Z.Stack
 0CA5   3   E8 0000 E		      call Action0
 0CA8   1   5B			      pop StateBx
 0CA9   1   5F			      pop StateDi
				      mv ds,cs
 0CAA   3   0E			  1   push cs
 0CAB   3p  1F			  1   pop ds
 0CAC				     NotOperand:z ParseDx; Indicates ready for another token.
 0CAC   1   8B D5		  1           mov ParseDx,bp
				     ; Reference state goes on AOE stack which is the normal stack.
				      Qry Wptr StateOrig[StateDi],Reference
 0CAE   2   2E: F6 85 01EB R	  1          test Bptr(Wptr StateOrig[StateDi]+1), high ??0008
	      08
 0CB4  3,1  0F 84 FE4B		      jz Cycle
 0CB8   3   E8 0000 E		      call StackSafe
				     ; The parser just needs StateDi pushed; other things useful at actions.
				     ; See Sshape. These pushes are not popped - sp is altered at prune.
				     ; It is annoying, but some messages have the <operator> as insert and since
				     ; the distinction between (say) "<>" and "><" and "\=" is otherwise lost,
				     ; we must stack it away now.
				      Assert $StrideS eq 4+4+2+2+2+2
 0CBB   1   66| 55		      pushd ebp
 0CBD   4   66| FF 76 74	      pushd Z.InsOperator
 0CC1   4   FF B6 0109		      push Z.TokWas
 0CC5   4   FF 76 08		      push Z.ClauseLine
 0CC8   1   55			      push bp
 0CC9   1   57			      push StateDi
 0CCA   3   E9 FE36		      jmp Cycle
				     ;------------------------------------------------------------------------------
				     ; QueryKey:
				     ;------------------------------------------------------------------------------
				     ; cx has been set to address of linear list of keywords, see keys.inc, KeyRec
				     ; May change cx. Will change bx
				     ; Returns carry flag. When carry set, TokNum in bx.
				     ; ES will be Z.Symbols.
 0CCD   2   F8			     QueryRet:clc
 0CCE   5   C3			     ret
 0CCF				     QueryKey:JcxzQ QueryRet; Saying not keyword.
 0CCF   1   85 C9		  1    test cx,cx
 0CD1  3,1  74 FA		  1    je QueryRet
 0CD3   1   57			      push di
 0CD4   1   50			      push ax
 0CD5   1   52			      push dx
 0CD6   1   56			      push si
				      mv ds,cs
 0CD7   3   0E			  1   push cs
 0CD8   3p  1F			  1   pop ds
				     ; ds:si over the table, SymbolsEs:di on the symbol.
				     ; Scan for word of given length.
 0CD9   1   8B D9		      mov bx,cx
				      z cx
 0CDB   1   8B CD		  1           mov cx,bp
 0CDD   1   26: 8B 46 04	      mov ax,He.Avail
 0CE1   1   8B F8		      mov di,ax
 0CE3   1   26: 8A 15		      mov dl,Bptr SymbolsEs:[di]
 0CE6   1   40			      inc ax
 0CE7   1   4B			      dec bx
				     ; First byte is data. Second byte is data including keyword length.
 0CE8   1   43			     CycleKey:inc bx
 0CE9   1   03 D9		     add bx,cx
 0CEB   1   43			     inc bx
 0CEC   1   8A 0F		      mov cl,[bx]
 0CEE   1   80 E1 0F		      and cl,mask KeyLen
 0CF1   1   38 D1		      cmp cl,dl
 0CF3  3,1  74 0B		      je Match
 0CF5   2   F6 07 10		     Mismatch:test Bptr [bx],mask EndList
 0CF8  3,1  74 EE		      jz CycleKey
 0CFA   2   F8			      clc
 0CFB   1   5E			     QKexit:pop si
 0CFC   1   5A			      pop dx
 0CFD   1   58			      pop ax
 0CFE   1   5F			      pop di
 0CFF   5   C3			      ret
 0D00				     Match:; Length matches, setup and compare letters.
 0D00   1   8B F3		      mov si,bx
 0D02   1   46			      inc si
 0D03   1   8B F8		      mov di,ax
 0D05   8n  F3/ A6		      repe cmpsb
 0D07   1   8A CA		      mov cl,dl
 0D09  3,1  75 EA		      jnz Mismatch
 0D0B   1   8B 5F FF		      mov bx,[bx-1]; Low bx now has $name value for this keyword,
				     ; relocated by KeysBase so as to fit 0-63 range.
 0D0E   1   8B CB		      mov cx,bx
				      z bh
 0D10   1   B7 00		  1         mov bh,0
 0D12   1   83 C3 28		      add bx,KeysBase
				     ; Clumsy treatment of TRACE VALUE....
 0D15   1   83 FB 58		      cmp bx,$VALUE
 0D18  3,1  74 03		      je @F
 0D1A   1   89 5E 12		      mov Z.KWFound,bx
 0D1D				      @@:
				     ; QueryKey side-affects
				     ; Here is better than in Actions - Actions happen after next token seen.
				      On Z.Clause,NotAssign
 0D1D   3   80 4E 0C 40		  1          or  Bptr(Z.Clause), low ??0009
				      Off Z.Middles,TakenConstant,LookLabel
 0D21   3   80 66 0A E7		  1          and Bptr(Z.Middles), low not ??000A
 0D25   2   C1 E9 0D		      shr cx,13; Isolate KeyFlags
 0D28  3,1  74 6A		      jz DoneSide
 0D2A  2,6  E2 07		      loop @F
				     ;(1) IF WHEN setup for THEN
 0D2C   1   C7 46 10 0000	      mov Z.KWMiddle,$ThenKey
 0D31   3   EB 61		      jmp DoneSide
 0D33  2,6  E2 0F		     @@:loop @F
				     ;(2) DO sets up for WHILE and UNTIL etc.
 0D35   3   FF 86 00F9		      inc Z.TraceOnly
				      Off Z.Clause,NotAssign
 0D39   3   80 66 0C BF		  1          and Bptr(Z.Clause), low not ??000B
 0D3D   1   C7 46 10 0000	      mov Z.KWMiddle,$DoKeys
 0D42   3   EB 50		      jmp DoneSide
 0D44  2,6  E2 14		     @@:loop @F
				     ;(3) WITH turns middle keyword detection off.
				     ;(3) END ITERATE LEAVE are different set really but codes are limited.
				      z Z.KWMiddle
 0D46   1   89 6E 10		  1           mov Z.KWMiddle,bp
 0D49   1   80 FA 04		      cmp dl,4
 0D4C  3,1  74 46		      je DoneSide
 0D4E  3,1  73 04		      jnb NotEND
 0D50   3   FF 8E 00F9		      dec Z.TraceOnly
 0D54				      NotEND:
				      On Z.Middles,CheckDO
 0D54   3   80 4E 0A 80		  1          or  Bptr(Z.Middles), low ??000C
 0D58   3   EB 3A		      jmp DoneSide
 0D5A  2,6  E2 0D		     @@:loop @F
				     ;(4) OTHERWISE ELSE imply a semicolon.
				      On Z.Middles,SemiAfter
 0D5C   3   80 4E 0B 40		  1          or  Bptr(Z.Middles+1), high ??000D
				     ;(4) THEN implies semicolons before and after, but
				     ; before is only for purposes of "end-clause" action, which THEN can do.
				     ; We want to call ClauseSourceEnd with SI before the THEN.
 0D60   1   8B B6 008B		      mov si,Z.Insert.TokPos
 0D64   3   E8 0000 E		      call ClauseSourceEnd
 0D67   3   EB 2B		      jmp DoneSide
 0D69  2,6  E2 06		     @@:loop @F
				     ;(5) ADDRESS setup for WITH, also VALUE
 0D6B   1   C7 46 10 0000	      mov Z.KWMiddle,$WithKey
 0D70   1   41			      inc cx; for fallthru
 0D71  2,6  E2 0D		     @@:loop @F
				     ;(6) FORM SIGNAL TRACE prepare for VALUE
				      On Z.Middles,ImplicitValue
 0D73   3   80 4E 0B 01		  1          or  Bptr(Z.Middles+1), high ??000E
				     ; SIGNAL also needs to set LookLabel
 0D77   1   80 FA 06		      cmp dl,6
 0D7A  3,1  75 14		      jne TakenC
				      On Z.Clause,Signal
 0D7C   3   80 4E 0D 08		  1          or  Bptr(Z.Clause+1), high ??000F
 0D80				     @@:; Last case, no need for test.
				     ;(7) CALL NAME preceed TakenConstant
				     ;(7) So do STEM and STREAM but they are not labels.
 0D80   1   81 FB 010C		      cmp bx,$STEM
 0D84  3,1  74 0A		      je TakenC
 0D86   1   81 FB 0110		      cmp bx,$STREAM
 0D8A  3,1  74 04		      je TakenC
				      On Z.Middles,LookLabel
 0D8C   3   80 4E 0A 08		  1          or  Bptr(Z.Middles), low ??0010
 0D90				     TakenC:On Z.Middles,TakenConstant
 0D90   3   80 4E 0A 10		  1          or  Bptr(Z.Middles), low ??0011
 0D94   2   F9			     DoneSide:stc
 0D95   3   E9 FF63		      jmp QKexit
				      end
Microsoft (R) Macro Assembler Version 6.11		    01/21/12 18:44:27
syntax.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

AllocAppend  . . . . . . . . . . . . .	Proc
BackRet  . . . . . . . . . . . . . . .	Proc
Back . . . . . . . . . . . . . . . . .	Proc
CheckType  . . . . . . . . . . . . . .	Proc
CodeModeR  . . . . . . . . . . . . . .	Proc
DownCare . . . . . . . . . . . . . . .	Proc
Down . . . . . . . . . . . . . . . . .	Proc
EvAh . . . . . . . . . . . . . . . . .	Proc
EvRet  . . . . . . . . . . . . . . . .	Proc
JcxzQ  . . . . . . . . . . . . . . . .	Proc
LoopQ  . . . . . . . . . . . . . . . .	Proc
MkMajMin . . . . . . . . . . . . . . .	Func
Move . . . . . . . . . . . . . . . . .	Proc
Mv . . . . . . . . . . . . . . . . . .	Proc
Off  . . . . . . . . . . . . . . . . .	Proc
On . . . . . . . . . . . . . . . . . .	Proc
OpAl . . . . . . . . . . . . . . . . .	Proc
OpRet  . . . . . . . . . . . . . . . .	Proc
PopJunk  . . . . . . . . . . . . . . .	Proc
Pos  . . . . . . . . . . . . . . . . .	Func
Qry  . . . . . . . . . . . . . . . . .	Proc
Repmovsb . . . . . . . . . . . . . . .	Proc
RetSi  . . . . . . . . . . . . . . . .	Proc
Splat  . . . . . . . . . . . . . . . .	Proc
StringOrder  . . . . . . . . . . . . .	Func
TestReg  . . . . . . . . . . . . . . .	Proc
UnCodeMode . . . . . . . . . . . . . .	Proc
UpCare . . . . . . . . . . . . . . . .	Proc
Up . . . . . . . . . . . . . . . . . .	Proc
XlatBDLS . . . . . . . . . . . . . . .	Proc
dec2 . . . . . . . . . . . . . . . . .	Proc
inc2 . . . . . . . . . . . . . . . . .	Proc
la . . . . . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . . . . .	Proc
mv . . . . . . . . . . . . . . . . . .	Proc
top  . . . . . . . . . . . . . . . . .	Proc
xax  . . . . . . . . . . . . . . . . .	Proc
z  . . . . . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Ashape . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Amount . . . . . . . . . . . . . . .	 0004	     Word
Dshape . . . . . . . . . . . . . . . .	 0028
  TailsAt  . . . . . . . . . . . . . .	 0000	     Word
  Subject  . . . . . . . . . . . . . .	 0000	     QWord
  CVinit . . . . . . . . . . . . . . .	 0000	     QWord
  Reps . . . . . . . . . . . . . . . .	 0000	     QWord
  To . . . . . . . . . . . . . . . . .	 0008	     QWord
  By . . . . . . . . . . . . . . . . .	 0010	     QWord
  ForCount . . . . . . . . . . . . . .	 0018	     QWord
  PcodePos . . . . . . . . . . . . . .	 0020	     Word
  Iteration  . . . . . . . . . . . . .	 0020	     Word
  Leaving  . . . . . . . . . . . . . .	 0022	     Word
  UpDO . . . . . . . . . . . . . . . .	 0024	     Word
  CV . . . . . . . . . . . . . . . . .	 0024	     Word
  Rec  . . . . . . . . . . . . . . . .	 0027	     Byte
EnvBlock . . . . . . . . . . . . . . .	 0008
  EnvNumber  . . . . . . . . . . . . .	 0000	     Word
  EnvResourceI . . . . . . . . . . . .	 0002	     Word
  EnvResourceO . . . . . . . . . . . .	 0004	     Word
  EnvResourceE . . . . . . . . . . . .	 0006	     Word
FarpX  . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
Farp . . . . . . . . . . . . . . . . .	 0004
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
Fshape . . . . . . . . . . . . . . . .	 001A
  Flags  . . . . . . . . . . . . . . .	 0000	     Word
  ToQual . . . . . . . . . . . . . . .	 0002	     Word
  Lines  . . . . . . . . . . . . . . .	 0004	     DWord
  Hand . . . . . . . . . . . . . . . .	 0008	     Word
  Other_Position . . . . . . . . . . .	 000A	     DWord
  Exten  . . . . . . . . . . . . . . .	 000E	     Byte
  TraceWidth . . . . . . . . . . . . .	 000F	     Byte
  Symbols  . . . . . . . . . . . . . .	 0010	     Word
  Code . . . . . . . . . . . . . . . .	 0012	     Word
  Vars . . . . . . . . . . . . . . . .	 0014	     Word
  Consts . . . . . . . . . . . . . . .	 0016	     Word
  ProgScope  . . . . . . . . . . . . .	 0018	     Word
Hshape . . . . . . . . . . . . . . . .	 0010
  Hdw0 . . . . . . . . . . . . . . . .	 0000	     DWord
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  Bump . . . . . . . . . . . . . . . .	 0002	     Word
  Avail  . . . . . . . . . . . . . . .	 0004	     Word
  Trigger  . . . . . . . . . . . . . .	 0006	     Word
  Link . . . . . . . . . . . . . . . .	 0008	     Word
  TreeBin  . . . . . . . . . . . . . .	 000A	     Word
  Original . . . . . . . . . . . . . .	 000A	     Word
  UpPool . . . . . . . . . . . . . . .	 000A	     Word
  Probe  . . . . . . . . . . . . . . .	 000C	     Word
  TreeProg . . . . . . . . . . . . . .	 000E	     Word
  Labels . . . . . . . . . . . . . . .	 000E	     Word
InsBlock . . . . . . . . . . . . . . .	 0015
  MajMin . . . . . . . . . . . . . . .	 0000	     Word
  Minor  . . . . . . . . . . . . . . .	 0000	     Byte
  Major  . . . . . . . . . . . . . . .	 0001	     Byte
  Value  . . . . . . . . . . . . . . .	 0002	     Word
  Named  . . . . . . . . . . . . . . .	 0004	     Word
  Position . . . . . . . . . . . . . .	 0004	     Word
  KeysList . . . . . . . . . . . . . .	 0006	     Word
  ArgNum . . . . . . . . . . . . . . .	 0008	     Byte
  Desc . . . . . . . . . . . . . . . .	 0009	     Byte
  Hex  . . . . . . . . . . . . . . . .	 000A	     Byte
  Char . . . . . . . . . . . . . . . .	 000A	     Byte
  Options  . . . . . . . . . . . . . .	 000B	     Word
  OptsHi . . . . . . . . . . . . . . .	 000D	     Word
  Digits . . . . . . . . . . . . . . .	 000F	     Word
  TokPos . . . . . . . . . . . . . . .	 0011	     Word
  TokLen . . . . . . . . . . . . . . .	 0013	     Word
Jshape . . . . . . . . . . . . . . . .	 000E
  Valued . . . . . . . . . . . . . . .	 0000	     QWord
  Pair . . . . . . . . . . . . . . . .	 0008	     DWord
  Lower  . . . . . . . . . . . . . . .	 0008	     Word
  Higher . . . . . . . . . . . . . . .	 000A	     Word
  KeyLen . . . . . . . . . . . . . . .	 000C	     Word
  Key  . . . . . . . . . . . . . . . .	 000E	     Byte
Lshape . . . . . . . . . . . . . . . .	 007C
  DigitsFuzz . . . . . . . . . . . . .	 0000	     DWord
  Digits . . . . . . . . . . . . . . .	 0000	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0002	     Word
  Form . . . . . . . . . . . . . . . .	 0004	     Byte
  StartTime  . . . . . . . . . . . . .	 0005	     QWord
  TraceLetter  . . . . . . . . . . . .	 000D	     Byte
  TraceWord  . . . . . . . . . . . . .	 000D	     Word
  Active . . . . . . . . . . . . . . .	 000F	     QWord
  Alternate  . . . . . . . . . . . . .	 0017	     QWord
  Syntax . . . . . . . . . . . . . . .	 001F	     Byte
  LostDigits . . . . . . . . . . . . .	 0020	     Byte
  NoValue  . . . . . . . . . . . . . .	 0021	     Byte
  NotReady . . . . . . . . . . . . . .	 0022	     Byte
  Error  . . . . . . . . . . . . . . .	 0023	     Byte
  Failure  . . . . . . . . . . . . . .	 0024	     Byte
  Halt . . . . . . . . . . . . . . . .	 0025	     Byte
  TrapName . . . . . . . . . . . . . .	 0026	     Word
  EventLevel . . . . . . . . . . . . .	 0034	     Word
  Condition  . . . . . . . . . . . . .	 0036	     Word
  ConditionDescription . . . . . . . .	 0038	     QWord
  ConditionExtra . . . . . . . . . . .	 0040	     QWord
  Inherit  . . . . . . . . . . . . . .	 0048	     Byte
  ClauseTime . . . . . . . . . . . . .	 0048	     QWord
  ClauseLocal  . . . . . . . . . . . .	 0050	     QWord
  PendingDescription . . . . . . . . .	 0058	     QWord
  PendingExtra . . . . . . . . . . . .	 0060	     QWord
  LevelDO  . . . . . . . . . . . . . .	 0068	     Word
  StackSave  . . . . . . . . . . . . .	 006A	     DWord
  File . . . . . . . . . . . . . . . .	 006E	     Word
  ProgScope  . . . . . . . . . . . . .	 0070	     Word
  VarScope . . . . . . . . . . . . . .	 0072	     Word
  Access . . . . . . . . . . . . . . .	 0074	     Word
  Flags  . . . . . . . . . . . . . . .	 0074	     Word
  UpLevel  . . . . . . . . . . . . . .	 0076	     Word
  Resume . . . . . . . . . . . . . . .	 0078	     Word
  Arg0 . . . . . . . . . . . . . . . .	 007A	     Word
PushShape  . . . . . . . . . . . . . .	 0010
  di_  . . . . . . . . . . . . . . . .	 0000	     Word
  si_  . . . . . . . . . . . . . . . .	 0002	     Word
  bp_  . . . . . . . . . . . . . . . .	 0004	     Word
  sp_  . . . . . . . . . . . . . . . .	 0006	     Word
  bx_  . . . . . . . . . . . . . . . .	 0008	     Word
  bl_  . . . . . . . . . . . . . . . .	 0008	     Byte
  bh_  . . . . . . . . . . . . . . . .	 0009	     Byte
  dx_  . . . . . . . . . . . . . . . .	 000A	     Word
  dl_  . . . . . . . . . . . . . . . .	 000A	     Byte
  dh_  . . . . . . . . . . . . . . . .	 000B	     Byte
  cx_  . . . . . . . . . . . . . . . .	 000C	     Word
  cl_  . . . . . . . . . . . . . . . .	 000C	     Byte
  ch_  . . . . . . . . . . . . . . . .	 000D	     Byte
  ax_  . . . . . . . . . . . . . . . .	 000E	     Word
  al_  . . . . . . . . . . . . . . . .	 000E	     Byte
  ah_  . . . . . . . . . . . . . . . .	 000F	     Byte
Sshape . . . . . . . . . . . . . . . .	 0010
  State  . . . . . . . . . . . . . . .	 0000	     Word
  Parser . . . . . . . . . . . . . . .	 0002	     Word
  ClauseWas  . . . . . . . . . . . . .	 0004	     Word
  Token  . . . . . . . . . . . . . . .	 0006	     Word
  Operation  . . . . . . . . . . . . .	 0008	     DWord
  Caller . . . . . . . . . . . . . . .	 000C	     Word
  Parms  . . . . . . . . . . . . . . .	 000E	     Word
  JumpSite . . . . . . . . . . . . . .	 0006	     Word
  SoFar  . . . . . . . . . . . . . . .	 0008	     Word
  WhatCV . . . . . . . . . . . . . . .	 0008	     Word
  SelectSite . . . . . . . . . . . . .	 0008	     Word
Vshape . . . . . . . . . . . . . . . .	 0008
  String . . . . . . . . . . . . . . .	 0000	     Byte
  Dtype  . . . . . . . . . . . . . . .	 0007	     Byte
  Sign . . . . . . . . . . . . . . . .	 0000	     Byte
  ExpAnd . . . . . . . . . . . . . . .	 0000	     DWord
  ExpoUses . . . . . . . . . . . . . .	 0000	     Byte
  ExpoSign . . . . . . . . . . . . . .	 0003	     Byte
  Mantissa . . . . . . . . . . . . . .	 0004	     DWord
  MantLow  . . . . . . . . . . . . . .	 0004	     Word
  MantHigh . . . . . . . . . . . . . .	 0006	     Word
  OverExpo . . . . . . . . . . . . . .	 0000	     DWord
  OverMant . . . . . . . . . . . . . .	 0004	     DWord
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
  LabelValue . . . . . . . . . . . . .	 0000	     Word
  LabelType  . . . . . . . . . . . . .	 0006	     Word
  WhichCon . . . . . . . . . . . . . .	 0000	     Word
  PcodePos . . . . . . . . . . . . . .	 0002	     Word
  HeldOver . . . . . . . . . . . . . .	 0000	     Word
  Pair . . . . . . . . . . . . . . . .	 0000	     DWord
  Lower  . . . . . . . . . . . . . . .	 0000	     Word
  Higher . . . . . . . . . . . . . . .	 0002	     Word
  Here . . . . . . . . . . . . . . . .	 0004	     Word
Yshape . . . . . . . . . . . . . . . .	 0053
  N1 . . . . . . . . . . . . . . . . .	 0004	     DWord
  N10  . . . . . . . . . . . . . . . .	 0008	     DWord
  N100 . . . . . . . . . . . . . . . .	 000C	     DWord
  N1000  . . . . . . . . . . . . . . .	 0010	     DWord
  N1e4 . . . . . . . . . . . . . . . .	 0014	     DWord
  N1e5 . . . . . . . . . . . . . . . .	 0018	     DWord
  N1e6 . . . . . . . . . . . . . . . .	 001C	     DWord
  N1e7 . . . . . . . . . . . . . . . .	 0020	     DWord
  N1e8 . . . . . . . . . . . . . . . .	 0024	     DWord
  N1e9 . . . . . . . . . . . . . . . .	 0028	     DWord
  N1664525 . . . . . . . . . . . . . .	 002C	     DWord
  ExponHi  . . . . . . . . . . . . . .	 0030	     DWord
  ExponLo  . . . . . . . . . . . . . .	 0034	     DWord
  Cseg . . . . . . . . . . . . . . . .	 0038	     Word
  DOS  . . . . . . . . . . . . . . . .	 003A	     DWord
  DosPool  . . . . . . . . . . . . . .	 003E	     Byte
  DqCrLf . . . . . . . . . . . . . . .	 004C	     Byte
  CrLf . . . . . . . . . . . . . . . .	 004D	     Byte
  StackSave  . . . . . . . . . . . . .	 004F	     DWord
Zshape . . . . . . . . . . . . . . . .	 137C
  w  . . . . . . . . . . . . . . . . .	 0000	     Word
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  ProgramCancel  . . . . . . . . . . .	 0002	     DWord
  Program  . . . . . . . . . . . . . .	 0002	     Word
  Cancel . . . . . . . . . . . . . . .	 0004	     Word
  Stack  . . . . . . . . . . . . . . .	 0006	     Word
  ClauseLine . . . . . . . . . . . . .	 0008	     Word
  Middles  . . . . . . . . . . . . . .	 000A	     Word
  Clause . . . . . . . . . . . . . . .	 000C	     Word
  Gen  . . . . . . . . . . . . . . . .	 000E	     Word
  KWMiddle . . . . . . . . . . . . . .	 0010	     Word
  KWFound  . . . . . . . . . . . . . .	 0012	     Word
  Stdout . . . . . . . . . . . . . . .	 0014	     Word
  Stderr . . . . . . . . . . . . . . .	 0016	     Word
  SourceHandle . . . . . . . . . . . .	 0018	     Word
  HowInvoked . . . . . . . . . . . . .	 001A	     Word
  Radix  . . . . . . . . . . . . . . .	 001C	     Byte
  AxAsNum  . . . . . . . . . . . . . .	 001D	     Byte
  Tag  . . . . . . . . . . . . . . . .	 0023	     Byte
  Seed . . . . . . . . . . . . . . . .	 0028	     DWord
  ParseResetSp . . . . . . . . . . . .	 002C	     Word
  XCycleResetSp  . . . . . . . . . . .	 002E	     Word
  Dumper . . . . . . . . . . . . . . .	 0030	     Word
  Stash  . . . . . . . . . . . . . . .	 0032	     Word
  Resolved . . . . . . . . . . . . . .	 0034	     Word
  Cursor . . . . . . . . . . . . . . .	 0036	     Word
  Stream . . . . . . . . . . . . . . .	 0038	     Word
  Queue  . . . . . . . . . . . . . . .	 003A	     Word
  InsSource  . . . . . . . . . . . . .	 003C	     DWord
  SysFile  . . . . . . . . . . . . . .	 003C	     DWord
  File . . . . . . . . . . . . . . . .	 003C	     Word
  SysFiles . . . . . . . . . . . . . .	 003E	     Word
  Consts . . . . . . . . . . . . . . .	 0040	     Word
  Vars . . . . . . . . . . . . . . . .	 0042	     Word
  ProgScope  . . . . . . . . . . . . .	 0044	     Word
  VarScope . . . . . . . . . . . . . .	 0046	     Word
  Symbols  . . . . . . . . . . . . . .	 0048	     Word
  Code . . . . . . . . . . . . . . . .	 004A	     Word
  Zone . . . . . . . . . . . . . . . .	 004C	     Word
  Stem . . . . . . . . . . . . . . . .	 004E	     Word
  PoolPool . . . . . . . . . . . . . .	 0050	     Word
  Level  . . . . . . . . . . . . . . .	 0052	     Word
  Base0  . . . . . . . . . . . . . . .	 0054	     Word
  CurrentDO  . . . . . . . . . . . . .	 0056	     Word
  ResumeP  . . . . . . . . . . . . . .	 0058	     Word
  ResumeDF . . . . . . . . . . . . . .	 005A	     DWord
  ResumeD  . . . . . . . . . . . . . .	 005A	     Word
  ResumeF  . . . . . . . . . . . . . .	 005C	     Word
  ResumeS  . . . . . . . . . . . . . .	 005E	     Byte
  DigitsFuzz . . . . . . . . . . . . .	 005F	     DWord
  Digits . . . . . . . . . . . . . . .	 005F	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0061	     Word
  Ceiling  . . . . . . . . . . . . . .	 0063	     DWord
  DivBreak . . . . . . . . . . . . . .	 0067	     DWord
  TwiceDigits  . . . . . . . . . . . .	 006B	     DWord
  UseGeneral . . . . . . . . . . . . .	 006F	     Word
  InsLine  . . . . . . . . . . . . . .	 0071	     Word
  InsBif . . . . . . . . . . . . . . .	 0073	     Byte
  InsOperator  . . . . . . . . . . . .	 0074	     DWord
  InsUnqual  . . . . . . . . . . . . .	 0078	     Word
  Insert . . . . . . . . . . . . . . .	 007A	      0015
  Inserts  . . . . . . . . . . . . . .	 008F	      0015
  SignM  . . . . . . . . . . . . . . .	 00A4	     Byte
  SignE  . . . . . . . . . . . . . . .	 00A5	     Byte
  MantPos  . . . . . . . . . . . . . .	 00A6	     Word
  MantPosZi  . . . . . . . . . . . . .	 00A8	     Word
  ExpPos . . . . . . . . . . . . . . .	 00AA	     Word
  ExpPosZi . . . . . . . . . . . . . .	 00AC	     Word
  ExpSign  . . . . . . . . . . . . . .	 00AE	     Word
  MantSize . . . . . . . . . . . . . .	 00B0	     Word
  OpIs . . . . . . . . . . . . . . . .	 00B2	     Byte
  Flags  . . . . . . . . . . . . . . .	 00B3	     Byte
  BifParmsHi . . . . . . . . . . . . .	 00B4	     Byte
  BifByte  . . . . . . . . . . . . . .	 00B5	     Byte
  TraceAlign . . . . . . . . . . . . .	 00B6	     DWord
  TraceSource  . . . . . . . . . . . .	 00BA	     DWord
  TraceEnds  . . . . . . . . . . . . .	 00BE	     DWord
  TraceSourceColumn  . . . . . . . . .	 00C2	     Word
  TraceEndsColumn  . . . . . . . . . .	 00C4	     Word
  DualCode . . . . . . . . . . . . . .	 00C6	     Word
  TraceOp  . . . . . . . . . . . . . .	 00C8	     Byte
  Relative . . . . . . . . . . . . . .	 00C9	     DWord
  RelativeNow  . . . . . . . . . . . .	 00CD	     DWord
  Continue . . . . . . . . . . . . . .	 00D1	     Word
  StackX . . . . . . . . . . . . . . .	 00D3	     Word
  TraceLine  . . . . . . . . . . . . .	 00D5	     Word
  InhibitTrace . . . . . . . . . . . .	 00D7	     DWord
  InhibitPauses  . . . . . . . . . . .	 00DB	     DWord
  Target . . . . . . . . . . . . . . .	 00DF	     Word
  Scanp  . . . . . . . . . . . . . . .	 00E1	     Word
  EndUsedBuffer  . . . . . . . . . . .	 00E3	     Word
  NearEnd  . . . . . . . . . . . . . .	 00E5	     Word
  CatOp  . . . . . . . . . . . . . . .	 00E7	     Byte
  RadixBadWhite  . . . . . . . . . . .	 00E8	     Byte
  BackExponent . . . . . . . . . . . .	 00E9	     Word
  LastContent  . . . . . . . . . . . .	 00EB	     Word
  CommaLine  . . . . . . . . . . . . .	 00ED	     Word
  Condition  . . . . . . . . . . . . .	 00EF	     Word
  UntilPlace . . . . . . . . . . . . .	 00F1	     Word
  StemSym  . . . . . . . . . . . . . .	 00F3	     Word
  SoFar  . . . . . . . . . . . . . . .	 00F5	     Word
  PcodePos . . . . . . . . . . . . . .	 00F7	     Word
  TraceOnly  . . . . . . . . . . . . .	 00F9	     Word
  CompareAt  . . . . . . . . . . . . .	 00FB	     Word
  StackHi  . . . . . . . . . . . . . .	 00FD	     Word
  StackLo  . . . . . . . . . . . . . .	 00FF	     Word
  OnSoft . . . . . . . . . . . . . . .	 0101	     Word
  Tail . . . . . . . . . . . . . . . .	 0103	     Word
  TokNum . . . . . . . . . . . . . . .	 0105	     Word
  TokNow . . . . . . . . . . . . . . .	 0107	     Word
  TokWas . . . . . . . . . . . . . . .	 0109	     Word
  TokData  . . . . . . . . . . . . . .	 010B	     Word
  Synch  . . . . . . . . . . . . . . .	 010D	     Word
  Lines  . . . . . . . . . . . . . . .	 010F	     Word
  MsgBegin . . . . . . . . . . . . . .	 0111	     Word
  MsgSoFar . . . . . . . . . . . . . .	 0113	     Word
  PreZi  . . . . . . . . . . . . . . .	 0115	     Word
  TargetMajMin . . . . . . . . . . . .	 0117	     Word
  TargetMinor  . . . . . . . . . . . .	 0117	     Byte
  TargetMajor  . . . . . . . . . . . .	 0118	     Byte
  EnvSeg . . . . . . . . . . . . . . .	 0119	     Word
  ForPSP . . . . . . . . . . . . . . .	 011B	     DWord
  Fcb1 . . . . . . . . . . . . . . . .	 011F	     DWord
  Fcb2 . . . . . . . . . . . . . . . .	 0123	     DWord
  AtPause  . . . . . . . . . . . . . .	 0127	     Word
  ArgsB  . . . . . . . . . . . . . . .	 0129	     Byte
  ArgsB0 . . . . . . . . . . . . . . .	 012A	     Word
  Parsee . . . . . . . . . . . . . . .	 012C	     FWord
  ParseeNum  . . . . . . . . . . . . .	 0132	     Word
  PattLenEtc . . . . . . . . . . . . .	 0134	     Word
  BreakStart . . . . . . . . . . . . .	 0136	     Word
  BreakEnd . . . . . . . . . . . . . .	 0138	     Word
  EnvNow . . . . . . . . . . . . . . .	 013A	     QWord
  CatTotal . . . . . . . . . . . . . .	 0142	     Word
  LastTarget . . . . . . . . . . . . .	 0144	     Word
  NewJshape  . . . . . . . . . . . . .	 0146	     Word
  FromDos  . . . . . . . . . . . . . .	 0148	     Word
  FromDosWas . . . . . . . . . . . . .	 014A	     Word
  FromDosZi  . . . . . . . . . . . . .	 014C	     Word
  MemoryTable  . . . . . . . . . . . .	 014E	     FWord
  MemoryTableZi  . . . . . . . . . . .	 018A	     Byte
  Left . . . . . . . . . . . . . . . .	 018A	     Word
  Right  . . . . . . . . . . . . . . .	 018C	     Word
  AllocBase  . . . . . . . . . . . . .	 018E	     DWord
  DsWas  . . . . . . . . . . . . . . .	 0192	     Word
  DsNew  . . . . . . . . . . . . . . .	 0194	     Word
  EsWas  . . . . . . . . . . . . . . .	 0196	     Word
  EsNew  . . . . . . . . . . . . . . .	 0198	     Word
  FsWas  . . . . . . . . . . . . . . .	 019A	     Word
  FsNew  . . . . . . . . . . . . . . .	 019C	     Word
  GsWas  . . . . . . . . . . . . . . .	 019E	     Word
  GsNew  . . . . . . . . . . . . . . .	 01A0	     Word
  DebugStash . . . . . . . . . . . . .	 01A2	     Word
  DebugD . . . . . . . . . . . . . . .	 01A4	     DWord
  DigitCount . . . . . . . . . . . . .	 01A8	     Word
  SerialNow  . . . . . . . . . . . . .	 01AA	     Byte
  Serial . . . . . . . . . . . . . . .	 01AB	     Byte
  CommandArg . . . . . . . . . . . . .	 1374	     QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

CancelRec  . . . . . . . . . . . . . .	 0010	   0010
  Format5  . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  AssignDO . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ForExpose  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FromIterCV . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  ForBIF . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  TokIsValue . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  ExpRange . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Description  . . . . . . . . . . . .	 0008	   0001	     0100     ?
  Compacted  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  BcodeInterpret . . . . . . . . . . .	 0006	   0001	     0040     ?
  MapOnly  . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ParseUpper . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ParseTrace . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  SourceFiles  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  BoolBefore . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  WasDropped . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ClauseRec  . . . . . . . . . . . . . .	 0010	   0010
  WasUpper . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  OffFlag  . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Condition  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  Append . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Signal . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ClauseSet  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  CVar . . . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Repit  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PosEq  . . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NotAssign  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  WasParse . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  InParse  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  Tailed . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  WasTailed  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PosPlus  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PosMinus . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ConditionRec . . . . . . . . . . . . .	 0008	   0005
  Enabling . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  Delayed  . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PendingNow . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  Instruction  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  CRspare  . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ErrorRec . . . . . . . . . . . . . . .	 0010	   0004
  HasShiftOn . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAloneOn . . . . . . . . . . . .	 000E	   0001	     4000     ?
  MajorField . . . . . . . . . . . . .	 0006	   0008	     3FC0     ?
  MinorField . . . . . . . . . . . . .	 0000	   0006	     003F     ?
FRec . . . . . . . . . . . . . . . . .	 0010	   0009
  Qual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Read . . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Open . . . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  BeenRead . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  BeenWrite  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  WriteMode  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  IsSource . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  BeenCompiled . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FFpad  . . . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
GenRec . . . . . . . . . . . . . . . .	 0010	   0005
  Dual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  DualPending  . . . . . . . . . . . .	 000E	   0001	     4000     ?
  DualGen  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  DualOnly . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  GenSpare . . . . . . . . . . . . . .	 0000	   000C	     0FFF     ?
KeyRec . . . . . . . . . . . . . . . .	 0008	   0003
  KeyFlags . . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  EndList  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KeyLen . . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
LevelRecI  . . . . . . . . . . . . . .	 0010	   0003
  LIPad  . . . . . . . . . . . . . . .	 0002	   000E	     FFFC     ?
  Interactive  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ConditionInstruction . . . . . . . .	 0000	   0001	     0001     ?
LevelRec . . . . . . . . . . . . . . .	 0010	   0007
  Lpad . . . . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  InheritDone  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DigitsSet  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IsProcedure  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IsExternal . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IsFunction . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  Lpad2  . . . . . . . . . . . . . . .	 0000	   0003	     0007     ?
LoopsRec . . . . . . . . . . . . . . .	 0008	   0007
  LoopsPad . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  HasDot . . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  HasDots  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HasTo  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  HasFor . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IsInterp . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ByDown . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MiddleRec  . . . . . . . . . . . . . .	 0010	   0010
  NotLabel . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  SemiAfter  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ValueBefore  . . . . . . . . . . . .	 000D	   0001	     2000     ?
  AbutOK . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  NoBlanks . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ModEquals  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  EndClause  . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  ImplicitValue  . . . . . . . . . . .	 0008	   0001	     0100     ?
  CheckDO  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TargetSymbol . . . . . . . . . . . .	 0006	   0001	     0040     ?
  Function . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  TakenConstant  . . . . . . . . . . .	 0004	   0001	     0010     ?
  LookLabel  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LookBin  . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DotOK  . . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  MRspare  . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OperatorRec  . . . . . . . . . . . . .	 0008	   0006
  InTypes  . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ResultType . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  AppendNum  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  AppendRef  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DownOne  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  EndsClause . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ParmsRec . . . . . . . . . . . . . . .	 0008	   0003
  ParmsMin . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ParmsXtr . . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  NonCheck . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ParserRec  . . . . . . . . . . . . . .	 0010	   0005
  ParserPad  . . . . . . . . . . . . .	 0004	   000C	     FFF0     ?
  DoRep  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DoCV . . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  Forever  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DoDataHost . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ProgramRec . . . . . . . . . . . . . .	 0010	   000B
  API_Enabled  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Repass . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  LabelsBad  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FirstBetween . . . . . . . . . . . .	 000C	   0001	     1000     ?
  EndSource  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  BifCheck . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  RandomSeeded . . . . . . . . . . . .	 0009	   0001	     0200     ?
  NotS9  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  TraceIF  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ShowELSE . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PRSpare  . . . . . . . . . . . . . .	 0000	   0006	     003F     ?
RedRec . . . . . . . . . . . . . . . .	 0010	   0005
  HasShiftOff  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  HasAction  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PruneCt  . . . . . . . . . . . . . .	 000C	   0002	     3000     ?
  Rtype  . . . . . . . . . . . . . . .	 000A	   0002	     0C00     ?
  Rstate . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
ShiftRec . . . . . . . . . . . . . . .	 0010	   0008
  HasShift . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAlone . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  CatFlag  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  HasKeys  . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Reference  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  Direct . . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  Indexb . . . . . . . . . . . . . . .	 0005	   0005	     03E0     ?
  Index  . . . . . . . . . . . . . . .	 0000	   0005	     001F     ?
TokRec . . . . . . . . . . . . . . . .	 0010	   0003
  X02  . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  NdxbT  . . . . . . . . . . . . . . .	 000A	   0005	     7C00     ?
  Aim  . . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
TokVal . . . . . . . . . . . . . . . .	 0008	   0002
  GrpNdx . . . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SubNum . . . . . . . . . . . . . . .	 0000	   0002	     0003     ?


Types:

                N a m e                  Size     Attr

Boolp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
Bool . . . . . . . . . . . . . . . . .	 0001	  Byte 
Handlep  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Handle . . . . . . . . . . . . . . . .	 0002	  Word 
Segp . . . . . . . . . . . . . . . . .	 0002	  Word 
Ulong  . . . . . . . . . . . . . . . .	 0004	  DWord 
Ushortp  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Ushort . . . . . . . . . . . . . . . .	 0002	  Word 
bytep  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
charfp . . . . . . . . . . . . . . . .	 0004	  FarPTR Byte 
charp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
char . . . . . . . . . . . . . . . . .	 0001	  Byte 
shortp . . . . . . . . . . . . . . . .	 0002	  PTR Word 
short  . . . . . . . . . . . . . . . .	 0002	  Word 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . . . . .	16 Bit	 0D98	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

$0 . . . . . . . . . . . . . . . . . .	Number	 0000h	 
$10  . . . . . . . . . . . . . . . . .	Number	 0007h	 
$11  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$12  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$15  . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$16  . . . . . . . . . . . . . . . . .	Number	 0017h	 
$17  . . . . . . . . . . . . . . . . .	Number	 0019h	 
$18  . . . . . . . . . . . . . . . . .	Number	 0018h	 
$19  . . . . . . . . . . . . . . . . .	Number	 001Ah	 
$1 . . . . . . . . . . . . . . . . . .	Number	 0013h	 
$21  . . . . . . . . . . . . . . . . .	Number	 0016h	 
$23  . . . . . . . . . . . . . . . . .	Number	 001Eh	 
$28  . . . . . . . . . . . . . . . . .	Number	 0012h	 
$2 . . . . . . . . . . . . . . . . . .	Number	 0015h	 
$31  . . . . . . . . . . . . . . . . .	Number	 001Fh	 
$3 . . . . . . . . . . . . . . . . . .	Number	 0004h	 
$5 . . . . . . . . . . . . . . . . . .	Number	 0006h	 
$6 . . . . . . . . . . . . . . . . . .	Number	 0003h	 
$7 . . . . . . . . . . . . . . . . . .	Number	 000Eh	 
$8 . . . . . . . . . . . . . . . . . .	Number	 0014h	 
$9 . . . . . . . . . . . . . . . . . .	Number	 0009h	 
$?BIF  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$?CLAUSELOCAL  . . . . . . . . . . . .	Number	 007Ch	 
$?CLAUSETIME . . . . . . . . . . . . .	Number	 0074h	 
$?Discard  . . . . . . . . . . . . . .	Number	 0010h	 
$?E  . . . . . . . . . . . . . . . . .	Number	 00B4h	 
$?LINEIN_POSITION  . . . . . . . . . .	Number	 006Ch	 
$?MN . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$?MONTHS . . . . . . . . . . . . . . .	Number	 0084h	 
$?Nine . . . . . . . . . . . . . . . .	Number	 009Ch	 
$?Null . . . . . . . . . . . . . . . .	Number	 00ACh	 
$?OUTCOME  . . . . . . . . . . . . . .	Number	 0044h	 
$?Omitted  . . . . . . . . . . . . . .	Number	 0014h	 
$?RCx  . . . . . . . . . . . . . . . .	Number	 0028h	 
$?RC . . . . . . . . . . . . . . . . .	Number	 0034h	 
$?RESPONSE . . . . . . . . . . . . . .	Number	 0064h	 
$?RESULTx  . . . . . . . . . . . . . .	Number	 0020h	 
$?RESULT . . . . . . . . . . . . . . .	Number	 002Ch	 
$?RS . . . . . . . . . . . . . . . . .	Number	 0024h	 
$?SIGLx  . . . . . . . . . . . . . . .	Number	 0030h	 
$?SIGL . . . . . . . . . . . . . . . .	Number	 003Ch	 
$?STARTTIME  . . . . . . . . . . . . .	Number	 0094h	 
$?STREAMSTATE  . . . . . . . . . . . .	Number	 005Ch	 
$?STREAM . . . . . . . . . . . . . . .	Number	 0054h	 
$?SysVars  . . . . . . . . . . . . . .	Number	 0044h	 
$?S  . . . . . . . . . . . . . . . . .	Number	 00BCh	 
$?WEEKDAYS . . . . . . . . . . . . . .	Number	 008Ch	 
$?Zero . . . . . . . . . . . . . . . .	Number	 00A4h	 
$ADDRESS . . . . . . . . . . . . . . .	Number	 008Ch	 
$APPEND  . . . . . . . . . . . . . . .	Number	 0090h	 
$ARG . . . . . . . . . . . . . . . . .	Number	 0088h	 
$Abut  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$And . . . . . . . . . . . . . . . . .	Number	 0018h	 
$ArithR  . . . . . . . . . . . . . . .	Number	 0003h	 
$Ashapes . . . . . . . . . . . . . . .	Number	 000Ah	 
$Assign  . . . . . . . . . . . . . . .	Number	 0054h	 
$Asterisk  . . . . . . . . . . . . . .	Number	 0011h	 
$AttribAnd . . . . . . . . . . . . . .	Number	 00D8h	 
$AttribComma . . . . . . . . . . . . .	Number	 00DCh	 
$AttribEq  . . . . . . . . . . . . . .	Number	 00EBh	 
$AttribGt  . . . . . . . . . . . . . .	Number	 00F0h	 
$AttribLine  . . . . . . . . . . . . .	Number	 00E7h	 
$AttribLt  . . . . . . . . . . . . . .	Number	 00EDh	 
$AttribMinus . . . . . . . . . . . . .	Number	 00E4h	 
$AttribOr  . . . . . . . . . . . . . .	Number	 00D5h	 
$AttribPlus  . . . . . . . . . . . . .	Number	 00E5h	 
$AttribSlash . . . . . . . . . . . . .	Number	 00D2h	 
$AttribStar  . . . . . . . . . . . . .	Number	 00D1h	 
$AwayString  . . . . . . . . . . . . .	Number	 00C0h	 
$BPcodesCeil . . . . . . . . . . . . .	Number	 005Dh	 
$BY  . . . . . . . . . . . . . . . . .	Number	 006Ch	 
$Bb  . . . . . . . . . . . . . . . . .	Number	 0004h	 
$BcodesBase  . . . . . . . . . . . . .	Number	 00B3h	 
$BifABBREV . . . . . . . . . . . . . .	Number	 0014h	 
$BifABS  . . . . . . . . . . . . . . .	Number	 002Ah	 
$BifADDRESS  . . . . . . . . . . . . .	Number	 0020h	 
$BifARG  . . . . . . . . . . . . . . .	Number	 0021h	 
$BifB2X  . . . . . . . . . . . . . . .	Number	 002Dh	 
$BifBITAND . . . . . . . . . . . . . .	Number	 0034h	 
$BifBITOR  . . . . . . . . . . . . . .	Number	 0035h	 
$BifBITXOR . . . . . . . . . . . . . .	Number	 0036h	 
$BifBase . . . . . . . . . . . . . . .	Number	 FFB9h	 
$BifC2D  . . . . . . . . . . . . . . .	Number	 0031h	 
$BifC2X  . . . . . . . . . . . . . . .	Number	 002Ch	 
$BifCENTER . . . . . . . . . . . . . .	Number	 0015h	 
$BifCENTRE . . . . . . . . . . . . . .	Number	 0016h	 
$BifCHANGESTR  . . . . . . . . . . . .	Number	 0042h	 
$BifCHARIN . . . . . . . . . . . . . .	Number	 0004h	 
$BifCHAROUT  . . . . . . . . . . . . .	Number	 0005h	 
$BifCHARS  . . . . . . . . . . . . . .	Number	 0003h	 
$BifCOMPARE  . . . . . . . . . . . . .	Number	 0017h	 
$BifCONDITION  . . . . . . . . . . . .	Number	 0022h	 
$BifCOPIES . . . . . . . . . . . . . .	Number	 0038h	 
$BifCOUNTSTR . . . . . . . . . . . . .	Number	 0041h	 
$BifD2C  . . . . . . . . . . . . . . .	Number	 0032h	 
$BifD2X  . . . . . . . . . . . . . . .	Number	 0033h	 
$BifDATATYPE . . . . . . . . . . . . .	Number	 001Fh	 
$BifDATE . . . . . . . . . . . . . . .	Number	 0000h	 
$BifDELSTR . . . . . . . . . . . . . .	Number	 0018h	 
$BifDELWORD  . . . . . . . . . . . . .	Number	 0019h	 
$BifDIGITS . . . . . . . . . . . . . .	Number	 0025h	 
$BifERRORTEXT  . . . . . . . . . . . .	Number	 000Eh	 
$BifFORMAT . . . . . . . . . . . . . .	Number	 0011h	 
$BifFORM . . . . . . . . . . . . . . .	Number	 001Eh	 
$BifFUZZ . . . . . . . . . . . . . . .	Number	 0024h	 
$BifINSERT . . . . . . . . . . . . . .	Number	 001Ch	 
$BifLASTPOS  . . . . . . . . . . . . .	Number	 001Bh	 
$BifLEFT . . . . . . . . . . . . . . .	Number	 003Dh	 
$BifLENGTH . . . . . . . . . . . . . .	Number	 0043h	 
$BifLINEIN . . . . . . . . . . . . . .	Number	 0006h	 
$BifLINEOUT  . . . . . . . . . . . . .	Number	 0007h	 
$BifLINES  . . . . . . . . . . . . . .	Number	 0002h	 
$BifMAX  . . . . . . . . . . . . . . .	Number	 0044h	 
$BifMIN  . . . . . . . . . . . . . . .	Number	 0045h	 
$BifOVERLAY  . . . . . . . . . . . . .	Number	 001Dh	 
$BifPOS  . . . . . . . . . . . . . . .	Number	 003Ch	 
$BifQUALIFY  . . . . . . . . . . . . .	Number	 000Bh	 
$BifQUEUED . . . . . . . . . . . . . .	Number	 003Fh	 
$BifRANDOM . . . . . . . . . . . . . .	Number	 0028h	 
$BifREVERSE  . . . . . . . . . . . . .	Number	 0029h	 
$BifRIGHT  . . . . . . . . . . . . . .	Number	 001Ah	 
$BifSIGN . . . . . . . . . . . . . . .	Number	 002Bh	 
$BifSOURCELINE . . . . . . . . . . . .	Number	 0026h	 
$BifSPACE  . . . . . . . . . . . . . .	Number	 000Fh	 
$BifSTREAM . . . . . . . . . . . . . .	Number	 0008h	 
$BifSTRIP  . . . . . . . . . . . . . .	Number	 0009h	 
$BifSUBSTR . . . . . . . . . . . . . .	Number	 003Eh	 
$BifSUBWORD  . . . . . . . . . . . . .	Number	 003Bh	 
$BifSYMBOL . . . . . . . . . . . . . .	Number	 0040h	 
$BifTIME . . . . . . . . . . . . . . .	Number	 0001h	 
$BifTRACE  . . . . . . . . . . . . . .	Number	 0023h	 
$BifTRANSLATE  . . . . . . . . . . . .	Number	 0010h	 
$BifTRUNC  . . . . . . . . . . . . . .	Number	 000Dh	 
$BifTag  . . . . . . . . . . . . . . .	Number	 0080h	 
$BifVALUE  . . . . . . . . . . . . . .	Number	 0037h	 
$BifVERIFY . . . . . . . . . . . . . .	Number	 000Ah	 
$BifWORDINDEX  . . . . . . . . . . . .	Number	 003Ah	 
$BifWORDLENGTH . . . . . . . . . . . .	Number	 0012h	 
$BifWORDPOS  . . . . . . . . . . . . .	Number	 0013h	 
$BifWORDS  . . . . . . . . . . . . . .	Number	 000Ch	 
$BifWORD . . . . . . . . . . . . . . .	Number	 0039h	 
$BifX2B  . . . . . . . . . . . . . . .	Number	 002Eh	 
$BifX2C  . . . . . . . . . . . . . . .	Number	 002Fh	 
$BifX2D  . . . . . . . . . . . . . . .	Number	 0030h	 
$BifXRANGE . . . . . . . . . . . . . .	Number	 0027h	 
$Bin . . . . . . . . . . . . . . . . .	Number	 0024h	 
$CALL  . . . . . . . . . . . . . . . .	Number	 0094h	 
$CONST_SYMBOL  . . . . . . . . . . . .	Number	 0040h	 
$CaseTarget  . . . . . . . . . . . . .	Number	 0006h	 
$Cat . . . . . . . . . . . . . . . . .	Number	 004Dh	 
$Colon . . . . . . . . . . . . . . . .	Number	 000Ah	 
$Comma . . . . . . . . . . . . . . . .	Number	 001Ch	 
$CondKeys  . . . . . . . . . . . . . .	L Near	 09EC	  _TEXT	Public
$Constant  . . . . . . . . . . . . . .	Number	 008Ah	 
$Cr  . . . . . . . . . . . . . . . . .	Text   	 0dh
$DIGITS  . . . . . . . . . . . . . . .	Number	 00E4h	 
$DO  . . . . . . . . . . . . . . . . .	Number	 0098h	 
$DROP  . . . . . . . . . . . . . . . .	Number	 00B8h	 
$Desc59H . . . . . . . . . . . . . . .	Number	 000Bh	 
$DescArgs  . . . . . . . . . . . . . .	Number	 000Ah	 
$DescFiles . . . . . . . . . . . . . .	Number	 000Ch	 
$DescQueue . . . . . . . . . . . . . .	Number	 000Dh	 
$DescString  . . . . . . . . . . . . .	Number	 0005h	 
$Descriptions  . . . . . . . . . . . .	Number	 0037h	 
$Digit . . . . . . . . . . . . . . . .	Number	 0040h	 
$DirectR . . . . . . . . . . . . . . .	Number	 0001h	 
$DoKeys  . . . . . . . . . . . . . . .	L Near	 0868	  _TEXT	Public
$DosAllocate . . . . . . . . . . . . .	Number	 0048h	 
$DosChmod  . . . . . . . . . . . . . .	Number	 0043h	 
$DosClose  . . . . . . . . . . . . . .	Number	 003Eh	 
$DosCreate . . . . . . . . . . . . . .	Number	 003Ch	 
$DosDate . . . . . . . . . . . . . . .	Number	 002Ah	 
$DosDelete . . . . . . . . . . . . . .	Number	 0041h	 
$DosDisk . . . . . . . . . . . . . . .	Number	 0019h	 
$DosExecute  . . . . . . . . . . . . .	Number	 004Bh	 
$DosExit . . . . . . . . . . . . . . .	Number	 004Ch	 
$DosFree . . . . . . . . . . . . . . .	Number	 0049h	 
$DosGetError . . . . . . . . . . . . .	Number	 0059h	 
$DosModifyAllocated  . . . . . . . . .	Number	 004Ah	 
$DosOpen . . . . . . . . . . . . . . .	Number	 003Dh	 
$DosPSP  . . . . . . . . . . . . . . .	Number	 0062h	 
$DosPath . . . . . . . . . . . . . . .	Number	 0047h	 
$DosRead . . . . . . . . . . . . . . .	Number	 003Fh	 
$DosReturnCode . . . . . . . . . . . .	Number	 004Dh	 
$DosSeek . . . . . . . . . . . . . . .	Number	 0042h	 
$DosTime . . . . . . . . . . . . . . .	Number	 002Ch	 
$DosWrite  . . . . . . . . . . . . . .	Number	 0040h	 
$Dropped . . . . . . . . . . . . . . .	Number	 0040h	 
$ELSE  . . . . . . . . . . . . . . . .	Number	 009Ch	 
$END . . . . . . . . . . . . . . . . .	Number	 005Ch	 
$ENGINEERING . . . . . . . . . . . . .	Number	 00ECh	 
$ERROR . . . . . . . . . . . . . . . .	Number	 00CCh	 
$EXIT  . . . . . . . . . . . . . . . .	Number	 00A8h	 
$EXPOSE  . . . . . . . . . . . . . . .	Number	 00BCh	 
$Ee  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$EndBuffer . . . . . . . . . . . . . .	Number	 000Ah	 
$Eof . . . . . . . . . . . . . . . . .	Text   	 1ah
$Eos . . . . . . . . . . . . . . . . .	Number	 0000h	 
$EqTest  . . . . . . . . . . . . . . .	Number	 0000h	 
$Eq  . . . . . . . . . . . . . . . . .	Number	 002Bh	 
$Exposed . . . . . . . . . . . . . . .	Number	 0050h	 
$FAILURE . . . . . . . . . . . . . . .	Number	 00C9h	 
$FOREVER . . . . . . . . . . . . . . .	Number	 0118h	 
$FORM  . . . . . . . . . . . . . . . .	Number	 00E8h	 
$FOR . . . . . . . . . . . . . . . . .	Number	 0064h	 
$FUZZ  . . . . . . . . . . . . . . . .	Number	 00E5h	 
$FileBufferSize  . . . . . . . . . . .	Number	 0400h	 
$GeTest  . . . . . . . . . . . . . . .	Number	 0001h	 
$Ge  . . . . . . . . . . . . . . . . .	Number	 002Fh	 
$Group . . . . . . . . . . . . . . . .	Number	 00FCh	 
$Grp0Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp0ndxb  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp0ndx . . . . . . . . . . . . . . .	Number	 0005h	 
$Grp10Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp10ndxb . . . . . . . . . . . . . .	Number	 0007h	 
$Grp10ndx  . . . . . . . . . . . . . .	Number	 0008h	 
$Grp11Aim  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp11Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp11ndxb . . . . . . . . . . . . . .	Number	 0002h	 
$Grp11ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp12Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp12ndxb . . . . . . . . . . . . . .	Number	 0008h	 
$Grp12ndx  . . . . . . . . . . . . . .	Number	 0006h	 
$Grp13Aim  . . . . . . . . . . . . . .	Number	 0168h	 
$Grp13ndxb . . . . . . . . . . . . . .	Number	 0009h	 
$Grp13ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp14ndxb . . . . . . . . . . . . . .	Number	 000Ah	 
$Grp14ndx  . . . . . . . . . . . . . .	Number	 0010h	 
$Grp15Aim  . . . . . . . . . . . . . .	Number	 01D9h	 
$Grp15Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp15ndxb . . . . . . . . . . . . . .	Number	 000Bh	 
$Grp15ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp16Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp16ndxb . . . . . . . . . . . . . .	Number	 0001h	 
$Grp16ndx  . . . . . . . . . . . . . .	Number	 0009h	 
$Grp17Aim  . . . . . . . . . . . . . .	Number	 01C9h	 
$Grp17Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp17ndxb . . . . . . . . . . . . . .	Number	 000Ch	 
$Grp17ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp18Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp18ndxb . . . . . . . . . . . . . .	Number	 000Dh	 
$Grp18ndx  . . . . . . . . . . . . . .	Number	 0007h	 
$Grp19Aim  . . . . . . . . . . . . . .	Number	 01CFh	 
$Grp19Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp19ndxb . . . . . . . . . . . . . .	Number	 000Eh	 
$Grp19ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp1Aim . . . . . . . . . . . . . . .	Number	 00BBh	 
$Grp1Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp1ndxb  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp1ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp20Aim  . . . . . . . . . . . . . .	Number	 02FAh	 
$Grp20ndxb . . . . . . . . . . . . . .	Number	 000Fh	 
$Grp20ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp21Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp21ndxb . . . . . . . . . . . . . .	Number	 0010h	 
$Grp21ndx  . . . . . . . . . . . . . .	Number	 0007h	 
$Grp22Aim  . . . . . . . . . . . . . .	Number	 02FCh	 
$Grp22ndxb . . . . . . . . . . . . . .	Number	 000Fh	 
$Grp22ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp23Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp23ndxb . . . . . . . . . . . . . .	Number	 0011h	 
$Grp23ndx  . . . . . . . . . . . . . .	Number	 0011h	 
$Grp24Aim  . . . . . . . . . . . . . .	Number	 0025h	 
$Grp24ndxb . . . . . . . . . . . . . .	Number	 0012h	 
$Grp24ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp25ndxb . . . . . . . . . . . . . .	Number	 0013h	 
$Grp25ndx  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp26ndxb . . . . . . . . . . . . . .	Number	 0014h	 
$Grp26ndx  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp27ndxb . . . . . . . . . . . . . .	Number	 0015h	 
$Grp27ndx  . . . . . . . . . . . . . .	Number	 0003h	 
$Grp28Only . . . . . . . . . . . . . .	Number	 0001h	 
$Grp28ndxb . . . . . . . . . . . . . .	Number	 0016h	 
$Grp28ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp29Aim  . . . . . . . . . . . . . .	Number	 0136h	 
$Grp29ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp29ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp2Aim . . . . . . . . . . . . . . .	Number	 01C5h	 
$Grp2Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp2ndxb  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp2ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp30Aim  . . . . . . . . . . . . . .	Number	 032Eh	 
$Grp30ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp30ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp31ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp31ndx  . . . . . . . . . . . . . .	Number	 000Ah	 
$Grp32Aim  . . . . . . . . . . . . . .	Number	 00CEh	 
$Grp32ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp32ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp33Aim  . . . . . . . . . . . . . .	Number	 01B7h	 
$Grp33ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp33ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp34Aim  . . . . . . . . . . . . . .	Number	 01B3h	 
$Grp34ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp34ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp35Aim  . . . . . . . . . . . . . .	Number	 01BDh	 
$Grp35ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp35ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp36ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp36ndx  . . . . . . . . . . . . . .	Number	 000Bh	 
$Grp37Aim  . . . . . . . . . . . . . .	Number	 021Dh	 
$Grp37ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp37ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp38ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp38ndx  . . . . . . . . . . . . . .	Number	 0012h	 
$Grp39Aim  . . . . . . . . . . . . . .	Number	 0271h	 
$Grp39ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp39ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp3Aim . . . . . . . . . . . . . . .	Number	 01C4h	 
$Grp3Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp3ndxb  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp3ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp40Aim  . . . . . . . . . . . . . .	Number	 01BDh	 
$Grp40ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp40ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp41Aim  . . . . . . . . . . . . . .	Number	 020Ah	 
$Grp41ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp41ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp42Aim  . . . . . . . . . . . . . .	Number	 02F8h	 
$Grp42ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp42ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp43Aim  . . . . . . . . . . . . . .	Number	 0103h	 
$Grp43ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp43ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp44Aim  . . . . . . . . . . . . . .	Number	 01D3h	 
$Grp44ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp44ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp45Aim  . . . . . . . . . . . . . .	Number	 008Fh	 
$Grp45ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp45ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp46Aim  . . . . . . . . . . . . . .	Number	 0274h	 
$Grp46ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp46ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp47Aim  . . . . . . . . . . . . . .	Number	 0193h	 
$Grp47ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp47ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp48Aim  . . . . . . . . . . . . . .	Number	 0125h	 
$Grp48ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp48ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp49Aim  . . . . . . . . . . . . . .	Number	 0324h	 
$Grp49ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp49ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp4Aim . . . . . . . . . . . . . . .	Number	 0187h	 
$Grp4ndxb  . . . . . . . . . . . . . .	Number	 0003h	 
$Grp4ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp50ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp50ndx  . . . . . . . . . . . . . .	Number	 0013h	 
$Grp51Aim  . . . . . . . . . . . . . .	Number	 025Dh	 
$Grp51ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp51ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp52ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp52ndx  . . . . . . . . . . . . . .	Number	 0014h	 
$Grp53Aim  . . . . . . . . . . . . . .	Number	 0237h	 
$Grp53ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp53ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp54Aim  . . . . . . . . . . . . . .	Number	 02F5h	 
$Grp54ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp54ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp55ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp55ndx  . . . . . . . . . . . . . .	Number	 0005h	 
$Grp56ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp56ndx  . . . . . . . . . . . . . .	Number	 000Ch	 
$Grp57Aim  . . . . . . . . . . . . . .	Number	 00B0h	 
$Grp57ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp57ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp58Aim  . . . . . . . . . . . . . .	Number	 021Ah	 
$Grp58ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp58ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp59Aim  . . . . . . . . . . . . . .	Number	 027Ch	 
$Grp59ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp59ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp5Aim . . . . . . . . . . . . . . .	Number	 00B7h	 
$Grp5Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp5ndxb  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp5ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp60ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp60ndx  . . . . . . . . . . . . . .	Number	 000Dh	 
$Grp61Aim  . . . . . . . . . . . . . .	Number	 0147h	 
$Grp61ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp61ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp62Aim  . . . . . . . . . . . . . .	Number	 0173h	 
$Grp62ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp62ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp63Aim  . . . . . . . . . . . . . .	Number	 00E3h	 
$Grp63ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp63ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp64Aim  . . . . . . . . . . . . . .	Number	 032Fh	 
$Grp64ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp64ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp65Aim  . . . . . . . . . . . . . .	Number	 0331h	 
$Grp65ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp65ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp66Aim  . . . . . . . . . . . . . .	Number	 0196h	 
$Grp66ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp66ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp67Aim  . . . . . . . . . . . . . .	Number	 0302h	 
$Grp67ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp67ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp68Aim  . . . . . . . . . . . . . .	Number	 01CDh	 
$Grp68ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp68ndx  . . . . . . . . . . . . . .	Number	 0000h	 
$Grp69ndxb . . . . . . . . . . . . . .	Number	 0000h	 
$Grp69ndx  . . . . . . . . . . . . . .	Number	 000Eh	 
$Grp6Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp6ndxb  . . . . . . . . . . . . . .	Number	 0004h	 
$Grp6ndx . . . . . . . . . . . . . . .	Number	 0001h	 
$Grp7Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp7ndxb  . . . . . . . . . . . . . .	Number	 0005h	 
$Grp7ndx . . . . . . . . . . . . . . .	Number	 000Fh	 
$Grp8Aim . . . . . . . . . . . . . . .	Number	 0052h	 
$Grp8Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp8ndxb  . . . . . . . . . . . . . .	Number	 0002h	 
$Grp8ndx . . . . . . . . . . . . . . .	Number	 0000h	 
$Grp9Only  . . . . . . . . . . . . . .	Number	 0001h	 
$Grp9ndxb  . . . . . . . . . . . . . .	Number	 0006h	 
$Grp9ndx . . . . . . . . . . . . . . .	Number	 0004h	 
$Gt  . . . . . . . . . . . . . . . . .	Number	 0030h	 
$HALT  . . . . . . . . . . . . . . . .	Number	 00CAh	 
$Hex . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$IF  . . . . . . . . . . . . . . . . .	Number	 00D4h	 
$INPUT . . . . . . . . . . . . . . . .	Number	 00D8h	 
$INTERPRET . . . . . . . . . . . . . .	Number	 00A4h	 
$ITERATE . . . . . . . . . . . . . . .	Number	 00B5h	 
$InitStackSize . . . . . . . . . . . .	Number	 2000h	 
$Invalid . . . . . . . . . . . . . . .	Number	 0009h	 
$LEAVE . . . . . . . . . . . . . . . .	Number	 00B4h	 
$LINEIN  . . . . . . . . . . . . . . .	Number	 007Ch	 
$LOSTDIGITS  . . . . . . . . . . . . .	Number	 00C5h	 
$Label . . . . . . . . . . . . . . . .	Number	 008Bh	 
$Leeway  . . . . . . . . . . . . . . .	Number	 0003h	 
$Letter  . . . . . . . . . . . . . . .	Number	 0080h	 
$Le  . . . . . . . . . . . . . . . . .	Number	 002Eh	 
$Lf  . . . . . . . . . . . . . . . . .	Text   	 0ah
$Limit_Digits  . . . . . . . . . . . .	Number	 270Fh	 
$Limit_EnvironmentName . . . . . . . .	Number	 000Ah	 
$Limit_ExponentDigits  . . . . . . . .	Number	 0009h	 
$Limit_Insert  . . . . . . . . . . . .	Number	 0032h	 
$Limit_Literal . . . . . . . . . . . .	Number	 00FAh	 
$Limit_Major . . . . . . . . . . . . .	Number	 0036h	 
$Limit_Name  . . . . . . . . . . . . .	Number	 00FAh	 
$Limit_String  . . . . . . . . . . . .	Number	 C350h	 
$LineFeed  . . . . . . . . . . . . . .	Number	 0027h	 
$Lowercase . . . . . . . . . . . . . .	Number	 0048h	 
$Lparen  . . . . . . . . . . . . . . .	Number	 000Ch	 
$Lt  . . . . . . . . . . . . . . . . .	Number	 002Dh	 
$M090  . . . . . . . . . . . . . . . .	Number	 0010h	 
$MaxParms  . . . . . . . . . . . . . .	Number	 0064h	 
$MaxPreInsert  . . . . . . . . . . . .	Number	 00AFh	 
$Minus . . . . . . . . . . . . . . . .	Number	 0024h	 
$MsgChunk  . . . . . . . . . . . . . .	Number	 0050h	 
$MsgNum  . . . . . . . . . . . . . . .	Number	 0044h	 
$MsgRoom . . . . . . . . . . . . . . .	Number	 00C8h	 
$NAME  . . . . . . . . . . . . . . . .	Number	 00DCh	 
$NOP . . . . . . . . . . . . . . . . .	Number	 00A0h	 
$NORMAL  . . . . . . . . . . . . . . .	Number	 0114h	 
$NOTREADY  . . . . . . . . . . . . . .	Number	 00C8h	 
$NOVALUE . . . . . . . . . . . . . . .	Number	 00C6h	 
$NUMBER  . . . . . . . . . . . . . . .	Number	 0044h	 
$NUMERIC . . . . . . . . . . . . . . .	Number	 00E0h	 
$Needed  . . . . . . . . . . . . . . .	Number	 067Eh	 
$Ne  . . . . . . . . . . . . . . . . .	Number	 002Ch	 
$NoMatch . . . . . . . . . . . . . . .	Number	 00FFh	 
$NonUpable . . . . . . . . . . . . . .	Number	 0008h	 
$Not . . . . . . . . . . . . . . . . .	Number	 0020h	 
$NullString  . . . . . . . . . . . . .	Number	 0080h	 
$Num . . . . . . . . . . . . . . . . .	Number	 000Ch	 
$OFF . . . . . . . . . . . . . . . . .	Number	 011Ch	 
$OKb . . . . . . . . . . . . . . . . .	Number	 0020h	 
$OKx . . . . . . . . . . . . . . . . .	Number	 0010h	 
$ON  . . . . . . . . . . . . . . . . .	Number	 0120h	 
$OPTIONS . . . . . . . . . . . . . . .	Number	 00A5h	 
$OTHERWISE . . . . . . . . . . . . . .	Number	 00F0h	 
$OUTPUT  . . . . . . . . . . . . . . .	Number	 00F4h	 
$Omitted . . . . . . . . . . . . . . .	Number	 0088h	 
$Or  . . . . . . . . . . . . . . . . .	Number	 0015h	 
$PARSE . . . . . . . . . . . . . . . .	Number	 00F8h	 
$PROCEDURE . . . . . . . . . . . . . .	Number	 00FCh	 
$PULL  . . . . . . . . . . . . . . . .	Number	 0080h	 
$PUSH  . . . . . . . . . . . . . . . .	Number	 00A9h	 
$Pad . . . . . . . . . . . . . . . . .	Number	 0018h	 
$PcodesBase  . . . . . . . . . . . . .	Number	 0001h	 
$PcodesCeil  . . . . . . . . . . . . .	Number	 00C5h	 
$Percent . . . . . . . . . . . . . . .	Number	 0010h	 
$PjumpBase . . . . . . . . . . . . . .	Number	 0057h	 
$PjumpCeil . . . . . . . . . . . . . .	Number	 0089h	 
$PlusMinus . . . . . . . . . . . . . .	Text   	 $AttribPlus and $Group
$Plus  . . . . . . . . . . . . . . . .	Number	 0025h	 
$Power . . . . . . . . . . . . . . . .	Number	 0050h	 
$QUEUE . . . . . . . . . . . . . . . .	Number	 00AAh	 
$REPLACE . . . . . . . . . . . . . . .	Number	 0108h	 
$RETURN  . . . . . . . . . . . . . . .	Number	 00ABh	 
$ReferR  . . . . . . . . . . . . . . .	Number	 0000h	 
$Rem . . . . . . . . . . . . . . . . .	Number	 0013h	 
$Rparen  . . . . . . . . . . . . . . .	Number	 0038h	 
$SAY . . . . . . . . . . . . . . . . .	Number	 00ACh	 
$SCIENTIFIC  . . . . . . . . . . . . .	Number	 00EDh	 
$SELECT  . . . . . . . . . . . . . . .	Number	 0100h	 
$SIGNAL  . . . . . . . . . . . . . . .	Number	 00C0h	 
$SOURCE  . . . . . . . . . . . . . . .	Number	 007Dh	 
$STEM  . . . . . . . . . . . . . . . .	Number	 010Ch	 
$STREAM  . . . . . . . . . . . . . . .	Number	 0110h	 
$STRING  . . . . . . . . . . . . . . .	Number	 003Ch	 
$SYNTAX  . . . . . . . . . . . . . . .	Number	 00C4h	 
$Semi  . . . . . . . . . . . . . . . .	Number	 0004h	 
$Seq . . . . . . . . . . . . . . . . .	Number	 0031h	 
$SerialCompaction  . . . . . . . . . .	Number	 0002h	 
$SerialInterpret . . . . . . . . . . .	Number	 0003h	 
$SerialNone  . . . . . . . . . . . . .	Number	 0000h	 
$SerialQue . . . . . . . . . . . . . .	Number	 0001h	 
$SerialSource  . . . . . . . . . . . .	Number	 0004h	 
$Sge . . . . . . . . . . . . . . . . .	Number	 0035h	 
$Sgt . . . . . . . . . . . . . . . . .	Number	 0036h	 
$ShiftV  . . . . . . . . . . . . . . .	Number	 0003h	 
$Sigl  . . . . . . . . . . . . . . . .	Number	 0048h	 
$SizeConstsHeader  . . . . . . . . . .	Number	 0014h	 
$Slash . . . . . . . . . . . . . . . .	Number	 0012h	 
$Sle . . . . . . . . . . . . . . . . .	Number	 0034h	 
$Slt . . . . . . . . . . . . . . . . .	Number	 0033h	 
$Sne . . . . . . . . . . . . . . . . .	Number	 0032h	 
$SourceBufferSize  . . . . . . . . . .	Number	 11C8h	 
$Special . . . . . . . . . . . . . . .	Number	 00C0h	 
$Stem  . . . . . . . . . . . . . . . .	Number	 0060h	 
$Stream  . . . . . . . . . . . . . . .	Number	 0020h	 
$StrideA . . . . . . . . . . . . . . .	Number	 0006h	 
$StrideD . . . . . . . . . . . . . . .	Number	 0028h	 
$StrideF . . . . . . . . . . . . . . .	Number	 001Ah	 
$StrideH . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideJ . . . . . . . . . . . . . . .	Number	 000Eh	 
$StrideL . . . . . . . . . . . . . . .	Number	 007Ch	 
$StrideS . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideV . . . . . . . . . . . . . . .	Number	 0008h	 
$SubsetR . . . . . . . . . . . . . . .	Number	 0002h	 
$Symbol  . . . . . . . . . . . . . . .	Number	 0028h	 
$SysCount  . . . . . . . . . . . . . .	Number	 000Bh	 
$THEN  . . . . . . . . . . . . . . . .	Number	 0060h	 
$TO  . . . . . . . . . . . . . . . . .	Number	 0068h	 
$TRACE . . . . . . . . . . . . . . . .	Number	 00B0h	 
$Test  . . . . . . . . . . . . . . . .	Number	 00C0h	 
$ThenKey . . . . . . . . . . . . . . .	L Near	 0A53	  _TEXT	Public
$TraceAssign . . . . . . . . . . . . .	Number	 0000h	 
$TraceBY . . . . . . . . . . . . . . .	Number	 0002h	 
$TraceBack . . . . . . . . . . . . . .	Number	 001Ah	 
$TraceClause . . . . . . . . . . . . .	Number	 0004h	 
$TraceCompound . . . . . . . . . . . .	Number	 0006h	 
$TraceDot  . . . . . . . . . . . . . .	Number	 0008h	 
$TraceEndClause  . . . . . . . . . . .	Number	 001Eh	 
$TraceError  . . . . . . . . . . . . .	Number	 000Ah	 
$TraceExpr . . . . . . . . . . . . . .	Number	 000Ch	 
$TraceFailure  . . . . . . . . . . . .	Number	 000Eh	 
$TraceFunction . . . . . . . . . . . .	Number	 0010h	 
$TraceLit  . . . . . . . . . . . . . .	Number	 0016h	 
$TraceOperator . . . . . . . . . . . .	Number	 0012h	 
$TraceParse  . . . . . . . . . . . . .	Number	 001Ch	 
$TracePrefix . . . . . . . . . . . . .	Number	 0014h	 
$TraceVar  . . . . . . . . . . . . . .	Number	 0018h	 
$UNTIL . . . . . . . . . . . . . . . .	Number	 0070h	 
$UPPER . . . . . . . . . . . . . . . .	Number	 00D0h	 
$UnAccept  . . . . . . . . . . . . . .	Number	 0008h	 
$VALUE . . . . . . . . . . . . . . . .	Number	 0058h	 
$VAR_SYMBOL  . . . . . . . . . . . . .	Number	 0048h	 
$VAR . . . . . . . . . . . . . . . . .	Number	 0084h	 
$VERSION . . . . . . . . . . . . . . .	Number	 007Eh	 
$Variable  . . . . . . . . . . . . . .	Number	 0089h	 
$WHEN  . . . . . . . . . . . . . . . .	Number	 0104h	 
$WHILE . . . . . . . . . . . . . . . .	Number	 0074h	 
$WITH  . . . . . . . . . . . . . . . .	Number	 0078h	 
$White . . . . . . . . . . . . . . . .	Number	 0000h	 
$WholeGE . . . . . . . . . . . . . . .	Number	 0004h	 
$WholeGT . . . . . . . . . . . . . . .	Number	 0008h	 
$WholeNum  . . . . . . . . . . . . . .	Number	 0014h	 
$Whole . . . . . . . . . . . . . . . .	Number	 0000h	 
$WithKey . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	Public
$Xor . . . . . . . . . . . . . . . . .	Number	 0014h	 
$Xx  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$mParseEnd . . . . . . . . . . . . . .	Number	 001Ah	 
$mParseEscape  . . . . . . . . . . . .	Number	 0012h	 
$mPattern  . . . . . . . . . . . . . .	Number	 002Ah	 
$mPosEq  . . . . . . . . . . . . . . .	Number	 0032h	 
$mPosMinus . . . . . . . . . . . . . .	Number	 0042h	 
$mPosPlus  . . . . . . . . . . . . . .	Number	 003Ah	 
$mPosRest  . . . . . . . . . . . . . .	Number	 0022h	 
$mRepTail  . . . . . . . . . . . . . .	Number	 0002h	 
$mTemplateComma  . . . . . . . . . . .	Number	 004Ah	 
$mUpper  . . . . . . . . . . . . . . .	Number	 000Ah	 
$n17p1 . . . . . . . . . . . . . . . .	Number	 0002h	 
$n40p3 . . . . . . . . . . . . . . . .	Number	 0004h	 
$n40p4 . . . . . . . . . . . . . . . .	Number	 0006h	 
$n40p5 . . . . . . . . . . . . . . . .	Number	 0008h	 
$n7p3  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nArg  . . . . . . . . . . . . . . . .	Number	 0004h	 
$nDigits . . . . . . . . . . . . . . .	Number	 0000h	 
$nForm . . . . . . . . . . . . . . . .	Number	 0004h	 
$nFuzz . . . . . . . . . . . . . . . .	Number	 0002h	 
$nLineIn . . . . . . . . . . . . . . .	Number	 0006h	 
$nNormal . . . . . . . . . . . . . . .	Number	 0040h	 
$nPull . . . . . . . . . . . . . . . .	Number	 0008h	 
$nSource . . . . . . . . . . . . . . .	Number	 000Ah	 
$nStem . . . . . . . . . . . . . . . .	Number	 0000h	 
$nStream . . . . . . . . . . . . . . .	Number	 0020h	 
$nVar  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nVersion  . . . . . . . . . . . . . .	Number	 000Ch	 
$nWith . . . . . . . . . . . . . . . .	Number	 0002h	 
$pAbut . . . . . . . . . . . . . . . .	Number	 0001h	 
$pAddress  . . . . . . . . . . . . . .	Number	 00A5h	 
$pAdd  . . . . . . . . . . . . . . . .	Number	 003Fh	 
$pAnd  . . . . . . . . . . . . . . . .	Number	 0035h	 
$pAssignConst  . . . . . . . . . . . .	Number	 0099h	 
$pAssignDotsP  . . . . . . . . . . . .	Number	 0007h	 
$pAssignDots . . . . . . . . . . . . .	Number	 0097h	 
$pAssignStem . . . . . . . . . . . . .	Number	 0095h	 
$pAssign . . . . . . . . . . . . . . .	Number	 0093h	 
$pBifGroup . . . . . . . . . . . . . .	Number	 00ADh	 
$pBifq . . . . . . . . . . . . . . . .	Number	 002Bh	 
$pBif  . . . . . . . . . . . . . . . .	Number	 00ABh	 
$pBool . . . . . . . . . . . . . . . .	Number	 00A1h	 
$pBy . . . . . . . . . . . . . . . . .	Number	 0011h	 
$pCallOn . . . . . . . . . . . . . . .	Number	 008Fh	 
$pCall . . . . . . . . . . . . . . . .	Number	 0055h	 
$pCat  . . . . . . . . . . . . . . . .	Number	 0003h	 
$pCeq  . . . . . . . . . . . . . . . .	Number	 007Dh	 
$pCge  . . . . . . . . . . . . . . . .	Number	 0085h	 
$pCgt  . . . . . . . . . . . . . . . .	Number	 0087h	 
$pCle  . . . . . . . . . . . . . . . .	Number	 0083h	 
$pClt  . . . . . . . . . . . . . . . .	Number	 0081h	 
$pCne  . . . . . . . . . . . . . . . .	Number	 007Fh	 
$pCommandEnv . . . . . . . . . . . . .	Number	 00A7h	 
$pCommand  . . . . . . . . . . . . . .	Number	 004Dh	 
$pControlVar . . . . . . . . . . . . .	Number	 005Bh	 
$pDivide . . . . . . . . . . . . . . .	Number	 0045h	 
$pDotControlVar  . . . . . . . . . . .	Number	 005Dh	 
$pDots . . . . . . . . . . . . . . . .	Number	 0091h	 
$pDropList . . . . . . . . . . . . . .	Number	 00B7h	 
$pDrop . . . . . . . . . . . . . . . .	Number	 009Dh	 
$pEnvName  . . . . . . . . . . . . . .	Number	 00A9h	 
$pEq . . . . . . . . . . . . . . . . .	Number	 0065h	 
$pExit . . . . . . . . . . . . . . . .	Number	 0027h	 
$pExposeList . . . . . . . . . . . . .	Number	 00B9h	 
$pExpose . . . . . . . . . . . . . . .	Number	 009Fh	 
$pFor  . . . . . . . . . . . . . . . .	Number	 0013h	 
$pGe . . . . . . . . . . . . . . . . .	Number	 006Dh	 
$pGt . . . . . . . . . . . . . . . . .	Number	 006Fh	 
$pIntDivide  . . . . . . . . . . . . .	Number	 0047h	 
$pInterpEnd  . . . . . . . . . . . . .	Number	 0089h	 
$pInterpret  . . . . . . . . . . . . .	Number	 004Fh	 
$pInvoke . . . . . . . . . . . . . . .	Number	 0053h	 
$pIterCV . . . . . . . . . . . . . . .	Number	 00A3h	 
$pIterRep  . . . . . . . . . . . . . .	Number	 0019h	 
$pIterate  . . . . . . . . . . . . . .	Number	 001Bh	 
$pJump . . . . . . . . . . . . . . . .	Number	 0063h	 
$pLeave  . . . . . . . . . . . . . . .	Number	 001Dh	 
$pLength . . . . . . . . . . . . . . .	Number	 002Dh	 
$pLe . . . . . . . . . . . . . . . . .	Number	 006Bh	 
$pLt . . . . . . . . . . . . . . . . .	Number	 0069h	 
$pMax  . . . . . . . . . . . . . . . .	Number	 002Fh	 
$pMin  . . . . . . . . . . . . . . . .	Number	 0031h	 
$pMultiply . . . . . . . . . . . . . .	Number	 0043h	 
$pNegate . . . . . . . . . . . . . . .	Number	 003Dh	 
$pNe . . . . . . . . . . . . . . . . .	Number	 0067h	 
$pNop  . . . . . . . . . . . . . . . .	Number	 0005h	 
$pNot  . . . . . . . . . . . . . . . .	Number	 0033h	 
$pNumber . . . . . . . . . . . . . . .	Number	 000Dh	 
$pNumeric  . . . . . . . . . . . . . .	Number	 0051h	 
$pOptions  . . . . . . . . . . . . . .	Number	 00C3h	 
$pOr . . . . . . . . . . . . . . . . .	Number	 0037h	 
$pParse  . . . . . . . . . . . . . . .	Number	 0009h	 
$pPositive . . . . . . . . . . . . . .	Number	 003Bh	 
$pPower  . . . . . . . . . . . . . . .	Number	 004Bh	 
$pPush . . . . . . . . . . . . . . . .	Number	 00BBh	 
$pQueue  . . . . . . . . . . . . . . .	Number	 00BDh	 
$pRaise  . . . . . . . . . . . . . . .	Number	 00AFh	 
$pRemainder  . . . . . . . . . . . . .	Number	 0049h	 
$pRepEver  . . . . . . . . . . . . . .	Number	 0059h	 
$pRep  . . . . . . . . . . . . . . . .	Number	 0057h	 
$pResult . . . . . . . . . . . . . . .	Number	 0021h	 
$pResumeParse  . . . . . . . . . . . .	Number	 000Bh	 
$pReturns  . . . . . . . . . . . . . .	Number	 0025h	 
$pReturn . . . . . . . . . . . . . . .	Number	 0023h	 
$pSay  . . . . . . . . . . . . . . . .	Number	 0029h	 
$pSeq  . . . . . . . . . . . . . . . .	Number	 0071h	 
$pSge  . . . . . . . . . . . . . . . .	Number	 0079h	 
$pSgt  . . . . . . . . . . . . . . . .	Number	 007Bh	 
$pSignalOff  . . . . . . . . . . . . .	Number	 00B1h	 
$pSignalOn . . . . . . . . . . . . . .	Number	 008Dh	 
$pSignalV  . . . . . . . . . . . . . .	Number	 00B3h	 
$pSignal . . . . . . . . . . . . . . .	Number	 008Bh	 
$pSle  . . . . . . . . . . . . . . . .	Number	 0077h	 
$pSlt  . . . . . . . . . . . . . . . .	Number	 0075h	 
$pSne  . . . . . . . . . . . . . . . .	Number	 0073h	 
$pSubtract . . . . . . . . . . . . . .	Number	 0041h	 
$pSysVar . . . . . . . . . . . . . . .	Number	 00B5h	 
$pThen . . . . . . . . . . . . . . . .	Number	 005Fh	 
$pTo . . . . . . . . . . . . . . . . .	Number	 000Fh	 
$pTraceEvent . . . . . . . . . . . . .	Number	 00C1h	 
$pTrace  . . . . . . . . . . . . . . .	Number	 00BFh	 
$pUnDo . . . . . . . . . . . . . . . .	Number	 001Fh	 
$pUnstore  . . . . . . . . . . . . . .	Number	 009Bh	 
$pUntil  . . . . . . . . . . . . . . .	Number	 0017h	 
$pWhen . . . . . . . . . . . . . . . .	Number	 0061h	 
$pWhile  . . . . . . . . . . . . . . .	Number	 0015h	 
$pXor  . . . . . . . . . . . . . . . .	Number	 0039h	 
$ret . . . . . . . . . . . . . . . . .	Number	 00C3h	 
$sAddress  . . . . . . . . . . . . . .	Number	 002Dh	 
$sDigits . . . . . . . . . . . . . . .	Number	 0027h	 
$sDropList . . . . . . . . . . . . . .	Number	 000Bh	 
$sDrop . . . . . . . . . . . . . . . .	Number	 0006h	 
$sEq . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$sExit . . . . . . . . . . . . . . . .	Number	 0032h	 
$sForm . . . . . . . . . . . . . . . .	Number	 002Bh	 
$sIterate  . . . . . . . . . . . . . .	Number	 003Fh	 
$sLeave  . . . . . . . . . . . . . . .	Number	 003Eh	 
$sLength . . . . . . . . . . . . . . .	Number	 0017h	 
$sMinus  . . . . . . . . . . . . . . .	Number	 0014h	 
$sNegate . . . . . . . . . . . . . . .	Number	 0030h	 
$sNop  . . . . . . . . . . . . . . . .	Number	 002Ah	 
$sNumber . . . . . . . . . . . . . . .	Number	 0037h	 
$sPercent  . . . . . . . . . . . . . .	Number	 0000h	 
$sPositive . . . . . . . . . . . . . .	Number	 0031h	 
$sRaise  . . . . . . . . . . . . . . .	Number	 0039h	 
$sReturns  . . . . . . . . . . . . . .	Number	 0035h	 
$sSeq  . . . . . . . . . . . . . . . .	Number	 0021h	 
$sStem . . . . . . . . . . . . . . . .	Number	 0009h	 
$sWith . . . . . . . . . . . . . . . .	Number	 000Ah	 
$tBinary . . . . . . . . . . . . . . .	Number	 00FDh	 
$tChar . . . . . . . . . . . . . . . .	Number	 00FFh	 
$tLabel  . . . . . . . . . . . . . . .	Number	 00FEh	 
??0000 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0001 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0002 . . . . . . . . . . . . . . . .	Number	 4000h	 
??0003 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0004 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0005 . . . . . . . . . . . . . . . .	Number	 0400h	 
??0006 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0007 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0008 . . . . . . . . . . . . . . . .	Number	 0800h	 
??0009 . . . . . . . . . . . . . . . .	Number	 0040h	 
??000A . . . . . . . . . . . . . . . .	Number	 0018h	 
??000B . . . . . . . . . . . . . . . .	Number	 0040h	 
??000C . . . . . . . . . . . . . . . .	Number	 0080h	 
??000D . . . . . . . . . . . . . . . .	Number	 4000h	 
??000E . . . . . . . . . . . . . . . .	Number	 0100h	 
??000F . . . . . . . . . . . . . . . .	Number	 0800h	 
??0010 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0011 . . . . . . . . . . . . . . . .	Number	 0010h	 
?BIF . . . . . . . . . . . . . . . . .	Number	 0002h	 
?CLAUSELOCAL . . . . . . . . . . . . .	Number	 000Eh	 
?CLAUSETIME  . . . . . . . . . . . . .	Number	 000Ch	 
?LINEIN_POSITION . . . . . . . . . . .	Number	 000Ah	 
?MONTHS  . . . . . . . . . . . . . . .	Number	 0010h	 
?OUTCOME . . . . . . . . . . . . . . .	Number	 0000h	 
?RESPONSE  . . . . . . . . . . . . . .	Number	 0008h	 
?STARTTIME . . . . . . . . . . . . . .	Number	 0014h	 
?STREAMSTATE . . . . . . . . . . . . .	Number	 0006h	 
?STREAM  . . . . . . . . . . . . . . .	Number	 0004h	 
?WEEKDAYS  . . . . . . . . . . . . . .	Number	 0012h	 
@CodeSize  . . . . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . . . . .	Text   	 DGROUP
AcceptBits . . . . . . . . . . . . . .	DWord	 0192	  _TEXT	
Accept . . . . . . . . . . . . . . . .	L Near	 0C4E	  _TEXT	
Action0  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action10 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action11 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action12 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action18 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action1  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action20 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action21 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action22 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action23 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action24 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action25 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action26 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action28 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action29 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action2  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action30 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action31 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action32 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action33 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action34 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action35 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action36 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action37 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action381  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action382  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action383  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action3  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action41 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action43 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action44 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action45 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action50 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action51 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action52 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action53 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action55 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action56 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action57 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action58 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action60 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action61 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action62 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action6  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action70 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action71 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action72 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action73 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action74 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action75 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action80 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action90 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Action91 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Actioning  . . . . . . . . . . . . . .	L Near	 0B1B	  _TEXT	
AllocateCx_EsAx  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Arith  . . . . . . . . . . . . . . . .	L Near	 0B72	  _TEXT	
ArrayBx  . . . . . . . . . . . . . . .	Text   	 bx
ArraySi  . . . . . . . . . . . . . . .	Text   	 si
Assert . . . . . . . . . . . . . . . .	Text   	 .erre
AssignExposed  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AssureSiPlus . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AttribAl . . . . . . . . . . . . . . .	Text   	 al
Attributes . . . . . . . . . . . . . .	L Near	 0092	  _TEXT	Public
AwayEsAxCx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Away . . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ax2DsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
A  . . . . . . . . . . . . . . . . . .	Text   	 (Ashape ptr[bp+si])
BifBound . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BitAccept  . . . . . . . . . . . . . .	L Near	 0C32	  _TEXT	
BooleryRejumps . . . . . . . . . . . .	Number	 0000h	 External
Boolery  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bptr . . . . . . . . . . . . . . . . .	Text   	 byte ptr
CD . . . . . . . . . . . . . . . . . .	Number	 0000h	 
CONFIG_ARITH . . . . . . . . . . . . .	Number	 00FFh	 
CONFIG_B2C . . . . . . . . . . . . . .	Number	 00E9h	 
CONFIG_C2B . . . . . . . . . . . . . .	Number	 00E7h	 
CONFIG_MSG . . . . . . . . . . . . . .	Number	 00E5h	 
CONFIG_RAISE40$$ . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_RAISE40 . . . . . . . . . . . .	Number	 00E1h	 
CONFIG_RAISE . . . . . . . . . . . . .	Number	 00DFh	 
CONFIG_STREAM_CHARIN . . . . . . . . .	Number	 00EDh	 
CONFIG_STREAM_CHAROUT  . . . . . . . .	Number	 00F3h	 
CONFIG_STREAM_CLOSE  . . . . . . . . .	Number	 00F1h	 
CONFIG_STREAM_COMMAND  . . . . . . . .	Number	 00F9h	 
CONFIG_STREAM_COUNT  . . . . . . . . .	Number	 00F5h	 
CONFIG_STREAM_POSITION . . . . . . . .	Number	 00EBh	 
CONFIG_STREAM_QUALIFIED  . . . . . . .	Number	 00F7h	 
CONFIG_STREAM_QUERY  . . . . . . . . .	Number	 00EFh	 
CONFIG_STREAM_STATE  . . . . . . . . .	Number	 00FBh	 
CONFIG_TIME  . . . . . . . . . . . . .	Number	 00FDh	 
CONFIG_UPPER$$ . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_UPPER . . . . . . . . . . . . .	Number	 00E3h	 
ClauseSourceEnd  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Command  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiler . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiling  . . . . . . . . . . . . . .	L Near	 0AA9	  _TEXT	Public
Consist  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValueX  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValue . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Create4Dump  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CursorBx . . . . . . . . . . . . . . .	Text   	 bx
CursorSi . . . . . . . . . . . . . . .	Text   	 si
CycleKey . . . . . . . . . . . . . . .	L Near	 0CE8	  _TEXT	
CycleTest  . . . . . . . . . . . . . .	L Near	 0B36	  _TEXT	
Cycle  . . . . . . . . . . . . . . . .	L Near	 0B03	  _TEXT	
D1 . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD])
Debug  . . . . . . . . . . . . . . . .	Number	 0001h	 
DepthBl  . . . . . . . . . . . . . . .	Text   	 bl
DepthBx  . . . . . . . . . . . . . . .	Text   	 bx
DigitsChange . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DoneSide . . . . . . . . . . . . . . .	L Near	 0D94	  _TEXT	
DosMemCheck  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsExposed  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSiX  . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotsFsBxDsSi . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dptr . . . . . . . . . . . . . . . . .	Text   	 dword ptr
DualSwitch . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dumper . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
D  . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD+$StrideV])
EqTest . . . . . . . . . . . . . . . .	L Near	 0B5D	  _TEXT	
Error49Bp  . . . . . . . . . . . . . .	Text   	 call bp
ExposedFs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
FileBx . . . . . . . . . . . . . . . .	Text   	 bx
ForBcode . . . . . . . . . . . . . . .	Number	 0000h	 
ForBig . . . . . . . . . . . . . . . .	Number	 0000h	 
F  . . . . . . . . . . . . . . . . . .	Text   	 (Fshape ptr[bx-$StrideF])
GiveDosMem . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Hang . . . . . . . . . . . . . . . . .	Text   	 jmp $
HasShiftL  . . . . . . . . . . . . . .	L Near	 0B82	  _TEXT	
HaveTarget . . . . . . . . . . . . . .	L Near	 0C6F	  _TEXT	
Hd . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr ds:[0])
HeritageDi . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
He . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr es:[bp])
Hf . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr fs:[bp])
Hg . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr gs:[bp])
HighDi . . . . . . . . . . . . . . . .	Text   	 di
H  . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr[si])
InitMemory . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InitSegDs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
IssueError . . . . . . . . . . . . . .	L Near	 0B86	  _TEXT	
Jbx  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[bx])
Jdi  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[di])
JmpReduction . . . . . . . . . . . . .	L Near	 0C87	  _TEXT	
J  . . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[si])
KeyListCx  . . . . . . . . . . . . . .	Text   	 cx
Keys0  . . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys102  . . . . . . . . . . . . . . .	L Near	 0A87	  _TEXT	
Keys110  . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	
Keys111  . . . . . . . . . . . . . . .	L Near	 094F	  _TEXT	
Keys112  . . . . . . . . . . . . . . .	L Near	 0942	  _TEXT	
Keys113  . . . . . . . . . . . . . . .	L Near	 097F	  _TEXT	
Keys114  . . . . . . . . . . . . . . .	L Near	 097F	  _TEXT	
Keys137  . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys148  . . . . . . . . . . . . . . .	L Near	 0A53	  _TEXT	
Keys156  . . . . . . . . . . . . . . .	L Near	 0A48	  _TEXT	
Keys161  . . . . . . . . . . . . . . .	L Near	 0A1E	  _TEXT	
Keys162  . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	
Keys163  . . . . . . . . . . . . . . .	L Near	 0A1E	  _TEXT	
Keys165  . . . . . . . . . . . . . . .	L Near	 0A42	  _TEXT	
Keys171  . . . . . . . . . . . . . . .	L Near	 087A	  _TEXT	
Keys173  . . . . . . . . . . . . . . .	L Near	 0A7F	  _TEXT	
Keys174  . . . . . . . . . . . . . . .	L Near	 0A76	  _TEXT	
Keys17 . . . . . . . . . . . . . . . .	L Near	 09FA	  _TEXT	
Keys184  . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	
Keys187  . . . . . . . . . . . . . . .	L Near	 0A48	  _TEXT	
Keys188  . . . . . . . . . . . . . . .	L Near	 0937	  _TEXT	
Keys189  . . . . . . . . . . . . . . .	L Near	 0A53	  _TEXT	
Keys192  . . . . . . . . . . . . . . .	L Near	 0A42	  _TEXT	
Keys19 . . . . . . . . . . . . . . . .	L Near	 0948	  _TEXT	
Keys208  . . . . . . . . . . . . . . .	L Near	 0A48	  _TEXT	
Keys214  . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys215  . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys218  . . . . . . . . . . . . . . .	L Near	 09BC	  _TEXT	
Keys219  . . . . . . . . . . . . . . .	L Near	 09CD	  _TEXT	
Keys220  . . . . . . . . . . . . . . .	L Near	 09BC	  _TEXT	
Keys222  . . . . . . . . . . . . . . .	L Near	 0A25	  _TEXT	
Keys223  . . . . . . . . . . . . . . .	L Near	 0A67	  _TEXT	
Keys224  . . . . . . . . . . . . . . .	L Near	 0A59	  _TEXT	
Keys230  . . . . . . . . . . . . . . .	L Near	 087F	  _TEXT	
Keys231  . . . . . . . . . . . . . . .	L Near	 0A7A	  _TEXT	
Keys233  . . . . . . . . . . . . . . .	L Near	 087F	  _TEXT	
Keys234  . . . . . . . . . . . . . . .	L Near	 0A83	  _TEXT	
Keys235  . . . . . . . . . . . . . . .	L Near	 0A7A	  _TEXT	
Keys236  . . . . . . . . . . . . . . .	L Near	 0A83	  _TEXT	
Keys23 . . . . . . . . . . . . . . . .	L Near	 0A0E	  _TEXT	
Keys244  . . . . . . . . . . . . . . .	L Near	 0937	  _TEXT	
Keys248  . . . . . . . . . . . . . . .	L Near	 0A53	  _TEXT	
Keys25 . . . . . . . . . . . . . . . .	L Near	 0978	  _TEXT	
Keys262  . . . . . . . . . . . . . . .	L Near	 09D5	  _TEXT	
Keys265  . . . . . . . . . . . . . . .	L Near	 09D5	  _TEXT	
Keys273  . . . . . . . . . . . . . . .	L Near	 0A2C	  _TEXT	
Keys274  . . . . . . . . . . . . . . .	L Near	 0A60	  _TEXT	
Keys275  . . . . . . . . . . . . . . .	L Near	 0A2C	  _TEXT	
Keys276  . . . . . . . . . . . . . . .	L Near	 09B5	  _TEXT	
Keys277  . . . . . . . . . . . . . . .	L Near	 0A60	  _TEXT	
Keys278  . . . . . . . . . . . . . . .	L Near	 09B5	  _TEXT	
Keys286  . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys31 . . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys48 . . . . . . . . . . . . . . . .	L Near	 0A53	  _TEXT	
Keys49 . . . . . . . . . . . . . . . .	L Near	 0A4D	  _TEXT	
Keys51 . . . . . . . . . . . . . . . .	L Near	 0A48	  _TEXT	
Keys54 . . . . . . . . . . . . . . . .	L Near	 0883	  _TEXT	
Keys57 . . . . . . . . . . . . . . . .	L Near	 0A34	  _TEXT	
Keys5  . . . . . . . . . . . . . . . .	L Near	 0978	  _TEXT	
Keys73 . . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	
Keys74 . . . . . . . . . . . . . . . .	L Near	 0A3C	  _TEXT	
Keys78 . . . . . . . . . . . . . . . .	L Near	 099C	  _TEXT	
Keys7  . . . . . . . . . . . . . . . .	L Near	 0A15	  _TEXT	
Keys81 . . . . . . . . . . . . . . . .	L Near	 099C	  _TEXT	
Keys86 . . . . . . . . . . . . . . . .	L Near	 0876	  _TEXT	
Keys88 . . . . . . . . . . . . . . . .	L Near	 09EC	  _TEXT	
Keys89 . . . . . . . . . . . . . . . .	L Near	 09EC	  _TEXT	
Keys8  . . . . . . . . . . . . . . . .	L Near	 09E3	  _TEXT	
KeysBase . . . . . . . . . . . . . . .	Number	 0028h	 
Keys . . . . . . . . . . . . . . . . .	Byte	 0876	  _TEXT	Public
KeywordOffsetCx  . . . . . . . . . . .	Text   	 cx
Lbx  . . . . . . . . . . . . . . . . .	Text   	 ss:(Lshape ptr[bx-$StrideL+$StrideV])
LengthAtBx . . . . . . . . . . . . . .	Text   	 bx
LevelDi  . . . . . . . . . . . . . . .	Text   	 di
LevelSi  . . . . . . . . . . . . . . .	Text   	 si
LinkBcodeX . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LinkBcode  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookFileDsBx . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookupSi . . . . . . . . . . . . . . .	Text   	 si
Lookup . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LowPartLenCl . . . . . . . . . . . . .	Text   	 cl
LowSi  . . . . . . . . . . . . . . . .	Text   	 si
Lsi  . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+si-$StrideL+$StrideV])
L  . . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+di-$StrideL+$StrideV])
MajMinDx . . . . . . . . . . . . . . .	Text   	 dx
MajorDh  . . . . . . . . . . . . . . .	Text   	 dh
Match  . . . . . . . . . . . . . . . .	L Near	 0D00	  _TEXT	
MemCheck . . . . . . . . . . . . . . .	Number	 0001h	 
MinorDl  . . . . . . . . . . . . . . .	Text   	 dl
MinorDx  . . . . . . . . . . . . . . .	Text   	 dx
Mismatch . . . . . . . . . . . . . . .	L Near	 0CF5	  _TEXT	
MoreSpaceEs  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Name2File  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NextTest . . . . . . . . . . . . . . .	L Near	 0B61	  _TEXT	
NextToken  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NoAction . . . . . . . . . . . . . . .	L Near	 0B29	  _TEXT	
NonAccept  . . . . . . . . . . . . . .	L Near	 0C22	  _TEXT	
NotEND . . . . . . . . . . . . . . . .	L Near	 0D54	  _TEXT	
NotOperand . . . . . . . . . . . . . .	L Near	 0CAC	  _TEXT	
NotPresent . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
NotRefer . . . . . . . . . . . . . . .	L Near	 0B65	  _TEXT	
Null . . . . . . . . . . . . . . . . .	Number	 00B7h	 
NumDxBx  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
One  . . . . . . . . . . . . . . . . .	Number	 00B5h	 
OpAppendCl . . . . . . . . . . . . . .	Text   	 cl
OpAppendCx . . . . . . . . . . . . . .	Text   	 cx
OpFlags  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OperandBl  . . . . . . . . . . . . . .	Text   	 bl
OperandBx  . . . . . . . . . . . . . .	Text   	 bx
Overlay  . . . . . . . . . . . . . . .	Text   	 0 dup(?)
ParaAllocAx  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ParmsCl  . . . . . . . . . . . . . . .	Text   	 cl
ParmsCx  . . . . . . . . . . . . . . .	Text   	 cx
ParseDot . . . . . . . . . . . . . . .	Number	 00FEh	 
ParseDx  . . . . . . . . . . . . . . .	Text   	 dx
ParseKl  . . . . . . . . . . . . . . .	L Near	 0BDF	  _TEXT	
ParseSi  . . . . . . . . . . . . . . .	Text   	 si
PartLenCx  . . . . . . . . . . . . . .	Text   	 cx
Pcode1 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Pcode2 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeArg . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeGapBx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeOp  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ProbeBx  . . . . . . . . . . . . . . .	Text   	 bx
ProgEs . . . . . . . . . . . . . . . .	Text   	 es
QKexit . . . . . . . . . . . . . . . .	L Near	 0CFB	  _TEXT	
QueryKey . . . . . . . . . . . . . . .	L Near	 0CCF	  _TEXT	Public
QueryRet . . . . . . . . . . . . . . .	L Near	 0CCD	  _TEXT	
RadixTypeDl  . . . . . . . . . . . . .	Text   	 dl
Raise5p1d  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RawCharAh  . . . . . . . . . . . . . .	Text   	 ah
RawCharAl  . . . . . . . . . . . . . .	Text   	 al
RawChar  . . . . . . . . . . . . . . .	Text   	 byte ptr ss:[si+bp]
RealShift  . . . . . . . . . . . . . .	L Near	 0C8A	  _TEXT	
Reduction  . . . . . . . . . . . . . .	L Near	 0B0F	  _TEXT	
ReferMatch . . . . . . . . . . . . . .	L Near	 0B53	  _TEXT	
Rejumps  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResultSpace  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResumeP$ . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RetEsSi  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
RtypeAh  . . . . . . . . . . . . . . .	Text   	 ah
S1 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+$StrideS])
S2 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+2*$StrideS])
Say$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ScanSi . . . . . . . . . . . . . . . .	Text   	 si
ScannerSi  . . . . . . . . . . . . . .	Text   	 si
Scode  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SegOffDi . . . . . . . . . . . . . . .	Text   	 di
Serialize  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetInherit . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetStack . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetSymLenJa  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Solid  . . . . . . . . . . . . . . . .	Number	 0001h	 
SortSpaceSS  . . . . . . . . . . . . .	Number	 0001h	 
StackDi  . . . . . . . . . . . . . . .	Text   	 di
StackDx  . . . . . . . . . . . . . . .	Text   	 dx
StackSafe  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StackSi  . . . . . . . . . . . . . . .	Text   	 si
StartExecutionY  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StartExecution . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
State0 . . . . . . . . . . . . . . . .	Number	 05C6h	 
StateBx  . . . . . . . . . . . . . . .	Text   	 bx
StateDi  . . . . . . . . . . . . . . .	Text   	 di
StateOrig  . . . . . . . . . . . . . .	Word	 01EA	  _TEXT	
StateSi  . . . . . . . . . . . . . . .	Text   	 si
StatesDim  . . . . . . . . . . . . . .	Number	 0012h	 
StemBx . . . . . . . . . . . . . . . .	Text   	 bx
StemEs . . . . . . . . . . . . . . . .	Text   	 es
String1  . . . . . . . . . . . . . . .	Number	 00BBh	 
String2  . . . . . . . . . . . . . . .	Number	 00BDh	 
String . . . . . . . . . . . . . . . .	Number	 00B9h	 
SymbolLook . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymbolsEs  . . . . . . . . . . . . . .	Text   	 es
SymbolsSafe  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymsZiDx . . . . . . . . . . . . . . .	Text   	 dx
S  . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si])
TailSi . . . . . . . . . . . . . . . .	Text   	 si
TakenC . . . . . . . . . . . . . . . .	L Near	 0D90	  _TEXT	
Terminate  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TheMsgBh . . . . . . . . . . . . . . .	Text   	 bh
Then$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToDsSiCx . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ToFindDx . . . . . . . . . . . . . . .	Text   	 dx
ToFindLenAx  . . . . . . . . . . . . .	Text   	 ax
ToWholeEbx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TokData  . . . . . . . . . . . . . . .	Word	 0000	  _TEXT	
TokNowCh . . . . . . . . . . . . . . .	Text   	 ch
TokNumAh . . . . . . . . . . . . . . .	Text   	 ah
TokensDim  . . . . . . . . . . . . . .	Number	 0015h	 
Trial  . . . . . . . . . . . . . . . .	Number	 0000h	 
UpStack  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperFirstAh . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
V00  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-2*$StrideV])
V0 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-$StrideV])
V2 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+$StrideV])
V3 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+2*$StrideV])
V4 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+3*$StrideV])
VasDsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Vbxe . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bx])
Vbxf2  . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx+$StrideV])
Vbxf . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx])
Vbxs . . . . . . . . . . . . . . . . .	Text   	 ss:(Vshape ptr[bx])
Vbxt . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx-$CaseTarget])
Vbx  . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[bx])
Vdid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[di])
Ve . . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bp])
Vf . . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bp])
Vsid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[si])
Vsif . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[si])
Vsi  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+si])
V  . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di])
Wptr . . . . . . . . . . . . . . . . .	Text   	 word ptr
XCycle . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ycx2 . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[2*ecx+ebp])
Ysi  . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[si])
Y  . . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[bp])
Zero$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZeroBp . . . . . . . . . . . . . . . .	Text   	 bp
Zero . . . . . . . . . . . . . . . . .	Number	 00B3h	 
ZoneNumerics . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZoneToLevel  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Z  . . . . . . . . . . . . . . . . . .	Text   	 (Zshape ptr[bp])
_Eq  . . . . . . . . . . . . . . . . .	Number	 00CDh	 
_Exists  . . . . . . . . . . . . . . .	Number	 00C7h	 
_Ge  . . . . . . . . . . . . . . . . .	Number	 00D5h	 
_Gt  . . . . . . . . . . . . . . . . .	Number	 00D7h	 
_IterCV  . . . . . . . . . . . . . . .	Number	 00C5h	 
_Jump  . . . . . . . . . . . . . . . .	Number	 00CBh	 
_Le  . . . . . . . . . . . . . . . . .	Number	 00D3h	 
_Lt  . . . . . . . . . . . . . . . . .	Number	 00D1h	 
_Ne  . . . . . . . . . . . . . . . . .	Number	 00CFh	 
_RetBc . . . . . . . . . . . . . . . .	Number	 00BFh	 
_RetB  . . . . . . . . . . . . . . . .	Number	 00C1h	 
_RetF  . . . . . . . . . . . . . . . .	Number	 00C3h	 
_Seq . . . . . . . . . . . . . . . . .	Number	 00D9h	 
_Slt . . . . . . . . . . . . . . . . .	Number	 00DDh	 
_Sne . . . . . . . . . . . . . . . . .	Number	 00DBh	 
_Then  . . . . . . . . . . . . . . . .	Number	 00C9h	 
is . . . . . . . . . . . . . . . . . .	Text   	 textequ

	   0 Warnings
	   0 Errors
