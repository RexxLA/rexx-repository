Microsoft (R) Macro Assembler Version 6.11		    01/27/12 18:05:59
execute.asm						     Page 1 - 1


				     ; Copyright Formcroft Ltd 1997-1999
				      .model small
				      .486
 0000				      .code
				     ;------------------------------------------------------------------------------
				     ; Literal and numeric replacements
				     ;------------------------------------------------------------------------------
 = textequ			     is textequ <textequ>
 = byte ptr			     Bptr  is <byte ptr>
 = word ptr			     Wptr  is <word ptr>
 = dword ptr			     Dptr  is <dword ptr>
 = jmp $			     Hang  is <jmp $>
 = 0dh				     $Cr   is <0dh>
 = 0ah				     $Lf   is <0ah>
 = 1ah				     $Eof  is <1ah>
 = 0 dup(?)			     Overlay is <0 dup(?)>
 = .erre			     Assert is <.erre>
				     ;------------------------------------------------------------------------------
				     ; Typedefs. MASMs pointers are offsets in a segment.
				     ; Some of this is to indicate the purpose to the reader rather than MASM,
				     ; ie CHAR v BYTE since both are unsigned 8 bits.
				     ; However, pointerness is worth saying for words containing offsets since
				     ; debugger will take note.
				     ; WORD will tend not to get used since a word is either an integer (USHORT)
				     ; or an offset.
				     ; I haven't yet found the penalty in giving up SHORT as a keyword so as to
				     ; use it in the 'C' sense.
				     ;------------------------------------------------------------------------------
				       option nokeyword:<short>
				       option nokeyword:<C>
				     ; One byte target:
				     char   typedef byte
				     Bool   typedef byte
				     bytep  typedef ptr byte
				     charp  typedef ptr byte
				     charfp  typedef far ptr byte
				     Boolp  typedef ptr byte
				     ; Two byte
				     Ushort typedef word
				     Ushortp typedef ptr word
				     short typedef sword
				     shortp typedef ptr sword
				     Handle typedef word
				     Handlep typedef ptr word
				     Segp typedef word; Slightly different sense.
				     ; Four byte
				     Ulong typedef dword
 0004				     Farp struc; For les,lds
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
				     Farp ends

				     ;------------------------------------------------------------------------------
				     ; Macros
				     ;------------------------------------------------------------------------------

				     MkMajMin macro Maj:req, Min:req
				      
; Makes parts of msg number into one number.
				      exitm %(256*Maj+Min)
				     endm

				     StringOrder macro a:req, b:req, c, d
				      
; Load so that a store puts them in the written order.
				      ifnb <d>
				       exitm %(256*256*256*(d)+256*256*(c)+256*(b)+(a))
				      endif
				      exitm %(256*(b)+(a))
				     endm

				     ; Splat makes a visual 'noise' on the output.
				     Splat macro It:=<'*'>
				      mov dl,It
				      mov ah,02h
				      int 21h
				     endm

				     LoopQ macro tgt:req
				     
; Faster than single loop instruction
				       dec cx
				       jnz tgt
				     endm

				     JcxzQ macro tgt:req
				     
; jcxz is written only where retaining flags matters, else JcxzQ
				     
; JcxzQ can be rendered in way that can do long jump. (And maybe faster)
				       test cx,cx
				       je tgt
				     endm

				     Pos macro Needle:req, Hay:req
				      exitm % @InStr(1,Hay,Needle)
				     endm

				     ; As provided in MASM readme, plus fixing:
				      la macro Dest:req, Symbol:req
				     ; This can go wrong because replacement in operand occurs later.
				     ; Page 583 of Waite suggests we can test this but...
				      if (opattr(Symbol)) and 20h
				        if (opattr(Symbol)) and 08h
				          mov Dest, offset Symbol
				        else
				          lea Dest, Symbol
				        endif
				      else
				        ; Assume MOV if errors
				        mov Dest, offset Symbol
				      endif
				      endm

				     ; Having bp=0 makes a difference to zeroing.
				     ; XOR is no better than MOV of 0, and disturbs flags so this is just shorthand.
				     ; XOR faster than MOV of 0 on some machines?
				     ; Actually XOR is better for accum, but macro can't distinquish accum.
				     ; If Ax is positive CWD is better for DX, but macro doesn't do that.
				      z macro Dest:req
				     ; Drop this bit because XOR never better than register move.
				          if (type Dest) eq 1
				            mov Dest,0
				          else
				            if (type Dest) eq 2
				              mov Dest,bp
				            else
				              if (type Dest) eq 4
				                mov Dest,ebp
				              else
				                Whoops
				              endif
				            endif
				          endif
				      endm

				     ; Illuminate special use of test to set flags.
				     TestReg macro arg:req
				            test arg,arg
				     endm

				     ; Illuminate pop that discards.
				     PopJunk  macro arg:req
				       pop arg
				     endm

				     ; Setting bits in records.
				     ; I'm having trouble with MASM. If arg is complicated, it uses two byte
				     ; offsets where one would do. (Cured by overlay of word on record)
				     ; I cannot get MASM to put what I want on the listing. I would like the
				     ; values computed to show in the listed expansion but MASM will only show
				     ; the macro variable names there.  A % at the beginning of the line returned
				     ; by the macro does nothing. A % before the macro variable name in it is seen
				     ; as a syntax error. Short of conditional generation returning lines with
				     ; only the macro arguments in (these do get replaced on the listing), I don't
				     ; see a solution.

				     On      macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             or  arg,masksum
				       else
				         if masksum gt 255
				             or  Bptr(arg+1), high masksum
				         else
				             or  Bptr(arg), low masksum
				         endif
				       endif
				     endm
				     Off     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             and arg, not masksum
				       else
				         if masksum gt 255
				             and Bptr(arg+1), high not masksum
				         else
				             and Bptr(arg), low not masksum
				         endif
				       endif
				     endm
				     Qry     macro arg:req, flg:req, flg2, flg3, flg4
				       local masksum
				       ifnb <flg4>
				         Need to elaborate
				       endif
				       masksum = mask flg
				       ifnb <flg2>
				         masksum=masksum + mask flg2
				       endif
				       ifnb <flg3>
				         masksum=masksum + mask flg3
				       endif
				       if ((type arg) ne 2) or (low masksum ne 0 and high masksum ne 0)
				             test arg, masksum
				       else
				         if masksum gt 255
				           if @SizeStr("&arg") gt 4
				             test Bptr(arg+1), high masksum
				           else
				             if "cx" ne "&arg"
				               test Bptr(arg+1), high masksum
				             else
				               test ch, high masksum
				             endif
				           endif
				         else
				             test Bptr(arg), low masksum
				         endif
				       endif
				     endm

				     mv   macro To:req,From:req
				     ; Used for segment moves
				      push From
				      pop To
				     endm

				     xax macro To:req
				     ; Used for ax moves when xchg saves a byte. (At expense of cycles)
				     ; Don't use xax form if exchange is "real" exchange.
				      if (type To) eq 2
				        xchg ax,To
				      else
				        xchg eax,To
				      endif
				     endm

				     inc2 macro Subj:req
				     ; Shorter than add Subj,2 when non-acc 16 bit reg.
				      inc Subj
				      inc Subj
				     endm

				     dec2 macro Subj:req
				     ; Shorter than dec Subj,2 when non-acc 16 bit reg.
				      dec Subj
				      dec Subj
				     endm

				     top macro To:req
				     ; Top element of hardware stack without disturbing it.
				      pop To
				      push To
				     endm

				     move macro To:req,From:req,Via
				     ; Memory to memory with arguments in same order as a mov.
				      ifb <Via>
				       if (type To) eq 2
				         mov ax,From
				         mov To,ax
				       elseif (type To) eq 1
				         mov al,From
				         mov To,al
				       else
				         mov eax,From
				         mov To,eax
				       endif
				      else
				       mov Via,From
				       mov To,Via
				      endif
				     endm

				     ;------------------------------------------------------------------------------
				     ; Shapes of structures for based addressing.
				     ;------------------------------------------------------------------------------
				     ; If we PUSHA and then copy SP to BP the caller's
				     ; registers have become locals accessible on [BP].
				     ; Structure PushShape holds the shape for this.
 0010				     PushShape struct
 0000  0000			      di_ word ?
 0002  0000			      si_ word ?
 0004  0000			      bp_ word ?
 0006  0000			      sp_ word ?
 0008	    0000 [		      bx_ word Overlay
	     0000
	    ]
 0008  00			      bl_ byte ?
 0009  00			      bh_ byte ?
 000A	    0000 [		      dx_ word Overlay
	     0000
	    ]
 000A  00			      dl_ byte ?
 000B  00			      dh_ byte ?
 000C	    0000 [		      cx_ word Overlay
	     0000
	    ]
 000C  00			      cl_ byte ?
 000D  00			      ch_ byte ?
 000E	    0000 [		      ax_ word Overlay
	     0000
	    ]
 000E  00			      al_ byte ?
 000F  00			      ah_ byte ?
				     PushShape ends
				     ; Build characteristics:
 = 0000				      CD equ 0; On when dump of compaction activity needed. See CD.REXX
 = 0001				      Debug equ 1; On for normal checks detecting internal flaws early.
 = 0001				      MemCheck equ 1; On for DOS memory checks.
 = 0000				      ForBcode equ 0; When making code that will be turned to BCode.
 = 0000				      ForBig equ 0; When making code that will be turned into one big assembly.
 = 0001				      SortSpaceSS equ 1; Design has compaction list under SS.
 = 0000				      Trial equ 0; Design change experiment.
 = 0001				      Solid equ 1; Always 1, used to mark sensitive areas for ForBig technology.
				     ;(Solid section with following label is assumed not to fall through.)
				     if ForBig
				      endif
				     if Debug
				     CheckType macro
				      test V.Dtype,$Test
				      jz @F
				      cmp V.Dtype,$AwayString
				      je @F
				      cmp V.Dtype,$NullString
				      je @F
				      cmp V.Dtype,$NullString+1
				      je @F
				      cmp V.Dtype,$NullString+2
				      je @F
				      cmp V.Dtype,$NullString+3
				      je @F
				      cmp V.Dtype,$NullString+4
				      je @F
				      cmp V.Dtype,$NullString+5
				      je @F
				      cmp V.Dtype,$NullString+6
				      je @F
				      cmp V.Dtype,$NullString+7
				      je @F
				     endm
				     endif
				      EXTERNDEF ToWholeEbx:near; Converts from Rexx variable to integer in EBX.
				      EXTERNDEF Zero$$:near; Puts zero on the stack.
				      EXTERNDEF Then$$:near; Execution of THEN
				      EXTERNDEF DigitsChange:near; Called at places where Digits() setting may change.
				      EXTERNDEF ZoneNumerics:near; Updates Zone for fast access to numeric settings.
				      EXTERNDEF SetInherit:near; Inherit, for an external routine.
				      EXTERNDEF Compiling:near; To start compiling something.
				      EXTERNDEF Compiler:near; To start compiling something.
				      EXTERNDEF StartExecution:near; To start executing made Pcode.
				      EXTERNDEF StartExecutionY:near; To start executing made Pcode.
				      EXTERNDEF ResumeP$:near; To start executing Pcode after Bcode.
				      EXTERNDEF Command:near; To start compiling source named on a command.
				      EXTERNDEF AssureSiPlus:near
				      EXTERNDEF AssignExposed:near
				      EXTERNDEF Name2File:near
				      EXTERNDEF ZoneToLevel:near
				      EXTERNDEF BifBound:near; A place separating code on basis of address
				      EXTERNDEF ConstValue:near
				      EXTERNDEF ConstValueX:near
				      EXTERNDEF Terminate:near
				      EXTERNDEF UpperFirstAh:near
				      EXTERNDEF NotPresent:near
				      EXTERNDEF Consist:near
				      EXTERNDEF Serialize:near
				      EXTERNDEF RetEsSi:near
				      EXTERNDEF ExposedFs:near, DotsExposed:near
				     ; Make the memory services available to all modules.
				      EXTERNDEF InitMemory:near, AllocateCx_EsAx:near, InitSegDs:near
				      EXTERNDEF MoreSpaceEs:near,GiveDosMem:near
				      EXTERNDEF ParaAllocAx:near, Raise5p1:near, Raise5p1d:near
				      EXTERNDEF StackSafe:near, SetStack:near, UpStack:near
				     ; Most modules need to load values from Rexx variables to registers.
				      EXTERNDEF ToDsSiCx:near, NumDxBx:near
				     ; Many modules create pseudo-code, test operator attributes..
				      EXTERNDEF Scode:near, Pcode1:near, Pcode2:near, PcodeArg:near
				      EXTERNDEF PcodeGapBx:near, PcodeOp:near, OpFlags:near
				     ; Lookup things may be needed in execution, eg for DROP (abc)
				      EXTERNDEF Lookup:near,SymbolsSafe:near,SetSymLenJa:near,SymbolLook:near
				      EXTERNDEF VasDsSiCx:near
				     ; And a few more in common use.
				      EXTERNDEF Ax2DsSiCx:near,HeritageDi:near, Raise:near
				      EXTERNDEF Attributes:near; Table for uppercasing, etc.
				      EXTERNDEF ResultSpace:near, AwayEsAxCx:near
				      EXTERNDEF LinkBcode:near, LinkBcodeX:near
				      EXTERNDEF CONFIG_UPPER$$:near
				      EXTERNDEF CONFIG_RAISE40$$:near
				      EXTERNDEF PcodesBase$:near
				      EXTERNDEF DotsFsBxDsSi:near
				      EXTERNDEF DotsFsBxDsSiX:near
				      EXTERNDEF XCycle:near,Rejumps:near,Boolery:near,BooleryRejumps:abs
				      EXTERNDEF LookFileDsBx:near
				      EXTERNDEF Away:near
				      EXTERNDEF ClauseSourceEnd:near
				      EXTERNDEF DualSwitch:near
				     if Debug
				      EXTERNDEF Say$$:near ; only for Consist debug
				      EXTERNDEF DosMemCheck:near
				      EXTERNDEF Create4Dump:near
				      EXTERNDEF Dumper:near
				     endif

 = 0001				     $PcodesBase equ 01h
 = 005D				     $BPcodesCeil equ 05Dh
 = 00C5				     $PcodesCeil equ 0C5h
 = 0057				     $PjumpBase equ 057h
 = 0089				     $PjumpCeil equ 089h
 = 0001				     $pAbut equ 01h
 = 0003				     $pCat equ 03h
 = 0005				     $pNop equ 05h
 = 0007				     $pAssignDotsP equ 07h
 = 0009				     $pParse equ 09h
 = 000B				     $pResumeParse equ 0Bh
 = 000D				     $pNumber equ 0Dh
 = 000F				     $pTo equ 0Fh
 = 0011				     $pBy equ 011h
 = 0013				     $pFor equ 013h
 = 0015				     $pWhile equ 015h
 = 0017				     $pUntil equ 017h
 = 0019				     $pIterRep equ 019h
 = 001B				     $pIterate equ 01Bh
 = 001D				     $pLeave equ 01Dh
 = 001F				     $pUnDo equ 01Fh
 = 0021				     $pResult equ 021h
 = 0023				     $pReturn equ 023h
 = 0025				     $pReturns equ 025h
 = 0027				     $pExit equ 027h
 = 0029				     $pSay equ 029h
 = 002B				     $pBifq equ 02Bh
 = 002D				     $pLength equ 02Dh
 = 002F				     $pMax equ 02Fh
 = 0031				     $pMin equ 031h
 = 0033				     $pNot equ 033h
 = 0035				     $pAnd equ 035h
 = 0037				     $pOr equ 037h
 = 0039				     $pXor equ 039h
 = 003B				     $pPositive equ 03Bh
 = 003D				     $pNegate equ 03Dh
 = 003F				     $pAdd equ 03Fh
 = 0041				     $pSubtract equ 041h
 = 0043				     $pMultiply equ 043h
 = 0045				     $pDivide equ 045h
 = 0047				     $pIntDivide equ 047h
 = 0049				     $pRemainder equ 049h
 = 004B				     $pPower equ 04Bh
 = 004D				     $pCommand equ 04Dh
 = 004F				     $pInterpret equ 04Fh
 = 0051				     $pNumeric equ 051h
 = 0053				     $pInvoke equ 053h
 = 0055				     $pCall equ 055h
 = 0057				     $pRep equ 057h
 = 0059				     $pRepEver equ 059h
 = 005B				     $pControlVar equ 05Bh
 = 005D				     $pDotControlVar equ 05Dh
 = 005F				     $pThen equ 05Fh
 = 0061				     $pWhen equ 061h
 = 0063				     $pJump equ 063h
 = 0065				     $pEq equ 065h
 = 0067				     $pNe equ 067h
 = 0069				     $pLt equ 069h
 = 006B				     $pLe equ 06Bh
 = 006D				     $pGe equ 06Dh
 = 006F				     $pGt equ 06Fh
 = 0071				     $pSeq equ 071h
 = 0073				     $pSne equ 073h
 = 0075				     $pSlt equ 075h
 = 0077				     $pSle equ 077h
 = 0079				     $pSge equ 079h
 = 007B				     $pSgt equ 07Bh
 = 007D				     $pCeq equ 07Dh
 = 007F				     $pCne equ 07Fh
 = 0081				     $pClt equ 081h
 = 0083				     $pCle equ 083h
 = 0085				     $pCge equ 085h
 = 0087				     $pCgt equ 087h
 = 0089				     $pInterpEnd equ 089h
 = 008B				     $pSignal equ 08Bh
 = 008D				     $pSignalOn equ 08Dh
 = 008F				     $pCallOn equ 08Fh
 = 0091				     $pDots equ 091h
 = 0093				     $pAssign equ 093h
 = 0095				     $pAssignStem equ 095h
 = 0097				     $pAssignDots equ 097h
 = 0099				     $pAssignConst equ 099h
 = 009B				     $pUnstore equ 09Bh
 = 009D				     $pDrop equ 09Dh
 = 009F				     $pExpose equ 09Fh
 = 00A1				     $pBool equ 0A1h
 = 00A3				     $pIterCV equ 0A3h
 = 00A5				     $pAddress equ 0A5h
 = 00A7				     $pCommandEnv equ 0A7h
 = 00A9				     $pEnvName equ 0A9h
 = 00AB				     $pBif equ 0ABh
 = 00AD				     $pBifGroup equ 0ADh
 = 00AF				     $pRaise equ 0AFh
 = 00B1				     $pSignalOff equ 0B1h
 = 00B3				     $pSignalV equ 0B3h
 = 00B5				     $pSysVar equ 0B5h
 = 00B7				     $pDropList equ 0B7h
 = 00B9				     $pExposeList equ 0B9h
 = 00BB				     $pPush equ 0BBh
 = 00BD				     $pQueue equ 0BDh
 = 00BF				     $pTrace equ 0BFh
 = 00C1				     $pTraceEvent equ 0C1h
 = 00C3				     $pOptions equ 0C3h
 = 0000				     $BifDATE equ 0
 = 0001				     $BifTIME equ 1
 = 0002				     $BifLINES equ 2
 = 0003				     $BifCHARS equ 3
 = 0004				     $BifCHARIN equ 4
 = 0005				     $BifCHAROUT equ 5
 = 0006				     $BifLINEIN equ 6
 = 0007				     $BifLINEOUT equ 7
 = 0008				     $BifSTREAM equ 8
 = 0009				     $BifSTRIP equ 9
 = 000A				     $BifVERIFY equ 10
 = 000B				     $BifQUALIFY equ 11
 = 000C				     $BifWORDS equ 12
 = 000D				     $BifTRUNC equ 13
 = 000E				     $BifERRORTEXT equ 14
 = 000F				     $BifSPACE equ 15
 = 0010				     $BifTRANSLATE equ 16
 = 0011				     $BifFORMAT equ 17
 = 0012				     $BifWORDLENGTH equ 18
 = 0013				     $BifWORDPOS equ 19
 = 0014				     $BifABBREV equ 20
 = 0015				     $BifCENTER equ 21
 = 0016				     $BifCENTRE equ 22
 = 0017				     $BifCOMPARE equ 23
 = 0018				     $BifDELSTR equ 24
 = 0019				     $BifDELWORD equ 25
 = 001A				     $BifRIGHT equ 26
 = 001B				     $BifLASTPOS equ 27
 = 001C				     $BifINSERT equ 28
 = 001D				     $BifOVERLAY equ 29
 = 001E				     $BifFORM equ 30
 = 001F				     $BifDATATYPE equ 31
 = 0020				     $BifADDRESS equ 32
 = 0021				     $BifARG equ 33
 = 0022				     $BifCONDITION equ 34
 = 0023				     $BifTRACE equ 35
 = 0024				     $BifFUZZ equ 36
 = 0025				     $BifDIGITS equ 37
 = 0026				     $BifSOURCELINE equ 38
 = 0027				     $BifXRANGE equ 39
 = 0028				     $BifRANDOM equ 40
 = 0029				     $BifREVERSE equ 41
 = 002A				     $BifABS equ 42
 = 002B				     $BifSIGN equ 43
 = 002C				     $BifC2X equ 44
 = 002D				     $BifB2X equ 45
 = 002E				     $BifX2B equ 46
 = 002F				     $BifX2C equ 47
 = 0030				     $BifX2D equ 48
 = 0031				     $BifC2D equ 49
 = 0032				     $BifD2C equ 50
 = 0033				     $BifD2X equ 51
 = 0034				     $BifBITAND equ 52
 = 0035				     $BifBITOR equ 53
 = 0036				     $BifBITXOR equ 54
 = 0037				     $BifVALUE equ 55
 = 0038				     $BifCOPIES equ 56
 = 0039				     $BifWORD equ 57
 = 003A				     $BifWORDINDEX equ 58
 = 003B				     $BifSUBWORD equ 59
 = 003C				     $BifPOS equ 60
 = 003D				     $BifLEFT equ 61
 = 003E				     $BifSUBSTR equ 62
 = 003F				     $BifQUEUED equ 63
 = 0040				     $BifSYMBOL equ 64
 = 0041				     $BifCOUNTSTR equ 65
 = 0042				     $BifCHANGESTR equ 66
 = 0043				     $BifLENGTH equ 67
 = 0044				     $BifMAX equ 68
 = 0045				     $BifMIN equ 69
 = 00B3				     $BcodesBase equ 0B3h
 = 00B3				     Zero equ 0B3h
 = 00B5				     One equ 0B5h
 = 00B7				     Null equ 0B7h
 = 00B9				     String equ 0B9h
 = 00BB				     String1 equ 0BBh
 = 00BD				     String2 equ 0BDh
 = 00BF				     _RetBc equ 0BFh
 = 00C1				     _RetB equ 0C1h
 = 00C3				     _RetF equ 0C3h
 = 00C5				     _IterCV equ 0C5h
 = 00C7				     _Exists equ 0C7h
 = 00C9				     _Then equ 0C9h
 = 00CB				     _Jump equ 0CBh
 = 00CD				     _Eq equ 0CDh
 = 00CF				     _Ne equ 0CFh
 = 00D1				     _Lt equ 0D1h
 = 00D3				     _Le equ 0D3h
 = 00D5				     _Ge equ 0D5h
 = 00D7				     _Gt equ 0D7h
 = 00D9				     _Seq equ 0D9h
 = 00DB				     _Sne equ 0DBh
 = 00DD				     _Slt equ 0DDh
 = 00DF				     CONFIG_RAISE equ 0DFh
 = 00E1				     CONFIG_RAISE40 equ 0E1h
 = 00E3				     CONFIG_UPPER equ 0E3h
 = 00E5				     CONFIG_MSG equ 0E5h
 = 00E7				     CONFIG_C2B equ 0E7h
 = 00E9				     CONFIG_B2C equ 0E9h
 = 00EB				     CONFIG_STREAM_POSITION equ 0EBh
 = 00ED				     CONFIG_STREAM_CHARIN equ 0EDh
 = 00EF				     CONFIG_STREAM_QUERY equ 0EFh
 = 00F1				     CONFIG_STREAM_CLOSE equ 0F1h
 = 00F3				     CONFIG_STREAM_CHAROUT equ 0F3h
 = 00F5				     CONFIG_STREAM_COUNT equ 0F5h
 = 00F7				     CONFIG_STREAM_QUALIFIED equ 0F7h
 = 00F9				     CONFIG_STREAM_COMMAND equ 0F9h
 = 00FB				     CONFIG_STREAM_STATE equ 0FBh
 = 00FD				     CONFIG_TIME equ 0FDh
 = 00FF				     CONFIG_ARITH equ 0FFh
 = 0000				     $0 equ 0
 = 0000				     $Eos equ 0*4
 = 0001				     $12 equ 1
 = 0004				     $Semi equ 1*4
 = 0002				     $11 equ 2
 = 0008				     $UnAccept equ 2*4
 = 0003				     $6 equ 3
 = 000C				     $Lparen equ 3*4
 = 0004				     $3 equ 4
 = 0010				     $Percent equ 4*4
 = 0011				     $Asterisk equ 4*(5-1) + 1
 = 0012				     $Slash equ 4*(5-1) + 2
 = 0013				     $Rem equ 4*(5-1) + 3
 = 0014				     $Xor equ 5*4
 = 0015				     $Or equ 4*(6-1) + 1
 = 0006				     $5 equ 6
 = 0018				     $And equ 6*4
 = 0007				     $10 equ 7
 = 001C				     $Comma equ 7*4
 = 0020				     $Not equ 8*4
 = 0009				     $9 equ 9
 = 0024				     $Minus equ 9*4
 = 0025				     $Plus equ 4*(10-1) + 1
 = 002B				     $Eq equ 10*4+3
 = 002C				     $Ne equ 11*4
 = 002D				     $Lt equ 4*(12-1) + 1
 = 002E				     $Le equ 4*(12-1) + 2
 = 002F				     $Ge equ 4*(12-1) + 3
 = 0030				     $Gt equ 12*4
 = 0031				     $Seq equ 4*(13-1) + 1
 = 0032				     $Sne equ 4*(13-1) + 2
 = 0033				     $Slt equ 4*(13-1) + 3
 = 0034				     $Sle equ 13*4
 = 0035				     $Sge equ 4*(14-1) + 1
 = 0036				     $Sgt equ 4*(14-1) + 2
 = 000E				     $7 equ 14
 = 0038				     $Rparen equ 14*4
 = 003C				     $STRING equ 15*4
 = 0040				     $CONST_SYMBOL equ 16*4
 = 0044				     $NUMBER equ 17*4
 = 0012				     $28 equ 18
 = 0048				     $VAR_SYMBOL equ 18*4
 = 0013				     $1 equ 19
 = 004C				     $Abut equ 19*4
 = 004D				     $Cat equ 4*(20-1) + 1
 = 0014				     $8 equ 20
 = 0050				     $Power equ 20*4
 = 0015				     $2 equ 21
 = 0054				     $Assign equ 21*4
 = 0016				     $21 equ 22
 = 0058				     $VALUE equ 22*4
 = 0017				     $16 equ 23
 = 005C				     $END equ 23*4
 = 0018				     $18 equ 24
 = 0060				     $THEN equ 24*4
 = 0019				     $17 equ 25
 = 0064				     $FOR equ 25*4
 = 001A				     $19 equ 26
 = 0068				     $TO equ 26*4
 = 001B				     $15 equ 27
 = 006C				     $BY equ 27*4
 = 0070				     $UNTIL equ 28*4
 = 0074				     $WHILE equ 29*4
 = 001E				     $23 equ 30
 = 0078				     $WITH equ 30*4
 = 007C				     $LINEIN equ 31*4
 = 007D				     $SOURCE equ 4*(32-1) + 1
 = 007E				     $VERSION equ 4*(32-1) + 2
 = 0080				     $PULL equ 32*4
 = 0084				     $VAR equ 33*4
 = 0088				     $ARG equ 34*4
 = 008C				     $ADDRESS equ 35*4
 = 0090				     $APPEND equ 36*4
 = 0094				     $CALL equ 37*4
 = 0098				     $DO equ 38*4
 = 009C				     $ELSE equ 39*4
 = 00A0				     $NOP equ 40*4
 = 00A4				     $INTERPRET equ 41*4
 = 00A5				     $OPTIONS equ 4*(42-1) + 1
 = 00A8				     $EXIT equ 42*4
 = 00A9				     $PUSH equ 4*(43-1) + 1
 = 00AA				     $QUEUE equ 4*(43-1) + 2
 = 00AB				     $RETURN equ 4*(43-1) + 3
 = 00AC				     $SAY equ 43*4
 = 00B0				     $TRACE equ 44*4
 = 00B4				     $LEAVE equ 45*4
 = 00B5				     $ITERATE equ 4*(46-1) + 1
 = 00B8				     $DROP equ 46*4
 = 00BC				     $EXPOSE equ 47*4
 = 00C0				     $SIGNAL equ 48*4
 = 00C4				     $SYNTAX equ 49*4
 = 00C5				     $LOSTDIGITS equ 4*(50-1) + 1
 = 00C6				     $NOVALUE equ 4*(50-1) + 2
 = 00C8				     $NOTREADY equ 50*4
 = 00C9				     $FAILURE equ 4*(51-1) + 1
 = 00CA				     $HALT equ 4*(51-1) + 2
 = 00CC				     $ERROR equ 51*4
 = 00D0				     $UPPER equ 52*4
 = 00D4				     $IF equ 53*4
 = 00D8				     $INPUT equ 54*4
 = 00DC				     $NAME equ 55*4
 = 00E0				     $NUMERIC equ 56*4
 = 00E4				     $DIGITS equ 57*4
 = 00E5				     $FUZZ equ 4*(58-1) + 1
 = 00E8				     $FORM equ 58*4
 = 00EC				     $ENGINEERING equ 59*4
 = 00ED				     $SCIENTIFIC equ 4*(60-1) + 1
 = 00F0				     $OTHERWISE equ 60*4
 = 00F4				     $OUTPUT equ 61*4
 = 00F8				     $PARSE equ 62*4
 = 00FC				     $PROCEDURE equ 63*4
 = 0100				     $SELECT equ 64*4
 = 0104				     $WHEN equ 65*4
 = 0108				     $REPLACE equ 66*4
 = 010C				     $STEM equ 67*4
 = 0110				     $STREAM equ 68*4
 = 0114				     $NORMAL equ 69*4
 = 0118				     $FOREVER equ 70*4
 = 011C				     $OFF equ 71*4
 = 0120				     $ON equ 72*4
 = 0000				     $sPercent equ 0
 = 0006				     $sDrop equ 6
 = 0009				     $sStem equ 9
 = 000A				     $sWith equ 10
 = 000B				     $sDropList equ 11
 = 0014				     $sMinus equ 20
 = 0017				     $sLength equ 23
 = 001B				     $sEq equ 27
 = 0021				     $sSeq equ 33
 = 0027				     $sDigits equ 39
 = 002A				     $sNop equ 42
 = 002B				     $sForm equ 43
 = 002D				     $sAddress equ 45
 = 0030				     $sNegate equ 48
 = 0031				     $sPositive equ 49
 = 0032				     $sExit equ 50
 = 0035				     $sReturns equ 53
 = 0037				     $sNumber equ 55
 = 0039				     $sRaise equ 57
 = 003E				     $sLeave equ 62
 = 003F				     $sIterate equ 63
 = 00FE				     ParseDot equ 254; A non-operator Bcode value otherwise unused.
 = 0028				     KeysBase equ 4*10; Manual
				     ; Here are some symbolic names of registers, used for readability of this code.
 = bp				     ZeroBp is <bp>
 = di				     StackDi is <di>      ; The soft stack pointer.
 = si				     StackSi is <si>      ; Another soft stack pointer.
 = dx				     StackDx is <dx>      ; Limit of range on soft stack.
 = bx				     ArrayBx is <bx>      ; To an element of Vshape.
 = bx				     StemBx is <bx>       ; When the subject is a stem.
 = si				     TailSi is <si>       ; When the subject is a tailed variable.
 = bx				     FileBx is <bx>       ; To an element of Fshape.
 = si				     ArraySi is <si>      ; To an element of Vshape.
 = bx				     OperandBx is <bx>    ; A pointer to an operand in one of the arrays of Vshapes.
 = bl				     OperandBl is <bl>    ;
 = bx				     ProbeBx is <bx>      ; Used when searching a binary tree for a stemmed variable.
 = si				     LowSi is <si>        ; Used when searching a binary tree.
 = di				     HighDi is <di>       ; Used when searching a binary tree.
 = ax				     ToFindLenAx is <ax>  ; Used when searching a binary tree.
 = dx				     ToFindDx is <dx>     ; Used when searching a binary tree.
 = cx				     KeyListCx is <cx>;   ; Parameter to keyword lookup.
 = ch				     TokNowCh is <ch>;    ; One of the places numbers for tokens are held.
 = si				     StateSi is <si>      ; The state in parsing.
 = si				     ParseSi is <si>      ; Parse state pushed on hard stack.
 = di				     StateDi is <di>      ; Address first word of the state.
 = bx				     StateBx is <bx>      ; Often distance from StateOrig to some state data.
 = dx				     ParseDx is <dx>      ; Token data in form the parser uses.
 = ah				     RtypeAh is <ah>      ; Type of reduction done in Cycle.
 = ah				     TokNumAh is <ah>     ; Where next token is returned, becoming TokNum.
 = si				     LookupSi is <si>     ; Where Lookup finds unresolved compound symbol.
 = si				     LevelSi is <si>      ; To block for this invocation level.
 = di				     LevelDi is <di>
 = si				     CursorSi is <si>     ; Offset in Pcode.
 = bx				     CursorBx is <bx>     ; Offset in Pcode.
 = cx				     OpAppendCx is <cx>   ; Numeric argument to PcodeOp routine.
 = si				     ScanSi is <si>       ; Scanning the user's source program.
 = cl				     OpAppendCl is <cl>
 = al				     RawCharAl is <al>
 = ah				     RawCharAh is <ah>
 = al				     AttribAl is <al>
 = dl				     RadixTypeDl is <dl>
 = cx				     ParmsCx is <cx>
 = cl				     ParmsCl is <cl>
 = bx				     LengthAtBx is <bx>
 = dx				     SymsZiDx is <dx>
 = di				     SegOffDi is <di> ; Offset in Zone of a segment pointer.
				     ; Special use of bp for two-byte call.
 = call bp			     Error49Bp is <call bp>
				     ; Shorthand for current byte of input.
 = byte ptr ss:[si+bp]		     RawChar is <byte ptr ss:[si+bp]>
				     ; These for making messages.
 = bl				     DepthBl is <bl>; of recursion.
 = bx				     DepthBx is <bx>; Bug if inc/dec affects bh.
 = bh				     TheMsgBh is <bh>; on when scanning the target.
 = cx				     PartLenCx is <cx>; Amount of compressed to expand.
 = cl				     LowPartLenCl is <cl>
 = cx				     KeywordOffsetCx is <cx>
 = dx				     MajMinDx is <dx>
 = dh				     MajorDh is <dh>
 = dl				     MinorDl is <dl>
 = dx				     MinorDx is <dx>; inc/dec
 = si				     ScannerSi is <si>; SI the address in table. (LODS used)
				     ; For segment registers.
				     ; ES has some transient uses (particularly because it cannot be overridden
				     ; in movsb) but mainly it is set to the symbols segment during compilation
				     ; and the program scope segment during execution.  Tailed variable references
				     ; also use it (transiently) because each stem variable has it's own segment.
 = es				     SymbolsEs is <es>
 = es				     ProgEs is <es>
 = es				     StemEs is <es>

 = 0019				     $DosDisk equ 19h
 = 002A				     $DosDate equ 2Ah
 = 002C				     $DosTime equ 2Ch
 = 003C				     $DosCreate equ 3Ch
 = 003D				     $DosOpen equ 3Dh
 = 003E				     $DosClose equ 3Eh
 = 003F				     $DosRead equ 3Fh
 = 0040				     $DosWrite equ 40h
 = 0041				     $DosDelete equ 41h
 = 0042				     $DosSeek equ 42h
 = 0043				     $DosChmod equ 43h
 = 0047				     $DosPath equ 47h
 = 0048				     $DosAllocate equ 48h
 = 0049				     $DosFree equ 49h
 = 004A				     $DosModifyAllocated equ 4Ah
 = 004B				     $DosExecute equ 4Bh
 = 004C				     $DosExit equ 4Ch
 = 004D				     $DosReturnCode equ 4Dh
 = 0059				     $DosGetError equ 59h
 = 0062				     $DosPSP equ 62h
				     ; As allowed by the Standard:
 = 000A				     $Limit_EnvironmentName equ 10
 = C350				     $Limit_String equ 50000
 = 00FA				     $Limit_Literal equ 250
 = 00FA				     $Limit_Name equ 250
 = 270F				     $Limit_Digits equ 9999; Note Msg33.2 must be generated to match.
 = 0009				     $Limit_ExponentDigits equ 9
 = 0032				     $Limit_Insert equ 50; Longest insert.
				     ; Ours
 = 0036				     $Limit_Major equ 54; Highest message user sees.
 = 0037				     $Descriptions equ 55; A place in the message numbering for oddment prose.
 = 00C8				     $MsgRoom equ 4*$Limit_Insert
 = 00AF				     $MaxPreInsert equ 175; Chars in message.
 = 0050				     $MsgChunk equ 80; Strictly, ANSI says leave chunking to system.
 = 0064				     $MaxParms equ 100; Per invokation. (Or temporary results within an expression)
 = 0400				     $FileBufferSize equ 1024
 = 0003				     $Leeway equ 3
				     ; Data types within symbols segment:
 = 00FF				     $tChar equ 0FFh
 = 00FE				     $tLabel equ 0FEh
 = 00FD				     $tBinary equ 0FDh
				     ; Minor bits on an operand reference.
 = 0006				     $CaseTarget equ 6
				     ; Subcodes to Pcodes.
				     ; These are used by the utility. Avoid putting semicolon abutting the "h".
				     ; These markers share values with Sysvar references in Bcode but we don't
				     ; parse into sysvars in our Bcode.
				     ; If we want to detect presence/absence of these they need to be 2 modulo 8.
				     ; However if they always follow something known, any value will do.
				     ; In practice we sometimes use the modulo 8 approach (even at the expense of
				     ; a shift when they are used) so as to make scanning of Pcode simpler.
 = 0002				     $mRepTail equ 02h        ; Used when $pDotControlVar addresses tails.
 = 000A				     $mUpper equ 0Ah          ; Modifier on parse source.
 = 0012				     $mParseEscape equ 12h    ; Parse part too complex to handle as single action.
 = 001A				     $mParseEnd equ 1Ah       ; Parse ends.
 = 0022				     $mPosRest equ 22h        ; Parse trigger
 = 002A				     $mPattern equ 2Ah        ; Parse trigger after operand
 = 0032				     $mPosEq equ 32h          ; Parse trigger after operand
 = 003A				     $mPosPlus equ 3Ah        ; Parse trigger after operand
 = 0042				     $mPosMinus equ 42h       ; Parse trigger after operand
 = 004A				     $mTemplateComma equ 4Ah  ; Parse trigger
				     ; These in number field of $pParse:
 = 0000				     $nVar equ 0              ; These
 = 0002				     $nWith equ 2             ;       two lowest of parse sources.
 = 0004				     $nArg equ 4
 = 0006				     $nLineIn equ 6
 = 0008				     $nPull equ 8
 = 000A				     $nSource equ 10
 = 000C				     $nVersion equ 12
				     ; These in number field of $pCommandEnv
 = 0000				     $nStem equ 00h
 = 0020				     $nStream equ 20h
 = 0040				     $nNormal equ 40h
				     ; These in number field of $pNumeric
 = 0000				     $nDigits equ 00h
 = 0002				     $nFuzz equ 02h
 = 0004				     $nForm equ 04h
				     ; These in number field of $pRaise
 = 0000				     $n7p3 equ 0
 = 0002				     $n17p1 equ 2
 = 0004				     $n40p3 equ 4
 = 0006				     $n40p4 equ 6
 = 0008				     $n40p5 equ 8
				     ; Types for things in Z.Serial
				     ; $SerialNone is also used for message building.
				     ; $SerialSource is qualified by Z.RelativeNow - what part of source file.
				     ; These are modals except for $SerialCompaction which saves/restores previous.
 = 0000				     $SerialNone equ 0
 = 0001				     $SerialQue equ 1
 = 0002				     $SerialCompaction equ 2
 = 0003				     $SerialInterpret equ 3
 = 0004				     $SerialSource equ 4
				     ; Trace events. (Order unexploited except for highest.)
 = 0000				     $TraceAssign equ 0
 = 0002				     $TraceBY equ 1*2
 = 0004				     $TraceClause equ 2*2
 = 0006				     $TraceCompound equ 3*2
 = 0008				     $TraceDot equ 4*2
 = 000A				     $TraceError equ 5*2
 = 000C				     $TraceExpr equ 6*2
 = 000E				     $TraceFailure equ 7*2
 = 0010				     $TraceFunction equ 8*2
 = 0012				     $TraceOperator equ 9*2
 = 0014				     $TracePrefix equ 10*2
 = 0016				     $TraceLit equ 11*2
 = 0018				     $TraceVar equ 12*2
 = 001A				     $TraceBack equ 13*2; Highest for $TrEv.
 = 001C				     $TraceParse equ 14*2; Only sets flag.
 = 001E				     $TraceEndClause equ 15*2; Compiled at end of a traced clause.
				     ; Descriptions on messages.    See OverfullMem for some.
				     Assert Zshape.SysFiles-Zshape.SysFiles eq 2*1-2
				     Assert Zshape.Consts-Zshape.SysFiles eq 2*2-2
				     Assert Zshape.Vars-Zshape.SysFiles eq 2*3-2
				     Assert Zshape.ProgScope-Zshape.SysFiles eq 2*4-2 ; Used for 'memory' msg.
				     Assert Zshape.VarScope-Zshape.SysFiles eq 2*5-2 ; Used for 'string length'
				     Assert Zshape.Symbols-Zshape.SysFiles eq 2*6-2
				     Assert Zshape.Code-Zshape.SysFiles eq 2*7-2
				     Assert Zshape.Zone-Zshape.SysFiles eq 2*8-2
				     Assert Zshape.Stem-Zshape.SysFiles eq 2*9-2
 = 0005				     $DescString equ 5
 = 000A				     $DescArgs   equ 10
 = 000B				     $Desc59H    equ 11
 = 000C				     $DescFiles  equ 12
 = 000D				     $DescQueue  equ 13
 = 0080				     $BifTag equ 80h; Helps with reverse lookup
				     ; As well as source coming from a file, there are the cases of INTERPRET,
				     ; VALUE, and SYMBOL where some compiling is needed.  Also VarPool cases.
				     ; Even if only Lookup is needed, it can be simplest to compile and pick
				     ; the answer up from the generated code.
 = 11C8				     $SourceBufferSize equ 4552; Allows for long bit literal.
 = 2000				     $InitStackSize equ 8192
 = 0000				      $White equ 0
 = 0040				      $Digit equ 64
 = 0080				      $Letter equ 128
 = 00C0				      $Special equ 192
 = 0008				      $NonUpable equ 8
 = 0004				      $Bb equ 4
 = 0002				      $Xx equ 2
 = 0001				      $Ee equ 1
 = 0048				      $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; Constants for Bifs.
 = FFB9				     $BifBase equ 65535-70; 68 bifs at high numbers.
				     ; The equates for pseudo code operations are with the P switch.
				     ; (See also $Reserved)
 = 00C0				     $Test       equ 11000000b; To test the most vital bits.
 = 0080				     $NullString equ 10000000b; 01000nnn for 0-7 length strings.
 = 0088				     $Omitted    equ 10001000b; Value of omitted is null string.
 = 0089				     $Variable   equ 10001001b; Only used at compile time.
 = 008A				     $Constant   equ 10001010b; Only used at compile time. (Untyped constant.)
 = 008B				     $Label      equ 10001011b;
 = 00C0				     $AwayString equ 11000000b;
				     ; NYI $AwayNumber equ 11110000b;
				     ; The 01 tags don't reach the runtime stack.
				     ; (That avoids a test when type checking operands now and allows future use.)
 = 0040				     $Dropped    equ 01000000b;
 = 0050				     $Exposed    equ 01010000b;
 = 0060				     $Stem       equ 01100000b;
 = 0044				     $MsgNum     equ 01000100b; Msg number in Major/Minor form.
 = 0048				     $Sigl       equ 01001000b; Jump point still as code offset.
				     ; Not to be confused with the bits from the table of characters:
				     XlatBDLS macro ;; 0=Blanks 1=Digits 2=Letters 3=Special
				      
; Picks up attributes of current char and sets flags.
				      xlat Bptr cs:[bx]
				      test al,0C0h
				     endm
				     Down macro
				      sub StackDi,$StrideV
				     endm
				     Up macro
				      add StackDi,$StrideV
				     endm
				     DownCare macro
				      lea StackDi,(-$StrideV)[StackDi]
				     endm
				     UpCare macro
				      lea StackDi,$StrideV[StackDi]
				     endm
				     ; Hard & soft cursors return.
				     RetSi macro
				      pop CursorSi
				      ret
				     endm
				     ; Macros for some common idioms in Pcode making.
				     OpAl macro $p
				       mov al,$p
				       call PcodeOp
				     endm
				     OpRet macro $p
				       mov al,$p
				       jmp PcodeOp
				     endm
				     EvAh macro $p
				       mov ah,$p
				       call TraceEvent
				     endm
				     EvRet macro $p
				       mov ah,$p
				       jmp TraceEvent
				     endm

				     ; Macros are used to make that clear where code is run out of the interpreter
				     ; loop, and to allow experiments in how the return is made.
				     ; These experiments never worked out because of the difficulty in having some
				     ; operations that needed to be routines (eg Assign as part of ControlVar) and
				     ; some that didn't.  Changing code to achieve sometimes-routine is a speed
				     ; killer.

				     Back macro
				     jmp XCycle
				     endm
				     BackRet macro
				     ret
				     endm

				     ; When all the operations end with a jump to XCycle we can turn them into
				     ; callable routines by sticking a ret instruction the code at XCycle.
				     ; Performance killer so rarely used.
 = 00C3				     $ret equ 0C3h
				     CodeModeR macro
				      push Wptr cs:XCycle
				      mov Bptr cs:XCycle,$ret
				     endm
				     UnCodeMode macro
				      pop Wptr cs:XCycle
				     endm

				     Repmovsb macro
				     local IsEven
				     if 1
				      rep movsb
				     endif
				     if 0
				     ; This ought to be faster but didn't seem to be. Perhaps jnc high cost.
				      shr cx,1
				      rep movsw
				      jnc IsEven
				      movsb
				      IsEven:
				     endif
				     endm

				     ; There is a "mv" macro that moves registers by push & pop.
				     ; There is a "move" that saves typing when memory-to-memory.
				     ; Here is "Mv" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by push & pop.
				     ; Here is "Move" that moves a Rexx variable (8 bytes addressed by pointer
				     ; register) memory-to-memory by shuffling through general registers.
				     Mv macro To,From
				     ; "Move" is faster than "Mv" and no bigger, if there is a spare register.
				        pushd From.OverExpo
				        pop To.OverExpo
				        pushd From.OverMant
				        pop To.OverMant
				     endm

				     Move macro To,From,Via
				     ; Move of a Rexx value. Convention is to use ecx:eax
				      ifb <To>
				     ; No target means load usual registers.
				        mov ecx,From.OverExpo
				        mov eax,From.OverMant
				      elseifb <From>
				     ; No source means store from usual registers.
				        mov To.OverExpo,ecx
				        mov To.OverMant,eax
				      elseifb <Via>
				     ; Copy via usual registers.
				        mov ecx,From.OverExpo
				        mov To.OverExpo,ecx
				        mov eax,From.OverMant
				        mov To.OverMant,eax
				      else
				     ; Copy via specified register.
				       mov Via,From.OverExpo
				       mov To.OverExpo,Via
				       mov Via,From.OverMant
				       mov To.OverMant,Via
				      endif
				     endm

 0006				     FarpX struc
 0000	    0000 [		      Fr dword Overlay
	     00000000
	    ]
 0000  0000			      Pt charp 0
 0002  0000			      Sg Segp 0
 0004	    0000 [		      Limit word Overlay
	     0000
	    ]
 0004  0000			      Len word 0
				     FarpX ends


 0008				     Vshape union
				      struc; When containing a short string.
 0000	    0007 [		       String db 7 dup(?)
	     00
	    ]
 0007  00			       Dtype db ?                        ; Whether string or not and used length.
				      ends
				      struc; When binary number
				       Sign byte Overlay     ; Odd means negative mantissa.
				       ExpAnd dword Overlay  ; Exponent and sign of mantissa.
				        ExpoUses db 3 dup(?)
				        ExpoSign db ?        ; Sign of exponent.
				       Mantissa dword Overlay
				        MantLow word ?
				        MantHigh word ?
				      ends
				      struc; When treated as just bytes.
				       OverExpo dword ?
				       OverMant dword ?
				      ends
				      struc; When referencing a long string.
				       FarpX <>
				       dw ?                              ; Covers Dtype.
				      ends
				      struc; When referencing label information
				       LabelValue word ?                 ; Offset in Pcode.
				       dword ?
				       LabelType word Overlay
				       byte ?                            ; 0 = normal, 1 = TraceOnly
				       db ?                              ; Covers Dtype. Will be $Label.
				      ends
				      struc; When compile time stack item for a constant.
				       WhichCon word ?                  ; Offset under ProgScope.
				       PcodePos word ?                  ; Where it will be in Pcode.
				       db 4 dup(?)                       ; Covers Dtype. Will be $Constant.
				      ends
				      struc; When compile time stack item for a resolved target.
				       HeldOver word ?                   ; To go in Pcode eventually.
				       db 6 dup(?)                       ; Covers Dtype. Will be $NullString
				      ends
				      struc ; When used to look up symbols.  Dtype not relevant then.
				     ; Moot whether this is really a Vshape but pretending it is allows use of Vbx.
				       Pair dd 0 dup(?)                  ; Next two together.
				        Lower Ushortp ?                  ; a subtree.
				        Higher Ushortp ?                 ; a subtree
				       Here charp ?                      ; to the symbol.
				      ends
				     Vshape ends
				     ; V. is for Vshape objects addressed by [di+bp]; eg variables on the stack.
 = (Vshape ptr[bp+di])		     V is <(Vshape ptr[bp+di])>
				     ; 1-origin numbers for the parameters of bif, but V is used for V1 (and result).
				     ; So lhs and rhs of binary operation are V and V2, result overlays V.
				     ; Of course, changing di by $StrideV is an alternative to using different Vn.
 = 0008				     $StrideV equ size Vshape
 = 0003				     $ShiftV equ 3
 = (Vshape ptr[bp+di-$StrideV])	     V0 is <(Vshape ptr[bp+di-$StrideV])>
 = (Vshape ptr[bp+di-2*$StrideV]     V00 is <(Vshape ptr[bp+di-2*$StrideV])>
   )
 = (Vshape ptr[bp+di+$StrideV])	     V2 is <(Vshape ptr[bp+di+$StrideV])>
 = (Vshape ptr[bp+di+2*$StrideV]     V3 is <(Vshape ptr[bp+di+2*$StrideV])>
   )
 = (Vshape ptr[bp+di+3*$StrideV]     V4 is <(Vshape ptr[bp+di+3*$StrideV])>
   )
				     ; Vsi. is for Vshape objects addressed by [si+bp]; variables on the stack.
 = (Vshape ptr[bp+si])		     Vsi is <(Vshape ptr[bp+si])>
				     ;Vsif. is for Vshape objects addressed by fs:[si]; Variables of procedure.
 = fs:(Vshape ptr[si])		     Vsif is <fs:(Vshape ptr[si])>
				     ; Vdid. is for Vshape objects addressed by ds:[di]
 = ds:(Vshape ptr[di])		     Vdid is <ds:(Vshape ptr[di])>
				     ; Vsid. is for Vshape objects addressed by ds:[si]
 = ds:(Vshape ptr[si])		     Vsid is <ds:(Vshape ptr[si])>
				     ;Vbx. is for Vshape objects addressed by ds:[bx]
 = ds:(Vshape ptr[bx])		     Vbx is <ds:(Vshape ptr[bx])>
				     ;Vbxf. is for Vshape objects addressed by fs:[bx]; Variables of procedure.
 = fs:(Vshape ptr[bx])		     Vbxf is <fs:(Vshape ptr[bx])>
 = fs:(Vshape ptr[bx-$CaseTarget     Vbxt is <fs:(Vshape ptr[bx-$CaseTarget])>
   ])
 = fs:(Vshape ptr[bx+$StrideV])	     Vbxf2 is <fs:(Vshape ptr[bx+$StrideV])>
				     ;Vbxs. is for Vshape objects addressed by ss:[bx]; Variables on the stack.
 = ss:(Vshape ptr[bx])		     Vbxs is <ss:(Vshape ptr[bx])>
				     ;Ve. is for Vshape objects addressed by es:[bp]; (Saves a byte sometimes)
 = es:(Vshape ptr[bp])		     Ve is <es:(Vshape ptr[bp])>
 = fs:(Vshape ptr[bp])		     Vf is <fs:(Vshape ptr[bp])>
				     ;Vbxe. is for Vshape objects addressed by es:[bx]
 = es:(Vshape ptr[bx])		     Vbxe is <es:(Vshape ptr[bx])>
				     if 0
				     endif
 0028				     Dshape struc; The elements of soft stack for DO loops.    (And INTERPRET)
				     ; Here the n of "DO n;" will wind up.
				     ; Also x of DO j=x...  We don't need to retain that through the DO-END, but
				     ; harmless to do so. (Overlaid when DO A.K=....)
 0000	    0000 [		      TailsAt word Overlay; Where the pcode to reload tails is.
	     0000
	    ]
 0000	    0000 [		      Subject Vshape 0 dup(<>); When block is for an INTERPRET.
	     0007 [
	      00 00
	     ]
 0000	     0000 [		      CVinit Vshape 0 dup(<>)
	      0007 [
	       00 00
	      ]
 0000	      0007 [		      Reps Vshape <>
	       00
	      ] 00
 0008	      0007 [		      To Vshape <>
	       00
	      ] 00
 0010	      0007 [		      By Vshape <>
	       00
	      ] 00
 0018	      0007 [		      ForCount Vshape <>
	       00
	      ] 00
				     ; The rest is made similar to a Vshape so that Bcode can overlay Dshape as
				     ; variables.
 0020	      0000 [		      PcodePos charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0020  0000			      Iteration charp ?; Where to branch on ITERATE
 0022  0000			      Leaving charp ?  ; Where to branch on LEAVE
 0024	      0000 [		      UpDO charp Overlay; When block used for an INTERPRET.
	       0000
	      ]
 0024  0000			      CV charp ?; Offset of the control variable.
 0026  00			      byte ?
 0027  00			      Rec byte ?;  MASM confused when LoopsRec<> used.
				     Dshape ends
 = 0028				     $StrideD equ size Dshape
				     ; D. is for Dshape objects addressed by [di+bp]; the DO nesting.
				     ; These objects are addressed from partway through them.  This is because the
				     ; XCycle loop benefits from moving StackDi over the "previous operand" when
				     ; loading the latest operand. But the "previous operand" may actually have
				     ; been one of these DO control blocks.
				     ; Use D1 to address the DO block when StackDi has been upped to indicate
				     ; there is a value stacked later than the DO block.
 = (Dshape ptr[bp+di-$StrideD+$S     D is <(Dshape ptr[bp+di-$StrideD+$StrideV])>
   trideV])
 = (Dshape ptr[bp+di-$StrideD])	     D1 is <(Dshape ptr[bp+di-$StrideD])>

				      FRec record Qual:1,Read:1,Open:1,BeenRead:1,BeenWrite:1,
				                  WriteMode:1,IsSource:1,BeenCompiled:1,FFpad:8
 001A				     Fshape struct ; Data for a file, the key is the file name.
 0000  0000			       Flags FRec <>
 0002  0000			       ToQual word ? ; To item for fully qualified name.
 0004  00000000			       Lines Ulong ?
 0008  0000			       Hand Handle ?
 000A  00000000			       Other_Position Ulong ? ; A position on the file, provided by DOS.
 000E  00			       Exten byte ?; 1=REX/CMD 2=COM 3=EXE 4=BAT
 000F  00			       TraceWidth byte ?; How many chars in a clause identifier.
 0010  0000			       Symbols Segp ? ; Saved from Zone when file inactive.
 0012  0000			       Code Segp ?
 0014  0000			       Vars Segp ?
 0016  0000			       Consts Segp ?
 0018  0000			       ProgScope Segp ?
				     Fshape ends
 = 001A				     $StrideF equ size Fshape
				     ; F. is for Fshape objects addressed by [bx]; a file.
				     ; An Fshape is put ahead of a Jshape.
 = (Fshape ptr[bx-$StrideF])	     F is <(Fshape ptr[bx-$StrideF])>

 0008				     EnvBlock struc 2
 0000  0000			      EnvNumber    word ?
 0002  0000			      EnvResourceI word ?
 0004  0000			      EnvResourceO word ?
 0006  0000			      EnvResourceE word ?
				     EnvBlock ends
				     if 1; Private to memory object
 0006				     Ashape struc; Describe pieces of memory got from Dos, and part of them used.
 0000  0000 0000		      Fr Farp <>
 0004  0000			      Amount Ushort 0
				     Ashape ends
				     ; A. is for Ashape objects addressed by [si+bp]; For memory allocation.
 = (Ashape ptr[bp+si])		     A is <(Ashape ptr[bp+si])>
 = 0006				     $StrideA equ size Ashape
				     endif
 0015				     InsBlock struc;  Used by issuing of messages, to deduce inserts.
 0000	      0000 [		      MajMin word Overlay    ; This is an error detected.
	       0000
	      ]
 0000  00			       Minor byte ?
 0001  00			       Major byte ?
 0002  0000			      Value word ?           ; Soft stack offset of value.
 0004	      0000 [		      Named Ushort Overlay
	       0000
	      ]
 0004  0000			      Position Ushort ?
 0006  0000			      KeysList charp ?       ; Yields keyword list
 0008  00			      ArgNum byte ?
 0009  00			      Desc byte ?            ; To find text of <Description>
 000A	      0000 [		      Hex byte Overlay
	       00
	      ]
 000A  00			      Char byte ?
 000B  0000			      Options charp ?        ; Msg 40.28
 000D  0000			      OptsHi charp ?         ; Msg 40.28
 000F  0000			      Digits word ?          ; Msgs 26.1 and 33.1  Don't overlay, zero meaningful.
 0011  0000			      TokPos charp ?         ; Position of token within segment holding source.
 0013  0000			      TokLen Ushort ?        ; Ushort although inserts have low limit length.
				     InsBlock ends

				     ; "Interacting" is a bug for "Interactive" ?. Pad 8 makes byte offset zero.
				     LevelRec record Lpad:8,InheritDone:1,DigitsSet:1,IsProcedure:1,IsExternal:1,
				         IsFunction:1,Lpad2:3

				     LevelRecI record LIPad:14,Interactive:1,ConditionInstruction:1
				     ; Instruction.Condition and ConditionInstruction are the same value.

				     ConditionRec record Enabling:1,Delayed:1,PendingNow:1,Instruction:1,CRspare:4

 007C				     Lshape struc; The elements of soft stack for invocations.
				     ; The part inherited from the level above. (When there is one.)
				      align 4; We move the inherited bit using doublewords.
 0000	      0000 [		       DigitsFuzz dword Overlay
	       00000000
	      ]
 0000  0000			       Digits Ushort ?
 0002  0000			       Fuzz Ushort ?
 0004  00			       Form char ?
 0005  0000000000000000		       StartTime qword ?
 000D	      0000 [		       TraceLetter char Overlay
	       00
	      ]
 000D  0000			       TraceWord word ?; LevelRecI <>.
 000F  0000 0000 0000 0000	       Active EnvBlock <>
 0017  0000 0000 0000 0000	       Alternate EnvBlock <>
 001F  00			       Syntax ConditionRec <>
 0020  00			       LostDigits ConditionRec <>
 0021  00			       NoValue ConditionRec <>
 0022  00			       NotReady ConditionRec <>
 0023  00			       Error ConditionRec <>
 0024  00			       Failure ConditionRec <>
 0025  00			       Halt ConditionRec <>
 0026	      0007 [		       TrapName word 7 dup(?)
	       0000
	      ]
 0034  0000			       EventLevel word ?   ; Only used for Halt.
 0036  0000			       Condition word ?    ; As CONDITION bif result(C)
 0038	      0007 [		       ConditionDescription Vshape <>; As CONDITION bif result(D)
	       00
	      ] 00
 0040	      0007 [		       ConditionExtra Vshape <>; As CONDITION bif result(E)
	       00
	      ] 00
				      align 4; We move the inherited bit using doublewords.
 0048	      0000 [		       Inherit char Overlay; End of inherited.
	       00
	      ]
 0048  0000000000000000		      ClauseTime qword ?
 0050  0000000000000000		      ClauseLocal qword ?
 0058  0000000000000000		      PendingDescription qword ?
 0060  0000000000000000		      PendingExtra qword ?
 0068  0000			      LevelDO charp ?;  Level's CurrentDO held over call.
 006A  0000 0000		      StackSave Farp <>; To make save over DosExecute recursive.
 006E  0000			      File charp ?     ; Save which external file is source when external call made.
 0070  0000			      ProgScope Segp ? ; Saved values of constants, when external call.
 0072  0000			      VarScope Segp ?  ; Saved values of variables, when external call.
				      align 4
				     ;The Lshape is normally addressed a few bytes ($StrideV) down from its high end.
 0074	      0000 [		      Access word Overlay; MASM gets confused if this is attached to the LevelRec.
	       0000
	      ]
 0074  0000			      Flags LevelRec <>
 0076  0000			      UpLevel charp ?; Invoker's block.
 0078  0000			      Resume charp ? ; On return from invoke from here.
 007A  0000			      Arg0 charp ?   ; Parameters to this invoke.
				     Lshape ends
 = 007C				      $StrideL equ size Lshape
				     ; L. is for Lshape objects addressed by ss:[di+bp]; the level of the execution.
 = (Lshape ptr[bp+di-$StrideL+$S     L is <(Lshape ptr[bp+di-$StrideL+$StrideV])>
   trideV])
				     ; Lsi. is for Lshape objects addressed by ss:[si+bp]
 = (Lshape ptr[bp+si-$StrideL+$S     Lsi is <(Lshape ptr[bp+si-$StrideL+$StrideV])>
   trideV])
				     ; Lbx. is for Lshape objects addressed by ss:[bx]; the level of the execution.
 = ss:(Lshape ptr[bx-$StrideL+$S     Lbx is <ss:(Lshape ptr[bx-$StrideL+$StrideV])>
   trideV])

				     ; LoopsRec is used only in Dshape.
				     ;HasDot:1,      ; When DO X.=
				     ;HasDots:1,     ; When DO X.Y =
				     ;HasTo:1,
				     ;HasFor:1,
				     ;ByDown:1,      ; When control variable values are going down.
				     ;IsInterp:1     ; When block is for INTERPRET, not DO.
				     LoopsRec record LoopsPad:2,HasDot:1,HasDots:1,HasTo:1,HasFor:1,IsInterp:1,
				                     ByDown:1; ByDown last - see use in CompareTo

				     ; API_Enabled:1,   Controls "Variable Pool" interface.
				     ; NoSource:1,      $5.10.11, but no need to implement.
				     ; RandomSeeded:1,  Has the seed been initialized?
				     ; NotS9:1,         Off if numerics are 9 digit SCIENTIFIC.
				     ; The following are to do with compiling - they are off in execution.
				     ; LabelsBad:1,     On when the compile is of text from INTERPRET.
				     ; Repass:1,        When user overides Bif name.
				     ; FirstBetween:1,  On when parsing should start with a Between call.
				     ; EndSource:1,     Helps parser detect end-of-source.
				     ; BifCheck:1,      Tells whether Bif check failed, for compile time .
				     ; TraceIF:1,       Controls trace output.
				     ; ShowELSE:1,      Controls trace output.
				     ProgramRec record API_Enabled:1,
				        Repass:1,
				        LabelsBad:1,
				        FirstBetween:1,
				        EndSource:1,
				        BifCheck:1,RandomSeeded:1,NotS9:1,TraceIF:1,ShowELSE:1,PRSpare:6

				     ; InTypes:2     What are the types of the input operand(s)?
				     ; ResultType:2  Mark result on stack with its type.
				     ; AppendNum:1   When opcode is followed by a number.
				     ; AppendRef:1   When opcode (plus maybe number) is followed by a reference.
				     ; DownOne:1     On if operator leaves stack down one on when it started.
				     ; EndsClause:1  On if operator ends a clause. (Only for internal checks)
				     OperatorRec record InTypes:2,ResultType:2,AppendNum:1,AppendRef:1,DownOne:1,
				                        EndsClause:1

				     ; The Dtype byte is too complex to describe as individual flags. See equates.

 000E				     Jshape struc
 0000	      0007 [		      Valued Vshape <>                  ; Will be addressable Vsid. and J.
	       00
	      ] 00
 0008	      0000 [		      Pair dd 0 dup(?)                  ; Next two together.
	       00000000
	      ]
 0008  0000			      Lower Ushortp ?                   ; a subtree.
 000A  0000			      Higher Ushortp ?                  ; a subtree
 000C  0000			      KeyLen word ?                     ; Always a word of length. Chars may follow.
 000E	      0000 [		      Key char 0 dup(?)
	       00
	      ]
				     Jshape ends
 = 000E				     $StrideJ equ size Jshape
				     ; J. is for Jshape objects addressed by [si]; To look up tails.
 = (Jshape ptr[si])		     J is <(Jshape ptr[si])>
				     ; Jbx. is for Jshape objects addressed by [bx]; To look up tails.
 = (Jshape ptr[bx])		     Jbx is <(Jshape ptr[bx])>
				     ; Jdi. is for Jshape objects addressed by [di]; To look up tails.
 = (Jshape ptr[di])		     Jdi is <(Jshape ptr[di])>

				     TokVal record  GrpNdx:6,SubNum:2; Shape of $name
				     TokRec record X02:1, NdxbT:5, Aim:10
				     KeyRec record KeyFlags:3,EndList:1, KeyLen:4
				     ; Shapes for interpreting syntax tables. Ensure match with table generator.
				     ShiftRec record HasShift:1, ErrorAlone:1, CatFlag:1, HasKeys:1, Reference:1,
				                     Direct:1,Indexb:5, Index:5
				     ErrorRec record HasShiftOn:1, ErrorAloneOn:1, MajorField:8, MinorField:6
				     RedRec record HasShiftOff:1, HasAction:1, PruneCt:2, Rtype:2, Rstate:10
				     ; Every element on the parser stack will have the same size but the contents
				     ; are not always the same, except for State which is the reference state
				     ; needed by the parser mechanism.  The other fields are used for error
				     ; message data, and code generation.
				     ; Field order of Sshape is sensitive, matched to pushes that create an item.
				     ParserRec record ParserPad:12,DoRep:1,DoCV:1,Forever:1,DoDataHost:1
 0010				     Sshape struc
 0000  0000			      State word ?
 0002	      0000 [		      Parser word Overlay
	       0000
	      ]
 0002  0000			      ParserRec <>
				     ; Some of these fields could logically be overlaid but they are not, so that
				     ; logic is avoided in deciding what to push. (They are all pushed)
				     ; Actually that applies to just ClauseWas.
 0004  0000			      ClauseWas  word ?; Line number for message 10.n and 7.n
				      union
				       struct; This one for an operation. Element is made on basis that it is this.
 0006  0000			        Token Ushort ?; Numeric coding of the operation.
 0008  00000000			        Operation dword ?; ASCII coding with length ahead, eg 3,">>=".
 000C  0000			        Caller word ?; Resolved reference to what is to be invoked.
 000E  0000			        Parms Ushort ?; To compute how many arguments there are.
				       ends
				       struct; This overlay for info on a SELECT structure. (Also IF & DO)
				        JumpSite word ?; Records how Pcode jumps from WHEN test to WHEN test.
				                       ; (Also used by IF-ELSE)
				        SoFar charp Overlay; For TraceOnly
				        WhatCV charp Overlay; Control variable identification.
				        SelectSite word ?; Records how Pcode jumps from end of WHENs to end SELECT.
				       ends
				      ends
				     Sshape ends
				     ; S. is for Sshape objects addressed by [si+bp]; the parser stack.
 = (Sshape ptr[bp+si])		     S is <(Sshape ptr[bp+si])>
 = 0010				     $StrideS equ size Sshape
 = (Sshape ptr[bp+si+$StrideS])	     S1 is <(Sshape ptr[bp+si+$StrideS])>
 = (Sshape ptr[bp+si+2*$StrideS]     S2 is <(Sshape ptr[bp+si+2*$StrideS])>
   )
				     ParmsRec record ParmsMin:2,ParmsXtr:2,NonCheck:4
				     MiddleRec record NotLabel:1,SemiAfter:1,ValueBefore:1,
				       AbutOK:1,NoBlanks:1,ModEquals:1,EndClause:1,ImplicitValue:1,
				       CheckDO:1,TargetSymbol:1,Function:1,TakenConstant:1,LookLabel:1,
				       LookBin:1,DotOK:1,MRspare:1

				     ; More flags for clause level.
				     ; NotAssign:1,     Off includes DO j=
				     ; ClauseSet:1,     On when ClauseLine set.
				     ; Tailed:1,        Tells Lookup that compound name is on stack.
				     ; WasTailed:1,     Last Lookup was of tailed.
				     ; WasUpper:1,      Remembers UPPER option on PARSE.
				     ; OffFlag:1,       Remembers OFF of CALL OFF.
				     ; Condition:1,     Remembers there was a condition on CALL ON or SIGNAL ON.
				     ; Append:1,        Remembers there is APPEND during ADDRESS.
				     ; Signal:1,        Remembers when the verb was SIGNAL
				     ; CVar:1,          Remembers when there is a control variable on DO.
				     ; Repit:1,         Remembers when there is repetition part in DO.
				     ; PosEq:1,         Grouped with PosPlus & PosMinus - triggers in PARSE.
				     ; InParse:1,       On during Parse instruction. (Off when escape)
				     ; WasParse:1,      On during Parse instruction.
				       ClauseRec record WasUpper:1,OffFlag:1,Condition:1,Append:1,Signal:1,
				       ClauseSet:1,CVar:1,Repit:1,PosEq:1,NotAssign:1,
				       WasParse:1,InParse:1,Tailed:1,WasTailed:1,
				       PosPlus:1,PosMinus:1; Using 5-gap of PosEq and PosPlus.

				     ; Format5:1,       On for FORMAT bif with five args.
				     ; AssignDO:1,      On when assignment is for DO.
				     ; ForExpose:1,     On while executing EXPOSE.
				     ; FromIterCV:1,    Used when DO loop execution has dotted control variable.
				     ; ForBIF:1,        TargetMsg without expanding inserts. Needed for ERRORTEXT.
				     ; TokIsValue:1     Conditions error message insert.
				     ; ExpRange:1,      Number failure due to exponent oversize.
				     ; Description:1,   Used in msg production.
				     ; Compacted:1,     Used to detect a loop within Compaction.
				     ; BcodeInterpret:1, On when INTERPRET executing on behalf of Bcode.
				     ; MapOnly:1,       Used by Debug for when to fill allocations.
				     ; ParseUpper:1,    On when PARSE has UPPER, in execution.
				     ; ParseTrace:1,    On when PARSE tracing, in execution.
				     ; SourceFiles:1, On when source files rather than ordinary data files relevant.
				     ; BoolBefore:1,    On to prevent code generated for trace making undue prefix.
				     ; WasDropped:1     On to tell us that last load of variable found it dropped.
				     CancelRec record Format5:1,AssignDO:1,ForExpose:1,FromIterCV:1,
				      ForBIF:1,TokIsValue:1, ExpRange:1, Description:1, Compacted:1,
				      BcodeInterpret:1, MapOnly:1, ParseUpper:1, ParseTrace:1, SourceFiles:1,
				      BoolBefore:1, WasDropped:1

				     ; Dual:1,          On when the purpose of compiling is clause by clause run.
				     ; DualPending:1,   On when DualGen is to be set later.
				     ; DualGen:1,       On when Pcode for trace events is being made.
				     ; DualOnly:1,      On when Pcode for Dual differs from original.
				     GenRec record Dual:1,DualPending:1,DualGen:1,DualOnly:1,
				      GenSpare:12

				     ; Experience may show how many allocations the Dos space will be in.
 = 000A				     $Ashapes equ 10
				     ; Shortest code for addressing Header fields is varied. If mov with ax, then
				     ; 2-byte offset is reasonable because there are dedicated opcodes. Else it
				     ; will usually pay to specify indexing with a zero-value index because that
				     ; uses a one byte offset. The index can be bp when there is segment override.
				     ; Otherwise it may pay to zero si especially for the purpose.
 0010				     Hshape struct
 0000	      0000 [		      Hdw0 dword Overlay; This and next dword used when making a copy of a segment.
	       00000000
	      ]
 0000  0000			      SegSize Ushort ?  ; Bytes including our header.
				     ; The segments for different purposes need different subsets of these fields.
				     ; They all need SegSize because Compaction uses it.
				     ; The stack segment needs only SegSize because it has its own routine for
				     ; expansion on demand.
				     ; The pool-type segments only need SegSize&Bump; their size changes only when
				     ; the relevant Vars or Consts segment changes size.
 0002  0000			      Bump Ushort ?   ; Number of new bytes added each expansion
				     ; Things that grow independently (Symbols, Vars, Consts, SysFiles, and each
				     ; compound variable) need Avail and Trigger.
 0004  0000			      Avail Ushort ?  ; Place, below Trigger, for new-stuff-at-end.
 0006  0000			      Trigger Ushort ?; Limit before extension.
				     ; Link identifies the type of segment and allows Zone updates.
 0008  0000			      Link Ushort ?   ; To find slot in Zone that addresses this segment.
 000A	      0000 [		      TreeBin Ushort Overlay ; Field reused in the constants lookup segment.
	       0000
	      ]
 000A	      0000 [		      Original Ushort Overlay ; Field reused in the Pcode segment.
	       0000
	      ]
				                              ; (End of original Pcode.)
 000A  0000			      UpPool Segp ?   ; When segment is a pool. (Also used as chain of free ones)
 000C  0000			      Probe Ushort ?  ; Place to start search if this is a lookup type segment.
 000E	      0000 [		      TreeProg Ushort Overlay ; Field reused as root for source file names lookup.
	       0000
	      ]
 000E  0000			      Labels Ushort ? ; Alternative needed since label and constant trees same seg.
				     Hshape ends
 = 0010				     $StrideH equ size Hshape
				     ; H. is for Hshape objects addressed by [si]; Headers on segments (si=0).
 = (Hshape ptr[si])		     H is <(Hshape ptr[si])>
				     ; Hd. is for Hshape objects addressed by ds:; Headers on segments.
 = (Hshape ptr ds:[0])		     Hd is <(Hshape ptr ds:[0])>
				     ; He. is for Hshape objects addressed by es:[bp]; Headers on segments.
 = (Hshape ptr es:[bp])		     He is <(Hshape ptr es:[bp])>
				     ; Hf. is for Hshape objects addressed by fs:[bp]; Headers on segments.
 = (Hshape ptr fs:[bp])		     Hf is <(Hshape ptr fs:[bp])>
				     ; Hg. is for Hshape objects addressed by gs:[bp]; Headers on segments.
 = (Hshape ptr gs:[bp])		     Hg is <(Hshape ptr gs:[bp])>

				     ; Zshape is resized by StackSafe, not by MoreSpaceEs, so doesn't need all
				     ; the Hshape header. It does need SegSize in correct location though because
				     ; Compaction treats it like a headed segment.
 137C				     Zshape struc
 0000	      0000 [		      w word Overlay       ; Not used in this position - always used like Z.w[index]
	       0000
	      ]
 0000  0000			      SegSize word ?       ; Bytes.
 0002	      0000 [		      ProgramCancel dword Overlay; Used for zeroing.
	       00000000
	      ]
 0002  0000			      Program ProgramRec <>; Program flags
 0004  0000			      Cancel CancelRec <>  ; Flags for transient logic.
 0006  0000			      Stack word ? ; Current variable for Compaction. (Top of soft stack-$StrideV)
 0008  0000			      ClauseLine Ushort ?  ; Line this clause starts on. (First token)
 000A  0000			      Middles MiddleRec <> ; Extension of Clause. Keep with Clause for zeroing.
 000C  0000			      Clause ClauseRec <>  ; Compile time clause flags
 000E  0000			      Gen GenRec <>        ; Flags for control of what gets compiled.
 0010  0000			      KWMiddle charp ?     ; List of search keywords.
 0012  0000			      KWFound Ushort ?     ; Latest keyword found.
 0014  0000			      Stdout Handle ?      ; A constant but potential redirection.
 0016  0000			      Stderr Handle ?      ; A constant but potential redirection.
 0018  0000			      SourceHandle Handle ?
 001A  0000			      HowInvoked Ushort ?  ; Length of COMMAND/FUNCTION/SUBROUTINE.
 001C  00			      Radix byte ?         ; Normally has value 10.
 001D	      0006 [		      AxAsNum char 6 dup(?); For result of Ax2DsSiCx
	       00
	      ]
 0023	      0005 [		      Tag char 5 dup(?)    ; For trace. Joined to AxAsNum
	       00
	      ]
 0028  00000000			      Seed dword ?         ; For Random bif.
 002C  0000			      ParseResetSp charp ? ; Where the parser started work on the hard stack.
 002E  0000			      XCycleResetSp charp ?; Where the execution started work on the hard stack.
 0030  0000			      Dumper word ?        ; Handle when we are writing Pcode to disk.
 0032  0000			      Stash word ?         ; Various
 0034  0000			      Resolved charp ?     ; Result of Lookup.
 0036  0000			      Cursor charp ?       ; Offset into code. (Compile time)
 0038  0000			      Stream charp ?       ; The current stream.  In SysFiles segment.
 003A  0000			      Queue  charp ?       ; The FileBx for CRXREXX.QUE in SysFiles segment.
				     ; Compaction exploits these Segp things being adjacent.
 003C	      0000 [		      InsSource dword Overlay
	       00000000
	      ]
 003C	      0000 [		      SysFile dword Overlay
	       00000000
	      ]
 003C  0000			      File charp ?         ; Current external file of source.
 003E  0000			      SysFiles Segp ?      ; DOS interface
 0040  0000			      Consts Segp ?        ; To an array, fixed size per constant.
 0042  0000			      Vars Segp ?          ; To an array, fixed size per variable.
 0044  0000			      ProgScope Segp ?     ; Shadow of Consts. Order is exploited, see MoreSpaceEs.
 0046  0000			      VarScope Segp ?      ; Shadow of Vars.
 0048  0000			      Symbols Segp ?       ; To a write-once for names and constants.
 004A  0000			      Code Segp ?          ; To the internal code.
 004C  0000			      Zone Segp ?          ; Convenient place for Compaction to find address.
				     ; End of section organised for Compaction.
 004E  0000			      Stem Segp ?          ; Used when a stem wants MoreSpaceEs.
 0050  0000			      PoolPool Segp ?      ; Spare VarScope copies.
 0052  0000			      Level charp ?        ; Latest level of invocation.
 0054  0000			      Base0 charp ?        ; Parser time, for checking how many operands pushed.
 0056  0000			      CurrentDO charp ?    ; Junction of DO blocks and stacked values.
 0058  0000			      ResumeP word ?       ; Save Pcode address while Bcode execution.
 005A	      0000 [		      ResumeDF dword Overlay
	       00000000
	      ]
 005A  0000			      ResumeD word ?       ; Digits() preserved over Bcode execution.
 005C  0000			      ResumeF word ?       ; Fuzz() preserved over Bcode execution.
 005E  00			      ResumeS char ?       ; S/E mode preserved over Bcode execution.
				     ; Section set by ZoneNumerics.  (cf NotS9)
 005F	      0000 [		      DigitsFuzz dword Overlay
	       00000000
	      ]
 005F  0000			      Digits Ushort ?      ; Current digits().
 0061  0000			      Fuzz Ushort ?        ; Current fuzz().
 0063  00000000			      Ceiling dword ?      ; 1eN where N is current digits().
 0067  00000000			      DivBreak dword ?     ; To test for enough digits made in division.
 006B  00000000			      TwiceDigits dword ?  ; 2*N where N is current digits().
 006F  0000			      UseGeneral Ushort ?  ; On for mandatory use of ArithGeneral
				     ; end section set by ZoneNumerics.
				     ; Inserts for messages are divided into (a) those that stay constant or which
				     ; we always want to set when compiling, and (b) those that might be undesirably
				     ; changed when we rescan during execution to find the line number for a message.
				     ; The latter are in a block for save/restore.
				     ; "Ins..." is used as help to identify.
 0071  0000			      InsLine Ushort ?     ; Value for insert
 0073  00			      InsBif byte ?        ; Bif offset.
 0074  00000000			      InsOperator dword ?  ; Actual chars.
 0078  0000			      InsUnqual charp ?    ; Offset in SysFiles. For <source> insert, msg 43.1
 007A	      0000 [		      Insert InsBlock <>   ; For message. The saved copy is Inserts.
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 008F	      0000 [		      Inserts InsBlock <>
	       0000
	      ] 00 00 0000
	      0000 [
	       0000
	      ] 0000 0000 00
	      00
	      0000 [
	       00
	      ] 00 0000 0000
	      0000 0000 0000
 00A4  00			      SignM byte ?         ; Of mantissa
 00A5  00			      SignE byte ?         ; Of exponent
 00A6  0000			      MantPos charp ?      ; Where mantissa starts.
 00A8  0000			      MantPosZi charp ?    ; Beyond end
 00AA  0000			      ExpPos charp ?       ; Where exponent starts.
 00AC  0000			      ExpPosZi charp ?     ; Beyond end
 00AE  0000			      ExpSign word ?
 00B0  0000			      MantSize word ?
 00B2  00			      OpIs byte ?          ; Remembers operator in execution of it.
 00B3  00			      Flags byte ?         ; In BifTypes
 00B4  00			      BifParmsHi byte ?    ; For Bifs to test how many parameters on instance.
 00B5  00			      BifByte byte ?       ; Combines bif number and a parms count.
				     ; Trace section
 00B6  00000000			      TraceAlign dword ?; Beginning of line of source as offset on source file.
 00BA  00000000			      TraceSource dword ?; Beginning of section of source to be shown.
 00BE  00000000			      TraceEnds dword ?; End of section of source to be shown.
 00C2  0000			      TraceSourceColumn word ?
 00C4  0000			      TraceEndsColumn word ?
 00C6  0000			      DualCode charp ?; Beginning of Pcode for one clause.
 00C8  00			      TraceOp byte ?   ; Trace info for current Pcode operation.
 00C9  00000000			      Relative dword ?; Adjustment between position on file and position in buffer.
 00CD  00000000			      RelativeNow dword ?; Used when Serial contains section of source.
 00D1  0000			      Continue word ?; Pcode offset of next clause.
 00D3  0000			      StackX word ?; Hold StackDi over parsing.
 00D5  0000			      TraceLine word ?; Last shown ClauseLine.
 00D7  00000000			      InhibitTrace dword ?
 00DB  00000000			      InhibitPauses dword ?
 00DF  0000			      Target word ?; Used to carry branch value from original pcode to dual.
				     ; Trace section end
				     ; Main also [ Tokens
 00E1  0000			        Scanp charp ?        ; Where the scan has reached. Zero when executing.
 00E3  0000			        EndUsedBuffer charp ?; Where marker to interrupt scan is placed.
 00E5  0000			        NearEnd charp ?      ; Towards end of buffer.
				     ;]
 00E7  00			        CatOp byte ?         ; $pCat or $pAbut
 00E8  00			        RadixBadWhite byte ?
 00E9  0000			        BackExponent charp ?
 00EB  0000			        LastContent charp ?
 00ED  0000			        CommaLine word ?; NonZero if previous line ended with non-continuation comma.
 00EF  0000			        Condition Ushort ?   ; Latest condition keyword.
 00F1  0000			        UntilPlace Ushort ?  ; Place in Pcode. Held just over UNTIL expression.
 00F3  0000			        StemSym charp ?      ; Temp for A.B.C type Lookup
 00F5  0000			        SoFar word ?         ; Temp for A.B.C type Lookup
 00F7  0000			        PcodePos word ?      ; Used by ConstValue
 00F9  0000			        TraceOnly word ?     ; Used to detect 'trace only' labels.
 00FB  0000			      CompareAt word ?       ; For detecting compare Pcode optimizing.
 00FD  0000			      StackHi charp ?        ; Used for compound lookup.
 00FF  0000			      StackLo charp ?        ; Also for function arguments.
 0101  0000			      OnSoft charp ?         ; Where stacked target symbols start. PARSE compiletime.
				                             ; Tokens tells Pcode.
 0103  0000			      Tail charp ?           ; Work when Pcode made for tailed.
 0105  0000			      TokNum word ?          ; As tokenizer makes, parser sees.
 0107  0000			      TokNow word ?
 0109  0000			      TokWas word ?
 010B  0000			        TokData word ?       ; Data for parser derived from TokNum
 010D  0000			        Synch charp ?        ; Instruction pointer, into Pcode, for synching.
 010F  0000			        Lines Ushort ?       ; Count of lines
 0111  0000			        MsgBegin charp ?     ; Where sub-messages concatenated.
 0113  0000			        MsgSoFar charp ?     ; As sub-messages concatenated.
 0115  0000			        PreZi charp ?        ; End of message before expanding insertions.
 0117	      0000 [		        TargetMajMin word Overlay; This is message being output.
	       0000
	      ]
 0117  00			         TargetMinor byte ?
 0118  00			         TargetMajor byte ?
				        struc                ; See DOS command 4Bh
 0119  0000			         EnvSeg Segp ?
 011B  0000 0000		         ForPSP Farp <>
 011F  0000 0000		         Fcb1 Farp <>
 0123  0000 0000		         Fcb2 Farp <>
				        ends
 0127  0000			        AtPause charp ?       ; NYI
 0129  00			        ArgsB byte ?; For Arg() of BCycle bif.
 012A  0000			        ArgsB0 charp ?; For Arg(exp) of BCycle bif.
				     ; Workspace for the verbs can be shared.
				        struct; For Parse
 012C	      0000 [		         Parsee FarpX <>
	       00000000
	      ] 0000 0000
	      0000 [
	       0000
	      ] 0000
 0132  0000			         ParseeNum Ushort ?; Counts arguments for commas in parsing template.
 0134  0000			         PattLenEtc Ushort ?  ; Length of pattern. Temp for cursor.
 0136  0000			         BreakStart charp ?; Beginning of previous section delimiter.
 0138  0000			         BreakEnd charp ?  ; End of previous section delimiter.
				        ends
 013A  0000 0000 0000 0000	        EnvNow EnvBlock <> ; Used to execute ADDRESS
 0142  0000			      CatTotal word ?      ; Used by Abut$$ & Cat$$
 0144  0000			      LastTarget word ?    ; For detecting when to make $pUnstore.
 0146  0000			      NewJshape charp ?    ; Used by FindKey.
 0148  0000			      FromDos charp ?; A slot addressing a segment DOS gave us. (Cat optim. uses)
 014A  0000			      FromDosWas word ?; To test for cycled through them.
 014C  0000			      FromDosZi charp ?; Bound for FromDos
 014E	      000A [		      MemoryTable Ashape $Ashapes dup(<>)
	       0000 0000 0000
	      ]
 018A	      0000 [		      MemoryTableZi byte Overlay; Just used as an offset.
	       00
	      ]
 018A  0000			      Left charp ?     ; For compaction.
 018C  0000			      Right charp ?    ; For compaction.
 018E  00000000			      AllocBase dword ?; For compaction.
				     ; Grouping matters here.
 0192  0000			      DsWas Segp ?
 0194  0000			      DsNew Segp ?
 0196  0000			      EsWas Segp ?
 0198  0000			      EsNew Segp ?     ; Sometimes reloaded from.
 019A  0000			      FsWas Segp ?
 019C  0000			      FsNew Segp ?
 019E  0000			      GsWas Segp ?
 01A0  0000			      GsNew Segp ?
				     if Debug
 01A2  0000			      DebugStash word ?
 01A4  00000000			      DebugD dword ?
				     endif
 01A8  0000			      DigitCount Ushort ?  ; Checking radix string, Compile and execute.
				     ; Byte before Serial better not accidentally look like $Eof.
 01AA  00			      SerialNow byte ? ; Indicates what is in Serial.
 01AB	      11C8 [		      Serial char $SourceBufferSize dup(?)
	       00
	      ]
				      align 4
 1374	      0007 [		      CommandArg Vshape <>; Parameters from Command line.
	       00
	      ] 00
				     Zshape ends
				     ; Z. is for Zshape objects addressed by [bp]; the Zone
 = (Zshape ptr[bp])		     Z is <(Zshape ptr[bp])>

 0053				     Yshape struc
 0000  00000000			      dword ?; Overlays jmp.
 0004  00000001			      N1 dword 1
 0008  0000000A			      N10 dword 10
 000C  00000064			      N100 dword 100
 0010  000003E8			      N1000 dword 1000
 0014  00002710			      N1e4 dword 10000
 0018  000186A0			      N1e5 dword 100000
 001C  000F4240			      N1e6  dword 1000000
 0020  00989680			      N1e7 dword 10000000
 0024  05F5E100			      N1e8 dword 100000000
 0028  3B9ACA00			      N1e9 dword 1000000000
 002C  0019660D			      N1664525 dword 1664525; For Random
				      Assert $Limit_ExponentDigits eq 9
 0030  3B9AA2F1			      ExponHi dword 1000000000-$Limit_Digits
 0034  C4653602			      ExponLo dword -1000000000+2
 0038  0000			      Cseg Segp ?          ; To be where the machine code is.
 003A	      0000 [		      DOS dword Overlay; Default ADDRESS
	       00000000
	      ]
 003A	      0001 [		       db "DOS "
	       44 4F 53 20
	      ]
 003E	      0001 [		      DosPool db "ENVIRONMENT"; Pool name
	       45 4E 56 49 52
	       4F 4E 4D 45 4E
	       54
	      ]
 0049	      0001 [		       db "..."; Joined to following CrLf
	       2E 2E 2E
	      ]
 004C  22			      DqCrLf db '"'
 004D  0D 0A			      CrLf db 13,10
 004F  0000 0000		      StackSave Farp <>    ; To recover when only CS:IP survives.
				     Yshape ends
				     ; Y. is for Yshape objects addressed by [bp]; the constants.
 = (Yshape ptr cs:[bp])		     Y is <(Yshape ptr cs:[bp])>
 = (Yshape ptr cs:[2*ecx+ebp])	     Ycx2 is <(Yshape ptr cs:[2*ecx+ebp])>
 = (Yshape ptr cs:[si])		     Ysi is <(Yshape ptr cs:[si])>

				     ; These equs should follow the declares of shapes they depend on.
 = 0014				     $SizeConstsHeader equ $StrideH+4
				     ; Configuration variables (used by the implementation but not seen by the user's
				     ; program) are in the order the utility that makes Bcode has numbered them. The
				     ; $Reserved string matches.
				     ; Also constants & reserved variables that are always in ProgScope area.
 = 0014				     $?Omitted equ $SizeConstsHeader
 = 001C				     $?MN equ $?Omitted+$StrideV
 = 0024				     $?RS equ $?MN+$StrideV
 = 002C				     $?RESULT equ $?RS+$StrideV
 = 0034				     $?RC equ $?RESULT+$StrideV
 = 003C				     $?SIGL equ $?RC+$StrideV
 = 0044				     $?SysVars equ $?SIGL+$StrideV
				     ; See $Reserved for number of vars here.
 = 000B				     $SysCount equ 11
 = 0000				     ?OUTCOME equ 0; These are the numbers used in Bcode references.
 = 0044				     $?OUTCOME equ $?SysVars; These are the offsets used in machine code references.
				     ; ie where the system variables are in the ProgScope segment.
 = 0002				     ?BIF equ 2
 = 004C				     $?BIF equ $?SysVars+$StrideV
 = 0004				     ?STREAM equ 4
 = 0054				     $?STREAM equ $?SysVars+2*$StrideV
 = 0006				     ?STREAMSTATE equ 6
 = 005C				     $?STREAMSTATE equ $?SysVars+3*$StrideV
 = 0008				     ?RESPONSE equ 8
 = 0064				     $?RESPONSE equ $?SysVars+4*$StrideV
 = 000A				     ?LINEIN_POSITION equ 10
 = 006C				     $?LINEIN_POSITION equ $?SysVars+5*$StrideV
 = 000C				     ?CLAUSETIME equ 12
 = 0074				     $?CLAUSETIME equ $?SysVars+6*$StrideV
 = 000E				     ?CLAUSELOCAL equ 14
 = 007C				     $?CLAUSELOCAL equ $?SysVars+7*$StrideV
 = 0010				     ?MONTHS equ 16
 = 0084				     $?MONTHS equ $?SysVars+8*$StrideV
 = 0012				     ?WEEKDAYS equ 18
 = 008C				     $?WEEKDAYS equ $?SysVars+9*$StrideV
 = 0014				     ?STARTTIME equ 20
 = 0094				     $?STARTTIME equ $?SysVars+10*$StrideV
 = 009C				     $?Nine equ $?SysVars+11*$StrideV
 = 00A4				     $?Zero equ $?Nine+$StrideV
 = 00AC				     $?Null equ $?Zero+$StrideV
 = 00B4				     $?E equ $?Null+$StrideV
 = 00BC				     $?S equ $?E+$StrideV
				     ; These are variables that are always in current VarScope area.
 = 0010				     $?Discard equ $StrideH; Takes two because ends in dot.
 = 0020				     $?RESULTx equ $?Discard+2*$StrideV
 = 0028				     $?RCx equ $?RESULTx+$StrideV
 = 0030				     $?SIGLx equ $?RCx+$StrideV
				     ; Not in the table, but we need to use some character as an end-used-buffer
				     ; mark. (Saves checking address repeatedly) Using Linefeed helps comment scan.
 = 000A				     $EndBuffer equ $Lf
 = 0000				     $Whole     equ 0
 = 0004				     $WholeGE   equ 4
 = 0008				     $WholeGT   equ 8
 = 000C				     $Num       equ 12
 = 0010				     $M090      equ 16
 = 0014				     $WholeNum  equ 20
 = 0018				     $Pad       equ 24
 = 001C				     $Hex       equ 28
 = 0020				     $Stream    equ 32
 = 0024				     $Bin       equ 36
 = 0028				     $Symbol    equ 40

				     AllocAppend macro Goes:req
				      push si
				      mov si,Z.FromDos; The current allocation source.
				      mov ax,A.Fr.Pt
				      sub ax,V.Len
				      cmp ax,V.Pt
				      jne Goes
				     ; Here if offset fits. Also need to check same segment.
				      mov ax,V.Sg
				      cmp ax,A.Fr.Sg
				      jne Goes
				      mov es,ax
				     ; The segment could be full, but if possible take the extra.
				      mov ax,V.Pt
				      add ax,cx
				      jc Goes
				      cmp ax,A.Amount
				      ja Goes
				      mov A.Fr.Pt,ax
				      sub ax,cx
				      mov V.Len,cx
				      endm
				     ; Here are the numbers which go in the Attributes table.
				     ; Most of this is just for compiling but some equates are relevant to
				     ; execution so those have been put in declares.inc
				     ; First two bits for quick test of Whitespace, Letter, Digit, Special
				     ; $White equ 0 $Digit equ 64 $Letter equ 128 $Special equ 192
				     ; When it is not Special, the remaining bits can be flags.
				     ; When it is Special, there is a switch indexed by the rest of the byte.
				     ; This corresponds to the right six bits of TokVal so we can test in groups.
				     ; In practice it is "+ or -" that gets tested this way.
 = 00FC				      $Group equ 0FCh
 = $AttribPlus and $Group	      $PlusMinus equ $AttribPlus and $Group
				     ; The bits to the right of $White are free, and we could distinquish the
				     ; reak blank from blank equivalents but there seems no reason to do so.
				     ; We are short of a bit for letters. It would be nice to have flags for
				     ; conveniently testing "Ee", "Xx", "Bb", "01", ok as hex digit, having upper
				     ; case, and real-letter, as well as $Letter for the purposes of a symbol.
				     ; Something has to be left out, and real-letter would only be used in
				     ; DATATYPE().
				     ; We are short of a bit for digits. It is highly desirable to be able to scan
				     ; a number using lods and not have to refer to the value before xlat (since
				     ; xlat overwrites al). So we would like to have the value of the digit in the
				     ; low order of the attribute, as opposed to subtracting character '0' from the
				     ; raw character. That leaves two, which gives us difficulty if we want
				     ; OK-for-radix-B, OK-for-radix-X, and a Lower-case-letter. (Since we would
				     ; like to test the latter in the symbol recognition loop without distinquishing
				     ; letter/digit first.)
				     ; The solution seems to be to invert the lowercase flag. Then with blanks and
				     ; specials out of the way (jpe), the upperableness can be tested as zeroness
				     ; of Digit flag and NonUpable flag, together.
				     ; So the scheme for Letter-or-Digit is to make the right nibble dependent on
				     ; whether letter or digit, leaving two bits for OK-for-radix.
 = 0020				      $OKb equ 32
 = 0010				      $OKx equ 16
				     ; For letters:
				     ; $NonUpable equ 8 $Bb equ 4 $Xx equ 2 $Ee equ 1
				     ; $Lowercase equ $Digit+$NonUpable; Use jnz avoiding uppering.
				     ; These values above $STRING go through switching like specials but are not
				     ; seen by the parser.
 = 0027				     $LineFeed equ $Eq-4
 = 0009				     $Invalid equ $UnAccept+1
 = 000A				     $Colon equ $UnAccept+2
 = 00D8				     $AttribAnd equ $Special+$And
 = 00D5				     $AttribOr equ $Special+$Or
 = 00EB				     $AttribEq equ $Special+$Eq
 = 00E4				     $AttribMinus equ $Special+$Minus
 = 00ED				     $AttribLt equ $Special+$Lt
 = 00F0				     $AttribGt equ $Special+$Gt
 = 00D2				     $AttribSlash equ $Special+$Slash
 = 00DC				     $AttribComma equ $Special+$Comma
 = 00E7				     $AttribLine equ $Special+$LineFeed
 = 00E5				     $AttribPlus equ $Special+$Plus
 = 00D1				     $AttribStar equ $Special+$Asterisk
 = 00FF				     $NoMatch equ $Special+63; No character has these attributes.

				     ; The GROUP mechanism is capable of spreading the table of operation addresses
				     ; amongst different assemblies but that is not now exploited - here are all
				     ; the Pcode addresses.
				     ; FanSeg is canned by a utility so not commented. See "Pcode generation".
				     MyGroup GROUP _TEXT, FanSeg
 0000				     FanSeg SEGMENT WORD PUBLIC 'CODE'
 0000				     PcodesBase$:
 0000  034E R			      dw Abut$$
 0002  03EA R			      dw Cat$$
 0004  04B7 R			      dw Nop$$
 0006  087C R			      dw AssignDotsP$$
 0008  04BD R			      dw Parse$$
 000A  085A R			      dw ResumeParse$$
 000C  0943 R			      dw Number$$; After J in DO J=...
 000E  0A37 R			      dw To$$
 0010  0A4E R			      dw By$$
 0012  0A24 R			      dw For$$
 0014  0AEA R			      dw While$$
 0016  0AD5 R			      dw Until$$
 0018  0BFF R			      dw IterRep$$; Matches DO 999
 001A  0C07 R			      dw Iterate$$; Matches DO FOREVER
 001C  0AFE R			      dw Leave$$
 001E  0B01 R			      dw UnDo$$
 0020  0F2C R			      dw Result$$
 0022  0F80 R			      dw Return$$
 0024  0F30 R			      dw Returns$$
 0026  101B R			      dw Exit$$
 0028  1DF2 R			      dw Say$$
 002A  0000 E			      dw Bifq$$
 002C  0000 E			      dw Length$$
 002E  0000 E			      dw Max$$
 0030  0000 E			      dw Min$$
 0032  15B3 R			      dw Not$$
 0034  15AC R			      dw And$$
 0036  15A5 R			      dw Or$$
 0038  159E R			      dw Xor$$
 003A  1829 R			      dw Positive$$
 003C  17FC R			      dw Negate$$
 003E  1164 R			      dw Add$$
 0040  128F R			      dw Subtract$$
 0042  1519 R			      dw Multiply$$
 0044  16DD R			      dw Divide$$
 0046  16DD R			      dw IntDivide$$
 0048  16DD R			      dw Remainder$$
 004A  17F3 R			      dw Power$$
 004C  0000 E			      dw Command$$
 004E  1D14 R			      dw Interpret$$
 0050  15F3 R			      dw Numeric$$
 0052  0C0A R			      dw Invoke$$
 0054  0C17 R			      dw Call$$
 0056				     PjumpBase$:
 0056  0A90 R			      dw Rep$$; DO 999
 0058  0A87 R			      dw RepEver$$; DO FOREVER
 005A  096E R			      dw ControlVar$$; DO N=A TO B
 005C				     BPcodesCeil$:
 005C  09C0 R			      dw DotControlVar$$
 005E  1A78 R			      dw Then$$
 0060  1A78 R			      dw When$$
 0062  1A68 R			      dw Jump$$
 0064  1395 R			      dw Eq$$
 0066  1395 R			      dw Ne$$
 0068  1395 R			      dw Lt$$
 006A  1395 R			      dw Le$$
 006C  1395 R			      dw Ge$$
 006E  1395 R			      dw Gt$$
 0070  1494 R			      dw Seq$$
 0072  1494 R			      dw Sne$$
 0074  1494 R			      dw Slt$$
 0076  1494 R			      dw Sle$$
 0078  1494 R			      dw Sge$$
 007A  1494 R			      dw Sgt$$
 007C  1409 R			      dw Ceq$$
 007E  1409 R			      dw Cne$$
 0080  1409 R			      dw Clt$$
 0082  1409 R			      dw Cle$$
 0084  1409 R			      dw Cge$$
 0086  1409 R			      dw Cgt$$
 0088				     PjumpCeil$:
 0088  1D70 R			      dw InterpEnd$$
 008A  19D7 R			      dw Signal$$
 008C  1A26 R			      dw SignalOn$$
 008E  1A22 R			      dw CallOn$$
 0090  1BEB R			      dw Dots$$
 0092  1AC1 R			      dw Assign$$
 0094  1C7A R			      dw AssignStem$$
 0096  1CEB R			      dw AssignDots$$
 0098  1A8D R			      dw AssignConst$$
 009A  1ABD R			      dw Unstore$$
 009C  1CDD R			      dw Drop$$
 009E  1B60 R			      dw Expose$$
 00A0  14AE R			      dw Bool$$
 00A2  0B10 R			      dw IterCV$$
 00A4  0000 E			      dw Address$$
 00A6  0000 R			      dw CommandEnv$$
 00A8  0000 E			      dw EnvName$$
 00AA  0000 E			      dw Bif$$
 00AC  0000 E			      dw BifGroup$$
 00AE  1A52 R			      dw Raise$$
 00B0  1A41 R			      dw SignalOff$$
 00B2  19D5 R			      dw SignalV$$
 00B4  02DF R			      dw SysVar$$
 00B6  1B0F R			      dw DropList$$
 00B8  1B8D R			      dw ExposeList$$
 00BA  1D97 R			      dw Push$$
 00BC  1D97 R			      dw Queue$$
 00BE  0000 E			      dw Trace$$
 00C0  0000 E			      dw TraceEvent$$
 00C2  1D93 R			      dw Options$$
 00C4				     PcodesCeil$:
 0000				     FanSeg ENDS

				      EXTERN Bif$$:near,Bifq$$:near,BifGroup$$:near,Trace$$:near; With the Bif.
				      EXTERN Max$$:near,Min$$:near,Length$$:near
				      EXTERN Address$$:near,EnvName$$:near
				      EXTERN Command$$:near,TraceEvent$$:near,TraceEventX:near
				      EXTERN One$$:near,String1$$:near

				      PUBLIC _Eq$$, _Ne$$, _Lt$$, _Le$$, _Ge$$, _Gt$$, _Seq$$, _Sne$$, _Slt$$
				      PUBLIC Abut$$; Used by Command$$
				      PUBLIC Interpret1; Used during initializing.
				      PUBLIC AddRegs,CompareTO; Used in Bcode implementation.
				      PUBLIC Exit, ExitDOS
				      PUBLIC StrictFlags; Used at compile to test constants.

				      PUBLIC Raise49
				      PUBLIC Raise26p5,Raise26p6
				      PUBLIC Raise33p1,Raise33p2,Raise33p3
				      PUBLIC Raise34p5,Raise34p6
				      PUBLIC Raise40
				      PUBLIC Raise40p11,Raise40p32,Raise40p33

				      EXTERN Bassign:near; This code does some work on behalf of Bcode.
				     ; Things implemented in Bcode, run from here.
				      EXTERN B4DROP:near,B4EXPOSE:near,ARITHOP$$:near,PATHQUALIFY:near
				      EXTERN CloseBx:near; Needed by Exit.
				      EXTERN MakeMsg:near
				      EXTERN ShowMsg:near

 0000   5p  FF D5		     CommandEnv$$:Error49Bp

 0002   1   46			     Operator:inc CursorSi
 0003   1   32 FF		     xor bh,bh
				     ; The fan-out is made with:
				     ; AX not in use.
				     ; BX containing the opcode (hence bh=0) and reusable.
				     ; CX not in use. (See Note 1)
				     ; DX not in use. (See Note 1)
				     ; SI such that gs:CursorSi is after opcode. Return must be made with SI
				     ; positioned on the next opcode.
				     ; DI at the low address end of the latest operand to be stacked.
				     ; DS not in use.
				     ; ES not in use.
				     ; FS addressing the current variables. Return must be with same value.
				     ; GS addressing the Pcode. Return must be with same value.
				     ; Note 1: Extensions of these registers are all not in use, except that
				     ; when the top stack item is binary, it's value will be in ecx:edx as well
				     ; on the stack.  (?? is this worth guaranteeing?)

				     if Debug
 0005   1   50			       push ax
 0006   3   8C E8		       mov ax,gs
 0008   2   2E: 3B 46 38	       cmp ax,Y.Cseg
 000C  3,1  73 01		       jae @F
 000E  26   CC			       int 3
 000F   1   58			       @@:pop ax

 0010   1   50			       push ax
 0011   3   8C C0		       mov ax,es
 0013   2   3B 46 44		       cmp ax,Z.ProgScope
 0016  3,1  74 01		       je @F
 0018  26   CC			       int 3
 0019   1   58			       @@:pop ax

 001A   1   89 9E 01A2		       mov Z.DebugStash,bx
				       Qry Z.Cancel,BcodeInterpret
 001E   2   F6 46 04 40		  1          test Bptr(Z.Cancel), low ??0000
 0022  3,1  74 06		       jz @F
 0024   1   C7 86 01A2 0025	       mov Z.DebugStash,$pReturns
 002A				       @@:
				     endif

 002A   1   89 7E 06		       mov Z.Stack,StackDi; Record of how much stack in use needed for Compaction.

				     ; Jmps are faster than Rets so potentially fast to jump out to code and jump
				     ; back (as is done for operand-to-stack loading) but that would prevent the
				     ; functions from being (easily) called from other places.

 002D   5p  2E: FF 97 FFFF R	       call cs:(PcodesBase$-1)[bx]

				     if Debug
				     ; Part of check that StackDi = Z.CurrentDO at end-of-clause, ie no
				     ; unprocessed operands left over.
				     if MemCheck
 0032   3   E8 0000 E		         call DosMemCheck
				     endif
 0035   1   8B 9E 01A2		      mov bx,Z.DebugStash
 0039   1   80 FB 25		      cmp bl,$pReturns
 003C  3,1  74 1D		      je @F
 003E   1   80 FB 27		      cmp bl,$pExit
 0041  3,1  74 18		      je @F
 0043   2   3B 7E 56		      cmp StackDi,Z.CurrentDO
 0046  3,1  74 13		      jz @F
 0048   1   8B D3		      mov dx,bx;Assert DX free to use. (Visible in CV)
 004A   3   D1 EB		      shr bx,1
 004C   1   2E: 8A 9F 0000 E	      mov bl,Bptr OpFlags[bx]
				      Qry bl,EndsClause
 0051   1   F6 C3 01		  1          test bl, ??0001
 0054  3,1  74 05		      jz @F
 0056  26   CC			      int 3
 0057   1   B4 4C		      mov ah,$DosExit
 0059  30   CD 21		      int 21h
 005B				     @@:
				     endif

 005B				     XCycle:

				     if 0
				     endif

				     ; Here with the soft instruction pointer on the bytes to be interpreted.
				     if Debug
 005B   1   3B F5		      cmp si,bp
 005D  3,1  79 01		      jns @F
 005F  26   CC			      int 3
 0060				      @@:
				     endif
 0060   1   65: 8B 1C		      mov bx,Wptr gs:[CursorSi]
				     ; Even means it is an operand. There are usually more operands than operators.
 0063   1   F6 C3 01		      test OperandBl,1
 0066  3,1  75 9A		      jnz Operator
 0068   1   83 C6 02		      add CursorSi,2
 006B   1   F6 C3 06		      test OperandBl,$CaseTarget
 006E  3,1  75 1E		      jnz NotLoadVariable

				     ; Alignment 8 means procedure scope. There are roughly as many of these
				     ; as there are constant references (program scope).
				     ; FS is maintained addressing the variables of the current procedure.
				     ; The following Up (=add) puts the previous operand (if any) underneath (lower
				     ; address than) StackDi, and the new operand is then positively addressed
				     ; by StackDi.
				     ; It isn't necessary to test for stack overflow here because there is a limit
				     ; on the number of operands that can happen without a function invocation
				     ; intervening and the function will make a check. (Limit is deduced at compile
				     ; time- NYI but conservative view taken.)
 0070				     FetchBx:Up
 0070   1   83 C7 08		  1   add StackDi,$StrideV
 0073   2   64: F6 47 07 C0	     test Vbxf.Dtype,$Test
 0078  3,1  0F 8F 0210		     jg NotPresent
				     ; If control branched off, it will return to XCycle when a value to be used
				     ; for the operand is established.
				     ; Whatever the datatype of the value, 8 bytes contains or anchors it.
				      Move V,Vbxf
 007C   1   66| 64: 8B 0F	  1     mov ecx,Vbxf.OverExpo
 0080   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0083   1   66| 64: 8B 47 04	  1     mov eax,Vbxf.OverMant
 0088   2   66| 89 43 04	  1     mov V.OverMant,eax
 008C   3   EB CD		      jmp XCycle

 008E  3,1  7B 23		     NotLoadVariable:jpo ProgScope
				     ; $CaseTarget (=6) modulo 8 means a variable being assigned to.
 0090   2   64: 80 7F 01 50	      cmp Vbxt.Dtype,$Exposed
 0095  3,1  74 16		      je @F
				      Move Vbxt,V
 0097   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 009A   1   66| 64: 89 4F FA	  1     mov Vbxt.OverExpo,ecx
 009F   2   66| 8B 43 04	  1     mov eax,V.OverMant
 00A3   1   66| 64: 89 47 FE	  1     mov Vbxt.OverMant,eax
				      Down
 00A8   1   83 EF 08		  1   sub StackDi,$StrideV
 00AB   3   EB AE		      jmp XCycle
 00AD   1   68 005B R		     @@:push XCycle
 00B0   3   E9 1A2F		      jmp AssignExposed

				     ; Excursion from XCycle for loading a constant.
 00B3				     ProgScope:Up
 00B3   1   83 C7 08		  1   add StackDi,$StrideV
				     Move V,Vbxe
 00B6   1   66| 26: 8B 0F	  1     mov ecx,Vbxe.OverExpo
 00BA   1   66| 89 0B		  1     mov V.OverExpo,ecx
 00BD   1   66| 26: 8B 47 04	  1     mov eax,Vbxe.OverMant
 00C2   2   66| 89 43 04	  1     mov V.OverMant,eax
 00C6   3   EB 93		     jmp XCycle

				     ; The Rejumps either change CursorSi, or don't, according to the hardware
				     ; flags. They are the "conditional jumps" of Pcode.  Which one to use is
				     ; determined by the Pcode operator, by this time converted into which of
				     ; this array of conditional jumps is to be used.
				     ; Once upon a time Rejumps were four bytes like je @F xax CursorSi @@:ret
				     ; but latest should be faster.

				     if Solid
 00C8				     Rejumps:
 00C8  3,1  74 02		      je @F
 00CA   1   8B F0		      mov CursorSi,ax
 00CC				      @@:BackRet
 00CC   5   C3			  1  ret
 00CD   3   90			      nop
 00CE   3   90			      nop
 00CF   3   90			      nop
 00D0  3,1  75 02		      jne @F
 00D2   1   8B F0		      mov CursorSi,ax
 00D4				      @@:BackRet
 00D4   5   C3			  1  ret
 00D5   3   90			      nop
 00D6   3   90			      nop
 00D7   3   90			      nop
 00D8  3,1  72 02		      jb @F
 00DA   1   8B F0		      mov CursorSi,ax
 00DC				      @@:BackRet
 00DC   5   C3			  1  ret
 00DD   3   90			      nop
 00DE   3   90			      nop
 00DF   3   90			      nop
 00E0  3,1  76 02		      jbe @F
 00E2   1   8B F0		      mov CursorSi,ax
 00E4				      @@:BackRet
 00E4   5   C3			  1  ret
 00E5   3   90			      nop
 00E6   3   90			      nop
 00E7   3   90			      nop
 00E8  3,1  73 02		      jae @F
 00EA   1   8B F0		      mov CursorSi,ax
 00EC				      @@:BackRet
 00EC   5   C3			  1  ret
 00ED   3   90			      nop
 00EE   3   90			      nop
 00EF   3   90			      nop
 00F0  3,1  77 02		      ja @F
 00F2   1   8B F0		      mov CursorSi,ax
 00F4				      @@:BackRet
 00F4   5   C3			  1  ret

 00F5				     Boolery:; Turns what is in hardware flags to a Boolean byte in al.
				     ; sete al ret will fit in four bytes but nowadays we use eight - see Rejumps.
 00F5   4   0F 94 43 04		      sete Bptr(V.Mantissa)
				      BackRet
 00F9   5   C3			  1  ret
 00FA   3   90			      nop
 00FB   3   90			      nop
 00FC   3   90			      nop
 00FD   4   0F 95 43 04		      setne Bptr(V.Mantissa)
				      BackRet
 0101   5   C3			  1  ret
 0102   3   90			      nop
 0103   3   90			      nop
 0104   3   90			      nop
 0105   4   0F 92 43 04		      setb Bptr(V.Mantissa)
				      BackRet
 0109   5   C3			  1  ret
 010A   3   90			      nop
 010B   3   90			      nop
 010C   3   90			      nop
 010D   4   0F 96 43 04		      setbe Bptr(V.Mantissa)
				      BackRet
 0111   5   C3			  1  ret
 0112   3   90			      nop
 0113   3   90			      nop
 0114   3   90			      nop
 0115   4   0F 93 43 04		      setae Bptr(V.Mantissa)
				      BackRet
 0119   5   C3			  1  ret
 011A   3   90			      nop
 011B   3   90			      nop
 011C   3   90			      nop
 011D   4   0F 97 43 04		      seta Bptr(V.Mantissa)
				      BackRet
 0121   5   C3			  1  ret

 = 002D				     BooleryRejumps equ Boolery-Rejumps
				     endif
				     ;------------------------------------------------------------------------------
				     ; When I changed the search from a subroutine to inline the performance
				     ; went down (!) so presumably alignment is important.
				     ;------------------------------------------------------------------------------
				     ; Concatenates parameters (with '.' between them) to make a tail value.
				     ; Looks under the stem (which comes in fs:bx) for item with that key, makes it
				     ; if necessary.  AX says how many parameters.
				     ; Results fs:bx for stem (upper of pair), ds:si for tailed item.
				     ; StackDi adjusted. ax & cx & dx not preserved.

 0122				     DotsFsBxDsSi:
				     ; AX defining how many parts.
				     ; Change fs to required pool, if necessary.
 0122   2   64: 80 7F 07 50	      cmp Vbxf.Dtype,$Exposed
 0127  3,1  75 03		      jne @F
 0129   3   E8 19D0		      call ExposedFs
 012C				      @@:
				     ; Find the segment owned by the stem.
				     ; If stem says dropped, a segment is needed which will hold all the keys.
 012C   2   64: 80 7F 0F 40	      cmp Vbxf2.Dtype,$Dropped
 0131  3,1  75 03		      jne @F
 0133   3   E8 013E		      call StemAllocVbxDs
 0136				      @@:
 0136				     DotsFsBxDsSiX:; Entry from externals lookup.
 0136   1   89 BE 00FD		      mov Z.StackHi,StackDi
 013A   1   89 BE 00FF		      mov Z.StackLo,StackDi
 013E   3   29 86 00FF		      sub Z.StackLo,ax
				     if Debug
				      TestReg ax
 0142   1   85 C0		  1         test ax,ax
 0144  3,1  79 01		      jns @F
 0146  26   CC			      int 3
 0147				      @@:
				     endif
				     ; Copy parts of tail to make complete key.
 0147   3p  64: 8E 47 0A	      mov StemEs,Vbxf2.Sg
 014B   1   26: 8B 76 04	      mov si,He.Avail; Points to spare space.
 014F   1+  8D 54 0E		      lea ToFindDx,J.Key
				      Up
 0152   1   83 C7 08		  1   add StackDi,$StrideV
 0155   1   8B C2		      mov ax,ToFindDx; ax as cursor across key.
 0157				     TailLenLoop:Down
 0157   1   83 EF 08		  1   sub StackDi,$StrideV
 015A   1   57			     @@:push StackDi
 015B   3   E8 1F1B		      call ToDsSiCx
				     ; Assure room in stem segment.
 015E   1   8B F8		      mov di,ax
 0160   1   03 F9		      add di,cx
 0162   1   47			      inc di
 0163   2   26: 3B 7E 06	      cmp di,He.Trigger
 0167  3,1  72 10		      jb @F
 0169   3   8C 46 4E		      mov Z.Stem,StemEs
 016C   1   BF 004E		      mov SegOffDi,Zshape.Stem
 016F   3   E8 0000 E		      call MoreSpaceEs
 0172   3   64: 8C 47 0A	      mov Vbxf2.Sg,StemEs
 0176   1   5F			      pop StackDi
 0177   3   EB E1		      jmp @B
				     ; Add tail part to the key, with dot after. AX advances.
 0179   1   8B F8		     @@:mov di,ax
				     ; Trade size for speed.
 017B   1   83 F9 08		       cmp cx,8
 017E  3,1  77 3E		       ja  SlowRep
 0180   1   66| 8B 04		       mov eax,Dptr[si]
 0183   1   66| 26: 89 05	       mov Dptr es:[di],eax
 0187   1   66| 8B 44 04	       mov eax,Dptr [si+4]
 018B   1   66| 26: 89 45 04	       mov Dptr es:[di+4],eax
 0190   1   03 F9		       add di,cx
 0192				     PostRep:
 0192   1   B0 2E		      mov al,'.'
 0194   5   AA			      stosb
 0195   1   8B C7		      mov ax,di
 0197   1   5F			      pop StackDi
 0198   2   3B BE 00FF		      cmp StackDi,Z.StackLo
				     if Debug
 019C  3,1  73 01		      jae @F
 019E  26   CC			      int 3
 019F				      @@:
				     endif
 019F  3,1  75 B6		      jne TailLenLoop
				     if 0
				     endif
				     if 0
				     endif
				     ; Now ready to see if stem has already used this key.; ES:ToFindDx at the key.
 01A1   1   2B C2		      sub ax,ToFindDx
 01A3   1   48			      dec ToFindLenAx; Lose trailing dot.

				     ; EXPOSE at the item level can lead to repeat lookup in a different pool.
				     ; Enter here with ES:DX::AX as the key.
 01A4   3p  64: 8E 5F 0A	     ExposedLoop:mov ds,Vbxf2.Sg
				     ;------------------------------------------------------------------------------
				     ; This section does the search for the keyed item.
				     ;------------------------------------------------------------------------------
				     ; ds&es at segment.
				     ; ToFindLenAx and ToFindDx set.
 01A8   1   53			      push StemBx
 01A9   1   8B 1E 000C		      mov ProbeBx,Hd.Probe
 01AD   1   8B F2		      mov TailSi,ToFindDx
 01AF   1   83 EE 0E		      sub TailSi,Jshape.Key
 01B2   1   89 B6 0146		      mov Z.NewJshape,TailSi
 01B6   1+  8D 74 08		      lea LowSi,J.Lower
				     ; ds now at segment for keys & Vshapes. bx the probe to start looking.
				     ; Lookup algorithm is like that for symbols, but has keys embedded.
				     ; So limited comments on this one.
 01B9   1+  8D 7C 02		      lea HighDi,[LowSi+Jshape.Higher-Jshape.Lower]
 01BC   3   EB 30		      jmp WhileStemBxQ

				     ; Backwater for hungover bit.
 01BE   7n  F3/ A4		     SlowRep:rep movsb
 01C0   3   EB D0		       jmp PostRep

				     ; Do the string (with length) compare.
 01C2   2   3B 47 0C		     StemLoopQ:cmp ToFindLenAx,Jbx.KeyLen
 01C5  3,1  77 20		     ja ProbeBelow2Q
 01C7  3,1  72 0F		     jb ProbeAboveQ
 01C9   1   56			      push si
 01CA   1   57			      push di
 01CB   1   8B FA		      mov di,ToFindDx
 01CD   1+  8D 77 0E		      lea TailSi,Jbx.Key
 01D0   1   8B C8		      mov cx,ToFindLenAx
 01D2   8n  F3/ A6		      repe cmpsb
 01D4   1   5F			      pop di
 01D5   1   5E			      pop si
 01D6  3,1  73 0D		      jae ProbeBelowQ
 01D8   1   89 1C		     ProbeAboveQ:mov [LowSi],ProbeBx; Complete prior iteration
 01DA   1+  8D 77 0A		      lea LowSi,Jbx.Higher
 01DD   1   8B 1C		      mov ProbeBx,[LowSi]
				     ; A little bit of duplication for speed.
				      TestReg ProbeBx
 01DF   1   85 DB		  1         test ProbeBx,ProbeBx
 01E1  3,1  75 DF		      jnz StemLoopQ
 01E3   3   EB 0D		      jmp NewStemBx

 01E5  3,1  74 26		     ProbeBelowQ:je ProbeMatchQ
 01E7   1   89 1D		     ProbeBelow2Q:mov [HighDi],ProbeBx
 01E9   1+  8D 7F 08		     lea HighDi,Jbx.Lower
 01EC   1   8B 1D		     mov ProbeBx,[HighDi]
 01EE				     WhileStemBxQ:TestReg ProbeBx
 01EE   1   85 DB		  1         test ProbeBx,ProbeBx
 01F0  3,1  75 D0		     jnz StemLoopQ; Drop through if not found.
 01F2				     NewStemBx:z Wptr[LowSi]
 01F2   1   89 2C		  1           mov Wptr[LowSi],bp
				     z Wptr[HighDi]
 01F4   1   89 2D		  1           mov Wptr[HighDi],bp
				     ; Commit the new item we have been making.
				     ; Key has already been copied into the relevant place.
 01F6   1   5B			      pop StemBx
 01F7   1   8B B6 0146		      mov TailSi,Z.NewJshape
 01FB   1   89 44 0C		      mov J.KeyLen,ToFindLenAx
 01FE   1+  8D 7C 0E		      lea di,J.Key
 0201   1   03 C7		      add ToFindLenAx,di
 0203   1   A3 0004		      mov Hd.Avail,ax
 0206   1   89 36 000C		      mov Hd.Probe,TailSi
 020A   2   F9			      stc
 020B   3   EB 1E		      jmp FoundKey

 020D				     ProbeMatchQ:;Subject found at ProbeBx.
 020D   1   8B 47 08		      mov ax,Jbx.Lower
 0210   1   89 04		      mov [LowSi],ax
 0212   1   8B 47 0A		      mov ax,Jbx.Higher
 0215   1   89 05		      mov [HighDi],ax
				     ; Address the place found with si and recover bx of the stem.
 0217   1   8B F3		      mov TailSi,ProbeBx
 0219   1   5B			      pop StemBx
 021A   1   8B BE 0146		      mov di,Z.NewJshape
 021E   1   66| 8B 7D 08	      mov edi,Jdi.Pair
 0222   1   66| 89 7C 08	      mov J.Pair,edi
 0226   1   89 36 000C		      mov Hd.Probe,TailSi; Probe for next time look at this stemmed.
 022A   2   F8			      clc
 022B				     FoundKey:
				     ;------------------------------------------------------------------------------
				     ; DS:SI now the relevant Vshape item.
				     ;------------------------------------------------------------------------------
				     ; Leave StackDi ready to take a value.
 022B   1   8B BE 00FF		      mov StackDi,Z.StackLo
 022F  3,1  72 3B		      jc TailNew
				     ; If this element is EXPOSEd, we need to lookup again, in the caller's pool.
 0231   2   80 7C 07 50		      cmp Vsid.Dtype,$Exposed
 0235  3,1  74 04		      je DotsExposed; And then ExposedLoop
 0237   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 023A   5   C3			      ret

				     ; We need to find the A.B which isn't EXPOSEd.
 023B   3   E8 18BE		     DotsExposed:call ExposedFs
				     ; Search will be with the same key.  Hard work to copy it to the new subject.
				      mv es,ds; Segment currently having key.
 023E   3   1E			  1   push ds
 023F   3p  07			  1   pop es
				     ; Stem may never have been used in the caller's pool.
 0240   2   64: 80 7F 0F 40	      cmp Vbxf2.Dtype,$Dropped
 0245  3,1  75 03		      jne @F
 0247   3   E8 002A		      call StemAllocVbxDs
 024A				      @@:
				      mv ds,es
 024A   3   06			  1   push es
 024B   3p  1F			  1   pop ds
 024C   1   57			      push di
 024D   3p  64: 8E 47 0A	      mov es,Vbxf2.Sg;
 0251   1   26: 8B 7E 04	      mov di,He.Avail
 0255   1   8B 44 0C		      mov ax,J.KeyLen
 0258   1   26: 89 45 0C	      mov es:Jdi.KeyLen,ax
 025C   1   8B C8		      mov cx,ax
 025E   1+  8D 74 0E		      lea TailSi,J.Key
 0261   1+  8D 7D 0E		      lea di,Jdi.Key
 0264   1   8B D7		      mov dx,di
				      Repmovsb
 0266   7n  F3/ A4		  1   rep movsb
 0268   1   5F			      pop di
				     ; Look again for this key on this stem in this pool.
 0269   3   E9 FF38		      jmp ExposedLoop

 026C   1   C6 44 07 88		     TailNew:mov Vsid.Dtype,$Omitted; Mark as new item.
 0270   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 0273   5   C3			      ret

 0274				     StemAllocVbxDs:; First time some tail of a stem is used. Second of pair gets
				     ; to address the segment for tails and their values.
 0274  11   60			      pusha
 0275   1   BB 01F8		      mov bx,512-8;Trigger
 0278   1+  8D 4F 08		      lea cx,[bx+8]; SegSize bytes.
 027B   1   BF 004E		      mov SegOffDi,Zshape.Stem
 027E   3   E8 0000 E		      call InitSegDs
 0281   9   61			      popa
 0282   3   64: 8C 5F 0A	      mov Vbxf2.Sg,ds
				     ; Compaction failure when this was before the allocate!
 0286   1   64: C6 47 0F 60	      mov Vbxf2.Dtype,$Stem; It is not a variable, but not now $Dropped either.
 028B   5   C3			      ret
				     ;------------------------------------------------------------------------------
				     ; The operand was not one that could be loaded directly from the ProgScope
				     ; or VarScope arrays.  The effect of the code here is as if it was.
				     ;------------------------------------------------------------------------------
				     ; There are various reasons why we might not yet have the final value.
 028C   1   68 005B R		     NotPresent:push XCycle
 028F				     NotPresentX:; Entry point when called from eg Parse.
				      mv ds,fs; Exposed only happens for variables.
 028F   3   0F A0		  1   push fs
 0291   3p  1F			  1   pop ds
;; Might be better code if we altered fs? Would have to reload after.
 0292   2   80 7F 07 50		      cmp Vbx.Dtype,$Exposed
 0296  3,1  75 0A		      jne NotExposed
				     ; Assert - loop for non-exposed bound to find one.
 0298   3p  8E 1E 000A		     @@:mov ds,Hd.UpPool
 029C   2   80 7F 07 50		     cmp Vbx.Dtype,$Exposed
 02A0  3,1  74 F6		     je @B
 02A2   2   F6 47 07 C0		     NotExposed:test Vbx.Dtype,$Test
 02A6  3,1  7F 0F		     jg @F
				      Move V,Vbx
 02A8   1   66| 8B 0F		  1     mov ecx,Vbx.OverExpo
 02AB   1   66| 89 0B		  1     mov V.OverExpo,ecx
 02AE   1   66| 8B 47 04	  1     mov eax,Vbx.OverMant
 02B2   2   66| 89 43 04	  1     mov V.OverMant,eax
				      BackRet
 02B6   5   C3			  1  ret

				     ; Here if now-non-exposed is not present. (Dropped or SIGL type)
 02B7   2   80 7F 07 40		     @@:cmp Vbx.Dtype,$Dropped
 02BB  3,1  75 14		     jne NotDropped
				     ; Is NOVALUE enabled?
 02BD   3   E8 1F98		      call HeritageDi
 02C0   3   80 7B AD 00		      cmp L.NoValue,0
 02C4   1   5F			      pop StackDi
 02C5  3,1  75 08		      jne @F
				      On Z.Cancel,WasDropped; For trace >L>
 02C7   3   80 4E 04 01		  1          or  Bptr(Z.Cancel), low ??0003
 02CB   3   E8 1F0B		      call ValueIsName
				      BackRet
 02CE   5   C3			  1  ret

				     ; NYI some lookahead here since tails of compounds don't give NOVALUE.
				     ; Lookahead for stemmed variable cases.
				     ; Raise NOVALUE.
 02CF   5p  FF D5		     @@:Error49Bp

 02D1				     NotDropped: Move V,Vbx
 02D1   1   66| 8B 0F		  1     mov ecx,Vbx.OverExpo
 02D4   1   66| 89 0B		  1     mov V.OverExpo,ecx
 02D7   1   66| 8B 47 04	  1     mov eax,Vbx.OverMant
 02DB   2   66| 89 43 04	  1     mov V.OverMant,eax

 02DF   3   F6 43 07 C0		     SysVar$$:test V.Dtype,$Test
 02E3  3,1  7F 01		     jg @F
				     BackRet
 02E5   5   C3			  1  ret

 02E6				     @@:; Assert - cannot be exposed.
 02E6   1   56			      push CursorSi
				     ; Here for ones where conversion to number has been postponed.
 02E7   3   80 7B 07 44		      cmp V.Dtype,$MsgNum
 02EB  3,1  75 2B		      jne NotMsgNum
				     ; This type, until needed, is stored with MajMin as binary.
 02ED   1   57			      push StackDi
				      mv es,ss
 02EE   3   16			  1   push ss
 02EF   3p  07			  1   pop es
 02F0   2   8B 53 04		      mov dx,V.MantLow
				     ; Major number as part of short string result, via Zone
 02F3   3   0F B6 C6		      movzx ax,dh
 02F6   3   E8 0000 E		      call Ax2DsSiCx
 02F9   7n  F3/ A4		      rep movsb
				     ; Dot and minor number unless zero.
 02FB   1   8A C2		      mov al,dl
				      TestReg ax
 02FD   1   85 C0		  1         test ax,ax
 02FF  3,1  74 0A		      jz @F
 0301   1   26: C6 05 2E	      mov Bptr es:[di],'.'
 0305   1   47			      inc di
 0306   3   E8 0000 E		      call Ax2DsSiCx
 0309   7n  F3/ A4		      rep movsb
				     ; Set Dtype of result.
 030B   1   8B C7		     @@:mov ax,di
 030D   1   5F			     pop StackDi
 030E   1   2B C7		     sub ax,StackDi
 0310   1   04 80		     add al,$NullString
 0312   2   88 43 07		     mov V.Dtype,al
 0315   3   E9 0000 E		      jmp RetEsSi

 0318   3   80 7B 07 48		     NotMsgNum:cmp V.Dtype,$Sigl
 031C  3,1  75 2E		     jne NotSigl
				     ; Use compile phase to find line number.
				      move Z.Synch,V.MantLow
 031E   2   8B 43 04		  1      mov ax,V.MantLow
 0321   1   89 86 010D		  1      mov Z.Synch,ax
 0325   1   C7 46 36 0010	      mov Z.Cursor,$StrideH
				      z Z.Scanp
 032A   1   89 AE 00E1		  1           mov Z.Scanp,bp
 032E   1   57			      push StackDi
 032F   3   E8 0000 E		      call Compiling
 0332   1   5F			      pop StackDi
 0333   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 0336   3p  8E 66 46		      mov fs,Z.VarScope
 0339   3p  8E 6E 4A		      mov gs,Z.Code
				     ; ??? NYI does Z.Stack survive? or matter?
 033C   1   66| 89 2B		      mov V.ExpAnd,ebp
 033F   2   66| 89 6B 04	      mov V.Mantissa,ebp
				      move V.MantLow,Z.ClauseLine; Or is it meant to be Z.Lines?
 0343   1   8B 46 08		  1      mov ax,Z.ClauseLine
 0346   2   89 43 04		  1      mov V.MantLow,ax
 0349   3   E9 0000 E		      jmp RetEsSi

 034C   5p  FF D5		     NotSigl:Error49Bp

				     ; End of loading operands.

				     ;------------------------------------------------------------------------------
				     ; Abut and Cat have special concerns over compaction since three strings
				     ; need pinning at the same time.
				     ;------------------------------------------------------------------------------
 = cx				     TotalCx is <cx>
 = cx				     MovsCx is <cx>
 = dx				     RHSLenDx is <dx>
 = bx				     LHSLenBx is <bx>
 034E   1   56			     Abut$$:push CursorSi
				     ; If the left one isn't a string then better convert it now so that no
				     ; compaction threat from ToDsSiCx of it.
 034F   3   F6 43 FF C0		      test V0.Dtype,$Test
 0353  3,1  75 09		      jnz @F
				      Down
 0355   1   83 EF 08		  1   sub StackDi,$StrideV
 0358   3   E8 1D1E		      call ToDsSiCx
				      Up
 035B   1   83 C7 08		  1   add StackDi,$StrideV
				     ; Remember RHS
 035E   3   E8 1D18		     @@:call ToDsSiCx
 0361   1   8B D1		     mov RHSLenDx,cx
 0363   3   1E			     push ds
 0364   1   56			     push si
				     ; Look at LHS
				      Down
 0365   1   83 EF 08		  1   sub StackDi,$StrideV
 0368   3   E8 1D0E		      call ToDsSiCx
 036B   1   8B D9		      mov LHSLenBx,cx
				     ; If room, just append in place.
 036D   1   03 CA		      add TotalCx,RHSLenDx
 036F  3,1  0F 82 0000 E	      jc Raise5p1d
 0373   1   83 F9 07		      cmp TotalCx,7
 0376  3,1  77 16		      ja AbutAlloc
				     ; Allow for possibility of a short AwayString.
 0378   3   80 7B 07 C0		      cmp V.Dtype,$AwayString
 037C  3,1  74 10		      je AbutAlloc
				     ; Setup ES:DI for place LHS to go.
				      mv es,ds
 037E   3   1E			  1   push ds
 037F   3p  07			  1   pop es
 0380   4   80 63 07 F8		      and V.Dtype,-8
 0384   4   00 4B 07		      add V.Dtype,cl; Adjust length of LHS.
 0387   3   87 DF		      xchg LHSLenBx,di
 0389   1   03 FE		      add di,si; Position inside LHS for RHS to go.
 038B   3   E9 00A3		      jmp CatAppend

 038E   1   89 8E 0142		     AbutAlloc:mov Z.CatTotal,TotalCx
				     ; Only Abut and Cat care about possible appended allocation so the code for
				     ; that is put inline, both places.
				     ; This sort of allocate may turn out to be an extend of the current $AwayString
				     ; stack item. Maybe not faster than allocate but may save a long move.
				     ; Test is whether the LHS operand is actually just ahead of what we are
				     ; about to allocate.
 0392   3   80 7B 07 C0		      cmp V.Dtype,$AwayString
 0396  3,1  75 32		      jne AbutOther
				      AllocAppend AbutOtherPop; Jump if cannot append.
 0398   1   56			  1   push si
 0399   1   8B B6 0148		  1   mov si,Z.FromDos; The current allocation source.
 039D   1   8B 02		  1   mov ax,A.Fr.Pt
 039F   3   2B 43 04		  1   sub ax,V.Len
 03A2   2   3B 03		  1   cmp ax,V.Pt
 03A4  3,1  75 23		  1   jne AbutOtherPop
 03A6   2   8B 43 02		  1   mov ax,V.Sg
 03A9   3   3B 42 02		  1   cmp ax,A.Fr.Sg
 03AC  3,1  75 1B		  1   jne AbutOtherPop
 03AE   3p  8E C0		  1   mov es,ax
 03B0   1   8B 03		  1   mov ax,V.Pt
 03B2   1   03 C1		  1   add ax,cx
 03B4  3,1  72 13		  1   jc AbutOtherPop
 03B6   3   3B 42 04		  1   cmp ax,A.Amount
 03B9  3,1  77 0E		  1   ja AbutOtherPop
 03BB   1   89 02		  1   mov A.Fr.Pt,ax
 03BD   1   2B C1		  1   sub ax,cx
 03BF   2   89 4B 04		  1   mov V.Len,cx
 03C2   1   5E			      pop si
				     ; Stack item has been changed to make room for RHS.  Setup target of RHS copy.
 03C3   3   87 DF		      xchg LHSLenBx,StackDi
 03C5   1   03 F8		      add di,ax
 03C7   3   EB 68		      jmp CatAppend
				     ; New space in memory is needed.
 03C9   1   5E			     AbutOtherPop:pop si
 03CA   3   E8 0000 E		     AbutOther:call AllocateCx_EsAx
				     ; RHS may have moved when compaction, invalidating pushed registers.
 03CD  3,1  73 10		      jnc @F
				      PopJunk si
 03CF   1   5E			  1    pop si
				      PopJunk si
 03D0   1   5E			  1    pop si
				      Up
 03D1   1   83 C7 08		  1   add StackDi,$StrideV
 03D4   3   E8 1CA2		      call ToDsSiCx
				      Down
 03D7   1   83 EF 08		  1   sub StackDi,$StrideV
 03DA   3   1E			      push ds
 03DB   1   56			      push si
 03DC   3   E8 1C9A		      call ToDsSiCx
 03DF				      @@:
				     ; Maybe LHS is short string - must move before altering stack item.
 03DF   1   8B CB		      mov MovsCx,LHSLenBx
 03E1   1   8B DF		      mov bx,StackDi
 03E3   1   8B F8		      mov di,ax
				      Repmovsb
 03E5   7n  F3/ A4		  1   rep movsb
 03E7   3   E9 00B2		      jmp CatLong

				     ; See also Abut$$
 03EA   1   56			     Cat$$:push CursorSi
				     ; If the left one isn't a string then better convert it now so that no
				     ; compaction threat from ToDsSiCx of it.
 03EB   3   F6 43 FF C0		      test V0.Dtype,$Test
 03EF  3,1  75 09		      jnz @F
				      Down
 03F1   1   83 EF 08		  1   sub StackDi,$StrideV
 03F4   3   E8 1C82		      call ToDsSiCx
				      Up
 03F7   1   83 C7 08		  1   add StackDi,$StrideV
 03FA   3   E8 1C7C		     @@:call ToDsSiCx
 03FD   1   8B D1		      mov RHSLenDx,cx
 03FF   3   1E			      push ds
 0400   1   56			      push si
				      Down
 0401   1   83 EF 08		  1   sub StackDi,$StrideV
 0404   3   E8 1C72		      call ToDsSiCx
 0407   1   8B D9		      mov LHSLenBx,cx
				     ; Allow for separating character.
 0409   1   03 CA		      add TotalCx,RHSLenDx
 040B  3,1  0F 82 0000 E	      jc Raise5p1d
 040F   1   41			      inc TotalCx
 0410  3,1  0F 84 0000 E	      jz Raise5p1d
 0414   1   83 F9 07		      cmp TotalCx,7
 0417  3,1  77 23		      ja CatAlloc
				     ; Allow for possibility of a short AwayString.
 0419   3   80 7B 07 C0		      cmp V.Dtype,$AwayString
 041D  3,1  0F 84 FF6D		      je AbutAlloc
				     ; If room, just append in place.
				      mv es,ds
 0421   3   1E			  1   push ds
 0422   3p  07			  1   pop es
 0423   4   80 63 07 F8		      and V.Dtype,-8
 0427   4   00 4B 07		      add V.Dtype,cl; Adjust length of LHS.
 042A   3   87 DF		      xchg LHSLenBx,di
 042C   1   03 FE		      add di,si; Position inside LHS for RHS to go.
 042E   1   B0 20		      mov al,' '
 0430   5   AA			      stosb
 0431   1   5E			     CatAppend:pop si
 0432   3p  1F			      pop ds
 0433   1   8B CA		      mov MovsCx,RHSLenDx
				      Repmovsb; Copy the RHS
 0435   7n  F3/ A4		  1   rep movsb
 0437   1   8B FB		      mov StackDi,bx
 0439   3   E9 0000 E		      jmp RetEsSi
 043C   1   89 8E 0142		     CatAlloc:mov Z.CatTotal,TotalCx
 0440   3   80 7B 07 C0		      cmp V.Dtype,$AwayString
 0444  3,1  75 32		      jne CatOther
				      AllocAppend CatOtherPop
 0446   1   56			  1   push si
 0447   1   8B B6 0148		  1   mov si,Z.FromDos; The current allocation source.
 044B   1   8B 02		  1   mov ax,A.Fr.Pt
 044D   3   2B 43 04		  1   sub ax,V.Len
 0450   2   3B 03		  1   cmp ax,V.Pt
 0452  3,1  75 23		  1   jne CatOtherPop
 0454   2   8B 43 02		  1   mov ax,V.Sg
 0457   3   3B 42 02		  1   cmp ax,A.Fr.Sg
 045A  3,1  75 1B		  1   jne CatOtherPop
 045C   3p  8E C0		  1   mov es,ax
 045E   1   8B 03		  1   mov ax,V.Pt
 0460   1   03 C1		  1   add ax,cx
 0462  3,1  72 13		  1   jc CatOtherPop
 0464   3   3B 42 04		  1   cmp ax,A.Amount
 0467  3,1  77 0E		  1   ja CatOtherPop
 0469   1   89 02		  1   mov A.Fr.Pt,ax
 046B   1   2B C1		  1   sub ax,cx
 046D   2   89 4B 04		  1   mov V.Len,cx
 0470   1   5E			      pop si
				     ; Stack item has been changed to make room for RHS.
 0471   3   87 DF		      xchg LHSLenBx,StackDi
 0473   1   03 F8		      add di,ax
 0475   3   EB 1E		      jmp CatMid

 0477   1   5E			     CatOtherPop:pop si
 0478   3   E8 0000 E		     CatOther:call AllocateCx_EsAx
				     ; RHS may have moved when compaction, invalidating pushed registers.
 047B  3,1  73 10		      jnc @F
				      PopJunk si
 047D   1   5E			  1    pop si
				      PopJunk si
 047E   1   5E			  1    pop si
				      Up
 047F   1   83 C7 08		  1   add StackDi,$StrideV
 0482   3   E8 1BF4		      call ToDsSiCx
				      Down
 0485   1   83 EF 08		  1   sub StackDi,$StrideV
 0488   3   1E			      push ds
 0489   1   56			      push si
 048A   3   E8 1BEC		      call ToDsSiCx
 048D				      @@:
				     ; Maybe LHS is short string - must move before altering stack item.
 048D   1   8B CB		      mov MovsCx,LHSLenBx
 048F   1   8B DF		      mov bx,StackDi
 0491   1   8B F8		      mov di,ax
				      Repmovsb
 0493   7n  F3/ A4		  1   rep movsb
 0495   1   8B C8		     CatMid:mov cx,ax
 0497   1   B0 20		      mov al,' '
 0499   5   AA			      stosb
 049A   1   8B C1		      mov ax,cx
 049C   1   5E			     CatLong:pop si
 049D   3p  1F			      pop ds
 049E   1   8B CA		      mov MovsCx,RHSLenDx
				      Repmovsb; Copy the RHS
 04A0   7n  F3/ A4		  1   rep movsb
				     ; Fill fields of stack item to address result
 04A2   1   8B FB		      mov StackDi,bx
 04A4   1   8B 8E 0142		      mov TotalCx,Z.CatTotal
 04A8   2   89 4B 04		      mov V.Len,TotalCx
 04AB   4   8C 43 02		      mov V.Sg,es
 04AE   1   89 03		      mov V.Pt,ax
 04B0   2   C6 43 07 C0		      mov V.Dtype,$AwayString
 04B4   3   E9 0000 E		      jmp RetEsSi

 04B7   1   26: C6 46 7B 80	     Nop$$:mov Ve.Dtype[$?CLAUSETIME],$NullString
				      BackRet
 04BC   5   C3			  1  ret

				     ;------------------------------------------------------------------------------
				     ; PARSE stage one is to get the subject addressed by the current stack variable.
				     ;------------------------------------------------------------------------------
 = di				     CursorDi is <di>
 = si				     SectionSi is <si>
 = di				     SectionDi is <di>
 = dx				     SectionDx is <dx>
 = cx				     DataLenCx is <cx>
 = cx				     SectionCx is <cx>
 = si				     PatternSi is <si>

 04BD   5   65: AC		     Parse$$:lodsb Bptr gs:[CursorSi]
 04BF   1   8A D8		     mov bl,al
 04C1   2   65: 80 3C 0A	      cmp Bptr gs:[CursorSi],$mUpper
 04C5  3,1  75 05		      jne @F
 04C7   1   46			      inc CursorSi
				      On Z.Cancel,ParseUpper
 04C8   3   80 4E 04 10		  1          or  Bptr(Z.Cancel), low ??0008
 04CC				      @@:
 04CC   1   56			      push CursorSi
 04CD   5p  2E: FF A7 04D2 R	      jmp SourceTable[bx]

				     if Solid
 04D2				     SourceTable:
 04D2  05CE R			      dw Var$
 04D4  05CE R			      dw With$
 04D6  04E0 R			      dw Arg$
 04D8  0521 R			      dw LineIn$
 04DA  0523 R			      dw Pull$
 04DC  057F R			      dw Source$
 04DE  0567 R			      dw Version$
				     endif

				     ; This can be repeated at the template comma.
 04E0				     Arg$:z Z.ParseeNum
 04E0   1   89 AE 0132		  1           mov Z.ParseeNum,bp
				     Up
 04E4   1   83 C7 08		  1   add StackDi,$StrideV
 04E7   3   FF 86 0132		     ArgInc:inc Z.ParseeNum; All the other sources keep ParseeNum at zero.
				     ; Set StackSi for relevant argument.
 04EB   1   8B 86 0132		      mov ax,Z.ParseeNum
 04EF   2   C1 E0 03		      shl ax,$ShiftV
 04F2   1   8B 76 52		      mov LevelSi,Z.Level
 04F5   2   8B 72 06		      mov StackSi,Lsi.Arg0
 04F8   1   03 F0		      add StackSi,ax
				     ; Put copy of it at current stack item.
				      Move V,Vsi
 04FA   1   66| 8B 0A		  1     mov ecx,Vsi.OverExpo
 04FD   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0500   2   66| 8B 42 04	  1     mov eax,Vsi.OverMant
 0504   2   66| 89 43 04	  1     mov V.OverMant,eax
 0508   3   E8 1B6E		      call ToDsSiCx
 050B   3   E9 00C4		      jmp FromArg

 050E   1   56			     TemplateComma$:push CursorSi
 050F   2   39 AE 0132		     cmp Z.ParseeNum,ZeroBp
 0513  3,1  75 D2		     jne ArgInc
 0515   1   5E			     pop CursorSi
				     ; Non-ARG so parse a null string.
				      move Z.Parsee.Limit,Z.Parsee.Pt
 0516   1   8B 86 012C		  1      mov ax,Z.Parsee.Pt
 051A   1   89 86 0130		  1      mov Z.Parsee.Limit,ax
 051E   3   E9 00D4		      jmp LoadTrigger

 0521				     LineIn$:
 0521   5p  FF D5		      Error49Bp

 0523				     Pull$:; Push/Pull is at the high end of Z.Serial.
				     ; Length of aggregate is first word of Z.Serial.
				     ; Items have their length at both ends of the item.
 0523   1   B0 01		      mov al,$SerialQue
 0525   3   E8 0000 E		      call Serialize
				      mv ds,ss
 0528   3   16			  1   push ss
 0529   3p  1F			  1   pop ds
				     ; Another source if nothing on Rexx stack.
 052A   1   8B B6 01AB		      mov si,Wptr Z.Serial
				      TestReg si
 052E   1   85 F6		  1         test si,si
 0530  3,1  74 22		      jz PullSysin
				     ; Do the "pop".
 0532   2   8B 8A 01AB		      mov cx,Wptr Z.Serial[si]
 0536   1   2B F1		      sub si,cx
 0538   1   89 B6 01AB		      mov Wptr Z.Serial,si
				     ; Item (including lengths) goes from Z.Serial[si+2] for cx bytes.
				     ; Have to physically copy because where it is can get reused.
 053C   2+  8D B2 01AF		     Pulled:lea si,Z.Serial[si+4]
 0540   1   83 E9 04		      sub cx,4
				      Up
 0543   1   83 C7 08		  1   add StackDi,$StrideV
 0546   3   E8 1CEE		      call ResultSpace
 0549   1   57			      push StackDi
 054A   1   8B F8		      mov di,ax
 054C   7n  F3/ A4		      rep movsb
 054E   1   5F			      pop StackDi
 054F   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 0552   3   EB 7A		      jmp Var$

 0554				     PullSysin:; Fill by read of Stdin
				     ; Pretend there are lengths, to share code.
				      z bx; Handle of Stdin
 0554   1   8B DD		  1           mov bx,bp
 0556   1   BA 01AF		      mov dx,offset Zshape.Serial+4
 0559   1   B9 11C4		      mov cx,sizeof Zshape.Serial-4
 055C   1   B4 3F		      mov ah,$DosRead
 055E  30   CD 21		      int 21h
 0560   1   83 C0 04		      add ax,4
 0563   1   8B C8		      mov cx,ax
 0565   3   EB D5		      jmp Pulled

 0567				     Version$:; Alias the constant from code segment to a stack variable.
				      Up
 0567   1   83 C7 08		  1   add StackDi,$StrideV
				      mv ds,cs
 056A   3   0E			  1   push cs
 056B   3p  1F			  1   pop ds
 056C   1   BE 2298 R		      mov si,offset Version
 056F   1   B9 0015		      mov cx,sizeof Version
 0572   3   EB 57		      jmp FromVersion

				     ; This routine makes the V stack variable reflect DS:SI::CX
 0574   1   89 33		     VasDsSiCx:mov V.Pt,si
 0576   4   8C 5B 02		     mov V.Sg,ds
 0579   2   89 4B 04		     mov V.Len,cx
 057C   3   E9 16D0		     jmp Away

 057F				     Source$:Up
 057F   1   83 C7 08		  1   add StackDi,$StrideV
 0582   1   57			     push StackDi
				     ; #Configuration #HowInvoked #Source, to be set up as string variable.
				     ; Add up lengths in cx and allocate space.
 0583   1   B9 000A		      mov cx,sizeof Configuration
 0586   2   03 4E 1A		      add cx,Z.HowInvoked
 0589   6p  C5 5E 3C		      lds bx,Z.InsSource
 058C   1   8B 5F 0C		      mov bx,Jbx.KeyLen
 058F   1   03 CB		      add cx,bx
 0591   1   51			      push cx
				      mv ds,cs
 0592   3   0E			  1   push cs
 0593   3p  1F			  1   pop ds
 0594   3   E8 0000 E		      call AllocateCx_EsAx
				     ; Copy Configuration from code segment.
 0597   1   8B F8		      mov di,ax
 0599   1   B9 000A		      mov cx,sizeof Configuration
 059C   1   BE 22AD R		      mov si,offset Configuration
 059F   7n  F3/ A4		      rep movsb
				     ; Copy HowInvoked from code segment.
 05A1   1   8B 4E 1A		      mov cx,Z.HowInvoked
 05A4   1   83 F9 09		      cmp cx,sizeof FUNCTION
 05A7  3,1  75 04		      jne @F
 05A9   1   81 C6 0008		      add si,FUNCTION-COMMAND
 05AD				      @@:
 05AD   1   83 F9 0B		      cmp cx,sizeof SUBROUTINE
 05B0  3,1  75 04		      jne @F
 05B2   1   81 C6 0011		      add si,SUBROUTINE-COMMAND
 05B6				      @@:
 05B6   7n  F3/ A4		      rep movsb
				     ; And the bit for #Source.
 05B8   1   8B CB		      mov cx,bx
 05BA   6p  C5 5E 3C		      lds bx,Z.InsSource
 05BD   1+  8D 77 0E		      lea si,Jbx.Key
 05C0   7n  F3/ A4		      rep movsb
				      mv ds,es
 05C2   3   06			  1   push es
 05C3   3p  1F			  1   pop ds
 05C4   1   8B F0		      mov si,ax
 05C6   1   59			      pop cx
 05C7   1   5F			      pop StackDi
 05C8   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 05CB				     FromVersion:; Set stack to reflect the value.
 05CB   3   E8 FFA6		      call VasDsSiCx

 05CE				     Var$:
 05CE				     With$:; Stack has the thing to be parsed.
				      z Z.ParseeNum; And stays that for these sources.
 05CE   1   89 AE 0132		  1           mov Z.ParseeNum,bp
 05D2				     FromArg:
				     ; We keep a stored copy of the subject during PARSE, on stack so that
				     ; Compaction is aware. (Compaction only during escape)
				      Qry Z.Cancel,ParseUpper
 05D2   2   F6 46 04 10		  1          test Bptr(Z.Cancel), low ??0009
 05D6  3,1  74 03		      jz @F
 05D8   3   E8 0000 E		      call CONFIG_UPPER$$
 05DB				      @@:
 05DB   3   E8 1A9B		      call ToDsSiCx
				     ; Z.Parsee.Sg we keep stored because of paucity of segment registers.
				     ; Z.Parsee.Pt we keep stored ready to create an empty segment. (TemplateComma)
				     ; Also keep track of the end of the sections.
 05DE   3   8C 9E 012E		      mov Z.Parsee.Sg,ds
 05E2   1   89 B6 012C		      mov Z.Parsee.Pt,si
 05E6   1   03 CE		      add cx,si
 05E8   1   89 8E 0130		      mov Z.Parsee.Limit,cx
				     ; The position of a pattern determines the start of the following section.
 05EC   1   89 B6 0136		      mov Z.BreakStart,si
 05F0   1   89 B6 0138		      mov Z.BreakEnd,si
 05F4   1   5E			      pop CursorSi
				     ;------------------------------------------------------------------------------
				     ; Second stage, get the trigger value, eg the pattern for a pattern search.
				     ;------------------------------------------------------------------------------
				     ; If the trigger is not a difficult value to load, we do not need to go
				     ; back to the interpreter loop to load it.
 05F5   1   65: 8B 04		     LoadTrigger:mov ax,Wptr gs:[CursorSi]
 05F8   1   46			     inc CursorSi
 05F9				     NextSection:
				     ; AX is two bytes from the Pcode, with CursorSi moved over one of them.
 05F9   1   3C 22		      cmp al,$mPosRest
 05FB  3,1  0F 84 0141		      je PosRest$; No value to load for PosRest$
 05FF   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0602  3,1  0F 85 02A2		      jne ParseBcode; Will return to TriggerWith.
				     if Debug
				     ; Shouldn't be an opcode.test al,1jz @FError49Bp@@:
				     endif
				     ; It will be a marker or an operand for a trigger.
 0606   1   A8 02		     TriggerArg:test al,02h
 0608  3,1  75 3E		     jnz PSwitch
				     ; It is a (non-complex) operand.
				     ; Load value of variable needed for trigger.
				     ; Advance cursor over the operand and wind up at TriggerWith.
 060A   1   46			      inc CursorSi
 060B   1   8B D8		      mov ArrayBx,ax
				      Up
 060D   1   83 C7 08		  1   add StackDi,$StrideV
 0610   1   A8 04		      test al,04h
 0612  3,1  75 1F		      jnz ConTrigger
				     ; Compile time could detect most complications, but not EXPOSED.
 0614   2   64: F6 47 07 C0	      test Vbxf.Dtype,$Test
 0619  3,1  7F 12		      jg @F
				      Move V,Vbxf
 061B   1   66| 64: 8B 0F	  1     mov ecx,Vbxf.OverExpo
 061F   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0622   1   66| 64: 8B 47 04	  1     mov eax,Vbxf.OverMant
 0627   2   66| 89 43 04	  1     mov V.OverMant,eax
 062B   3   EB 19		      jmp TriggerWith
 062D   1   68 0646 R		     @@:push TriggerWith
 0630   3   E9 FC5C		      jmp NotPresentX
				     ; Load value of constant needed for trigger.
 0633   3p  8E 46 44		     ConTrigger: mov ProgEs,Z.ProgScope
				     Move V,Vbxe
 0636   1   66| 26: 8B 0F	  1     mov ecx,Vbxe.OverExpo
 063A   1   66| 89 0B		  1     mov V.OverExpo,ecx
 063D   1   66| 26: 8B 47 04	  1     mov eax,Vbxe.OverMant
 0642   2   66| 89 43 04	  1     mov V.OverMant,eax

				     ; Switch on which trigger.  StackDi has the trigger value, if trigger uses one.
 0646   5   65: AC		     TriggerWith:lodsb gs:[CursorSi]; Known to be a marker.

 0648   2   C0 E8 02		     PSwitch:shr al,2
 064B   3   0F B6 D8		     movzx bx,al
 064E   5p  2E: FF A7 064F R	     jmp Triggers[bx-$mParseEscape/4]
				     if Solid
 0653				     Triggers:
 0653  0842 R			      dw ParseEscape$ ; Complex operand. Get and resume at TriggerWith.
 0655  0824 R			      dw ParseEnd$
 0657  0740 R			      dw PosRest$     ; Won't happen here - was tested early.
 0659  0663 R			      dw Pattern$
 065B  06C8 R			      dw PosEq$
 065D  06F1 R			      dw PosPlus$
 065F  06E5 R			      dw PosMinus$
 0661  050E R			      dw TemplateComma$
				     endif

				     ;------------------------------------------------------------------------------
				     ; Third stage.
				     ; Here we deal with a section of the parse. We deduce where the section runs,
				     ; and record BreakStart and BreakEnd for use next time around in determining
				     ; the next section.  Goes on to WordParse, via Section.
				     ;------------------------------------------------------------------------------
 0663   1   56			     Pattern$:push CursorSi
 0664   3   E8 1A12		     call ToDsSiCx
				      Down
 0667   1   83 EF 08		  1   sub StackDi,$StrideV
 066A   1   58			      pop ax
 066B   1   57			      push StackDi
 066C   1   50			      push ax; CursorSi nearest as WordParse needs.
				     ; Search for this pattern.
				      JcxzQ NullPattern; Null matches the end of the subject.
 066D   1   85 C9		  1    test cx,cx
 066F  3,1  74 45		  1    je NullPattern
				     ; Setup where to search.
 0671   1   89 8E 0134		      mov Z.PattLenEtc,cx
 0675   3p  8E 86 012E		      mov es,Z.Parsee.Sg
 0679   1   8B BE 0138		      mov SectionDi,Z.BreakEnd
 067D   1   8B 8E 0130		      mov SectionCx,Z.Parsee.Limit
 0681   1   2B CF		      sub SectionCx,SectionDi
				     ; PatternSi is at pattern, SectionDi at subject, SectionCx to look over.
				     ; Stop on places that match the first character.
 0683   1   8A 04		      mov al,[PatternSi]
 0685   6n  F2/ AE		     SingleNext:repne scasb
 0687  3,1  75 2D		      jne NullPattern
				     ; One character match. Is the pattern longer?
 0689   1   8B 96 0134		      mov dx,Z.PattLenEtc
 068D   1   4A			      dec dx
 068E  3,1  74 14		      jz HasPattern
				     ; Compare rest of pattern, without advancing. dx is amount left to compare.
 0690   1   3B D1		      cmp dx,SectionCx
 0692  3,1  77 22		      ja NullPattern
 0694   1   57			      push SectionDi
 0695   1   51			      push SectionCx
 0696   1   56			      push PatternSi
 0697   1   46			      inc PatternSi
 0698   1   8B CA		      mov cx,dx
 069A   8n  F3/ A6		      repe cmpsb
 069C   1   5E			      pop PatternSi
 069D   1   59			      pop SectionCx
 069E  3,1  74 03		      je HasPatternPop
 06A0   1   5F			      pop SectionDi
 06A1   3   EB E2		      jmp SingleNext
 06A3				     HasPatternPop:PopJunk ax
 06A3   1   58			  1    pop ax
				     ; Match over all pattern.
 06A4				     HasPattern:; SectionDi is now position after the last matching character.
 06A4   1   8B B6 0138		      mov SectionSi,Z.BreakEnd; Start of this section.
 06A8   1   89 BE 0138		      mov Z.BreakEnd,SectionDi
 06AC   2   2B BE 0134		      sub SectionDi,Z.PattLenEtc
 06B0   1   89 BE 0136		      mov Z.BreakStart,SectionDi
 06B4   3   EB 7A		      jmp Section

 06B6   1   8B B6 0138		     NullPattern:mov SectionSi,Z.BreakEnd
 06BA   1   8B 86 0130		      mov ax,Z.Parsee.Limit
 06BE   1   89 86 0138		      mov Z.BreakEnd,ax
 06C2   1   89 86 0136		      mov Z.BreakStart,ax
 06C6   3   EB 68		      jmp Section
				     ; Here the column for the limit of a new section is specified.
 06C8   3   E8 192A		     PosEq$:call ToWholeEbx
 06CB  3,1  0F 82 1177		     jc Raise26p4
				     Down
 06CF   1   83 EF 08		  1   sub StackDi,$StrideV
 06D2   1   57			     push StackDi
 06D3   1   56			     push CursorSi
 06D4   1   8B B6 0138		      mov SectionSi,Z.BreakEnd
				     ; Convert from column to segment offset.
 06D8   1   8B 86 012C		      mov ax,Z.Parsee.Pt
 06DC   1   03 C3		      add ax,bx
 06DE   1   48			      dec ax
 06DF   3   66| 0F B7 D0	      movzx edx,ax
 06E3   3   EB 25		      jmp PosNew

				     ; Relative means relative to start of last section delimiter.
				     ; If we do this in 16 bits, negatives will look like large addresses.
 06E5   3   E8 190D		     PosMinus$:call ToWholeEbx
 06E8  3,1  0F 82 115A		     jc Raise26p4
 06EC   1   66| F7 DB		     neg ebx
 06EF   3   EB 07		     jmp @F
 06F1   3   E8 1901		     PosPlus$:call ToWholeEbx
 06F4  3,1  0F 82 114E		     jc Raise26p4
 06F8				     @@:Down
 06F8   1   83 EF 08		  1   sub StackDi,$StrideV
 06FB   1   57			     push StackDi
 06FC   1   56			     push CursorSi
 06FD   3   66| 0F B7 96 0136	     movzx edx,Z.BreakStart
 0703   1   8B F2		      mov SectionSi,dx
 0705   1   66| 03 D3		      add edx,ebx
 0708   1   8B C2		      mov ax,dx
				     ; Keep position to start next section within range.
 070A   3   66| 0F B7 8E 012C	     PosNew:movzx ecx,Z.Parsee.Pt
 0710   1   66| 3B D1		     cmp edx,ecx
 0713  3,1  7D 04		     jge @F
 0715   1   8B 86 012C		     mov ax,Z.Parsee.Pt
 0719				     @@:
 0719   3   66| 0F B7 8E 0130	      movzx ecx,Z.Parsee.Limit
 071F   1   66| 3B D1		      cmp edx,ecx
 0722  3,1  7C 04		      jl @F
 0724   1   8B 86 0130		      mov ax,Z.Parsee.Limit
 0728				      @@:
 0728   1   89 86 0136		      mov Z.BreakStart,ax
 072C   1   89 86 0138		      mov Z.BreakEnd,ax
 0730				     Section:; Section goes from current SectionSi to new Z.BreakStart or end of
				     ; subject. Hence DataLenCx.
 0730   1   8B 8E 0136		      mov cx,Z.BreakStart
 0734   2   3B B6 0138		      cmp SectionSi,Z.BreakEnd
 0738  3,1  72 04		      jb @F
 073A   1   8B 8E 0130		      mov cx,Z.Parsee.Limit
 073E				      @@:
 073E   3   EB 0A		      jmp SectionGo

 0740				     PosRest$:; Section runs to end of parsee.
				     ; No need to set things for next section, or to range check.
 0740   1   57			      push StackDi
 0741   1   56			      push CursorSi
 0742   1   8B B6 0138		      mov SectionSi,Z.BreakEnd
 0746   1   8B 8E 0130		      mov cx,Z.Parsee.Limit
 074A   1   2B CE		     SectionGo:sub DataLenCx,SectionSi

				     ;------------------------------------------------------------------------------
				     ; Stage 4 - Bits of the identified section are assigned to variables.
				     ; WordParse - see the Standard.
				     ;------------------------------------------------------------------------------
 074C   1   5F			      pop CursorDi
 074D   3p  8E 9E 012E		      mov ds,Z.Parsee.Sg
				     ; This is a routine where Pcode and Bcode are distinquished during execution.
 0751   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0754  3,1  0F 85 0166		      jne ParseB
				     ; Looking though ds:si:cx for words. Assigning to targets given in Pcode.
				     ; The loop will advance si with corresponding reduction in cx, in conjunction
				     ; with di advancing through targets.
 0758   1   65: 8B 1D		     NextTarget:mov OperandBx,gs:[CursorDi]
				     ; It will either be a target, or a marker (for EndParse or ParseEscape),
				     ; or an operand which is next trigger value.
 075B   1   F6 C3 06		      test bl,$CaseTarget
 075E  3,1  0F 8B 00CD		      jpo WpDone
				     ; It is a target. Cursor advances over target.
 0762   1   47			      inc CursorDi
 0763   1   47			      inc CursorDi
 0764   1   83 EB 06		      sub OperandBx,$CaseTarget
				     ; Make fs:bx the item to be assigned to.
 0767   2   64: 80 7F 07 50	      cmp Vbxf.Dtype,$Exposed
 076C  3,1  75 03		      jne @F
 076E   3   E8 138B		      call ExposedFs
 0771				      @@:
 0771   3   0F A0		      push fs
 0773   1   53			      push OperandBx
				     ; Enter here from escape for tailed cases.
 0774				     ParseAssign:; The next part of the subject is to be assigned to (pushed) FS:BX.
				     ; There will be no compaction while determining what to assign.
				      JcxzQ AssignNull; Assign null is same whether this is last of section or not.
 0774   1   85 C9		  1    test cx,cx
 0776  3,1  0F 84 008B		  1    je AssignNull
 077A   1   65: 8A 05		      mov al,Bptr gs:[CursorDi]
 077D   1   A8 06		      test al,$CaseTarget
 077F  3,1  74 33		      jz WpLast
 0781  3,1  7A 04		      jpe WpWord
 0783   1   3C 12		      cmp al,$mParseEscape
 0785  3,1  75 2D		      jne WpLast
				     ; When not last of section, target gets just one word.
 0787				     WpWord:
 0787   1   BB 0000 E		      mov bx,Attributes; Prepare to test AllBlanks.
				     ; Move SI on to nonblank.
 078A   5   AC			     @@:lodsb
				     XlatBDLS
 078B   4   2E: D7		  1   xlat Bptr cs:[bx]
 078D   1   A8 C0		  1   test al,0C0h
 078F  3,1  75 05		     jnz @F
				     LoopQ @B
 0791   1   49			  1    dec cx
 0792  3,1  75 F6		  1    jnz @B
 0794   3   EB 6F		     jmp AssignNull
				     ; Came out of the above loop with si advanced but cx not fully decreased.
				     ; SectionDx to remember start of the word.
 0796   1   8B D6		     @@:mov SectionDx,SectionSi
 0798   1   4A			     dec SectionDx
 0799   1   49			     dec cx
 079A  3,1  74 0A		     jz WpOne
				     ; Move SI on to blank.
 079C   5   AC			     @@:lodsb
				     XlatBDLS
 079D   4   2E: D7		  1   xlat Bptr cs:[bx]
 079F   1   A8 C0		  1   test al,0C0h
 07A1  3,1  74 05		     jz @F
				     LoopQ @B
 07A3   1   49			  1    dec cx
 07A4  3,1  75 F6		  1    jnz @B
				     ; Nothing ends the word. We want to do further work with DataLenCx=0
 07A6   1   41			     WpOne:inc DataLenCx
 07A7   1   46			     inc SectionSi
 07A8   1   49			     @@:dec DataLenCx; Word terminator not part of residue.
				     ; SectionSi is beyond the blank but that is OK - don't want to scan it again.
 07A9   1   89 8E 0134		      mov Z.PattLenEtc,DataLenCx; Save use as residue, start use as word length.
 07AD   1   8B CE		      mov cx,SectionSi
 07AF   1   2B CA		      sub cx,SectionDx
 07B1   1   49			      dec cx; Word length.
 07B2   3   87 F2		      xchg SectionSi,SectionDx; Back to start of the word. SectionDx for next scan.
				     ; Assign that word away, to variable specified in pcode, now ArrayBx.
				     ; ds:si::cx is the word.
 07B4				     WpLast:; Enter here for last target -last one gets the residue, blanks and all.
 07B4   1   5B			      pop OperandBx
 07B5   3p  0F A1		      pop fs
				     ; I hate to have a test that costs even when trace isn't used but this place
				     ; is so deep in parse that I see no reasonable way to use $pTraceEvent instead.
				      Qry Z.Cancel,ParseTrace
 07B7   2   F6 46 04 08		  1          test Bptr(Z.Cancel), low ??000A
 07BB  3,1  74 0E		      jz NotTracing
 07BD  11   60			      pusha
 07BE   1   B0 00		      mov al,$TraceAssign
 07C0   1   83 FB 10		      cmp OperandBx,$?Discard
 07C3  3,1  75 02		      jne @F
 07C5   1   B0 08		      mov al,$TraceDot
 07C7				      @@:
 07C7   3   E8 0000 E		      call TraceEventX
 07CA   9   61			      popa
 07CB				     NotTracing:
				     ; Moot whether testing for 'no target' is worth the saving.
				     ; It didn't help REXXCPS much. So we assign to $?Discard instead.
 07CB   1   83 F9 07		      cmp cx,7
 07CE  3,1  77 23		      ja @8p3p17A
				      Move Vbxf,Vsid,eax
 07D0   1   66| 8B 04		  1    mov eax,Vsid.OverExpo
 07D3   1   66| 64: 89 07	  1    mov Vbxf.OverExpo,eax
 07D7   1   66| 8B 44 04	  1    mov eax,Vsid.OverMant
 07DB   1   66| 64: 89 47 04	  1    mov Vbxf.OverMant,eax
 07E0   1   80 C1 80		      add cl,$NullString
 07E3   1   64: 88 4F 07	      mov Vbxf.Dtype,cl
				     ; Rescan from where we had reached.
 07E7   3p  8E 66 46		     WpResume:mov fs,Z.VarScope
 07EA   1   8B F2		      mov SectionSi,SectionDx
 07EC   1   8B 8E 0134		      mov DataLenCx,Z.PattLenEtc
 07F0   3   E9 FF65		      jmp NextTarget

 07F3				     @8p3p17A:; Alias setup
 07F3   3   64: 8C 5F 02	      mov Vbxf.Sg,ds
 07F7   1   64: 89 37		      mov Vbxf.Pt,si
 07FA   1   64: 89 4F 04	      mov Vbxf.Len,cx
 07FE   1   64: C6 47 07 C0	      mov Vbxf.Dtype,$AwayString
 0803   3   EB E2		      jmp WpResume

 0805				     AssignNull:
				      Qry Z.Cancel,ParseTrace
 0805   2   F6 46 04 08		  1          test Bptr(Z.Cancel), low ??000B
 0809  3,1  74 0E		      jz NotTracingX
 080B  11   60			      pusha
 080C   1   B0 00		      mov al,$TraceAssign
 080E   1   83 FB 10		      cmp OperandBx,$?Discard
 0811  3,1  75 02		      jne @F
 0813   1   B0 08		      mov al,$TraceDot
 0815				      @@:
 0815   3   E8 0000 E		      call TraceEventX
 0818   9   61			      popa
 0819   1   5B			     NotTracingX:pop OperandBx
 081A   3p  0F A1		      pop fs
 081C   1   64: C6 47 07 80	      mov Vbxf.Dtype,$NullString
 0821   3   E9 FF34		      jmp NextTarget

				     ; Parsee to be taken off stack at end of PARSE clause.
 0824				     ParseEnd$:Down
 0824   1   83 EF 08		  1   sub StackDi,$StrideV
				     Off Z.Cancel,ParseUpper
 0827   3   80 66 04 EF		  1          and Bptr(Z.Cancel), low not ??000C
 082B   3p  8E 46 44		     mov ProgEs,Z.ProgScope
				     BackRet
 082E   5   C3			  1  ret

 082F   1   89 B6 0134		     WpDone:mov Z.PattLenEtc,SectionSi
 0833   1   8B F7		      mov CursorSi,CursorDi
 0835   1   5F			      pop StackDi
 0836   3p  8E 66 46		      mov fs,Z.VarScope
				     ; The sequence of targets was ended either by a marker or by the operand
				     ; part of the next trigger. In the latter case we go to work
				     ; on the next section of the parse. In the former case we may have an
				     ; operandless trigger like PosRest or ParseEnd, or this may not really
				     ; be the end of the targets, just a target that needs AssignDotsP$$.
				     ; That target calculation will start with a $mParseEscape.
 0839   1   8B C3		      mov ax,bx
 083B   1   46			      inc CursorSi
 083C   1   3C 12		      cmp al,$mParseEscape
 083E  3,1  0F 85 FDB7		      jne NextSection
				     ;------------------------------------------------------------------------------
				     ; Escapes from simple parsing.
				     ;------------------------------------------------------------------------------
				     ; We won't come here often but there is a lot to do.
				     ; If Compaction happens the parse subject will move in memory. So our
				     ; pointers into it have to be made relative to its first byte and
				     ; reconstructed later.

 0842				     ParseEscape$:
				     ; The simple parse for a trigger will have an operand then a code for the
				     ; type of trigger. If the operand cannot be represented as just a two-byte
				     ; reference (eg because tailed) then escape is made to load the operand.
				     ; The other use of $mParseEscape is similar, when a target is tailed.
				     ; Make info relative to start of subject.
 0842   1   8B 86 012C		      mov ax,Z.Parsee.Pt
 0846   3   29 86 0130		      sub Z.Parsee.Limit,ax
 084A   3   29 86 0136		      sub Z.BreakStart,ax
 084E   3   29 86 0138		      sub Z.BreakEnd,ax
 0852   3   29 86 0134		      sub Z.PattLenEtc,ax
 0856   3p  8E 46 44		      mov ProgEs,Z.ProgScope
				      BackRet; PARSE suspends for a while.
 0859   5   C3			  1  ret
				     ; Here from XCycle when complex trigger operand has been loaded.
 085A   1   46			     ResumeParse$$:inc CursorSi
 085B   1   68 0646 R		     push TriggerWith
 085E   1   56			     SubjectRestore:push CursorSi
				     ; Make info reflect (possibly) new position of parsee.
 085F   3   E8 1817		      call ToDsSiCx
 0862   3   8C 9E 012E		      mov Z.Parsee.Sg,ds
 0866   1   89 B6 012C		      mov Z.Parsee.Pt,si
 086A   3   01 B6 0130		      add Z.Parsee.Limit,si
 086E   3   01 B6 0136		      add Z.BreakStart,si
 0872   3   01 B6 0138		      add Z.BreakEnd,si
 0876   3   01 B6 0134		      add Z.PattLenEtc,si
 087A   1   5E			      pop CursorSi
 087B   5   C3			      ret
				     ; Here from XCycle when tail parts have been loaded.
 087C				     AssignDotsP$$:; This is like AssignDots$$ to start with.
 087C   5   65: AD		      lodsw gs:[CursorSi]
 087E   1   8B D8		      mov StemBx,ax
 0880   1   56			      push CursorSi
 0881   1   8B C7		      mov ax,StackDi
 0883   2   2B 46 56		      sub ax,Z.CurrentDO
 0886   1   83 E8 10		      sub ax,2*$StrideV
 0889   3   E8 F896		      call DotsFsBxDsSi
				      Down
 088C   1   83 EF 08		  1   sub StackDi,$StrideV
 088F   3p  8E 66 46		      mov fs,Z.VarScope
				     ; We have worked out what to assign to, Vsid, but the value to assign
				     ; is not what is on the stack. The parse subject is on the stack and
				     ; only a part of that is to be assigned.
				     ; Use the code that decides what part.
				     ; We left the parse in the WordParse stage, which operates with StackDi pushed
				     ; and CursorDi replacing CursorSi role.
 0892   1   58			      pop ax; Was CursorSi
 0893   1   57			      push StackDi
 0894   3   1E			      push ds
 0895   1   56			      push si; Will restore to fs:bx
 0896   3   E8 FFC5		      call SubjectRestore
 0899   1   8B F8		      mov CursorDi,ax
 089B   1   8B B6 0134		      mov SectionSi,Z.PattLenEtc
 089F   1   8B 8E 0130		      mov DataLenCx,Z.Parsee.Limit
 08A3   1   2B CE		      sub DataLenCx,SectionSi
 08A5   3   E9 FECC		      jmp ParseAssign

				     ;------------------------------------------------------------------------------
				     ; Spacewise, I don't like duplicating the WordParse code. The alternative
				     ; of first copying the isolated word to $pDiscard and then using Bassign
				     ; worked but makes Bcode dependent on VarScope which isn't logical.
				     ;------------------------------------------------------------------------------
				     ; We might needed to enhance this section to allow more complex PARSE in Bcode.
				     ; Loading trigger argument from Bcode:
 08A8   1   3C BB		     ParseBcode:cmp al,String1
 08AA  3,1  75 06		     jne @F
 08AC   3   E8 0000 E		     call String1$$
 08AF   3   E9 FD94		     jmp TriggerWith
 08B2				     @@:
 08B2   1   3C B5		      cmp al,One
 08B4  3,1  75 06		      jne @F
 08B6   3   E8 0000 E		      call One$$
 08B9   3   E9 FD8A		      jmp TriggerWith
 08BC   5p  FF D5		      @@:Error49Bp

 08BE				     ParseB:
				     ; Looking though ds:si:cx for words. Assigning to targets given in Bcode.
				     ; The loop will advance si with corresponding reduction in cx, in conjunction
				     ; with di advancing through targets.
 08BE   1   65: 8B 05		     NextTargetB:mov ax,gs:[CursorDi]
				     ; al is ultimate target. Will be checked for ParseDot.
 08C1   1   A8 01		      test al,1
 08C3  3,1  75 6B		      jnz WpDoneB; Operator to load constant for next section, end section.
				     ; Both subcodes and operands are even, so the test for operands is by value.
 08C5   1   3C 22		      cmp al,$mPosRest
 08C7  3,1  76 67		      jna WpDoneB
 08C9   1   47			      inc CursorDi; Over target.
				      JcxzQ AssignNullB
 08CA   1   85 C9		  1    test cx,cx
 08CC  3,1  74 5A		  1    je AssignNullB
 08CE   1   8A D8		      mov bl,al
 08D0   1   F6 C4 01		      test ah,1
 08D3  3,1  75 35		      jnz WpLastB
 08D5   1   80 FC 22		      cmp ah,$mPosRest
 08D8  3,1  76 30		      jna WpLastB
 08DA   1   50			     WpWordB:push ax
 08DB   1   BB 0000 E		      mov bx,Attributes; Prepare to test AllBlanks.
				     ; Move SI on to nonblank.
 08DE   5   AC			     @@:lodsb
				     XlatBDLS
 08DF   4   2E: D7		  1   xlat Bptr cs:[bx]
 08E1   1   A8 C0		  1   test al,0C0h
 08E3  3,1  75 06		     jnz @F
				     LoopQ @B
 08E5   1   49			  1    dec cx
 08E6  3,1  75 F6		  1    jnz @B
 08E8   1   58			     pop ax
 08E9   3   EB 3D		     jmp AssignNullB
				     ; Came out of the above loop with si advanced but cx not fully decreased.
				     ; SectionDx remembers start of the word.
 08EB   1   8B D6		     @@:mov SectionDx,SectionSi
 08ED   1   4A			     dec SectionDx
 08EE   1   49			     dec cx
 08EF  3,1  74 0A		     jz WpOneB
				     ; Move SI on to blank.
 08F1   5   AC			     @@:lodsb
				     XlatBDLS
 08F2   4   2E: D7		  1   xlat Bptr cs:[bx]
 08F4   1   A8 C0		  1   test al,0C0h
 08F6  3,1  74 05		     jz @F
				     LoopQ @B
 08F8   1   49			  1    dec cx
 08F9  3,1  75 F6		  1    jnz @B
				     ; Nothing ends the word. We want to do further searches with DataLenCx=0
 08FB   1   41			     WpOneB:inc DataLenCx
 08FC   1   46			     inc SectionSi
 08FD   1   49			     @@:dec DataLenCx; Word terminator not part of residue.
				     ; SectionSi is beyond the blank but that is OK - don't want to scan it again.
 08FE   1   89 8E 0134		      mov Z.PattLenEtc,DataLenCx; Change use.
 0902   1   8B CE		      mov cx,SectionSi
 0904   1   2B CA		      sub cx,SectionDx
 0906   1   49			      dec cx; Word length.
 0907   3   87 F2		      xchg SectionSi,SectionDx; Back to start of the word. SectionDx for next scan.
 0909   1   5B			      pop OperandBx; Was ax.
				     ; Assign that word away, to variable specified in Bcode, now bl.
				     ; ds:si::cx is the string.
 090A   1   80 FB FE		     WpLastB:cmp bl,ParseDot
 090D  3,1  74 11		     je WpResumeB
				     ; Put it on the stack, so as to use Bassign to put it away.
 090F   1   58			      pop ax; StackDi
 0910   1   50			      push ax
 0911   1   57			      push CursorDi
 0912   1   8B F8		      mov StackDi,ax
				      Up
 0914   1   83 C7 08		  1   add StackDi,$StrideV
 0917   3   E8 FC5A		      call VasDsSiCx
 091A   1   B7 FF		      mov bh,0FFh
 091C   3   E8 0000 E		      call Bassign
 091F   1   5F			      pop CursorDi
				     ; Rescan from where we had reached in getting that word.
 0920   1   8B F2		     WpResumeB:mov SectionSi,SectionDx
 0922   1   8B 8E 0134		     mov DataLenCx,Z.PattLenEtc
 0926   3   EB 96		     jmp NextTargetB

				     ; (CX is zero but is there a risk about DsSi?)
 0928   1   8A D8		     AssignNullB:mov bl,al
 092A   1   89 AE 0134		     mov Z.PattLenEtc,ZeroBp
 092E   3   EB DA		     jmp WpLastB

 0930   1   8B F7		     WpDoneB:mov CursorSi,CursorDi
 0932   1   5F			     pop StackDi
				     ; The sequence of targets was ended either by a marker or by the next constant
				     ; trigger.
 0933   1   46			      inc CursorSi
 0934   1   A8 01		      test al,1
 0936  3,1  0F 85 FCCC		      jnz TriggerArg
 093A   1   3C 22		      cmp al,$mPosRest
 093C  3,1  0F 86 FD08		      jna PSwitch
 0940   3   E9 FCC3		      jmp TriggerArg
				     ;------------------------------------------------------------------------------
				     ; This lot are about looping.
				     ;------------------------------------------------------------------------------
 0943   1   56			     Number$$:push CursorSi; The expression of DO N=Expr...
				     ; According to $6.3.6, check on numberness should be before check of TO/BY/FOR.
 0944   3   E8 1535		      call NumDxBx
 0947  3,1  0F 82 0F04		      jc Raise41p6
				     ; Build DO block over where the parameter was.
 094B   1   83 C7 20		      add StackDi,$StrideD-$StrideV
 094E   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0951  3,1  75 06		      jne @F
 0953   1   89 7E 06		      mov Z.Stack,StackDi
 0956   1   89 7E 56		      mov Z.CurrentDO,StackDi
 0959   3   E8 0000 E		     @@:call StackSafe
 095C   2   C6 43 07 00		      mov D.Rec,0
				     ; Default BY
 0960   2   66| 89 6B F0	      mov D.By.ExpAnd,ebp
 0964   2   66| 89 6B F4	      mov D.By.Mantissa,ebp
 0968   4   66| FF 43 F4	      inc D.By.Mantissa
				      RetSi
 096C   1   5E			  1   pop CursorSi
 096D   5   C3			  1   ret

 096E				     ControlVar$$:
				     ; The thing to be assigned was noted (maybe long ago).
				     ; First argument of this Pcode is a target, as on Assign$$.
 096E   1   83 EF 20		      sub StackDi,$StrideD-$StrideV; Tos now value to be assigned.
 0971   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0974  3,1  74 0F		      je @F
 0976   3   65: 0F BE 1C	      movsx bx,gs:Bptr[CursorSi]
 097A   1   46			      inc CursorSi
				     ; This says where the control variable is relative to stack-with-this-DO
 097B   1   53			      push bx
 097C   1   80 C3 0A		      add bl,(2*$StrideD/$StrideV)
 097F   3   E8 0000 E		      call Bassign
 0982   1   5B			      pop bx
 0983   3   EB 03		      jmp Bassigned
 0985				     @@:
 0985   3   E8 1139		      call Assign$$
 0988				     Bassigned:; What stored now in ecx:eax
 0988   1   83 C7 28		      add StackDi,$StrideD; Back to addressing the loop block.
				      Move V2; Have to place the CV value again so as to share compare with TO.
 098B   2   66| 89 4B 08	  1     mov V2.OverExpo,ecx
 098F   2   66| 89 43 0C	  1     mov V2.OverMant,eax
 0993   2   89 5B 04		      mov D.CV,bx; Set CV field in LoopBlock.
				     ; Set Leaving field in LoopBlock from argument.
 0996   5   65: AD		      lodsw gs:[CursorSi]
 0998   2   89 43 02		      mov D.Leaving,ax
 099B				     AsControlVar:
 099B   1   89 33		      mov D.Iteration,CursorSi; Set Iterate field in LoopBlock to here.
				     ; The test against TO is like the one at the end of a loop except that if
				     ; it doesn't LEAVE it needs CursorSi where it is now rather than at UNTIL
				     ; stuff.
 099D   1   57			      push StackDi
 099E   3   E8 01AC		      call CompareTO
 09A1   1   5A			      pop dx
 09A2   1   3B D7		      cmp dx,StackDi
 09A4  3,1  74 01		      je @F
 09A6   5   C3			      ret; CompareTO did LEAVE
				     ; If here is a jump, this is Until and the Iterate avoids the jump.
 09A7   2   39 6E 58		     @@:cmp Z.ResumeP,ZeroBp
 09AA  3,1  75 0A		     jne ACV
 09AC   2   65: 80 3C 63	      cmp Bptr gs:[CursorSi],$pJump
 09B0  3,1  75 03		      jne @F
 09B2   3   83 03 03		      add D.Iteration,3
 09B5   5   C3			      @@:ret

 09B6   2   65: 80 3C CB	     ACV:cmp Bptr gs:[CursorSi],_Jump
 09BA  3,1  75 03		     jne @F
 09BC   3   83 03 02		     add D.Iteration,2
 09BF   5   C3			     @@:ret

 09C0				     DotControlVar$$:
				     ; This is the more complicated variation, so that ControlVar$$ can be kept fast.
				     ; The code layout is like:  (expr) $pNumber, (expr) $pTo, Tail1 Tail2,
				     ; $pDotControlVar & args, $mRepTail & arg,body of DO, $pIterCV
				     ; Argument one of $pDotControlVar is a target, as on Assign$$.
				     ; Argument of $mRepTail is a label, the place to go to reload tail
				     ; components. (At Tail1 in example)
				     ; On iteration the loop picks up at loading the tails. Whether this is first
				     ; time or not, we need the address of the control variable.
				     ; The $mRepTail part is not there if CV is A. rather than A.B
 09C0   5   65: AD		      lodsw gs:[CursorSi]
 09C2   2   65: 80 7C 02 02	      cmp Bptr gs:[CursorSi+2],$mRepTail
 09C7  3,1  74 02		      je @F
				     ; Here for A.
 09C9   5p  FF D5		      Error49Bp
 09CB   1   8B D8		     @@:mov StemBx,ax
 09CD   1   56			      push CursorSi
 09CE   1   8B C7		      mov ax,StackDi
 09D0   2   2B 46 56		      sub ax,Z.CurrentDO
 09D3   1   83 E8 08		      sub ax,$StrideV; At least a tail
 09D6   3   E8 F749		      call DotsFsBxDsSi
				     ; DotsFsBxDsSi allowed for value pickup by Dots$$.
 09D9   8   0F BA 76 04 0C	      btr Z.Cancel,FromIterCV
 09DE  3,1  0F 82 01DE		      jc BackToIterCV
 09E2   1   83 EF 28		      sub StackDi,$StrideD; Tos now value to be assigned.
				      Move Vsid,V
 09E5   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 09E8   1   66| 89 0C		  1     mov Vsid.OverExpo,ecx
 09EB   2   66| 8B 43 04	  1     mov eax,V.OverMant
 09EF   1   66| 89 44 04	  1     mov Vsid.OverMant,eax
				      Down
 09F3   1   83 EF 08		  1   sub StackDi,$StrideV
 09F6   3p  8E 66 46		      mov fs,Z.VarScope
				     ; What stored now in ecx:eax
 09F9   1   83 C7 28		      add StackDi,$StrideD; Back to addressing the loop block.
				      Move V2; Have to place the CV value again so as to share compare with TO.
 09FC   2   66| 89 4B 08	  1     mov V2.OverExpo,ecx
 0A00   2   66| 89 43 0C	  1     mov V2.OverMant,eax
 0A04   2   89 5B 04		      mov D.CV,bx; Set CV field in LoopBlock.
				     ; Set Leaving field in LoopBlock from argument.
 0A07   5   65: AD		      lodsw gs:[CursorSi]
 0A09   2   89 43 02		      mov D.Leaving,ax
 0A0C   2   C6 43 E7 80		      mov D.CVinit.Dtype,$NullString; frees space where TailsAt overlaid.
				      On D.Rec,HasDot
 0A10   4   80 4B 07 20		  1          or  D.Rec,??000D
 0A14   1   5E			      pop CursorSi
 0A15   1   46			      inc CursorSi
 0A16   1   50			      push ax
 0A17   5   65: AD		      lodsw gs:[CursorSi]
 0A19   2   89 43 E0		      mov D.TailsAt,ax
 0A1C   1   58			      pop ax
				      On D.Rec,HasDots; Overrides HasDot.
 0A1D   4   80 4B 07 10		  1          or  D.Rec,??000E
 0A21   3   E9 FF77		      jmp AsControlVar

 0A24				     For$$:; Set field in control block
 0A24   3   E8 15CE		      call ToWholeEbx
 0A27  3,1  0F 82 0E1C		      jc Raise26p3
				      Down
 0A2B   1   83 EF 08		  1   sub StackDi,$StrideV
 0A2E   2   66| 89 5B FC	      mov D.ForCount.Mantissa,ebx
				      On D.Rec,HasFor
 0A32   4   80 4B 07 04		  1          or  D.Rec,??000F
				      BackRet
 0A36   5   C3			  1  ret

 0A37				     To$$:; Set field in control block
 0A37   3   E8 1442		      call NumDxBx
 0A3A  3,1  0F 82 0E13		      jc Raise41p4
				      Down
 0A3E   1   83 EF 08		  1   sub StackDi,$StrideV
 0A41   2   66| 89 53 E8	      mov D.To.ExpAnd,edx
 0A45   2   66| 89 5B EC	      mov D.To.Mantissa,ebx
				      On D.Rec,HasTo
 0A49   4   80 4B 07 08		  1          or  D.Rec,??0010
				      BackRet
 0A4D   5   C3			  1  ret

 0A4E				     By$$:; Set field in control block
 0A4E   3   E8 142B		      call NumDxBx
 0A51  3,1  0F 82 0DFB		      jc Raise41p5
 0A55  3,1  75 15		      jnz ByChar
				      Down
 0A57   1   83 EF 08		  1   sub StackDi,$StrideV
 0A5A   2   66| 89 53 F0	      mov D.By.ExpAnd,edx
 0A5E   2   66| 89 5B F4	      mov D.By.Mantissa,ebx
 0A62   1   F6 C2 01		      test dl,1
 0A65  3,1  74 04		      jz @F
 0A67				     ByRetNeg:On D.Rec,ByDown
 0A67   4   80 4B 07 01		  1          or  D.Rec,??0011
 0A6B				     @@:BackRet
 0A6B   5   C3			  1  ret

				     ; BY value is numeric but not held as binary.
 0A6C				     ByChar:
 0A6C   3   E8 160A		      call ToDsSiCx
				      Down
 0A6F   1   83 EF 08		  1   sub StackDi,$StrideV
				      Move D.By,V
 0A72   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 0A75   2   66| 89 4B F0	  1     mov D.By.OverExpo,ecx
 0A79   2   66| 8B 43 04	  1     mov eax,V.OverMant
 0A7D   2   66| 89 43 F4	  1     mov D.By.OverMant,eax
 0A81   2   80 3C 2D		      cmp Bptr[si],'-'
 0A84  3,1  74 E1		      je ByRetNeg
				      BackRet
 0A86   5   C3			  1  ret

 0A87				     RepEver$$:Up
 0A87   1   83 C7 08		  1   add StackDi,$StrideV
 0A8A   2   C6 43 07 88		     mov V.Dtype,$Omitted
 0A8E   3   EB 0E		     jmp FromEver; bx non-zero

 0A90				     Rep$$:; Set fields in control block.
				     ; The parameter will need to be an integer.
 0A90   3   E8 1562		      call ToWholeEbx
 0A93  3,1  0F 82 0DB1		      jc Raise26p2
 0A97   1   66| 3B DD		      cmp ebx,ebp
 0A9A  3,1  0F 88 0DAA		      js Raise26p2
				     ; Build DO block over where the parameter was.
 0A9E   1   83 C7 20		     FromEver:add StackDi,$StrideD-$StrideV
				     ; Assert ToWholeEbx will have filled V.Mantissa and that overlays D.Reps.Mantissa
 0AA1   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0AA4  3,1  75 06		      jne @F
 0AA6   1   89 7E 06		      mov Z.Stack,StackDi
 0AA9   1   89 7E 56		      mov Z.CurrentDO,StackDi
 0AAC   3   E8 0000 E		     @@:call StackSafe
				     ; Iterate will come back to the bytes after the $pRep instruction.
				     ; Leave address is the argument of $pRep
 0AAF   5   65: AD		      lodsw gs:[CursorSi]
 0AB1   2   89 43 02		      mov D.Leaving,ax
 0AB4   1   89 33		      mov D.Iteration,CursorSi
				     ; If here is a jump, this is Until and the Iterate avoids the jump.
 0AB6   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0AB9  3,1  74 0B		      je @F
 0ABB   2   65: 80 3C CB	      cmp Bptr gs:[CursorSi],_Jump
 0ABF  3,1  75 0E		      jne IfZero
 0AC1   3   83 03 02		      add D.Iteration,2
 0AC4   3   EB 09		      jmp IfZero
 0AC6   2   65: 80 3C 63	     @@: cmp Bptr gs:[CursorSi],$pJump
 0ACA  3,1  75 03		      jne IfZero
 0ACC   3   83 03 03		      add D.Iteration,3
				     ; Leave DO if zero repetitions.
 0ACF   1   66| 3B DD		     IfZero:cmp ebx,ebp
 0AD2  3,1  74 2A		     je Leave$$
				     BackRet
 0AD4   5   C3			  1  ret

 0AD5				     Until$$:; If T='1' then leave.
 0AD5   3   E8 151D		      call ToWholeEbx
 0AD8  3,1  0F 82 0D87		      jc Raise34p4
 0ADC   1   66| 4B		      dec ebx
 0ADE  3,1  74 1B		      jz DownLeave
 0AE0   1   66| 43		      inc ebx
 0AE2  3,1  0F 85 0D7D		      jnz Raise34p4
 0AE6				     WhUntRet:Down
 0AE6   1   83 EF 08		  1   sub StackDi,$StrideV
				      BackRet
 0AE9   5   C3			  1  ret

 0AEA				     While$$:; If T='0' then leave.
 0AEA   3   E8 1508		      call ToWholeEbx
 0AED  3,1  0F 82 0D73		      jc Raise34p3
 0AF1   1   66| 4B		      dec ebx
 0AF3  3,1  74 F1		      jz WhUntRet
 0AF5   1   66| 43		      inc ebx
 0AF7  3,1  0F 85 0D69		      jnz Raise34p3
 0AFB				     DownLeave:Down
 0AFB   1   83 EF 08		  1   sub StackDi,$StrideV
 0AFE				     Leave$$:; Jump to where block says, with UnDo.
 0AFE   2   8B 73 02		      mov CursorSi,D.Leaving
 0B01   1   83 EF 28		     UnDo$$:sub StackDi,$StrideD
 0B04   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 0B07  3,1  75 06		      jne @F
 0B09   1   89 7E 06		      mov Z.Stack,StackDi
 0B0C   1   89 7E 56		      mov Z.CurrentDO,StackDi
 0B0F				     @@:BackRet
 0B0F   5   C3			  1  ret

 0B10				     IterCV$$:;Jump to where block says. This one when there is a Control Variable
				      Qry D.Rec,HasDots
 0B10   3   F6 43 07 10		  1          test D.Rec, ??0012
 0B14  3,1  0F 85 009D		      jnz DotsIterCV
				     ; Retreive CV, with test of Dropped.!!
				     ; CV could be Exposed!!
				      Up
 0B18   1   83 C7 08		  1   add StackDi,$StrideV
 0B1B   2   8B 5B FC		      mov bx,D1.CV
				      Move V,Vbxf
 0B1E   1   66| 64: 8B 0F	  1     mov ecx,Vbxf.OverExpo
 0B22   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0B25   1   66| 64: 8B 47 04	  1     mov eax,Vbxf.OverMant
 0B2A   2   66| 89 43 04	  1     mov V.OverMant,eax
 0B2E   1   53			      push bx
 0B2F   3   E8 134A		      call NumDxBx
 0B32  3,1  0F 82 0D1E		      jc Raise41p1
				     ; It would be inefficent to use all the code of Add$$ because that checks
				     ; LHS and then RHS. We don't need the RHS (the BY value) checked again.
				     ; Add on BY.
				      Move V2,D1.By
 0B36   2   66| 8B 4B E8	  1     mov ecx,D1.By.OverExpo
 0B3A   2   66| 89 4B 08	  1     mov V2.OverExpo,ecx
 0B3E   2   66| 8B 43 EC	  1     mov eax,D1.By.OverMant
 0B42   2   66| 89 43 0C	  1     mov V2.OverMant,eax
				     ; AddRegs only when binary !!
 0B46   3   E8 0638		      call AddRegs
 0B49   1   5B			      pop bx
				     ; Store that back in CV.
 0B4A   3   E8 0F7A		      call AsgnToFsBx
 0B4D				     CompareTO:
				      Qry D.Rec,HasTo
 0B4D   3   F6 43 07 08		  1          test D.Rec, ??0013
 0B51  3,1  74 51		      jz ItNoTo
				      Up; Over as assigned to CV.
 0B53   1   83 C7 08		  1   add StackDi,$StrideV
				     ; Compare with TO
				     ; !! Not good enough to do compare with Subtract because of FUZZ<>0 case.
				      Move V2,D1.To,edx
 0B56   2   66| 8B 53 E0	  1    mov edx,D1.To.OverExpo
 0B5A   2   66| 89 53 08	  1    mov V2.OverExpo,edx
 0B5E   2   66| 8B 53 E4	  1    mov edx,D1.To.OverMant
 0B62   2   66| 89 53 0C	  1    mov V2.OverMant,edx
				      Up
 0B66   1   83 C7 08		  1   add StackDi,$StrideV
 0B69   3   E8 0723		      call Subtract$$
				     ; It is possible for the result to be out of binary range.
 0B6C   3   F6 43 07 C0		      test V.Dtype,$Test
 0B70  3,1  74 1E		      jz ByBin
				     ; TO value was subtracted so LEAVE when signs of result and BY are same.
 0B72   3   E8 1504		      call ToDsSiCx
				      Down
 0B75   1   83 EF 08		  1   sub StackDi,$StrideV
 0B78   2   80 3C 30		      cmp Bptr[si],'0'
 0B7B  3,1  74 27		      je ItNoTo; No LEAVE when compare equal.
 0B7D   1   B0 00		      mov al,0
 0B7F   2   80 3C 2D		      cmp Bptr[si],'-'
 0B82  3,1  75 01		      jne @F
 0B84   1   40			      inc ax
 0B85				      @@:
 0B85   3   32 43 07		      xor al,D.Rec
 0B88   1   A8 01		      test al,1
 0B8A  3,1  0F 84 FF70		      jz Leave$$
 0B8E   3   EB 14		      jmp ItNoTo
 0B90				     ByBin:
				      Down
 0B90   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; Assert Subtract$$ leaves eax as mantissa.
 0B93   1   66| 3B C5		      cmp eax,ebp
 0B96  3,1  74 0C		      je ItNoTo; No LEAVE when compare equal.
				     ; TO value was subtracted so LEAVE when signs of result and BY are same.
 0B98   2   8A 43 08		      mov al,V2.Sign
 0B9B   3   32 43 07		      xor al,D.Rec
 0B9E   1   A8 01		      test al,1
 0BA0  3,1  0F 84 FF5A		      jz Leave$$
 0BA4				     ItNoTo:
				      Qry D.Rec,HasFor
 0BA4   3   F6 43 07 04		  1          test D.Rec, ??0014
 0BA8  3,1  74 08		      jz ItNoFor
				     ; Count down FOR
 0BAA   4   66| FF 4B FC	      dec D.ForCount.Mantissa
 0BAE  3,1  0F 88 FF4C		      js Leave$$
 0BB2   1   8B 33		     ItNoFor:mov CursorSi,D.Iteration
				      BackRet
 0BB4   5   C3			  1  ret

 0BB5				     DotsIterCV:; To establish the CV, it is necessary to go to the top of the
				     ; loop again, where the tails are specified.
 0BB5   1   56			      push CursorSi
 0BB6   2   8B 73 E0		      mov CursorSi,D.TailsAt
				      On Z.Cancel,FromIterCV
 0BB9   3   80 4E 05 10		  1          or  Bptr(Z.Cancel+1), high ??0015
				      Back
 0BBD   3   E9 F49B		  1  jmp XCycle
 0BC0				     BackToIterCV:; From DotControlVar$$ when CV resolved.
				      PopJunk ax; SI pushed by DotsControlVar$$
 0BC0   1   58			  1    pop ax
				      PopJunk ax; XCycle return link.
 0BC1   1   58			  1    pop ax
				     ; Was left Up.
				      Move V,Vsid
 0BC2   1   66| 8B 0C		  1     mov ecx,Vsid.OverExpo
 0BC5   1   66| 89 0B		  1     mov V.OverExpo,ecx
 0BC8   1   66| 8B 44 04	  1     mov eax,Vsid.OverMant
 0BCC   2   66| 89 43 04	  1     mov V.OverMant,eax
 0BD0   3   E8 12A9		      call NumDxBx
 0BD3  3,1  0F 82 0C7D		      jc Raise41p1
				     ; Add on BY.
				      Move V2,D1.By
 0BD7   2   66| 8B 4B E8	  1     mov ecx,D1.By.OverExpo
 0BDB   2   66| 89 4B 08	  1     mov V2.OverExpo,ecx
 0BDF   2   66| 8B 43 EC	  1     mov eax,D1.By.OverMant
 0BE3   2   66| 89 43 0C	  1     mov V2.OverMant,eax
 0BE7   3   E8 0597		      call AddRegs
				     ; Store that back in CV.
				      Move Vsid,V
 0BEA   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 0BED   1   66| 89 0C		  1     mov Vsid.OverExpo,ecx
 0BF0   2   66| 8B 43 04	  1     mov eax,V.OverMant
 0BF4   1   66| 89 44 04	  1     mov Vsid.OverMant,eax
				     ; Doesn't work for A.  NYI
				      Down
 0BF8   1   83 EF 08		  1   sub StackDi,$StrideV
 0BFB   1   5E			      pop CursorSi
 0BFC   3   E9 FF4E		      jmp CompareTO

 0BFF				     IterRep$$:; This is where DO n enters.
 0BFF   4   66| FF 4B E4	      dec D.Reps.Mantissa
 0C03  3,1  0F 84 FEF7		      jz Leave$$
 0C07				     Iterate$$:; This is where FOREVER enters.
 0C07   1   8B 33		      mov CursorSi,D.Iteration
				      BackRet
 0C09   5   C3			  1  ret

				     ;------------------------------------------------------------------------------
				     ; This lot are about invoke and return.
				     ;------------------------------------------------------------------------------

				     ; Invoke is like CALL, with an extra argument to count relevant parameters.
 0C0A   5   65: AC		     Invoke$$:lodsb gs:[CursorSi]
 0C0C   1   B4 F8		     mov ah,-$StrideV
 0C0E  13+  F6 EC		     imul ah
 0C10   1   03 C7		      add ax,StackDi; For where the arguments are.
 0C12   1   BA 0008		      mov dx,mask IsFunction; And zeroes for other flags in callee level.
 0C15   3   EB 05		      jmp AsCall

				     ; The CALL argument is the relevant label.  There may be parameters.
 0C17   1   8B 46 56		     Call$$:mov ax,Z.CurrentDO; Parameters lie between last DO block and new level.
				      z dx
 0C1A   1   8B D5		  1           mov dx,bp
 0C1C				     AsCall:
				     ;MASM..............................
				     ; ax is where the callee will find its arguments.
				     ; dx distinguishes call v invoke.
				     ; Should not change to new level yet, by update of Z.Level, because any
				     ; error in calling needs to be raised in the caller level.
 0C1C   1   50			      push ax
 0C1D   1   52			      push dx
				     ; Wont hurt to complete some fields in the caller level, even if call fails.
 0C1E   1   8B 5E 52		      mov bx,Z.Level; The level being called from.
				      move Lbx.LevelDO,Z.CurrentDO; Avoidable for CALL but code sharing with Invoke.
 0C21   1   8B 46 56		  1      mov ax,Z.CurrentDO
 0C24   1   36: 89 47 F4	  1      mov Lbx.LevelDO,ax
 0C28   5   65: AD		      lodsw gs:[CursorSi]; The callee.
				     ; Note where to resume if we return to caller, in the caller level.
				     ; (For simple case, CursorSi not pushed. But that complicates error case.)
 0C2A   1   36: 89 77 04	      mov Lbx.Resume,CursorSi
				     ; There are both .SIGL and SIGL.
 0C2E   1   26: C6 46 43 48	      mov Ve.Dtype[$?SIGL],$Sigl
 0C33   1   26: 89 76 40	      mov Ve.MantLow[$?SIGL],CursorSi
 0C37   1   64: C6 46 37 48	      mov Vf.Dtype[$?SIGLx],$Sigl
 0C3C   1   64: 89 76 34	      mov Vf.MantLow[$?SIGLx],CursorSi
				     ;------------------------------------------------------------------------------
				     ; Check that callee is callable.
				     ;------------------------------------------------------------------------------
 0C40   1   8B D8		      mov OperandBx,ax; Target routine
 0C42   2   26: 80 7F 06 00	      cmp Bptr Vbxe.LabelType,0
 0C47  3,1  75 77		      jne Raise16p3; Trace-only
 0C49   1   26: 8B 37		      mov CursorSi,Vbxe.LabelValue; Offset in Code of callee.
				      TestReg CursorSi
 0C4C   1   85 F6		  1         test CursorSi,CursorSi
 0C4E  3,1  75 55		      jnz NotExternal
				     ; There was no label-with-colon in the source for this name. The
				     ; name itself is the determinant of what is called.
 0C50   3p  8E 5E 40		      mov ds,Z.Consts
				      move Z.Insert.Named,Vbx.Here; In case error 43.1
 0C53   1   8B 47 04		  1      mov ax,Vbx.Here
 0C56   1   89 46 7E		  1      mov Z.Insert.Named,ax
				      Up
 0C59   1   83 C7 08		  1   add StackDi,$StrideV
 0C5C   3   E8 15AC		      call BxConst
 0C5F   1   C7 46 1A 0009	      mov Z.HowInvoked,sizeof FUNCTION
				     ; Use a Bcode routine to search DOS path for the name.
 0C64				     External:On Z.Cancel,SourceFiles
 0C64   3   80 4E 04 04		  1          or  Bptr(Z.Cancel), low ??0016
 0C68   3   E8 0000 E		     call Name2File
				     Off Z.Cancel,SourceFiles
 0C6B   3   80 66 04 FB		  1          and Bptr(Z.Cancel), low not ??0017
				      z Z.ResumeP; Done with Bcode for now.
 0C6F   1   89 6E 58		  1           mov Z.ResumeP,bp
				     ; We have looked up the fully qualified name of the source program file.
				     ; Address the qualified name.
 0C72   3p  8E 5E 3E		      mov ds,Z.SysFiles
 0C75   1+  8D 57 0E		      lea dx,Jbx.Key
 0C78   1   8B 77 0C		      mov si,Jbx.KeyLen
 0C7B   1   3B F5		      cmp si,ZeroBp
 0C7D  3,1  0F 85 00AE		      jne FullName

				     ; PATHQUALIFY could not find the relevant file.
				     ; In non-command case, not found is error 43.1
				      PopJunk ax
 0C81   1   58			  1    pop ax
				      PopJunk ax
 0C82   1   58			  1    pop ax
 0C83   1   B8 2B01		      mov ax,MkMajMin(43,1)
 0C86   2   80 7E 1A 08		      cmp Bptr Z.HowInvoked,sizeof COMMAND
 0C8A  3,1  74 09		      je @F
 0C8C   1   8B 7E 52		      mov StackDi,Z.Level
 0C8F   2   8B 73 04		      mov CursorSi,L.Resume
 0C92   3   E9 0C1A		      jmp Raise
				     ; "Routine not found" seems better than "Initializing error".
 0C95   1   48			     @@:dec ax; We don't have a constant to be <name>, so short msg.
				     ; Need some initializing to prevent Raise falling over.
				      z Z.Code
 0C96   1   89 6E 4A		  1           mov Z.Code,bp
				      z Z.InsLine
 0C99   1   89 6E 71		  1           mov Z.InsLine,bp
				     ; We want <source> to be the unqualified file name.
				      move Z.File,Z.InsUnqual,cx
 0C9C   1   8B 4E 78		  1    mov cx,Z.InsUnqual
 0C9F   1   89 4E 3C		  1    mov Z.File,cx
 0CA2   3   E9 0C0A		      jmp Raise

				     ;------------------------------------------------------------------------------
				     ; Invoke the internal routine.
				     ;------------------------------------------------------------------------------
 0CA5				     NotExternal:; Make new level and fill fields.
 0CA5   1   83 C7 7C		      add StackDi,$StrideL; Is also new LevelDi
 0CA8   6   8F 03		      pop L.Access; Was dx
 0CAA   7   8F 43 06		      pop L.Arg0; Was ax
				      move L.UpLevel,Z.Level; From new to old.
 0CAD   1   8B 46 52		  1      mov ax,Z.Level
 0CB0   2   89 43 02		  1      mov L.UpLevel,ax
 0CB3   1   89 7E 52		      mov Z.Level,LevelDi
 0CB6   1   89 7E 56		      mov Z.CurrentDO,StackDi
				     ; Procedures are marked at their beginning.
 0CB9   2   65: 80 3C AF	      cmp Bptr gs:[CursorSi],$pRaise
 0CBD  3,1  74 09		      je @F
				      BackRet
 0CBF   5   C3			  1  ret

 0CC0				     Raise16p3:PopJunk ax
 0CC0   1   58			  1    pop ax
				     PopJunk ax
 0CC1   1   58			  1    pop ax
 0CC2   1   B8 1003		     mov ax,MkMajMin(16,3)
 0CC5   3   E9 0D4E		     jmp Raise16

 0CC8				     @@:; Turn on flag for the benefit of Return$$.
				      inc2 CursorSi; Length of Raise op.
 0CC8   1   46			  1   inc CursorSi
 0CC9   1   46			  1   inc CursorSi
				      On L.Access,IsProcedure
 0CCA   3   80 0B 20		  1          or  Bptr(L.Access), low ??0018


 0CCD   1   56			      push CursorSi
				      z si; Supports H mode of addressing.
 0CCE   1   8B F5		  1           mov si,bp
				     ; Is there a recycled pool space available?
 0CD0   1   64: 8B 0C		      mov cx,fs:H.SegSize; Assembles better than Hf.SegSize since offset=si=zero.
 0CD3   2   39 6E 50		      cmp Z.PoolPool,ZeroBp
 0CD6  3,1  75 07		      jne HavePool
				     ; Z.Vars is the array for naming variables.
				     ; Z.VarScope is the array for the values of variables.
				     ; They are the same size, same header.
				     ; Make space for a copy of the latter.
 0CD8   3   E8 0000 E		      call ParaAllocAx
 0CDB   3p  8E D8		      mov ds,ax
 0CDD   3   EB 0F		      jmp HaveSpace
 0CDF   3p  8E 5E 50		     HavePool:mov ds,Z.PoolPool
				     if Debug
 0CE2   2   39 0C		      cmp H.SegSize,cx
 0CE4  3,1  74 02		      je @F
 0CE6   5p  FF D5		      Error49Bp
 0CE8				      @@:
				     endif
				      move Z.PoolPool,H.UpPool
 0CE8   1   8B 44 0A		  1      mov ax,H.UpPool
 0CEB   1   89 46 50		  1      mov Z.PoolPool,ax
 0CEE				     HaveSpace:; At ds for cx bytes.
 0CEE   3   E8 0002		      call VarPoolInit
 0CF1   1   5E			      pop CursorSi
				      BackRet
 0CF2   5   C3			  1  ret

 0CF3				     VarPoolInit:; Initialise with copy of header, variables all type Dropped.
				     ; Used for a PROCEDURE call and for a reuse of an external.
				      z bx
 0CF3   1   8B DD		  1           mov bx,bp
 0CF5   2   C1 E9 03		      shr cx,$ShiftV
 0CF8   1   C6 47 07 40		     @@:mov Vbx.Dtype,$Dropped
 0CFC   1   83 C3 08		      add bx,$StrideV
				      LoopQ @B
 0CFF   1   49			  1    dec cx
 0D00  3,1  75 F6		  1    jnz @B
				      z si
 0D02   1   8B F5		  1           mov si,bp
 0D04   1   66| 64: 8B 14	      mov edx,fs:H.Hdw0
 0D08   1   66| 89 14		      mov H.Hdw0,edx
 0D0B   1   66| 64: 8B 56 04	      mov edx,Hf.Hdw0+4
 0D10   1   66| 89 54 04	      mov H.Hdw0+4,edx
				     ; I am not sure following is needed. It sets Link but that not needed?
 0D14   1   C7 44 08 0046	      mov H.Link,Zshape.VarScope
				     ; Procedure's pool remembers caller's pool for reinstatement at return.
				     ; (In PROCEDURE case)
 0D19   3   8C 64 0A		      mov H.UpPool,fs
				     ; Zone to show the latest.
 0D1C   3   8C 5E 46		      mov Z.VarScope,ds
 0D1F   3p  8E 66 46		      mov fs,Z.VarScope
 0D22   5   C3			      ret

				     ; To treat Command like an external call we have already put the callee name
				     ; on the stack. Push where args are and not-a-function tag.
 0D23   1   68 136C		     Command:push Zshape.CommandArg-$StrideV
 0D26   1   55			     push ZeroBp
 0D27   1   C7 46 1A 0008	      mov Z.HowInvoked,sizeof COMMAND
 0D2C   3   E9 FF35		      jmp External
				     ;------------------------------------------------------------------------------
				     ; Invoke an external routine.
				     ;------------------------------------------------------------------------------
 0D2F				     FullName:; FileBx leads to name of compilee.
 0D2F   1   83 C7 7C		      add StackDi,$StrideL; Is also new LevelDi
 0D32   6   8F 03		      pop L.Access; Was dx
				      On L.Access,IsExternal
 0D34   3   80 0B 10		  1          or  Bptr(L.Access), low ??0019
 0D37   7   8F 43 06		      pop L.Arg0; Was ax
				      move L.UpLevel,Z.Level; From new to old.
 0D3A   1   8B 46 52		  1      mov ax,Z.Level
 0D3D   2   89 43 02		  1      mov L.UpLevel,ax
				     ; We can change to the new level because even if it fails to compile that will
				     ; count as a failure in the callee.
 0D40   1   89 7E 52		      mov Z.Level,LevelDi
 0D43   1   89 7E 56		      mov Z.CurrentDO,StackDi
 0D46   1   89 7E 06		      mov Z.Stack,StackDi


				     ; Exit is to scan for Level, so as to actually Return.

				     ; Raise to know.

 0D49   2   8B 73 02		      mov LevelSi,L.UpLevel
				     ; Outermost level has no segments to save.
 0D4C   1   3B F5		      cmp LevelSi,ZeroBp
 0D4E  3,1  74 09		      je @F
 0D50   3   E8 00D1		      call ZoneToLevel
 0D53   3   8C 4E 46		      mov Z.VarScope,cs
 0D56   3   8C 4E 44		      mov Z.ProgScope,cs
 0D59				     @@:
 0D59   3   E8 08E1		      call SetInherit

				     ; The Vshape part of the item (used for buffer when a data file) is not used
				     ; in the case of source, except as a flag for whether this is first sighting
				     ; of the file.
 0D5C   2   80 7F 07 40		      cmp Vbx.Dtype,$Dropped
 0D60  3,1  0F 85 018A		      jne KnownExternal
 0D64   1   C6 47 07 80		      mov Vbx.Dtype,$NullString
				     ; This is first sighting, so compile the source.
				     ; ASCIIZfy.
 0D68   1   8B 77 0C		      mov si,Jbx.KeyLen
				      z cl
 0D6B   1   B1 00		  1         mov cl,0
 0D6D   6   86 48 0E		      xchg cl,Bptr(Jbx.Key[si])
				     ; Attempt to open the source file.
 0D70   1   B8 3D00		      mov ax,MkMajMin($DosOpen,0)
 0D73  30   CD 21		      int 21h
 0D75   2   88 48 0E		      mov Bptr(Jbx.Key[si]),cl; Un-ASCIIZfy
 0D78   1   89 46 18		      mov Z.SourceHandle,ax
 0D7B  3,1  0F 83 00BA		      jnc OpenedOK

				     ; Get extended error. Don't care if es,ds changed.
 0D7F   1   52			      push dx
 0D80   1   56			      push si
 0D81   1   57			      push di
				      z bx
 0D82   1   8B DD		  1           mov bx,bp
 0D84   1   B4 59		      mov ah,$DosGetError
 0D86  30   CD 21		      int 21h
 0D88   1   5F			      pop di
 0D89   1   5E			      pop si
 0D8A   1   5A			      pop dx
				     ; if al==4 No handles left.
 0D8B   1   3C 04		      cmp al,4
 0D8D  3,1  75 05		      jne @F
 0D8F   1   B2 0C		      mov dl,$DescFiles
 0D91   3   E9 0000 E		      jmp Raise5p1
 0D94				      @@:
				     ; else some other initialization error.
 0D94   1   88 86 0084		      mov Z.Insert.Hex,al
 0D98   1   B8 0301		      mov ax,MkMajMin(3,1)
 0D9B   1   B2 0B		      mov dl,$Desc59H
 0D9D   3   E9 0B0F		      jmp Raise

				     if Solid
				     ; 'E' and 'S' would do except for result of bif FORM()
 0DA0 2E 4D 4E 20 2E 52 53 20	     $Reserved db ".MN .RS .RESULT .RC .SIGL;"
	      2E 52 45 53 55
	      4C 54 20 2E 52
	      43 20 2E 53 49
	      47 4C 3B
 0DBA  31 3A 32 3A 33 3A 34 3A	               db "1:2:3:4:5:6:7:8:9:A:B:;"
	      35 3A 36 3A 37
	      3A 38 3A 39 3A
	      41 3A 42 3A 3B
 0DD1  39 20 30 27 27 20 27 45	               db "9 0'' 'ENGINEERING' 'SCIENTIFIC';"
	      4E 47 49 4E 45
	      45 52 49 4E 47
	      27 20 27 53 43
	      49 45 4E 54 49
	      46 49 43 27 3B
 0DF2  41 52 47 20 2E 20 52 45	               db "ARG . RESULT RC SIGL ;push qualify('CRXREXX.QUE');"
	      53 55 4C 54 20
	      52 43 20 53 49
	      47 4C 20 3B 70
	      75 73 68 20 71
	      75 61 6C 69 66
	      79 28 27 43 52
	      58 52 45 58 58
	      2E 51 55 45 27
	      29 3B
 0E24 = 0084			     $ReservedLen equ $-$Reserved
				     endif

 0E24				     ZoneToLevel:; Saves Zone contents before External call.
 0E24   1   50			      push ax
				      move Lsi.ProgScope,Z.ProgScope
 0E25   1   8B 46 44		  1      mov ax,Z.ProgScope
 0E28   2   89 42 FC		  1      mov Lsi.ProgScope,ax
				      move Lsi.VarScope,Z.VarScope
 0E2B   1   8B 46 46		  1      mov ax,Z.VarScope
 0E2E   2   89 42 FE		  1      mov Lsi.VarScope,ax
				      move Lsi.File,Z.File
 0E31   1   8B 46 3C		  1      mov ax,Z.File
 0E34   2   89 42 FA		  1      mov Lsi.File,ax
 0E37   1   58			      pop ax
 0E38   5   C3			      ret

 0E39				     OpenedOK:
 0E39   1   89 5E 3C		      mov Z.File,FileBx; Not earlier or <source> in msgs would be wrong.

				     ; Setup segments for Symbols etc.
				     ; These sizes are not crucial, they are just granularity for segment expansion.
 0E3C   1   B9 1000		      mov cx,4096; Bytes.
 0E3F   1   BB 0FFE		      mov bx,4096-2; Trigger for when to extend.
 0E42   1   BF 0048		      mov SegOffDi,Zshape.Symbols
 0E45   3   E8 0000 E		      call InitSegDs
				     ; Setup segment for Code
 0E48   1   BF 004A		      mov SegOffDi,Zshape.Code
 0E4B   3   E8 0000 E		      call InitSegDs
				     ; Setup segment for Vars
 0E4E   1   B9 07F0		      mov cx,127*16
 0E51   1   BB 07E0		      mov bx,127*16-2*$StrideV
 0E54   1   BF 0042		      mov SegOffDi,Zshape.Vars
 0E57   3   E8 0000 E		      call InitSegDs
				     ; VarScope is a shadow of Vars.
 0E5A   1   BF 0046		      mov SegOffDi,Zshape.VarScope
 0E5D   3   E8 0000 E		      call InitSegDs
				     ; Setup segment for Consts
 0E60   1   BF 0040		      mov SegOffDi,Zshape.Consts
 0E63   3   E8 0000 E		      call InitSegDs
				     ; Make offsets into ProgScope multiples of two but not of eight.
				     ; And add a spare item for $Omitted.
 0E66   1   C7 06 0004 001C	      mov Wptr Hd.Avail,$StrideV+$SizeConstsHeader
				     ; Set up ProgScope segment which contains space for $?OUTCOME etc.
 0E6C   1   B9 07F0		      mov cx,127*16
 0E6F   1   BB 07E0		      mov bx,127*16-2*$StrideV
 0E72   1   BF 0044		      mov SegOffDi,Zshape.ProgScope
 0E75   3   E8 0000 E		      call InitSegDs
				     ; Make offsets into ProgScope two modulo eight.
				     ; And add a spare item for $Omitted.
 0E78   1   C7 06 0004 001C	      mov Wptr Hd.Avail,$StrideV+$SizeConstsHeader
				     if MemCheck
 0E7E   3   E8 0000 E		      call DosMemCheck
				     endif
				     ;------------------------------------------------------------------------------
				     ; Initializing of names for Lookup is done by an INTERPRET of $Reserved string.
				     ;------------------------------------------------------------------------------
 0E81   3   E8 0000 E		      call UpStack
 0E84   4   8C 4B 02		      mov V.Sg,cs
 0E87   1   C7 03 0DA0 R	      mov V.Pt,offset $Reserved
 0E8B   2   C7 43 04 0084	      mov V.Len,$ReservedLen
 0E90   2   C6 43 07 C0		      mov V.Dtype,$AwayString
 0E94   3p  8E 6E 4A		      mov gs,Z.Code
 0E97   3   E8 0E7E		      call Interpret1; Interpret with labels allowed, no execution.
				     ; Any code made from Reserved is unwanted.
 0E9A   1   65: C7 46 04 0010	      mov Hg.Avail,$StrideH
				     ; The labels were just to reserve some slots. Lookup should not see them.
				      z si
 0EA0   1   8B F5		  1           mov si,bp
 0EA2   3p  8E 5E 40		      mov ds,Z.Consts
				      z H.Labels
 0EA5   1   89 6C 0E		  1           mov H.Labels,bp
				      z H.TreeBin
 0EA8   1   89 6C 0A		  1           mov H.TreeBin,bp
				     ; Make the constant for Omitted special.
				     ; Omitted to have value of null string and unique datatype.
				      move Vsid.Here[$?Omitted],Vsid.Here[$?Null]
 0EAB   1   8B 84 00B0		  1      mov ax,Vsid.Here[$?Null]
 0EAF   1   89 44 18		  1      mov Vsid.Here[$?Omitted],ax
				     ; Last stream encountered in $Reserved was for Rexx queue.
				      move Z.Queue,Z.Stream
 0EB2   1   8B 46 38		  1      mov ax,Z.Stream
 0EB5   1   89 46 3A		  1      mov Z.Queue,ax
 0EB8   3   E8 0009		      call ProgScopeInit
 0EBB   3p  8E 5E 3E		      mov ds,Z.SysFiles
 0EBE				     Jett:; Just a label for debugging.
				     if MemCheck
 0EBE   3   E8 0000 E		      call DosMemCheck
				     endif
 0EC1   3   E9 0000 E		      jmp Compiler

 0EC4				     ProgScopeInit:; SI is set zero
 0EC4   1   57			      push StackDi
 0EC5   3p  8E 5E 44		      mov ds,Z.ProgScope
				      z si
 0EC8   1   8B F5		  1           mov si,bp
 0ECA   1   BF 0010		      mov di,$StrideH
 0ECD   1   C6 05 00		     @@:mov Bptr[di],0
 0ED0   1   47			      inc di
 0ED1   1   81 FF 009C		      cmp di,$?Nine
 0ED5  3,1  72 F6		      jb @B
 0ED7   1   C6 44 1B 88		      mov Vsid.Dtype[$?Omitted],$Omitted
				     ; Set the type of some SysVars.
 0EDB   1   C6 44 6B 81		      mov Vsid.Dtype[$?RESPONSE],$NullString+1
 0EDF   1   C6 44 7B 80		      mov Vsid.Dtype[$?CLAUSETIME],$NullString
 0EE3   1   C6 84 009B 80	      mov Vsid.Dtype[$?STARTTIME],$NullString
 0EE8   1   C6 44 33 80		      mov Vsid.Dtype[$?RESULT],$NullString
 0EEC   1   5F			      pop StackDi
 0EED   5   C3			      ret

 0EEE				     KnownExternal:; Invoke of something previously compiled.
				      move Z.File,FileBx
 0EEE   1   8B C3		  1      mov ax,FileBx
 0EF0   1   89 46 3C		  1      mov Z.File,ax
				      move Z.Symbols,F.Symbols
 0EF3   1   8B 47 F6		  1      mov ax,F.Symbols
 0EF6   1   89 46 48		  1      mov Z.Symbols,ax
				      move Z.Code,F.Code
 0EF9   1   8B 47 F8		  1      mov ax,F.Code
 0EFC   1   89 46 4A		  1      mov Z.Code,ax
				      move Z.Consts,F.Consts
 0EFF   1   8B 47 FC		  1      mov ax,F.Consts
 0F02   1   89 46 40		  1      mov Z.Consts,ax
				      move Z.ProgScope,F.ProgScope
 0F05   1   8B 47 FE		  1      mov ax,F.ProgScope
 0F08   1   89 46 44		  1      mov Z.ProgScope,ax
				      move Z.Vars,F.Vars
 0F0B   1   8B 47 FA		  1      mov ax,F.Vars
 0F0E   1   89 46 42		  1      mov Z.Vars,ax
 0F11   3   E8 FFB0		      call ProgScopeInit
				     ; !! If only one copy of ProgScope values, need .MN etc in Level.
				     if 0
				     endif
				     ; Make Z.VarScope for the callee.
				     ; Size of Z.VarScope is the same as Z.Vars.
 0F14   3p  8E E0		      mov fs,ax
 0F16   1   64: 8B 4E 00	      mov cx,Hf.SegSize
 0F1A   3   E8 0000 E		      call ParaAllocAx
 0F1D   3p  8E D8		      mov ds,ax
 0F1F   1   89 46 46		      mov Z.VarScope,ax
 0F22   3   E8 FDCE		      call VarPoolInit
 0F25   1   64: 89 6E 0A	      mov Hf.UpPool,ZeroBp; Unlike PROCEDURE
 0F29   3   E9 0000 E		      jmp StartExecution

 0F2C				     Result$$:Down
 0F2C   1   83 EF 08		  1   sub StackDi,$StrideV
				     BackRet; Lose unwanted result from called bif.
 0F2F   5   C3			  1  ret

 0F30				     Returns$$:
 0F30   5   66| FF 73 04	      push V.Mantissa
 0F34   4   66| FF 33		      push V.ExpAnd
 0F37   1   8B 7E 52		      mov LevelDi,Z.Level; Lose DO's at this level.
				      Qry L.Access,IsFunction
 0F3A   2   F6 03 08		  1          test Bptr(L.Access), low ??001A
 0F3D  3,1  74 0E		      jz CallResult
 0F3F   3   E8 0064		      call ReturnX
				      Up
 0F42   1   83 C7 08		  1   add StackDi,$StrideV
 0F45   6   66| 8F 03		      pop V.ExpAnd
 0F48   7   66| 8F 43 04	      pop V.Mantissa
				      BackRet
 0F4C   5   C3			  1  ret

 0F4D				     CallResult:
 0F4D   3   E8 0056		      call ReturnX
				      Up
 0F50   1   83 C7 08		  1   add StackDi,$StrideV
 0F53   6   66| 8F 03		      pop V.ExpAnd
 0F56   7   66| 8F 43 04	      pop V.Mantissa
				     ; Set RESULT special variable.
				      Move Vf[$?RESULTx],V
 0F5A   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 0F5D   1   66| 64: 89 4E 20	  1     mov Vf[$?RESULTx].OverExpo,ecx
 0F62   2   66| 8B 43 04	  1     mov eax,V.OverMant
 0F66   1   66| 64: 89 46 24	  1     mov Vf[$?RESULTx].OverMant,eax
				     ; Set .RESULT reserved variable.
				      Move Ve[$?RESULT],V
 0F6B   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 0F6E   1   66| 26: 89 4E 2C	  1     mov Ve[$?RESULT].OverExpo,ecx
 0F73   2   66| 8B 43 04	  1     mov eax,V.OverMant
 0F77   1   66| 26: 89 46 30	  1     mov Ve[$?RESULT].OverMant,eax
				      Down
 0F7C   1   83 EF 08		  1   sub StackDi,$StrideV
				      BackRet
 0F7F   5   C3			  1  ret

 0F80   1   8B 7E 52		     Return$$:mov LevelDi,Z.Level; Lose DO's at this level.
				     ; Check for RETURN when called as a function.
				      Qry L.Access,IsFunction
 0F83   2   F6 03 08		  1          test Bptr(L.Access), low ??001B
 0F86  3,1  74 1E		      jz ReturnX
				     ; Msg 45.1 happens in the callee. (External has 44.1 in caller)
				      Qry L.Access,IsExternal
 0F88   2   F6 03 10		  1          test Bptr(L.Access), low ??001C
 0F8B  3,1  75 2D		      jnz PlainRet
				     ; Recover caller name.
 0F8D   2   8B 7B 02		      mov LevelDi,L.UpLevel; Invoker block. Assert cannot be zero.
 0F90   2   8B 5B 04		      mov CursorBx,L.Resume; Invoker holds resume point.
 0F93   1   65: 8B 5F FE	      mov ArrayBx,gs:[CursorBx-2]
 0F97   3p  8E 5E 40		      mov ds,Z.Consts
				      move Z.Insert.Named,Vbx.Here
 0F9A   1   8B 47 04		  1      mov ax,Vbx.Here
 0F9D   1   89 46 7E		  1      mov Z.Insert.Named,ax
 0FA0   1   B8 2D01		      mov ax,MkMajMin(45,1)
 0FA3   3   E9 0909		      jmp Raise

				     ; If this is a procedure folding, there will be a change of Z.VarScope.
 0FA6				     ReturnX:Qry L.Access,IsProcedure
 0FA6   2   F6 03 20		  1          test Bptr(L.Access), low ??001D
 0FA9  3,1  74 0F		     jz PlainRet
				     ; Current scope goes on freespace chain.
 0FAB   1   8B 46 50		      mov ax,Z.PoolPool
 0FAE   5   64: 87 46 0A	      xchg ax,Hf.UpPool
 0FB2   3   8C 66 50		      mov Z.PoolPool,fs
				     ; Caller's pool becomes current.
 0FB5   1   89 46 46		      mov Z.VarScope,ax
 0FB8   3p  8E E0		      mov fs,ax
 0FBA				     PlainRet:
				     ; Drop RESULT special variable.
 0FBA   1   64: C6 46 27 40	      mov Vf.Dtype[$?RESULTx],$Dropped
				     ; Drop .RESULT reserved variable.
 0FBF   1   26: C6 46 33 40	      mov Ve.Dtype[$?RESULT],$Dropped
 0FC4   2   8B 73 02		      mov LevelSi,L.UpLevel; Invoker block.
				      TestReg LevelSi
 0FC7   1   85 F6		  1         test LevelSi,LevelSi
 0FC9  3,1  74 50		      jz Exit$$
 0FCB   1   89 76 52		      mov Z.Level,LevelSi
				     ; Some Zone restoration from callers stuff if an External is being left.
				      Qry L.Access,IsExternal
 0FCE   2   F6 03 10		  1          test Bptr(L.Access), low ??001E
 0FD1  3,1  74 33		      jz @F
				      move Z.ProgScope,Lsi.ProgScope
 0FD3   2   8B 42 FC		  1      mov ax,Lsi.ProgScope
 0FD6   1   89 46 44		  1      mov Z.ProgScope,ax
 0FD9   3p  8E C0		      mov ProgEs,ax
				      move Z.VarScope,Lsi.VarScope
 0FDB   2   8B 42 FE		  1      mov ax,Lsi.VarScope
 0FDE   1   89 46 46		  1      mov Z.VarScope,ax
 0FE1   3p  8E E0		      mov fs,ax
				      move Z.File,Lsi.File,FileBx
 0FE3   2   8B 5A FA		  1    mov FileBx,Lsi.File
 0FE6   1   89 5E 3C		  1    mov Z.File,FileBx
 0FE9   3p  8E 5E 3E		      mov ds,Z.SysFiles
				      move Z.Symbols,F.Symbols
 0FEC   1   8B 47 F6		  1      mov ax,F.Symbols
 0FEF   1   89 46 48		  1      mov Z.Symbols,ax
				      move Z.Code,F.Code
 0FF2   1   8B 47 F8		  1      mov ax,F.Code
 0FF5   1   89 46 4A		  1      mov Z.Code,ax
 0FF8   3p  8E E8		      mov gs,ax
				      move Z.Consts,F.Consts
 0FFA   1   8B 47 FC		  1      mov ax,F.Consts
 0FFD   1   89 46 40		  1      mov Z.Consts,ax
				      move Z.Vars,F.Vars
 1000   1   8B 47 FA		  1      mov ax,F.Vars
 1003   1   89 46 42		  1      mov Z.Vars,ax
 1006				     @@:
				     ; Return can have the effect of altering the current digits().
				     ; But only if the invokee(s) altered digits().
				      Qry L.Access,DigitsSet
 1006   2   F6 03 40		  1          test Bptr(L.Access), low ??001F
 1009  3,1  74 03		      jz @F
 100B   3   E8 0619		      call DigitsChange
 100E				     @@:
				     ; Lose arguments and level block of completing routine.
 100E   2   8B 7B 06		      mov StackDi,L.Arg0
				      move Z.CurrentDO,Lsi.LevelDO
 1011   2   8B 42 F4		  1      mov ax,Lsi.LevelDO
 1014   1   89 46 56		  1      mov Z.CurrentDO,ax
 1017   2   8B 72 04		      mov CursorSi,Lsi.Resume; Invoker holds resume point.
				      BackRet
 101A   5   C3			  1  ret

 101B				     Exit$$:; Exit has an optional argument.
				      z cx
 101B   1   8B CD		  1           mov cx,bp
 101D   2   3B 7E 56		      cmp StackDi,Z.CurrentDO
 1020  3,1  74 08		      je @F
 1022   1   41			      inc cx
 1023   4   66| FF 33		      pushd V.ExpAnd
 1026   5   66| FF 73 04	      pushd V.Mantissa
 102A   1   56			     @@:push CursorSi
				     ; Go up the Level chain to the current External
 102B   1   8B 76 52		     ExitUp:mov LevelSi,Z.Level
 102E   2   8B 7A 06		     mov StackDi,Lsi.Arg0
				     if Debug
				      TestReg LevelSi
 1031   1   85 F6		  1         test LevelSi,LevelSi
 1033  3,1  75 02		      jnz @F
 1035   5p  FF D5		      Error49Bp
 1037				      @@:
				     endif
				      Qry Lsi.Access,IsExternal
 1037   2   F6 02 10		  1          test Bptr(Lsi.Access), low ??0020
 103A  3,1  75 08		      jnz @F
				      move Z.Level,Lsi.UpLevel,LevelSi
 103C   2   8B 72 02		  1    mov LevelSi,Lsi.UpLevel
 103F   1   89 76 52		  1    mov Z.Level,LevelSi
 1042   3   EB E7		      jmp ExitUp
 1044				     @@:move Z.CurrentDO,Lsi.LevelDO
 1044   2   8B 42 F4		  1      mov ax,Lsi.LevelDO
 1047   1   89 46 56		  1      mov Z.CurrentDO,ax
				     ; Is this the outermost external (that came as a command)?
 104A   3   39 6A 02		      cmp Lsi.UpLevel,ZeroBp
 104D  3,1  74 14		      je @F
 104F   1   5E			      pop CursorSi
				      TestReg cx
 1050   1   85 C9		  1         test cx,cx
 1052  3,1  0F 84 FF2A		      jz Return$$; EXIT with no argument becomes RETURN.
				      Up
 1056   1   83 C7 08		  1   add StackDi,$StrideV
 1059   7   66| 8F 43 04	      pop V.Mantissa
 105D   6   66| 8F 03		      pop V.ExpAnd
 1060   3   E9 FECD		      jmp Returns$$; EXIT(...) becomes RETURN(...)
 1063				     @@:; True exit. Can only return a byte (in AL) as result.
				     if 0
				     endif

 1063				     Exit:
 1063   1   B0 00		      mov al,$SerialNone
 1065   3   E8 0000 E		      call Serialize
 1068   1   8B 5E 30		      mov bx,Z.Dumper
 106B   1   B4 3E		      mov ah,$DosClose
 106D  30   CD 21		      int 21h
 106F   1   B4 4C		     ExitDOS:mov ah,$DosExit
 1071  30   CD 21		      int 21h

				     ;------------------------------------------------------------------------------
				     ; Here are the other operators for expressions.
				     ;------------------------------------------------------------------------------
				     ; Aug 99 - clumsy interface to ArithOp since future undecided.
 1073  26   CC			     Raise41p2BLM:int 3
 1074   3   E9 07DC		     jmp Raise41p2
 1077  3,1  72 FA		     ArithRight:jc Raise41p2BLM
 1079				     ArithGeneral:
 1079   1   65: 8A 54 FF	      mov dl,gs:Bptr[CursorSi-1]
 107D   1   56			      push CursorSi
				      Down
 107E   1   83 EF 08		  1   sub StackDi,$StrideV
 1081   3   E8 0FF5		      call ToDsSiCx
 1084   3   EB 0B		      jmp @F

 1086  26   CC			     Raise41p1BLM:int 3
 1087   3   E9 07CA		     jmp Raise41p1
 108A  3,1  72 FA		     ArithLeft:jc Raise41p1BLM
 108C   1   65: 8A 54 FF	      mov dl,gs:Bptr[CursorSi-1]
 1090   1   56			     ArithDl:push CursorSi; Entry with lower already string and DL for the operator.
 1091				     @@:Up
 1091   1   83 C7 08		  1   add StackDi,$StrideV
 1094   3   E8 0FE2		      call ToDsSiCx
				      Up
 1097   1   83 C7 08		  1   add StackDi,$StrideV
 109A   2   C6 43 07 81		      mov V.Dtype,$NullString+1
 109E   1   C6 03 3E		      mov V.String,'>'; All compares
 10A1   1   80 FA 3F		      cmp dl,$pAdd
 10A4  3,1  75 03		      jne @F
 10A6   1   C6 03 2B		      mov V.String,'+'
 10A9				      @@:
 10A9   1   80 FA 41		      cmp dl,$pSubtract
 10AC  3,1  75 03		      jne @F
 10AE   1   C6 03 2D		      mov V.String,'-'
 10B1				      @@:
 10B1   1   80 FA 3D		      cmp dl,$pNegate
 10B4  3,1  75 03		      jne @F
 10B6   1   C6 03 2D		      mov V.String,'-'
 10B9				      @@:
 10B9   1   80 FA 3B		      cmp dl,$pPositive
 10BC  3,1  75 03		      jne @F
 10BE   1   C6 03 2B		      mov V.String,'+'
 10C1				      @@:
 10C1   1   80 FA 43		      cmp dl,$pMultiply
 10C4  3,1  75 03		      jne @F
 10C6   1   C6 03 2A		      mov V.String,'*'
 10C9				      @@:
 10C9   1   80 FA 45		      cmp dl,$pDivide
 10CC  3,1  75 03		      jne @F
 10CE   1   C6 03 2F		      mov V.String,'/'
 10D1				      @@:
 10D1   1   80 FA 47		      cmp dl,$pIntDivide
 10D4  3,1  75 03		      jne @F
 10D6   1   C6 03 25		      mov V.String,'%'
 10D9				      @@:
 10D9   1   80 FA 49		      cmp dl,$pRemainder
 10DC  3,1  75 07		      jne @F
 10DE   1   C7 03 2F2F		      mov Wptr V.String,'//'
 10E2   4   FE 43 07		      inc V.Dtype
 10E5				      @@:
 10E5   1   80 FA 4B		      cmp dl,$pPower
 10E8  3,1  75 07		      jne @F
 10EA   1   C7 03 2A2A		      mov Wptr V.String,'**'
 10EE   4   FE 43 07		      inc V.Dtype
 10F1				      @@:
 10F1   3   E8 1164		      call HeritageDi
 10F4   4   66| 0F B7 43 8C	      movzx eax,L.Digits
 10F9   2   8B 53 8E		      mov dx,L.Fuzz
 10FC   1   5F			      pop StackDi
 10FD   2   80 3B 3E		      cmp V.String,'>'
 1100  3,1  75 02		      jne @F
 1102   1   2B C2		      sub ax,dx
 1104				      @@:
				      Up
 1104   1   83 C7 08		  1   add StackDi,$StrideV
 1107   2   66| 89 43 04	      mov V.Mantissa,eax
 110B   1   66| 89 2B		      mov V.ExpAnd,ebp
 110E   1   5E			      pop CursorSi
 110F   1   56			      push CursorSi; Might be needed for Msg
 1110   1   BA 0000 E		      mov dx,offset ARITHOP$$
 1113   3   E8 0000 E		      call LinkBcode
 1116   1   89 7E 06		      mov Z.Stack,StackDi
 1119   1   5E			      pop CursorSi
				     if Debug
				      CheckType
 111A   3   F6 43 07 C0		  1   test V.Dtype,$Test
 111E  3,1  74 37		  1   jz @F
 1120   3   80 7B 07 C0		  1   cmp V.Dtype,$AwayString
 1124  3,1  74 31		  1   je @F
 1126   3   80 7B 07 80		  1   cmp V.Dtype,$NullString
 112A  3,1  74 2B		  1   je @F
 112C   3   80 7B 07 81		  1   cmp V.Dtype,$NullString+1
 1130  3,1  74 25		  1   je @F
 1132   3   80 7B 07 82		  1   cmp V.Dtype,$NullString+2
 1136  3,1  74 1F		  1   je @F
 1138   3   80 7B 07 83		  1   cmp V.Dtype,$NullString+3
 113C  3,1  74 19		  1   je @F
 113E   3   80 7B 07 84		  1   cmp V.Dtype,$NullString+4
 1142  3,1  74 13		  1   je @F
 1144   3   80 7B 07 85		  1   cmp V.Dtype,$NullString+5
 1148  3,1  74 0D		  1   je @F
 114A   3   80 7B 07 86		  1   cmp V.Dtype,$NullString+6
 114E  3,1  74 07		  1   je @F
 1150   3   80 7B 07 87		  1   cmp V.Dtype,$NullString+7
 1154  3,1  74 01		  1   je @F
 1156  26   CC			      int 3
 1157				     @@:
				     endif
				     ; We do some conversions at compile time.
 1157   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 115A   2   39 AE 00E1		      cmp Z.Scanp,ZeroBp
 115E  3,1  74 03		      je @F
 1160   3p  8E 46 48		      mov SymbolsEs,Z.Symbols
 1163				     @@:BackRet
 1163   5   C3			  1  ret

				     ; The binary operators find their LHS as the older parameter and their RHS
				     ; as the latest parameter.
				     ; Add, subtract, and numeric compare are similar.
				     ; If the values are too big for the precision we must use ArithGeneral to
				     ; raise LOSTDIGITS. This check is in NumDxBx
 1164				     Add$$:; Required to check left one first.
				      Down
 1164   1   83 EF 08		  1   sub StackDi,$StrideV
 1167   3   E8 0D12		      call NumDxBx
 116A  3,1  0F 85 FF1C		      jnz ArithLeft
 116E   1   66| 8B CA		      mov ecx,edx
 1171   1   66| 8B C3		      mov eax,ebx
				      Up
 1174   1   83 C7 08		  1   add StackDi,$StrideV
 1177   3   E8 0D02		      call NumDxBx
 117A  3,1  0F 85 FEF9		      jnz ArithRight
				      Down
 117E   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; Now we know it is to be done in binary, the predominant case.
 1181				     AddRegs:;LHS in ecx:eax (V originally)   RHS in edx:ebx (V2 originally)
				     ; Easy case with both signs and exponents the same.
 1181   1   66| 3B CA		      cmp ecx,edx
 1184  3,1  75 30		      jne AddTest
				     ; Result cannot be zero unless both operands were, in which case exponent
				     ; already zero.
 1186   1   66| 03 C3		      add eax,ebx
 1189   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 118D  3,1  73 14		      jae Round32; Unusual
 118F   2   66| 89 43 04	     AddSubEax:mov V.Mantissa,eax
 1193				     AddSubNull:
				     ; If not SCIENTIFIC 9, convert to char because if char needed later the
				     ; numeric settings may have changed.
 1193   2   39 6E 6F		      cmp Z.UseGeneral,ZeroBp
 1196  3,1  74 0A		      je AddS9b
				     ; Don't want to do this in Bcode because (1) numeric setting won't lower and
				     ; (2) assumptions of S9 are made.
 1198   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 119B  3,1  75 05		      jnz AddS9b
 119D   1   56			      push CursorSi
 119E   3   E8 0ED8		      call ToDsSiCx
 11A1   1   5E			      pop CursorSi
 11A2				     AddS9b:BackRet; Does not guarantee registers match V.
 11A2   5   C3			  1  ret

 11A3				     Round32:;32 bit result to be rounded
				     z edx
 11A3   1   66| 8B D5		  1             mov edx,ebp
 11A6   3   EB 67		     jmp Acc64

				     ; Mantissa shifted out of significance is the same as being zero.
 11A8   1   66| 03 D1		     AlignNoOver:add edx,ecx
 11AB   1   66| 8B D8		     mov ebx,eax
 11AE   1   66| 89 13		     RetEdxEbx:mov V.ExpAnd,edx
 11B1   2   66| 89 5B 04	     mov V.Mantissa,ebx
				     BackRet
 11B5   5   C3			  1  ret

 11B6				     AddTest:; Still doing AddRegs, after some cases handled.
				     ; Test zero mantissas.
 11B6   1   66| 3B DD		      cmp ebx,ebp
 11B9  3,1  74 D8		      je AddSubNull; LHS+0 case.
				     if 0
				     endif
				     ; If the signs differ, change sign and change to a subtract.
 11BB   1   66| 52		      push edx
 11BD   1   66| 33 D1		      xor edx,ecx
 11C0   1   F6 C2 01		      test dl,1
 11C3   1   66| 5A		      pop edx
 11C5  3,1  74 06		      jz @F
 11C7   1   80 F2 01		      xor dl,1
 11CA   3   E9 00DF		      jmp SubRegs
 11CD				      @@:
				     ; Signs are now the same but exponents will not be.
 11CD   1   66| 3B CA		      cmp ecx,edx
 11D0  3,1  7D 05		      jge @F; First make LHS have the large exponent.
				     ; Simplest is to change A+B to B+A.
 11D2   3   66| 87 D1		      xchg edx,ecx
 11D5   3   66| 93		      xchg ebx,eax
 11D7   1   66| 2B CA		     @@:sub ecx,edx; ecx is non-negative, twice the difference of exponents.
				     ; If the difference is large there will be no overlap of mantissae
				     ; and the big magnitude operand is the result.
 11DA   2   66| 3B 4E 6B	      cmp ecx,Z.TwiceDigits
 11DE  3,1  7D C8		      jge AlignNoOver
				     ; Multiply by appropriate power of ten. (ecx is double shift required)
 11E0   1   66| 52		      push edx
 11E2  14+  67& 66| 2E: F7 64 4D      mul Ycx2.N1; Indexing does a second doubling.
	      04 3A
				     ; It may be we are just adding cents to dollars and the result is going to fit
				     ; in 32 bits but more likely we are doing a scientific calculation which has
				     ; built up nine digits. So probably best just to do things with 64 bits(?).
 11E9   1   66| 59		      pop ecx
 11EB   1   66| 03 C3		      add eax,ebx
 11EE   1   66| 13 D5		      adc edx,ebp
				     ; Assert ebx+eax cannot have result zero. (So pushed edx remains the exponent)
				     ; Does result need rounding? Note that V & V2 are intact, for a possible msg.
 11F1   1   66| 3B D5		      cmp edx,ebp
 11F4  3,1  75 19		      jne Acc64
 11F6   2   66| 3B 46 63	     AddPos32:cmp eax,Z.Ceiling
 11FA  3,1  73 13		      jae Acc64
 11FC				     PostAcc64:Move V
 11FC   1   66| 89 0B		  1     mov V.OverExpo,ecx
 11FF   2   66| 89 43 04	  1     mov V.OverMant,eax
				      BackRet
 1203   5   C3			  1  ret

 1204				     OneMore:z edx
 1204   1   66| 8B D5		  1             mov edx,ebp
 1207   3   EB 0D		     jmp ChangeExpon

 1209				     ToArithGeneral:Up
 1209   1   83 C7 08		  1   add StackDi,$StrideV
 120C   3   E9 FE6A		     jmp ArithGeneral

 120F				     Acc64:; The 64 bit accumulator edx:eax has a result that is too big for
				     ; Z.Ceiling.
				     ; It may need rounding, or if current digits >9 it needs rework as long.
 120F   2   83 7E 5F 09		      cmp Z.Digits,9
 1213  3,1  77 F4		      ja ToArithGeneral
				     ; The exponent of the result is in ecx. (Doubled form)
 1215   1   56			      push CursorSi
				     ; Something with BSR instruction and lookup might be quicker than a loop here.
				     ; We are going to have to reduce the Mantissa and bump the exponent at least
				     ; once. Do initially divide with enough to zero edx of edx:eax.
 1216				     ChangeExpon:z si
 1216   1   8B F5		  1           mov si,bp
 1218   1   66| 83 C1 02	     @@:add ecx,2
 121C   1   83 C6 04		     add si,4
 121F   2   66| 2E: 3B 54 04	     cmp edx,Ysi.N1
 1224  3,1  73 F2		     jae @B
 1226  40   66| 2E: F7 74 04	      div Ysi.N1; Division by this power of ten will give result in 32 bits.
				     ; That took (edx*2**32+eax)*(ecx/2) to eax*10**(N+ecx/2) with edx remainder.
 122B   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 122F  3,1  73 D3		      jae OneMore
				     ; We have enough significant decimals to the eax number. edx decides rounding.
 1231   1   66| 03 D2		      add edx,edx
 1234   2   66| 2E: 3B 54 04	      cmp edx,Ysi.N1
 1239  3,1  72 08		      jb @F
 123B   1   66| 40		      inc eax
				     ; It is just possible accum is now exactly over limit
 123D   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 1241  3,1  74 C1		      je OneMore
 1243   1   5E			     @@:pop CursorSi
				     ; Quick test accepts most exponents.
 1244   2   66| 2E: 3B 4E 30	      cmp ecx,Y.ExponHi
 1249  3,1  7F 07		      jg TestExpon
 124B   2   66| 2E: 3B 4E 34	      cmp ecx,Y.ExponLo
 1250  3,1  7F AA		      jg PostAcc64

 1252				     TestExpon:; The quick check on V. has already been made, so ecx is extreme.
				     ; Need to keep original LHS for possible message.
 1252   4   66| FF 33		      pushd V.ExpAnd
 1255   5   66| FF 73 04	      pushd V.Mantissa
				      Move V
 1259   1   66| 89 0B		  1     mov V.OverExpo,ecx
 125C   2   66| 89 43 04	  1     mov V.OverMant,eax
 1260   1   56			      push CursorSi
 1261   1   66| 51		      push ecx
 1263   3   E8 0E13		      call ToDsSiCx
 1266   1   49			     @@:dec cx
 1267   1   46			      inc si
 1268   2   80 3C 45		      cmp Bptr[si],'E'
 126B  3,1  75 F9		      jne @B
 126D   1   8A 54 01		      mov dl,Bptr[si+1]
 1270   1   83 F9 0A		      cmp cx,$Limit_ExponentDigits+1
 1273   1   66| 59		      pop ecx
 1275   1   5E			      pop CursorSi
 1276   7   66| 8F 43 04	      pop V.Mantissa
 127A   6   66| 8F 03		      pop V.ExpAnd
 127D  3,1  0F 87 FF7B		      ja PostAcc64
				     ; 40.9 and 41.7 occur on loading operands for input to operations.
				     ; 42.1 and 42.2 occur when testing the output of operations.
 1281   1   B8 2A01		      mov ax,MkMajMin(42,1)
 1284   1   80 FA 2B		      cmp dl,'+'
 1287  3,1  0F 84 0624		      je Raise
 128B   1   40			      inc ax
 128C   3   E9 0620		      jmp Raise

 128F				     Subtract$$:; Required to check left one first.
				      Down
 128F   1   83 EF 08		  1   sub StackDi,$StrideV
 1292   3   E8 0BE7		      call NumDxBx
 1295  3,1  0F 85 FDF1		      jnz ArithLeft
 1299   1   66| 8B CA		      mov ecx,edx
 129C   1   66| 8B C3		      mov eax,ebx
				      Up
 129F   1   83 C7 08		  1   add StackDi,$StrideV
 12A2   3   E8 0BD7		      call NumDxBx
 12A5  3,1  0F 85 FDCE		      jnz ArithRight
				      Down
 12A9   1   83 EF 08		  1   sub StackDi,$StrideV

 12AC				     SubRegs:; Read the code for Add first.
 12AC   1   66| 3B CA		      cmp ecx,edx
 12AF  3,1  75 28		      jne SubTest
 12B1   1   66| 2B C3		      sub eax,ebx
 12B4  3,1  0F 84 0085		      jz SubZero
 12B8  3,1  7C 0B		      jl @F
 12BA   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 12BE  3,1  0F 82 FECD		      jb AddSubEax
 12C2   3   E9 FEDE		      jmp Round32
 12C5   1   80 F1 01		     @@:xor cl,1
 12C8   1   66| F7 D8		      neg eax
 12CB   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 12CF  3,1  0F 83 FED0		      jae Round32
 12D3   1   66| 89 0B		     SubAddEcxEax:mov V.ExpAnd,ecx
 12D6   3   E9 FEB6		      jmp AddSubEax

 12D9   1   66| 3B DD		     SubTest:cmp ebx,ebp
 12DC  3,1  0F 84 FEB3		     je AddSubNull
				     ; If the signs differ, change sign and change to an add.
 12E0   1   66| 52		      push edx
 12E2   1   66| 33 D1		      xor edx,ecx
 12E5   1   F6 C2 01		      test dl,1
 12E8   1   66| 5A		      pop edx
 12EA  3,1  74 06		      jz @F
 12EC   1   80 F2 01		      xor dl,1
 12EF   3   E9 FE8F		      jmp AddRegs
 12F2				     SubRegsCmp:; Here from compare, avoiding some tests.
 12F2   1   66| 3B CA		     @@:cmp ecx,edx
 12F5  3,1  7D 0B		      jge @F
				     ; Simplest is to change A-B to (-B)-(-A), so exponents ordered.
 12F7   1   80 F1 01		      xor cl,1
 12FA   1   80 F2 01		      xor dl,1
 12FD   3   66| 87 D1		      xchg edx,ecx
 1300   3   66| 93		      xchg ebx,eax
 1302   1   66| 2B CA		     @@:sub ecx,edx
 1305   2   66| 3B 4E 6B	      cmp ecx,Z.TwiceDigits
 1309  3,1  0F 8D FE9B		      jge AlignNoOver
 130D   1   66| 52		      push edx
 130F  14+  67& 66| 2E: F7 64 4D      mul Ycx2.N1
	      04 3A
 1316   1   66| 59		      pop ecx
 1318   1   66| 2B C3		      sub eax,ebx
 131B   1   66| 1B D5		      sbb edx,ebp
 131E  3,1  79 0F		      jns SubPos
				     ; Subtract is harder than Add, since zero and negative possible.
 1320   1   80 F1 01		      xor cl,1
 1323   1   66| F7 D8		      neg eax
 1326   4p  9C			      pushf
 1327   1   66| F7 DA		      neg edx
 132A   9p  9D			      popf
 132B  3,1  73 02		      jnc @F
 132D   1   66| 4A		      dec edx
 132F				      @@:
 132F   1   66| 3B D5		     SubPos:cmp edx,ebp
 1332  3,1  0F 85 FED9		      jne Acc64
 1336   1   66| 3B C5		      cmp eax,ebp
 1339  3,1  0F 85 FEB9		      jnz AddPos32
 133D   1   66| 89 2B		     SubZero:mov V.ExpAnd,ebp
 1340   3   E9 FE4C		      jmp AddSubEax

				     ;------------------------------------------------------------------------------
				     ; Conditional Pcode jumps and Boolean results here.
				     ;------------------------------------------------------------------------------
				     if 0
				     endif

				     ; CmpGen is the general test for whether non-strict is char or arith compare.
				     ; Already filtered off (at compile) case where one argument is non-arith const.
				     ; Already filtered off case of both in binary.

 1343				     StringC:Up; RHS was number but LHS proved not.
 1343   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V; Non-binary form of RHS
 1346   1   66| 89 0B		  1     mov V.OverExpo,ecx
 1349   2   66| 89 43 04	  1     mov V.OverMant,eax
 134D   3   E9 00C1		      jmp StringCompare

 1350				     CmpGen2:; RHS is bin (and was originally), LHS may be convertible.
 1350   3   E8 0B29		      call NumDxBx
 1353  3,1  73 1C		      jnc CmpArith
				      Up
 1355   1   83 C7 08		  1   add StackDi,$StrideV
 1358   3   E9 00B6		      jmp StringCompare

				     ; No msgs so we can look at rhs first.
				     ; This is a touch clumsy because NumDxBx is destructive - usually conversion
				     ; is desirable if possible - but for comparison we want conversion only
				     ; if both will convert.
 135B				     CmpGen:Move ,V
 135B   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 135E   2   66| 8B 43 04	  1     mov eax,V.OverMant
 1362   3   E8 0B17		     call NumDxBx
 1365  3,1  0F 82 00A8		     jc StringCompare
				     ; RHS is some sort of number
				     Down
 1369   1   83 EF 08		  1   sub StackDi,$StrideV
 136C   3   E8 0B0D		     call NumDxBx
 136F  3,1  72 D2		     jc StringC
				     ; Both some sort of arith.  ArithGeneral if either out of range for Binary.
				     ; Or if FUZZ<>0
 1371  3,1  75 06		     CmpArith:jnz @F
				     ; 2011 UseGeneral does not apply if both binary.
				     ; cmp Z.UseGeneral,ZeroBp
				     ; jne @F
 1373   3   F6 43 0F C0		      test V2.Dtype,$Test
 1377  3,1  74 38		      jz FromCmpGen; For binary Arith compare after conversion(s).
 1379				     @@:Up
 1379   1   83 C7 08		  1   add StackDi,$StrideV
 137C   3   E8 FCFA		      call ArithGeneral
 137F   3   E8 0AFA		      call NumDxBx
 1382  3,1  74 51		      jz MantPare
				     ; Difference was still not binary.
 1384   6p  C5 1B		      lds bx,V.Fr
				      z V.ExpAnd
 1386   1   66| 89 2B		  1             mov V.ExpAnd,ebp
				      z V.MantHigh
 1389   2   89 6B 06		  1           mov V.MantHigh,bp
 138C   2   80 3F 2D		      cmp Bptr[bx],'-'
 138F  3,1  75 44		      jne MantPare
 1391   3   FE 03		      inc V.Sign
 1393   3   EB 40		      jmp MantPare

 1395				     Eq$$:
 1395				     Ne$$:
 1395				     Lt$$:
 1395				     Le$$:
 1395				     Ge$$:
 1395				     Gt$$:
				     ; Convert particular operator to place in Rejumps.
 1395   2   C1 E3 02		      shl bx,2
 1398   1   81 C3 FF34 R	      add bx,Rejumps-(4*$pEq)
 139C   1   53			      push bx
 139D				     SetFlags:; Set hardware flags from compare and also ax from Pcode.
				     ; Is it worth a quick test for the number v number case? (Avoids CmpGen)
 139D   2   39 6E 6F		      cmp Z.UseGeneral,ZeroBp
 13A0  3,1  75 B9		      jne CmpGen
 13A2   3   F6 43 07 C0		      test V.Dtype,$Test
 13A6  3,1  75 B3		      jnz CmpGen
				      Down
 13A8   1   83 EF 08		  1   sub StackDi,$StrideV
 13AB   3   F6 43 07 C0		      test V.Dtype,$Test
 13AF  3,1  75 9F		      jnz CmpGen2
 13B1				     FromCmpGen:; When conversions to binary worked.
				      Move ,V
 13B1   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 13B4   2   66| 8B 43 04	  1     mov eax,V.OverMant
 13B8   2   66| 8B 53 08	      mov edx,V2.ExpAnd
 13BC   2   66| 8B 5B 0C	      mov ebx,V2.Mantissa
				     ; RHS in edx:ebx LHS in ecx:eax
 13C0   1   66| 33 CA		      xor ecx,edx
 13C3  3,1  74 17		      jz EasyPare; Quick if exponents and signs are the same.
 13C5   1   F6 C1 01		      test cl,1
 13C8  3,1  75 22		      jnz EasySign; Quick if signs differ.
 13CA   1   66| 8B 0B		      mov ecx,V.ExpAnd
				     ; Subtract and test result will work but may be overkill.
				     ; Signs are the same, exponents differ.
				     ;Exponent is irrelevant if comparison is with zero.(Nearly 1/4 of reached here)
 13CD   1   66| 3B DD		       cmp ebx,ebp
 13D0  3,1  74 0A		       je EasyPare
				     ; Subtract and test result.
 13D2   3   E8 FF1D		      call SubRegsCmp
				     ; Compare Mantissa with zero.
 13D5   2   66| 8B 43 04	     MantPare:mov eax,V.Mantissa
				     z ebx
 13D9   1   66| 8B DD		  1             mov ebx,ebp
 13DC   2   F6 03 01		     EasyPare:test V.Sign,1
 13DF  3,1  74 02		     jz @F
 13E1   3   66| 93		     xchg eax,ebx
 13E3				     @@:
				      Down
 13E3   1   83 EF 08		  1   sub StackDi,$StrideV
 13E6   1   66| 3B C3		      cmp eax,ebx
				     ; Interpreted branch conditional.
				     ; Flags reflect relation.
 13E9   5   65: AD		      lodsw gs:[CursorSi]
				     ; User wants fallthru on Pcode if the test succeeds, else continuation at ax.
				     ; We jump to some jump conditional.  (Or return if called.)
 13EB   5   C3			      ret
 13EC				     EasySign:; Deduce result from the (differing) signs.
				      Down
 13EC   1   83 EF 08		  1   sub StackDi,$StrideV
 13EF   1   B8 0001		      mov ax,1
 13F2   1   F6 C2 01		      test dl,1
 13F5  3,1  75 02		      jnz @F
 13F7   3   86 E0		      xchg ah,al
 13F9   1   38 E0		      @@:cmp al,ah
 13FB   5   65: AD		      lodsw gs:[CursorSi]
 13FD   5   C3			      ret

				     ;------------------------------------------------------------------------------
				     ; The C series of compares are known from compile time to be string compares.
				     ; They join the general case once the hardware flags are set.
				     ; The S for strict series are similar.
				     ; The _ series of Bcode operators is similar but with one byte jump addresses.
				     ;------------------------------------------------------------------------------
 13FE				     @@:Down
 13FE   1   83 EF 08		  1   sub StackDi,$StrideV
 1401   3   E8 0C75		     call ToDsSiCx
				     Up
 1404   1   83 C7 08		  1   add StackDi,$StrideV
 1407   3   EB 12		     jmp @F

 1409				     Ceq$$:
 1409				     Cne$$:
 1409				     Clt$$:
 1409				     Cle$$:
 1409				     Cge$$:
 1409				     Cgt$$:
 1409   2   C1 E3 02		      shl bx,2
 140C   1   81 C3 FED4 R	      add bx,Rejumps-(4*$pCeq)
 1410   1   53			      push bx
 1411				     StringCompare:; Space traded for speed.
 1411   1   BB 0000 E		      mov bx,Attributes; For potential XLAT
 1414   1   56			      push CursorSi
				     ; If the left one isn't a string then better convert it now so that no
				     ; compaction threat from ToDsSiCx of it.
 1415   3   F6 43 FF C0		      test V0.Dtype,$Test
 1419  3,1  74 E3		      jz @B
 141B   3   E8 0C5B		     @@:call ToDsSiCx
				      JcxzQ FromStripR
 141E   1   85 C9		  1    test cx,cx
 1420  3,1  74 12		  1    je FromStripR
				     ; All my blanks rank no higher than plain blank so quick test is possible.
 1422   1   BA 1434 R		      mov dx,FromStripR
 1425   2   80 3C 20		      cmp Bptr[si],' '
 1428  3,1  76 4A		      jbe StripB
 142A   1   56			      push si
 142B   1   03 F1		      add si,cx
 142D   1   4E			      dec si
 142E   2   80 3C 20		      cmp Bptr[si],' '
 1431  3,1  76 52		      jbe StripE
 1433   1   5E			      pop si
 1434				     FromStripR:
				      mv es,ds
 1434   3   1E			  1   push ds
 1435   3p  07			  1   pop es
 1436   1   56			      push si
 1437   1   51			      push cx
				      Down
 1438   1   83 EF 08		  1   sub StackDi,$StrideV
 143B   3   E8 0C3B		      call ToDsSiCx
				      JcxzQ FromStripL
 143E   1   85 C9		  1    test cx,cx
 1440  3,1  74 12		  1    je FromStripL
 1442   1   BA 1454 R		      mov dx,FromStripL
 1445   2   80 3C 20		      cmp Bptr[si],' '
 1448  3,1  76 2A		      jbe StripB
 144A   1   56			      push si
 144B   1   03 F1		      add si,cx
 144D   1   4E			      dec si
 144E   2   80 3C 20		      cmp Bptr[si],' '
 1451  3,1  76 32		      jbe StripE
 1453   1   5E			      pop si
 1454   1   5B			     FromStripL:pop bx
 1455   1   58			      pop ax
 1456				     FromStrict:Down
 1456   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; Now strict comparison of the lhs(ds:si:cx) with rhs(es:ax:bx)
 1459   1   57			      push StackDi
 145A   1   8B F8		      mov di,ax
 145C   1   8B C1		      mov ax,cx
				     ; Change cx to shared length.
 145E   1   3B D9		      cmp bx,cx
 1460  3,1  7F 02		      jg @F
 1462   1   8B CB		      mov cx,bx
 1464				      @@:
 1464   1   3B ED		      cmp bp,bp; Zero flags in case cx=0.
 1466   8n  F3/ A6		      repe cmpsb
 1468  3,1  75 02		      jne @F
				     ; Equal over shared length. Comparison now on lengths.
 146A   1   3B D8		      cmp bx,ax
 146C				     @@:; Flags reflect relation.
 146C   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 146F   1   5F			      pop StackDi
 1470   1   5E			      pop CursorSi
 1471   5   65: AD		      lodsw gs:[CursorSi]
 1473   5   C3			      ret

				     ; Remove all types of blank from both ends of Ds:Si:Cx
 1474   5   AC			     StripB:lodsb
				     XlatBDLS
 1475   4   2E: D7		  1   xlat Bptr cs:[bx]
 1477   1   A8 C0		  1   test al,0C0h
 1479  3,1  75 05		     jnz @F
				     LoopQ StripB
 147B   1   49			  1    dec cx
 147C  3,1  75 F6		  1    jnz StripB
 147E   5p  FF E2		     jmp dx
 1480   1   4E			     @@:dec si
 1481   1   56			     push si
 1482   1   03 F1		     add si,cx
 1484   1   4E			     dec si
 1485   2   FD			     StripE:std
 1486   5   AC			     @@:lodsb
				     XlatBDLS
 1487   4   2E: D7		  1   xlat Bptr cs:[bx]
 1489   1   A8 C0		  1   test al,0C0h
 148B  3,1  75 03		     jnz @F
				     LoopQ @B
 148D   1   49			  1    dec cx
 148E  3,1  75 F6		  1    jnz @B
 1490   2   FC			     @@:cld
 1491   1   5E			     pop si
 1492   5p  FF E2		     jmp dx
 1494				     Seq$$:
 1494				     Sne$$:
 1494				     Slt$$:
 1494				     Sle$$:
 1494				     Sge$$:
 1494				     Sgt$$:
				     ; Convert particular operator to place in Rejumps.
 1494   2   C1 E3 02		      shl bx,2
 1497   1   81 C3 FF04 R	      add bx,Rejumps-(4*$pSeq)
 149B   1   53			      push bx
 149C   1   56			     StrictFlags:push CursorSi
 149D   3   E8 0BD9		      call ToDsSiCx
				      mv es,ds
 14A0   3   1E			  1   push ds
 14A1   3p  07			  1   pop es
 14A2   1   8B C6		      mov ax,si
 14A4   1   8B D9		      mov bx,cx
				      Down
 14A6   1   83 EF 08		  1   sub StackDi,$StrideV
 14A9   3   E8 0BCD		      call ToDsSiCx
 14AC   3   EB A8		      jmp FromStrict

				     ; The prefix to a comparison operator means the result is to go to the
				     ; stack rather than used for a conditional jump.
				     ; It would have been simpler to reserve a zero value of jump to mean Boolery
				     ; but we don't want to add a test to the more frequent case.
				     ; There is shared code for doing the comparison, entered at different places
				     ; for strict and non-strict.
				     ; That code ends with a jump to something it pops.  For conditional branch
				     ; that jump leads to a conditional jump instruction. For Bool$$ it leads
				     ; back to BoolBack.
 14AE   1   65: 8A 1C		     Bool$$:mov bl,gs:[CursorSi]
 14B1   1   80 FB 71		      cmp bl,$pSeq
 14B4  3,1  73 1B		      jae BoolSC
				     ; Stride is eight in the table we will eventually use. Stride of $pXXX is two.
 14B6   2   C1 E3 02		      shl bx,2
 14B9   1   53			      push bx
 14BA   3   E8 FEE0		      call SetFlags
 14BD				     BoolBack:; Hardware flags reflect the relation.
 14BD   1+  8D 74 FF		      lea CursorSi,(-1)[CursorSi]; Non-existent target word was loaded.
 14C0   1   5B			      pop bx
 14C1   1+  8D 9F FF61 R	      lea bx,(Boolery-4*$pEq)[bx]
 14C5				     SetV:UpCare
 14C5   1+  8D 7D 08		  1   lea StackDi,$StrideV[StackDi]
 14C8   1   66| 89 2B		      mov V.ExpAnd,ebp
 14CB   2   66| 89 6B 04	      mov V.Mantissa,ebp
 14CF   5p  FF E3		      jmp bx

 14D1   1   80 FB 7D		     BoolSC:cmp bl,$pCeq
 14D4  3,1  73 0C		     jae BoolC
 14D6   1   80 C3 F4		      add bl,($pEq-$pSeq)
 14D9   2   C1 E3 02		      shl bx,2
 14DC   1   53			      push bx
 14DD   1   68 14BD R		      push BoolBack
 14E0   3   EB BA		      jmp StrictFlags

 14E2				     BoolC:
 14E2   1   80 C3 E8		      add bl,($pEq-$pCeq)
 14E5   2   C1 E3 02		      shl bx,2
 14E8   1   53			      push bx
 14E9   1   68 14BD R		      push BoolBack
 14EC   3   E9 FF22		      jmp StringCompare
 14EF				     _Eq$$:
 14EF				      _Ne$$:
 14EF				      _Lt$$:
 14EF				      _Le$$:
 14EF				      _Ge$$:
 14EF				      _Gt$$:
				     ; Convert particular operator to place in Rejumps.
 14EF   2   C1 E3 02		      shl bx,2
 14F2   1   81 C3 FD94 R	      add bx,Rejumps-(4*_Eq)
 14F6   1   53			      push bx
 14F7   3   E8 FEA3		      call SetFlags; Hardware flags reflect the relation.
				     ; That code assumed two-byte jump argument so step back a byte.
 14FA   4p  9C			     Relatives:pushf
 14FB   1   4E			     dec CursorSi
				     z ah
 14FC   1   B4 00		  1         mov ah,0
 14FE   1   48			     dec ax
 14FF  3,1  78 04		     js @F
 1501   1   03 C6		     add ax,CursorSi
 1503   9p  9D			     popf
 1504   5   C3			      ret; To Rejumps.
 1505				     @@:; We use zero relative jump to mean Boolery.
 1505   9p  9D			      popf
 1506   1   5B			      pop bx
 1507   1+  8D 5F 2D		      lea bx,(BooleryRejumps)[bx]
 150A   3   EB B9		      jmp SetV

 150C				     _Seq$$:
 150C				     _Sne$$:
 150C				     _Slt$$:
 150C				     _Sle$$:
 150C				     _Sge$$:
 150C				     _Sgt$$:
				     ; Convert particular operator to place in Rejumps.
 150C   2   C1 E3 02		      shl bx,2
 150F   1   81 C3 FD64 R	      add bx,Rejumps-(4*_Seq)
 1513   1   53			      push bx
 1514   3   E8 FF85		      call StrictFlags
 1517   3   EB E1		      jmp Relatives

				     ;------------------------------------------------------------------------------
				     ;
				     ;------------------------------------------------------------------------------
 1519				     Multiply$$:Down
 1519   1   83 EF 08		  1   sub StackDi,$StrideV
 151C   3   E8 095D		     call NumDxBx
 151F  3,1  0F 85 FB67		     jnz ArithLeft
 1523   1   66| 8B CA		     mov ecx,edx
 1526   1   66| 8B C3		     mov eax,ebx
				      Up
 1529   1   83 C7 08		  1   add StackDi,$StrideV
 152C   3   E8 094D		      call NumDxBx
 152F  3,1  0F 85 FB44		      jnz ArithRight
				      Down
 1533   1   83 EF 08		  1   sub StackDi,$StrideV
				     ; StackDi is at the LHS & Result. LHS in eax:ecx RHS in ebx:edx
				     ; Signs & Exponents by add of (Exponent*2 + Sign) unless both negative.
				     ; Both negative made into both positive.
 1536   1   F6 C1 01		      test cl,1
 1539  3,1  74 07		      jz @F
 153B   1   F6 C2 01		      test dl,1
 153E  3,1  74 02		      jz @F
 1540   1   49			      dec cx
 1541   1   4A			      dec dx
 1542   1   66| 03 CA		      @@:add ecx,edx; Exponent result.
 1545  13+  66| F7 E3		      mul ebx
 1548  3,1  0F 82 FCC3		      jc Acc64
 154C				     MagTest:
 154C   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 1550  3,1  0F 83 FCBB		      jae Acc64
 1554   2   66| 2E: 3B 4E 30	      cmp ecx,Y.ExponHi
 1559  3,1  0F 8F FCF5		      jg TestExpon
 155D   2   66| 2E: 3B 4E 34	      cmp ecx,Y.ExponLo
 1562  3,1  0F 8C FCEC		      jl TestExpon
				      Move V
 1566   1   66| 89 0B		  1     mov V.OverExpo,ecx
 1569   2   66| 89 43 04	  1     mov V.OverMant,eax
				      BackRet
 156D   5   C3			  1  ret

 156E				     Check34:; Leaves V. with rhs, bx as rhs.
				      Down
 156E   1   83 EF 08		  1   sub StackDi,$StrideV
 1571   3   E8 0A81		      call ToWholeEbx
 1574  3,1  0F 82 02E9		      jc Raise34p5
 1578   1   66| 4B		      dec ebx
 157A  3,1  74 06		      jz @F
 157C   1   66| 43		      inc ebx
 157E  3,1  0F 85 02DF		      jnz Raise34p5
 1582				     @@:Up
 1582   1   83 C7 08		  1   add StackDi,$StrideV
 1585				     Check34A:
 1585   3   E8 0A6D		      call ToWholeEbx
 1588  3,1  0F 82 02D4		      jc Raise34p6
 158C   1   8B C3		      mov ax,bx
 158E   1   66| 4B		      dec ebx
 1590  3,1  74 06		      jz @F
 1592   1   66| 43		      inc ebx
 1594  3,1  0F 85 02C8		      jnz Raise34p6
 1598				     @@:Down
 1598   1   83 EF 08		  1   sub StackDi,$StrideV
 159B   1   8B D8		      mov bx,ax
 159D   5   C3			      ret

 159E   3   E8 FFCD		     Xor$$:call Check34
 15A1   4   30 5B 04		     Xorx:xor Bptr(V.MantLow),bl
				     BackRet
 15A4   5   C3			  1  ret

 15A5   3   E8 FFC6		     Or$$:call Check34
 15A8   4   08 5B 04		     or Bptr(V.MantLow),bl
				     BackRet
 15AB   5   C3			  1  ret

 15AC   3   E8 FFBF		     And$$:call Check34
 15AF   4   20 5B 04		     and Bptr(V.MantLow),bl
				     BackRet
 15B2   5   C3			  1  ret

 15B3   3   E8 FFCF		     Not$$:call Check34A
				     Up
 15B6   1   83 C7 08		  1   add StackDi,$StrideV
 15B9   1   B3 01		     mov bl,1
 15BB   3   EB E4		     jmp Xorx

				     ; NUMERIC settings. When the settings change, all the constants have to be
				     ; scanned to be sure that only those convertable both ways are held as binary.
				     ; Also if Digits<>9 or Fuzz<>0 we need to use different operators.

 15BD   1   56			     Form$:push CursorSi; Parameter is the VALUE.
				     ; Test first character of the parameter.
 15BE   3   E8 0000 E		      call UpperFirstAh
 15C1   1   80 FC 45		      cmp ah,'E'
 15C4  3,1  74 07		      je NewForm
 15C6   1   80 FC 53		      cmp ah,'S'
 15C9  3,1  0F 85 028C		      jne Raise33p3
 15CD   3   E8 0C88		     NewForm:call HeritageDi
 15D0   2   88 63 90		      mov L.Form,ah
 15D3   3   E8 008A		     FormRet:call ZoneNumerics
 15D6   1   5F			     FormRetx:pop StackDi
				      Down
 15D7   1   83 EF 08		  1   sub StackDi,$StrideV
 15DA   1   5E			      pop CursorSi
				      BackRet
 15DB   5   C3			  1  ret

				     ; Routine sets carry if value not whole >= zero.
 15DC   3   E8 0A16		     ToWholeEbxGE:call ToWholeEbx
 15DF  3,1  72 06		     jc @F
 15E1   2   F6 03 01		     test V.Sign,1
 15E4  3,1  74 01		     jz @F
 15E6   2   F9			     stc
 15E7   5   C3			     @@:ret

				     ; Set up for <value> inserts that is actually value of Digits().
 15E8   3   93			     DigInsertz:xchg ax,bx
				     ; AX for second <value> of msg.
 15E9   2   89 43 04		     DigInsertx:mov V.MantLow,ax
 15EC   1   89 9E 0089		     mov Z.Insert.Digits,bx
 15F0   3   E9 0268		     jmp Raise33p1

 15F3   1   65: 8A 1C		     Numeric$$:mov bl,Bptr gs:[CursorSi]
 15F6   1   46			     inc CursorSi
 15F7   5p  2E: FF A7 15FC R	     jmp Numeric$[bx]

				     if Solid
 15FC				     Numeric$:
 15FC  1602 R			      dw Digits$
 15FE  16C0 R			      dw Fuzz$
 1600  15BD R			      dw Form$
				     endif

 1602   1   56			     Digits$:push CursorSi;Defaulted parameter was added in making Pcode.
 1603   3   E8 FFD6		      call ToWholeEbxGE
 1606  3,1  0F 82 023B		      jc Raise26p5
				     ; New Digits, test range.
 160A   1   66| 81 FB 0000270F	      cmp ebx,$Limit_Digits
 1611  3,1  0F 87 0245		      ja Raise33p2
 1615   1   8B 46 61		      mov ax,Z.Fuzz
 1618   1   3B D8		      cmp bx,ax
 161A  3,1  76 CD		      jbe DigInsertx
 161C   3   E8 0C39		      call HeritageDi
 161F   2   89 5B 8C		      mov L.Digits,bx
				     ; If Digits() changed we need to keep the Zone up-to-date, etc.
 1622   3   E8 0002		      call DigitsChange
 1625   3   EB AF		      jmp FormRetx

 1627				     DigitsChange:;Also used at Return$$
 1627   1   57			     push di
				     ; Z.Digits is what we have been running at.
				     ; The Level has been set to desired Digits.
 1628   1   8B 7E 52		      mov LevelDi,Z.Level
 162B   2   8B 5B 8C		      mov bx,L.Digits
 162E   1   8B 56 5F		      mov dx,Z.Digits
 1631   1   3B DA		      cmp bx,dx
 1633  3,1  74 06		      je DigitsSame
				      On L.Access,DigitsSet
 1635   3   80 0B 40		  1          or  Bptr(L.Access), low ??0021
 1638   3   E8 0025		      call ZoneNumerics
 163B   1   5F			     DigitsSame:pop di
 163C   5   C3			      ret

				     ; Values in a level block which are normally inherited are not inherited when
				     ; this is an external call.
 163D   1   8B 7E 52		     SetInherit:mov LevelDi,Z.Level
				      Assert (Lshape.Inherit-Lshape.Digits) mod 4 eq 0
 1640   1   B9 0012		      mov cx,(Lshape.Inherit-Lshape.Digits)/4
				      mv es,ss
 1643   3   16			  1   push ss
 1644   3p  07			  1   pop es
 1645   1   57			      push LevelDi
 1646   2+  8D 7B 8C		      lea di,L.Digits
				      z eax
 1649   1   66| 8B C5		  1             mov eax,ebp
 164C   5n  F3/ 66| AB		      rep stosd
 164F   1   5F			      pop LevelDi
 1650   2   C6 43 99 4E		      mov L.TraceLetter,'N'
 1654   2   C7 43 8C 0009	      mov L.Digits,9
 1659   2   C6 43 90 53		      mov L.Form,'S'
				      On L.Access,InheritDone
 165D   3   80 0B 80		  1          or  Bptr(L.Access), low ??0022

 1660				     ZoneNumerics:; The Zone is kept showing current settings.(Speeds up arithmetic.)
				     ; Source of settings is the current Level.
 1660   1   66| 51		      push ecx
 1662   1   66| 50		      push eax
 1664   2   66| 8B 4B 8C	      mov ecx,L.DigitsFuzz
 1668   1   66| 89 4E 5F	      mov Z.DigitsFuzz,ecx
 166C   3   66| 0F B7 C9	      movzx ecx,cx
 1670   1   66| 03 C9		      add ecx,ecx
 1673   1   66| 89 4E 6B	      mov Z.TwiceDigits,ecx
				      z Z.UseGeneral
 1677   1   89 6E 6F		  1           mov Z.UseGeneral,bp
				      Off Z.Program,NotS9
 167A   3   80 66 03 FE		  1          and Bptr(Z.Program+1), high not ??0023
 167E   1   83 F9 12		      cmp cx,18
 1681  3,1  76 03		      jna @F
 1683   1   B9 0012		      mov cx,18
 1686				      @@:
 1686  3,1  74 07		      je @F
				      On Z.Program,NotS9
 1688   3   80 4E 03 01		  1          or  Bptr(Z.Program+1), high ??0024
 168C   3   FF 46 6F		      inc Z.UseGeneral
 168F				      @@:
				     ; FUZZ<>0 is rarely used. It won't hurt to generalize all operations then,
				     ; even though only compares are affected.
 168F   2   39 6E 61		      cmp Z.Fuzz,ZeroBp
 1692  3,1  75 06		      jne Fuzzy
 1694   3   80 7B 90 53		      cmp L.Form,'S'
 1698  3,1  74 07		      je @F
 169A				     Fuzzy:On Z.Program,NotS9
 169A   3   80 4E 03 01		  1          or  Bptr(Z.Program+1), high ??0025
 169E   3   FF 46 6F		      inc Z.UseGeneral
 16A1				      @@:
 16A1   3   66| 0F B7 C9	      movzx ecx,cx
 16A5   2   67& 66| 2E: 8B 44 4D      mov eax,Ycx2.N1
	      04 3A
 16AC   1   66| 89 46 63	      mov Z.Ceiling,eax
 16B0   1   67& 66| 2E: 8B 44 4D      mov eax,Ycx2.N1-4
	      00 3A
 16B7   1   66| 89 46 67	      mov Z.DivBreak,eax
 16BB   1   66| 58		      pop eax
 16BD   1   66| 59		      pop ecx
 16BF   5   C3			      ret

 16C0   1   56			     Fuzz$:push CursorSi;Defaulted parameter was added in making Pcode.
 16C1   3   E8 FF18		      call ToWholeEbxGE
 16C4  3,1  0F 82 017C		      jc Raise26p6
				     ; New Fuzz, test bound.
 16C8   3   66| 0F B7 46 5F	      movzx eax,Z.Digits
 16CD   1   66| 3B D8		      cmp ebx,eax
 16D0  3,1  0F 83 FF14		      jae DigInsertz
				     ; Keep the Zone up-to-date
 16D4   3   E8 0B81		      call HeritageDi
 16D7   2   89 5B 8E		      mov L.Fuzz,bx
 16DA   3   E9 FEF6		      jmp FormRet

 16DD				     IntDivide$$:
 16DD				     Remainder$$:
 16DD   1   88 9E 00B2		     Divide$$:mov Z.OpIs,bl
				      Down
 16E1   1   83 EF 08		  1   sub StackDi,$StrideV
 16E4   3   E8 0795		      call NumDxBx
 16E7  3,1  0F 85 F99F		      jnz ArithLeft
 16EB   1   66| 8B CA		      mov ecx,edx
 16EE   1   66| 8B C3		      mov eax,ebx
				      Up
 16F1   1   83 C7 08		  1   add StackDi,$StrideV
 16F4   3   E8 0785		      call NumDxBx
 16F7  3,1  0F 85 F97C		      jnz ArithRight
				      Down
 16FB   1   83 EF 08		  1   sub StackDi,$StrideV
 16FE   1   56			      push CursorSi
				     ; About to divide ecx:eax by edx:ebx, result to V.
 16FF   1   66| 3B C5		      cmp eax,ebp
 1702  3,1  0F 84 00EB		      je DivideNull
 1706   1   66| 3B DD		      cmp ebx,ebp
 1709  3,1  0F 84 0087		      je ZeroDivide
				     ; Sign of answer to Z.SignM
 170D   1   88 8E 00A4		      mov Z.SignM,cl
 1711   2   80 BE 00B2 49	      cmp Z.OpIs,$pRemainder
 1716  3,1  74 04		      je @F
 1718   3   30 96 00A4		      xor Z.SignM,dl
 171C				      @@:
 171C   3   66| D1 F9		      sar ecx,1
 171F   3   66| D1 FA		      sar edx,1
 1722   1   66| 2B CA		      sub ecx,edx; ecx now result exponent undoubled. edx freed.
 1725   1   66| 8B F5		      mov esi,ebp
 1728   1   66| 8B D5		      mov edx,ebp
				     ; esi**ecx now with partial result (0 to begin). eax:edx now 64 bit dividend.
 172B   2   80 BE 00B2 45	      cmp Z.OpIs,$pDivide
 1730  3,1  75 68		      jne RemIntDiv
 1732   1   66| 3B C3		     @@:cmp eax,ebx
 1735  3,1  73 09		      jae @F
				     ; Multiply achieves shift of one decimal place, 64 bit answer in edx:eax.
				     ; Shift will be compensated by exponent adjustment.
 1737   1   66| 49		      dec ecx
 1739  13+  66| 2E: F7 66 08	      mul Y.N10
 173E  3,1  73 F2		      jnc @B
 1740				     @@:; Now Dividend at least size of divisor.
				     ; That was just a speedup to avoid producing initial zeros from the loop.
 1740  40   66| F7 F3		     DivLoop:div ebx; Divide into edx:eax with result to eax and remainder in edx.
				     ; ((esi+eax)*ebx+edx)*10**ecx is result of original divide
 1743   1   66| 03 C6		      add eax,esi; From an earlier cycle.
 1746   1   66| 3B D5		      cmp edx,ebp
 1749  3,1  74 23		      je DivExact; Done if remainder zero.
 174B   2   66| 3B 46 67	      cmp eax,Z.DivBreak
 174F  3,1  73 13		      jae @F; Done if enough digits known.
				     ; Treat as (10*(latest eax)*ebx+10*edx)*10**(ecx-1) to get more digits.
				     ; The 2-operand imul alters just its first operand (and flags).
 1751   1   66| 49		      dec ecx
 1753  13+  66| 6B C0 0A	      imul eax,10
 1757   1   66| 8B F0		      mov esi,eax
 175A   1   66| 8B C2		      mov eax,edx
 175D  13+  66| 2E: F7 66 08	      mul Y.N10
 1762   3   EB DC		      jmp DivLoop
 1764				     @@:; When needed number of digits, round based on remainder.
 1764   1   66| 03 D2		      add edx,edx
 1767   1   66| 3B D3		      cmp edx,ebx
 176A  3,1  72 02		      jb @F
 176C   1   66| 40		      inc eax
 176E				      @@:
 176E				     DivExact:
				     ; An insignificant trailing zero is one that would come after the decimal point.
 176E   1   66| 8B F0		     @@:mov esi,eax
				     TestReg ecx
 1771   1   66| 85 C9		  1         test ecx,ecx
 1774  3,1  79 10		     jns @F
 1776   1   66| 8B D5		      mov edx,ebp
 1779  40   66| 2E: F7 76 08	      div Y.N10
 177E   1   85 D2		      test dx,dx
 1780  3,1  75 04		      jnz @F
 1782   1   66| 41		      inc ecx
 1784   3   EB E8		      jmp @B
				     ; Put sign of result in.
 1786   4   D0 AE 00A4		     @@:shr Z.SignM,1
 178A   1   66| 13 C9		     adc ecx,ecx
 178D   1   66| 8B C6		      mov eax,esi
 1790   1   5E			      pop CursorSi
 1791   3   E9 FDB8		      jmp MagTest

 1794   1   B8 2A03		     ZeroDivide:mov ax,MkMajMin(42,3)
 1797   3   E9 0115		     jmp Raise

 179A				     RemIntDiv:
				     ; For % and // it is the integer part of the dividend that gets divided into.
				     ; We have already set up so that divisor is integer.
				     ; % and // must not make negative exponent.
				     ; This case not speeded up for leading zeros.

				     if 0
				     endif
				     ; We could divide by power of ten so that ecx became zero. Then put the residue
				     ; aside to go with the final remainder. Do the divide into integer part.
				     ; Or just bail out to ArithOp.   NYI
 179A				     MayFloat:; For now
 179A   1   5E			      pop CursorSi
				      Up
 179B   1   83 C7 08		  1   add StackDi,$StrideV
 179E   3   E9 F8D8		      jmp ArithGeneral
				     if 0
				     endif

				     ; Here with non-$pDivide, non-neg exponent of dividend (ecx), integer divisor.
 17A1  40   66| F7 F3		     IntDivLoop:div ebx
 17A4   1   66| 03 C6		      add eax,esi; From an earlier cycle.
 17A7  3,1  72 F1		      jc MayFloat
 17A9   2   66| 3B 46 63	      cmp eax,Z.Ceiling
 17AD  3,1  73 EB		      jae MayFloat
 17AF   1   66| 3B CD		      cmp ecx,ebp
 17B2  3,1  74 13		      je IntDiv; Done if last divide was of integer.
 17B4   1   66| 49		      dec ecx
 17B6  13+  66| 6B C0 0A	      imul eax,10
 17BA   1   66| 8B F0		      mov esi,eax
 17BD   1   66| 8B C2		      mov eax,edx
 17C0  13+  66| 2E: F7 66 08	      mul Y.N10
 17C5   3   EB DA		      jmp IntDivLoop
				     ; eax is the // result. edx is remainder.
 17C7   2   80 BE 00B2 49	     IntDiv:cmp Z.OpIs,$pRemainder
 17CC  3,1  74 10		     je IntRem
				     ; Put sign of result in.
 17CE   4   D0 AE 00A4		     @@:shr Z.SignM,1
 17D2   1   66| 13 C9		     adc ecx,ecx
				      Move V
 17D5   1   66| 89 0B		  1     mov V.OverExpo,ecx
 17D8   2   66| 89 43 04	  1     mov V.OverMant,eax
 17DC   1   5E			      pop CursorSi
				      BackRet
 17DD   5   C3			  1  ret

 17DE   1   66| 8B C2		     IntRem:mov eax,edx
 17E1   3   EB EB		     jmp @B

 17E3   2   80 BE 00B2 49	     ZeroInt:cmp Z.OpIs,$pRemainder
 17E8  3,1  74 07		     je DivideNull
 17EA   2   66| 89 6B 04	     ArithZero:mov V.Mantissa,ebp
 17EE   1   66| 89 2B		     mov V.ExpAnd,ebp
 17F1   1   5E			     DivideNull:pop CursorSi
				     BackRet
 17F2   5   C3			  1  ret

 17F3   3   E8 07FF		     Power$$:call ToWholeEbx
 17F6  3,1  0F 83 F87F		     jnc ArithGeneral
 17FA   3   EB 46		      jmp Raise26p8

				     ; Unary operators.
 17FC				     Negate$$:;  "-0" is not allowed to occur.
 17FC   3   E8 067D		      call NumDxBx
 17FF  3,1  72 51		      jc Raise41p3
 1801  3,1  75 09		      jnz NegGen
 1803   1   66| 3B DD		      cmp ebx,ebp
 1806  3,1  74 03		      je @F
 1808   3   80 33 01		      xor V.Sign,1
 180B				      @@:BackRet
 180B   5   C3			  1  ret
				     ; Use ArithGeneral of 0 - Subject
 180C				     NegGen:Up
 180C   1   83 C7 08		  1   add StackDi,$StrideV
				     Move V,V0
 180F   2   66| 8B 4B F8	  1     mov ecx,V0.OverExpo
 1813   1   66| 89 0B		  1     mov V.OverExpo,ecx
 1816   2   66| 8B 43 FC	  1     mov eax,V0.OverMant
 181A   2   66| 89 43 04	  1     mov V.OverMant,eax
 181E   2   66| 89 6B FC	     mov V0.Mantissa,ebp
 1822   2   66| 89 6B F8	     mov V0.ExpAnd,ebp
 1826   3   E9 F850		     jmp ArithGeneral

 1829				     Positive$$:
 1829   3   E8 0650		      call NumDxBx
 182C  3,1  72 24		      jc Raise41p3
 182E  3,1  75 01		      jnz @F
				      BackRet
 1830   5   C3			  1  ret
				     ; Use ArithGeneral of Subject + 0
 1831				     @@:Up
 1831   1   83 C7 08		  1   add StackDi,$StrideV
 1834   2   66| 89 6B 04	     mov V.Mantissa,ebp
 1838   1   66| 89 2B		     mov V.ExpAnd,ebp
 183B   3   E9 F83B		     jmp ArithGeneral

 183E   1   45			     Raise26p12:inc bp
 183F   1   45			     Raise26p11:inc bp
 1840   1   45			     inc bp
 1841   1   45			     inc bp
 1842   1   45			     Raise26p8:inc bp
 1843   1   45			     Raise26p7:inc bp
 1844   1   45			     Raise26p6:inc bp
 1845   1   45			     Raise26p5:inc bp
 1846   1   45			     Raise26p4:inc bp
 1847   1   45			     Raise26p3:inc bp
 1848   1   45			     Raise26p2:inc bp
 1849   1   45			     Raise26p1:inc bp
 184A   1   B2 1A		      mov dl,26
 184C   3   EB 61		      jmp Raise

 184E   1   45			     Raise41p7:inc bp
 184F   1   45			     Raise41p6:inc bp
 1850   1   45			     Raise41p5:inc bp
 1851   1   45			     Raise41p4:inc bp
 1852   1   45			     Raise41p3:inc bp
 1853   1   45			     Raise41p2:inc bp
 1854   1   45			     Raise41p1:inc bp
 1855   1   B2 29		      mov dl,41
 1857   3   EB 56		      jmp Raise

 1859   1   45			     Raise33p3:inc bp
 185A   1   45			     Raise33p2:inc bp
 185B   1   45			     Raise33p1:inc bp
 185C   1   B2 21		      mov dl,33
 185E   3   EB 4F		      jmp Raise

 1860   1   45			     Raise34p6:inc bp
 1861   1   45			     Raise34p5:inc bp
				     ; The two above were checked in a subroutine before saving CursorSi.
				      PopJunk cx; Makes Raise push CursorSi in required place.
 1862   1   59			  1    pop cx
 1863   1   45			     Raise34p4:inc bp
 1864   1   45			     Raise34p3:inc bp
 1865   1   45			     Raise34p2:inc bp
 1866   1   45			     Raise34p1:inc bp
 1867   1   B2 22		       mov dl,34
 1869   3   EB 44		       jmp Raise

 186B   1   B0 0B		     Raise40p11:mov al,11
 186D   3   EB 3E		     jmp Raise40
 186F   1   B0 20		     Raise40p32:mov al,32
 1871   3   EB 3A		     jmp Raise40
 1873   1   B0 21		     Raise40p33:mov al,33
 1875   3   EB 36		     jmp Raise40
				     ;------------------------------------------------------------------------------
				     ; This the significant recovery point.
				     ;------------------------------------------------------------------------------
				     ;------------------------------------------------------------------------------
				     ; Raise stage 1, collect the message number and some insert info.
				     ; It is assumed that we cannot be in the middle of synchronizing because if
				     ; the source parsed OK originally it will do for Synch.
				     ; Similarly we are not in a clause-by-clause compilation.
				     ; We can be in the original compilation, INTERPRET compilation, or the
				     ; execution of original, INTERPRET, clause-by-clause Pcode.
				     ;------------------------------------------------------------------------------
 1877				     Raise49:
				     if Debug
 1877  26   CC			      int 3
 1878   1   58			      pop ax; Caller.
				     endif
 1879   1   B8 3100		      mov ax,MkMajMin(49,0)
 187C   3   EB 31		      jmp Raise


 187E				     CONFIG_RAISE40$$:
 187E   1   8B 76 2E		      mov si,Z.XCycleResetSp
				      move Wptr[si+bp-4],Z.ResumeP
 1881   1   8B 46 58		  1      mov ax,Z.ResumeP
 1884   2   89 42 FC		  1      mov Wptr[si+bp-4],ax
 1887   3   E8 0000 E		      call ResumeP$
 188A   2   8A 43 04		      mov al,Bptr V.Mantissa; The minor code.
				      Down
 188D   1   83 EF 08		  1   sub StackDi,$StrideV
 1890   1   3C 04		      cmp al,4
 1892  3,1  74 08		      je @F
 1894   1   3C 26		      cmp al,38
 1896  3,1  74 04		      je @F
 1898   1   3C 29		      cmp al,41
 189A  3,1  75 0A		      jne NoArgNum
 189C   2   8A 53 04		     @@:mov dl,Bptr V.Mantissa
 189F   1   88 96 0082		      mov Z.Insert.ArgNum,dl
				      Down
 18A3   1   83 EF 08		  1   sub StackDi,$StrideV
 18A6   1   3C 13		     NoArgNum:cmp al,19
 18A8  3,1  75 03		      jne @F
				      Down
 18AA   1   83 EF 08		  1   sub StackDi,$StrideV
 18AD				      @@:
				     ; 40.18 won't care about inserts.

 18AD   1   B4 28		     Raise40:mov ah,40
 18AF				     Raise:
				     ; Non-zero bp is just a space-saving trick for passing value for al.
				     ; (Requires dl for ah also.)
				      TestReg bp
 18AF   1   85 ED		  1         test bp,bp
 18B1  3,1  74 05		      jz @F
				      xax bp
 18B3   3   95			  1     xchg ax,bp
 18B4   1   33 ED		      xor bp,bp
 18B6   1   8A E2		      mov ah,dl
 18B8				      @@:
				     ; Some registers will be relevant only for certain messages. Store anyway.
 18B8   1   88 96 0083		      mov Z.Insert.Desc,dl
 18BC   1   89 7E 7C		      mov Z.Insert.Value,StackDi
 18BF   1   56			      push CursorSi; Only relevant to retrieve it if operator did not push it before.
 18C0   1   56			      push CursorSi
				     if 0
				     endif
				     ; All the 41.xx have to become 41.7 if exponent range is the reason.
 18C1   1   80 FC 29		      cmp ah,41
 18C4  3,1  75 08		      jne Not41
				      Qry Z.Cancel,ExpRange
 18C6   2   F6 46 05 02		  1          test Bptr(Z.Cancel+1), high ??0026
 18CA  3,1  74 02		      jz @F
 18CC   1   B0 07		      mov al,7
 18CE				      @@:
				     ; The message number is now in AX
 18CE				     Not41:z Z.Cancel; Cancel any flags that might be pending.
 18CE   1   89 6E 04		  1           mov Z.Cancel,bp

				     ; The <linenumber> insert takes its value from Z.InsLine.
				     ; A parser state has a field, ClauseWas, to hold relevant previous line
				     ; numbers. Because we came here on a jump, sp will address the current state.
				     ; The case of major code 14, (incomplete DO...) the number in the pre-message
				     ; has to change. Set si for source of number, di where to put it.
 18D1   1   8B F4		      mov ParseSi,sp
 18D3   1   BF 0008		      mov di,Zshape.ClauseLine
 18D6   1   80 FC 0E		      cmp ah,14
 18D9  3,1  75 05		      jne @F
 18DB   1   BF 0071		      mov di,Zshape.InsLine
 18DE   3   EB 09		      jmp Is14
 18E0				      @@:
				     ; The case of major code 7, the relevant SELECT has to be found on the stack.
 18E0   1   80 FC 07		      cmp ah,7
 18E3  3,1  75 0C		      jne Not7
 18E5   1   3C 01		      cmp al,1
 18E7  3,1  74 03		      je @F
 18E9   1   83 C6 10		     Is14:add ParseSi,$StrideS
 18EC				     @@:move Wptr[di+bp],S.ClauseWas,dx
 18EC   2   8B 52 04		  1    mov dx,S.ClauseWas
 18EF   1   89 13		  1    mov Wptr[di+bp],dx
 18F1   1   89 46 7A		     Not7:mov Z.Insert.MajMin,ax

				     ;------------------------------------------------------------------------------
				     ; Raise stage 2, note where the SYNTAX error occurred, and position the source
				     ; to match if necessary.
				     ;------------------------------------------------------------------------------
				     ; There can be message before we really get started. eg couldn't find source
				     ; of the very first file.
 18F4   2   39 6E 4A		      cmp Z.Code,ZeroBp
 18F7  3,1  74 6B		      je InSynch
				     ; If we have never started executing this source file, the line number etc will
				     ; be current.  SYNTAX trapping cannot have been turned on in this file.
 18F9   2   65: 39 6E 0A	      cmp Hg.Original,ZeroBp
 18FD  3,1  74 65		      je InSynch
				     ; There has been some execution of this file, so can find the execution point
				     ; relevant to the Raise.  Also there is a place for .MN
				     ; Could not store .MN if Z.ProgScope not yet made.
				     ; Put ax into .MN, still in Major+Minor format. (May not get used.)
 18FF   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 1902   1   26: C6 46 23 44	      mov Ve.Dtype[$?MN],$MsgNum
 1907   1   26: 89 46 20	      mov Ve.MantLow[$?MN],ax
				     ; At this point we are in execution, although could be parsing part of
				     ; INTERPRET. So we will have called Operator and the Raise is from some
				     ; operation.
				     ; Mar 2000 method of recover CursorSi is to ensure it was first thing saved
				     ; by execution of the operation.
				     ; Link to the operator follows reset place, want below that.
 190B   1   8B 76 2E		      mov si,Z.XCycleResetSp
 190E   2   8B 72 FC		      mov CursorSi,Wptr[si+bp-4]
				     ; At this point CursorSi is correct, either for a message or as SIGL.
 1911   1   89 B6 010D		      mov Z.Synch,CursorSi;
				     ; NYI - loop protection for msg 5 or 49.
				     ; It may be that SYNTAX is being trapped and the message will never be shown
				     ; but we make it anyway for CONDITION('D')
				     ; If error was detected while compiling, the info for inserts will be available.
				     ; So in the compile-of-INTERPRET-subject case we could record that before
				     ; doing the synch required to get the line number of the INTERPRET clause.
				     ; However, in the not-compiling case we have to synch on both the source file
				     ; and the subject so might as well always do that.
				     ;
				     ; This re-compilation up to the Z.Synch point is very similar to the
				     ; original compilation.
				     ; The Synch won't necessarily happen with all the Zone fields the same as now.
				     ; We copy some that might get harmed, don't copy ones Synch is to set.
				     ; ?? InsBlock mechanism over-engineered?
				     ; Execution messages don't use <token> so TokPos is in the copied block to
				     ; retain it for the INTERPRET case.
 1915   1   BE 007A		      mov si,Zshape.Insert
 1918   1   BF 008F		      mov di,Zshape.Inserts
 191B   3   E8 0072		      call CopyInsert
 191E   3   83 46 06 10		      add Z.Stack,2*$StrideV; Protect what may be needed for Z.Insert.Value.
 1922   1   C7 46 36 0010	      mov Z.Cursor,$StrideH
				      z Z.Scanp
 1927   1   89 AE 00E1		  1           mov Z.Scanp,bp
				     ; LabelsBad tells us whether it was INTERPRET that failed, although this
				     ; Synch is against the original, not the INTERPRET subject.
 192B   8   0F BA 76 02 0D	      btr Z.Program,LabelsBad
 1930  3,1  73 18		      jnc NotINT
				     if Debug
 1932   3p  8E 5E 40		      mov ds,Z.Consts
 1935   1   A1 0004		      mov ax,Hd.Avail
				     endif
 1938   3   E8 0000 E		      call Compiling
				     if Debug
 193B   3   1E			      push ds
 193C   3p  8E 5E 40		      mov ds,Z.Consts
 193F   1   A1 0004		      mov ax,Hd.Avail
 1942   3p  1F			      pop ds
				     endif
				     ; We also have to restore the buffer, in the case where a message from
				     ; INTERPRET uses Insert.TokPos.
 1943   1   B0 03		      mov al,$SerialInterpret
 1945   3   E8 0000 E		      call Serialize
 1948   3   EB 11		      jmp @F
 194A				     NotINT:
				     if Debug
 194A   3p  8E 5E 40		      mov ds,Z.Consts
 194D   1   A1 0004		      mov ax,Hd.Avail
				     endif
 1950   3   E8 0000 E		      call Compiling
				     if Debug
 1953   3   1E			      push ds
 1954   3p  8E 5E 40		      mov ds,Z.Consts
 1957   1   A1 0004		      mov ax,Hd.Avail
 195A   3p  1F			      pop ds
				     endif
 195B   1   BE 008F		     @@:mov si,Zshape.Inserts
 195E   1   BF 007A		     mov di,Zshape.Insert
 1961   3   E8 002C		     call CopyInsert
 1964				     InSynch:
				      z Z.Scanp
 1964   1   89 AE 00E1		  1           mov Z.Scanp,bp
				      Off Z.Program,LabelsBad
 1968   3   80 66 03 DF		  1          and Bptr(Z.Program+1), high not ??0027
				     ;------------------------------------------------------------------------------
				     ; Raise stage 3, convert all the info to a text message.
				     ; Save the message if not now finishing.
				     ;------------------------------------------------------------------------------
				     ; If the condition is handled, we go back to execution as if there had
				     ; been SIGNAL rather than SYNTAX.
				     ;
				     ; Too risky to allow handling in some cases.
 196C   1   8B 46 7A		      mov ax,Z.Insert.MajMin
 196F   1   80 FC 05		      cmp ah,5
 1972  3,1  74 10		      je GetOut
 1974   1   80 FC 31		      cmp ah,49
 1977  3,1  74 0B		      je GetOut
				     ; Assert Syntax is zero position amongst the conditions. Enabling < 8
 1979   3   E8 08DC		      call HeritageDi
 197C   9   0F BA 73 C2 07	      btr L.Condition,Enabling
 1981  3,1  72 19		      jc OnSyntax
 1983   1   5F			      pop di
				     ; Exit with message and traceback.
 1984				     GetOut:
 1984   3   E8 0000 E		      call MakeMsg; Result Z.MsgBegin to Z.MsgSoFar(and di).
 1987   3   E8 0000 E		      call ShowMsg
				     ; TraceBack.        NYI
				     ; Return code is error number. Only room for Major code.
 198A   1   8A 46 7B		      mov al,Z.Insert.Major
 198D   3   E9 F6D3		      jmp Exit

 1990   1   B9 0015		     CopyInsert:mov cx,sizeof InsBlock
 1993   3   06			      push es
				      mv ds,ss
 1994   3   16			  1   push ss
 1995   3p  1F			  1   pop ds
				      mv es,ss
 1996   3   16			  1   push ss
 1997   3p  07			  1   pop es
 1998   7n  F3/ A4		      rep movsb
 199A   3p  07			      pop es
 199B   5   C3			      ret

 199C				     OnSyntax:
				     ;$8.4.1
				      PopJunk ax
 199C   1   58			  1    pop ax
				     ; BX tells where to resume interpretation.
 199D   2   C6 43 D3 80		      mov L.ConditionExtra.Dtype,$NullString
 19A1   2   8B 5B B2		      mov bx,L.TrapName
 19A4   1   B9 01A9		      mov cx,$MaxPreInsert+5*$Limit_Insert
 19A7   3   E8 0000 E		      call AllocateCx_EsAx
 19AA   2   C6 43 CB C0		      mov L.ConditionDescription.Dtype,$AwayString
 19AE   4   8C 43 C6		      mov L.ConditionDescription.Sg,es
 19B1   2   89 43 C4		      mov L.ConditionDescription.Pt,ax
 19B4   2   89 4B C8		      mov L.ConditionDescription.Len,cx
 19B7   1   57			      push LevelDi
 19B8   3   E8 0000 E		      call MakeMsg; Result Z.MsgBegin to Z.MsgSoFar(and di).
 19BB   1   5F			      pop LevelDi
				     ; Move the message to variable allocated earlier.
 19BC   1   8B 8E 0113		      mov cx,Z.MsgSoFar
 19C0   1   8B B6 0111		      mov si,Z.MsgBegin
 19C4   1   2B CE		      sub cx,si
 19C6   2   89 4B C8		      mov L.ConditionDescription.Len,cx
 19C9   7p  C4 7B C4		      les di,L.ConditionDescription.Fr
 19CC   7n  F3/ 36: A4		      rep movsb [di],ss:[si]
 19CF   1   8B B6 010D		      mov CursorSi,Z.Synch
 19D3   3   EB 05		      jmp OnSyntaxX
 19D5				     SignalV$$:
 19D5   5p  FF D5		      Error49Bp

 19D7   1   65: 8B 1C		     Signal$$:mov bx,gs:[CursorSi]
 19DA				     OnSyntaxX:
				      Off Z.Cancel,TokIsValue
 19DA   3   80 66 05 FB		  1          and Bptr(Z.Cancel+1), high not ??0028
 19DE   1   8B 66 2E		      mov sp,Z.XCycleResetSp
				     ; bx is the label sought.
				     ; CursorSi is where the jump was from.
 19E1   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 19E4   1   26: C6 46 43 48	      mov Ve.Dtype[$?SIGL],$Sigl
 19E9   1   26: 89 76 40	      mov Ve.MantLow[$?SIGL],CursorSi
				     ; There are both .SIGL and SIGL.
 19ED   1   64: C6 46 37 48	      mov Vf.Dtype[$?SIGLx],$Sigl
 19F2   1   64: 89 76 34	      mov Vf.MantLow[$?SIGLx],CursorSi
				     ; Lose DOs, INTERPRETs and temps.
 19F6   1   8B 7E 52		      mov LevelDi,Z.Level
 19F9   1   89 7E 06		      mov Z.Stack,StackDi
 19FC   1   89 7E 56		      mov Z.CurrentDO,StackDi
				     ; Test for trace-only or absent label.
 19FF   1   B8 1002		      mov ax,MkMajMin(16,2)
 1A02   2   26: 80 7F 06 00	      cmp Bptr Vbxe.LabelType,0
 1A07  3,1  75 0D		      jne Raise16
 1A09   1   26: 8B 0F		      mov cx,Vbxe.LabelValue
				      JcxzQ @F
 1A0C   1   85 C9		  1    test cx,cx
 1A0E  3,1  74 05		  1    je @F
 1A10   1   8B F1		      mov CursorSi,cx
 1A12   3   E9 0000 E		      jmp StartExecutionY
 1A15				      @@:
				     ; Label never appeared with colon.
 1A15   1   48			      dec ax
 1A16   3p  8E 5E 40		     Raise16: mov ds,Z.Consts
 1A19   1   8B 5F 04		      mov bx,Vbx.Here
 1A1C   1   89 5E 7E		      mov Z.Insert.Named,bx
 1A1F   3   E9 FE8D		      jmp Raise

 1A22   1   B2 90		     CallOn$$:mov dl,mask Instruction + mask Enabling
 1A24   3   EB 02		     jmp @F
 1A26   1   B2 80		     SignalOn$$:mov dl,mask Enabling
 1A28   3   E8 082D		     @@:call HeritageDi
				     ; The condition is in the next byte.
				     ; Syntax,LostDigits,NoValue,NotReady,Error,Failure,Halt
 1A2B   1   65: 8A 1C		      mov bl,Bptr gs:[CursorSi]
 1A2E   1   46			      inc CursorSi
				     ; Target label follows.
 1A2F   5   65: AD		      lodsw gs:[CursorSi]
 1A31   1   03 FB		      add LevelDi,bx
 1A33   4   80 63 C2 6F		      and Bptr(L.Condition),not(mask Enabling+mask Instruction)
 1A37   4   08 53 C2		      or Bptr(L.Condition),dl
 1A3A   1   03 FB		      add LevelDi,bx
 1A3C   2   89 43 B2		      mov L.TrapName,ax
 1A3F   1   5F			      pop StackDi
				      BackRet
 1A40   5   C3			  1  ret

 1A41				     SignalOff$$:
				     ; MASM error ...............................
 1A41   3   65: 0F B6 1C	      movzx bx,Bptr gs:[CursorSi]
 1A45   1   46			      inc CursorSi
 1A46   1   57			      push StackDi
 1A47   1   8B 7E 52		      mov LevelDi,Z.Level
 1A4A   1   03 FB		      add LevelDi,bx
 1A4C   4   80 63 C2 7F		      and Bptr L.Condition,not(mask Enabling)
 1A50   1   5F			      pop StackDi
				      BackRet
 1A51   5   C3			  1  ret

 1A52				     Raise$$:
				     ; The errors from number of args (statically detected) on a bif will be 40.n
				     ; Other under this code is SELECT out of choices. 7.3
				     ; ?? What about line number on that?
				     ; Also PROCEDURE misplaced. 17.1
 1A52   1   65: 8A 1C		      mov bl,Bptr gs:[CursorSi]
 1A55   1   46			      inc CursorSi
 1A56   1   2E: 8B 87 1A5E R	      mov ax,Raise$[bx]
 1A5B   3   E9 FE51		      jmp Raise
				     if Solid
 1A5E				     Raise$:
 1A5E  0703			      dw MkMajMin(7,3)
 1A60  1101			      dw MkMajMin(17,1)
 1A62  2803			      dw MkMajMin(40,3)
 1A64  2804			      dw MkMajMin(40,4)
 1A66  2805			      dw MkMajMin(40,5)
				     endif

 1A68   1   65: 8B 34		     Jump$$:mov CursorSi,Wptr gs:[CursorSi]
				     BackRet
 1A6B   5   C3			  1  ret

 1A6C   2   65: 80 7C FD 5F	     Raise34:cmp Bptr(gs:[CursorSi-3]),$pThen
 1A71  3,1  0F 85 FDF0		     jne Raise34p2
 1A75   3   E9 FDEE		     jmp Raise34p1

 1A78				     When$$:
 1A78   3   E8 057A		     Then$$:call ToWholeEbx
 1A7B  3,1  72 EF		     jc Raise34
 1A7D   5   65: AD		     lodsw gs:[CursorSi]
 1A7F   1   66| 4B		      dec ebx
 1A81  3,1  74 06		      jz @F
 1A83   1   66| 43		      inc ebx
 1A85  3,1  75 E5		      jnz Raise34
 1A87   1   8B F0		      mov CursorSi,ax
 1A89				      @@:Down
 1A89   1   83 EF 08		  1   sub StackDi,$StrideV
				      BackRet
 1A8C   5   C3			  1  ret

 1A8D				     AssignConst$$:; This is assign without going via stack.
				     ; Only 15% faster than Assign$$.  I wonder if the order affects pipelines.
				     ; Might have been alignment affected.
 1A8D   1   65: 8B 1C		      mov bx,gs:[CursorSi]
				      Move ,Vbxe
 1A90   1   66| 26: 8B 0F	  1     mov ecx,Vbxe.OverExpo
 1A94   1   66| 26: 8B 47 04	  1     mov eax,Vbxe.OverMant
				     ; Swop to Assign$$ when target exposed.
 1A99   1   65: 8B 5C 02	      mov bx,gs:[CursorSi+2]
 1A9D   1   83 C6 04		      add CursorSi,4
 1AA0   2   64: 80 7F 07 50	      cmp Vbxf.Dtype,$Exposed
 1AA5  3,1  74 0A		      je @F
				      Move Vbxf
 1AA7   1   66| 64: 89 0F	  1     mov Vbxf.OverExpo,ecx
 1AAB   1   66| 64: 89 47 04	  1     mov Vbxf.OverMant,eax
				      BackRet
 1AB0   5   C3			  1  ret

 1AB1				     @@:Up
 1AB1   1   83 C7 08		  1   add StackDi,$StrideV
				     Move V
 1AB4   1   66| 89 0B		  1     mov V.OverExpo,ecx
 1AB7   2   66| 89 43 04	  1     mov V.OverMant,eax
 1ABB   3   EB 25		     jmp AssignExposed

				     ; Unstore follows Assign if the assigned value is to be reloaded.
 1ABD				     Unstore$$:Up
 1ABD   1   83 C7 08		  1   add StackDi,$StrideV
				     BackRet
 1AC0   5   C3			  1  ret

 1AC1				     Assign$$:; The target will be the only argument.
				     ; ControlVar$$ relies on BX, EAX, ECX at return.
				     ; If the target is changing from uninitialized in this procedure to initialized,
				     ; that has to be recorded so that it can be backed out when the procedure
				     ; returns, making the array of variable names fit for reuse. NYI
 1AC1   1   65: 8B 1C		      mov bx,gs:[CursorSi]
 1AC4   1   83 C6 02		      add CursorSi,2; Add2 is slower.
 1AC7   2   64: 80 7F 07 50	     AsgnToFsBx:cmp Vbxf.Dtype,$Exposed
 1ACC  3,1  74 14		      je AssignExposed
				      Move Vbxf,V
 1ACE   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 1AD1   1   66| 64: 89 0F	  1     mov Vbxf.OverExpo,ecx
 1AD5   2   66| 8B 43 04	  1     mov eax,V.OverMant
 1AD9   1   66| 64: 89 47 04	  1     mov Vbxf.OverMant,eax
				      Down
 1ADE   1   83 EF 08		  1   sub StackDi,$StrideV
 1AE1   5   C3			      ret

 1AE2				     AssignExposed:; A bit slower because of FS temporary shift.
 1AE2   3   E8 0017		      call ExposedFs
 1AE5				     AssignRet:Move Vbxf,V
 1AE5   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 1AE8   1   66| 64: 89 0F	  1     mov Vbxf.OverExpo,ecx
 1AEC   2   66| 8B 43 04	  1     mov eax,V.OverMant
 1AF0   1   66| 64: 89 47 04	  1     mov Vbxf.OverMant,eax
 1AF5   3p  8E 66 46		      mov fs,Z.VarScope
				      Down
 1AF8   1   83 EF 08		  1   sub StackDi,$StrideV
 1AFB   5   C3			      ret

 1AFC				     ExposedFs:; Sets FS to the non-exposed level for variable BX.
				     ; Assert - Dtype is $Exposed in current FS:BX
				     ; When setting something to $Exposed we should not follow the expose chain.
				      Qry Z.Cancel,ForExpose
 1AFC   2   F6 46 05 20		  1          test Bptr(Z.Cancel+1), high ??0029
 1B00  3,1  74 01		      jz @F
 1B02   5   C3			      ret
				     ; Scan for containing procedure.
 1B03   3p  64: 8E 66 0A	     @@:mov fs,Hf.UpPool
 1B07   2   64: 80 7F 07 50	     cmp Vbxf.Dtype,$Exposed
 1B0C  3,1  74 F5		     je @B
 1B0E   5   C3			     ret

 1B0F   1   56			     DropList$$:push CursorSi
				     ; We want to parse the value into symbols but using compiler would
				     ; allow comments etc.
 1B10   3   E8 0566		      call ToDsSiCx
 1B13   1   BB 0000 E		      mov bx,Attributes
				      Up
 1B16   1   83 C7 08		  1   add StackDi,$StrideV
 1B19   3   E8 EA58		      call VasDsSiCx; A copy to alter.
				     ; Skip blanks
 1B1C				     DropLoopX:JcxzQ DropListRet
 1B1C   1   85 C9		  1    test cx,cx
 1B1E  3,1  74 0A		  1    je DropListRet
 1B20   5   AC			     DropLoop:lodsb
				     XlatBDLS
 1B21   4   2E: D7		  1   xlat Bptr cs:[bx]
 1B23   1   A8 C0		  1   test al,0C0h
 1B25  3,1  75 08		     jnz @F
				     LoopQ DropLoop
 1B27   1   49			  1    dec cx
 1B28  3,1  75 F6		  1    jnz DropLoop
 1B2A   1   83 EF 10		     DropListRet:sub StackDi,2*$StrideV
 1B2D   1   5E			     pop CursorSi
				     BackRet
 1B2E   5   C3			  1  ret

				     ; Begin of potential symbol found. Check it is a name.
 1B2F   1   4E			     @@:dec si
 1B30   1   8B D6		     mov dx,si
 1B32   3   E8 0000 E		     call SymbolLook
				     TestReg bx
 1B35   1   85 DB		  1         test bx,bx
 1B37  3,1  75 16		     jnz Raise20p1
 1B39   1   51			      push cx
 1B3A   1   56			      push si
				     ; Set up V to be just the symbol found.
 1B3B   1   89 13		      mov V.Pt,dx
 1B3D   1   2B F2		      sub si,dx
 1B3F   2   89 73 04		      mov V.Len,si
				     ; Drop by interpret.
 1B42   1   BA 0000 E		      mov dx,offset B4DROP
 1B45   3   E8 0000 E		      call LinkBcode
 1B48   1   89 7E 06		      mov Z.Stack,StackDi
 1B4B   1   5E			      pop si
 1B4C   1   59			      pop cx
 1B4D   3   EB CD		      jmp DropLoopX
 1B4F				     Raise20p1:; This msg can happen as runtime or compile time. The insert is
				     ; <token>, which is fine for compile time. For runtime we need a flag to
				     ; treat the insert differently.
 1B4F   3p  8E 66 46		       mov fs,Z.VarScope
 1B52   1   89 7E 06		       mov Z.Stack,StackDi
 1B55   1   5E			       pop CursorSi
				       On Z.Cancel,TokIsValue
 1B56   3   80 4E 05 04		  1          or  Bptr(Z.Cancel+1), high ??002A
 1B5A   1   B8 1401		       mov ax,MkMajMin(20,1)
 1B5D   3   E9 FD4F		       jmp Raise
 1B60   5   65: AD		     Expose$$:lodsw gs:[CursorSi]
				       xax bx
 1B62   3   93			  1     xchg ax,bx
				     ; Tail parts on the stack if compound name.
 1B63   1   8B C7		      mov ax,StackDi
 1B65   2   2B 46 56		      sub ax,Z.CurrentDO
 1B68  3,1  75 06		      jnz @F
 1B6A   1   64: C6 47 07 50	      mov Vbxf.Dtype,$Exposed
				      BackRet
 1B6F   5   C3			  1  ret
 1B70   1   56			     @@:push CursorSi
				      On Z.Cancel,ForExpose
 1B71   3   80 4E 05 20		  1          or  Bptr(Z.Cancel+1), high ??002B
 1B75   1   83 E8 08		      sub ax,$StrideV
 1B78   3   E8 E5A7		      call DotsFsBxDsSi
				      Down
 1B7B   1   83 EF 08		  1   sub StackDi,$StrideV
				      Off Z.Cancel,ForExpose
 1B7E   3   80 66 05 DF		  1          and Bptr(Z.Cancel+1), high not ??002C
 1B82   1   C6 44 07 50		      mov Vsid.Dtype,$Exposed
 1B86   3p  8E 66 46		      mov fs,Z.VarScope
				      z bx
 1B89   1   8B DD		  1           mov bx,bp
 1B8B   1   5E			      pop CursorSi
				      BackRet
 1B8C   5   C3			  1  ret

 1B8D				     ExposeList$$:; EXPOSE (A) first does EXPOSE A.
 1B8D   3   E8 FFD0		      call Expose$$
 1B90   1   56			      push CursorSi
				      TestReg bx
 1B91   1   85 DB		  1         test bx,bx
 1B93  3,1  75 02		      jnz @F
 1B95   5p  FF D5		      Error49Bp
 1B97				      @@:
				      CodeModeR
 1B97   4   2E: FF 36 005B R	  1   push Wptr cs:XCycle
 1B9C   1   2E: C6 06 005B R	  1   mov Bptr cs:XCycle,$ret
	      C3
 1BA2   3   E8 E4CB		      call FetchBx
				      UnCodeMode
 1BA5   6   2E: 8F 06 005B R	  1   pop Wptr cs:XCycle
 1BAA   3   E8 04CC		      call ToDsSiCx
 1BAD   1   BB 0000 E		      mov bx,Attributes
				      Up
 1BB0   1   83 C7 08		  1   add StackDi,$StrideV
 1BB3   3   E8 E9BE		      call VasDsSiCx; A copy to alter.
				     ; Skip blanks
 1BB6				     ExposeLoopX:JcxzQ ExposeListRet
 1BB6   1   85 C9		  1    test cx,cx
 1BB8  3,1  74 0A		  1    je ExposeListRet
 1BBA   5   AC			     ExposeLoop:lodsb
				     XlatBDLS
 1BBB   4   2E: D7		  1   xlat Bptr cs:[bx]
 1BBD   1   A8 C0		  1   test al,0C0h
 1BBF  3,1  75 08		     jnz @F
				     LoopQ ExposeLoop
 1BC1   1   49			  1    dec cx
 1BC2  3,1  75 F6		  1    jnz ExposeLoop
 1BC4   1   83 EF 10		     ExposeListRet:sub StackDi,2*$StrideV
 1BC7   1   5E			     pop CursorSi
				     BackRet
 1BC8   5   C3			  1  ret
				     ; Begin of potential symbol found.
 1BC9   1   4E			     @@:dec si
 1BCA   1   8B D6		     mov dx,si
 1BCC   3   E8 0000 E		     call SymbolLook
				     TestReg bx
 1BCF   1   85 DB		  1         test bx,bx
 1BD1  3,1  0F 85 FF7A		     jnz Raise20p1
 1BD5   1   51			      push cx
 1BD6   1   56			      push si
				     ; Set up V to be just the symbol found.
 1BD7   1   89 13		      mov V.Pt,dx
 1BD9   1   2B F2		      sub si,dx
 1BDB   2   89 73 04		      mov V.Len,si
 1BDE   1   BA 0000 E		      mov dx,offset B4EXPOSE
 1BE1   3   E8 0000 E		      call LinkBcode
 1BE4   1   89 7E 06		      mov Z.Stack,StackDi
 1BE7   1   5E			      pop si
 1BE8   1   59			      pop cx
 1BE9   3   EB CB		      jmp ExposeLoopX
 1BEB				     Dots$$:; Fetch from a compound. The compound is the only argument.
				     ; The values for the tail parts are parameters.
 1BEB   3   65: 0F B6 04	      movzx ax,Bptr gs:[CursorSi]
 1BEF   1   46			      inc CursorSi
				     ; AX now 0 = One part tail, $StrideV = two part tail,...
 1BF0   1   65: 8B 1C		      mov StemBx,gs:[CursorSi]
 1BF3   1   83 C6 02		      add CursorSi,2
 1BF6   1   56			      push CursorSi
 1BF7   3   E8 E528		      call DotsFsBxDsSi; Sets FS:BX the lower of pair, DS:SI the item.
 1BFA   2   80 7C 07 88		      cmp Vsid.Dtype,$Omitted
 1BFE  3,1  74 19		      je DotsNew
 1C00   2   F6 44 07 C0		     PostDotsNew:test Vsid.Dtype,$Test
 1C04  3,1  7F 25		      jg TailedDropped
				      Move V,Vsid
 1C06   1   66| 8B 0C		  1     mov ecx,Vsid.OverExpo
 1C09   1   66| 89 0B		  1     mov V.OverExpo,ecx
 1C0C   1   66| 8B 44 04	  1     mov eax,Vsid.OverMant
 1C10   2   66| 89 43 04	  1     mov V.OverMant,eax
 1C14   3p  8E 66 46		     DotsReturn:mov fs,Z.VarScope
 1C17   1   5E			      pop CursorSi
				      BackRet
 1C18   5   C3			  1  ret

 1C19				     DotsNew:; New item gets it's value from the stem default.
				     ; Assert - default known not to be exposed.
				       Move Vsid,Vbxf
 1C19   1   66| 64: 8B 0F	  1     mov ecx,Vbxf.OverExpo
 1C1D   1   66| 89 0C		  1     mov Vsid.OverExpo,ecx
 1C20   1   66| 64: 8B 47 04	  1     mov eax,Vbxf.OverMant
 1C25   1   66| 89 44 04	  1     mov Vsid.OverMant,eax
 1C29   3   EB D5		       jmp PostDotsNew

 1C2B				     TailedDropped:
				     if Debug
 1C2B   2   80 7C 07 40		      cmp Vsid.Dtype,$Dropped
 1C2F  3,1  74 02		      je @F
 1C31   5p  FF D5		      Error49Bp
 1C33				      @@:
				     endif
				     ; Have to construct STEM.tail as value.
 1C33   3   E8 05A3		      call ValueIsName
				     ; Recover the tail - it is the key of the compound.
				      Up
 1C36   1   83 C7 08		  1   add StackDi,$StrideV
 1C39   4   8C 5B 02		      mov V.Sg,ds
 1C3C   1   8B 44 0C		      mov ax,J.KeyLen
 1C3F   2   89 43 04		      mov V.Len,ax
 1C42   1+  8D 44 0E		      lea ax,J.Key
 1C45   1   89 03		      mov V.Pt,ax
 1C47   3   E8 0005		      call Away
 1C4A   3   E8 E701		      call Abut$$
 1C4D   3   EB C5		      jmp DotsReturn

 1C4F				     Away:; Mark stack as an away string if not optimizable.
 1C4F   1   51			      push cx
 1C50   2   8B 4B 04		      mov cx,V.Len
 1C53   1   83 F9 07		      cmp cx,7
 1C56  3,1  76 06		      jna @F
 1C58   2   C6 43 07 C0		      mov V.Dtype,$AwayString
 1C5C   1   59			      pop cx
 1C5D   5   C3			      ret
 1C5E   3   1E			     @@:push ds
 1C5F   1   56			      push si
 1C60   6p  C5 33		      lds si,V.Fr
				      Mv V,Vsid
 1C62   4   66| FF 34		  1     pushd Vsid.OverExpo
 1C65   6   66| 8F 03		  1     pop V.OverExpo
 1C68   4   66| FF 74 04	  1     pushd Vsid.OverMant
 1C6C   7   66| 8F 43 04	  1     pop V.OverMant
 1C70   1   80 C1 80		      add cl,$NullString
 1C73   2   88 4B 07		      mov V.Dtype,cl
 1C76   1   5E			      pop si
 1C77   3p  1F			      pop ds
 1C78   1   59			      pop cx
 1C79   5   C3			      ret

 1C7A				     AssignStem$$:; eg ABC.=99
				     ; If the whole stem is exposed we must change pool until it isn't.
 1C7A   1   65: 8B 1C		      mov bx,gs:[CursorSi]
 1C7D   1   83 C6 02		      add CursorSi,2
 1C80   2   64: 80 7F 07 50	      cmp Vbxf.Dtype,$Exposed
 1C85  3,1  75 03		      jne @F
 1C87   3   E8 FE72		      call ExposedFs
 1C8A				      @@:
				     ; Look at the stem to see if anything (ABC.XXX as opposed to ABC.) is exposed.
				     ; The stem may never have been used.
 1C8A   2   64: 80 7F 0F 40	      cmp Vbxf2.Dtype,$Dropped
 1C8F  3,1  0F 84 FE52		      je AssignRet; to just set default value.
 1C93   1   56			      push CursorSi
 1C94   3p  64: 8E 5F 0A	      mov ds,Vbxf2.Sg
 1C98   1   BE 0010		      mov TailSi,$StrideH
 1C9B   2   80 7C 07 50		      cmp Vsid.Dtype,$Exposed
 1C9F  3,1  74 0E		      je SomeExposed
				     ; Empty the stem segment.
 1CA1   1   C7 06 0004 0010	      mov Hd.Avail,$StrideH
				      z Hd.Probe
 1CA7   1   89 2E 000C		  1           mov Hd.Probe,bp
 1CAB   1   5E			      pop CursorSi
 1CAC   3   E9 FE36		      jmp AssignRet; To set ABC.

 1CAF				     SomeExposed:; DS:SI item to be given Stack value.
 1CAF				     AssignLoop:; Simple when it is not exposed.
 1CAF   2   80 7C 07 50		      cmp Vsid.Dtype,$Exposed
 1CB3  3,1  74 1E		      je AssignUp
 1CB5				     AssignUpRet:Move Vsid,V
 1CB5   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 1CB8   1   66| 89 0C		  1     mov Vsid.OverExpo,ecx
 1CBB   2   66| 8B 43 04	  1     mov eax,V.OverMant
 1CBF   1   66| 89 44 04	  1     mov Vsid.OverMant,eax
 1CC3   2   03 74 0C		      add TailSi,J.KeyLen
 1CC6   1   83 C6 0E		      add TailSi,$StrideJ
 1CC9   2   3B 36 0004		      cmp TailSi,Hd.Avail
 1CCD  3,1  72 E0		      jb AssignLoop
 1CCF   1   5E			      pop CursorSi
 1CD0   3   E9 FE12		      jmp AssignRet
 1CD3   1   89 BE 00FF		     AssignUp:mov Z.StackLo,StackDi; So that DotsRet can be used.
 1CD7   1   68 1CB5 R		      push AssignUpRet
 1CDA   3   E9 E55E		      jmp DotsExposed
 1CDD				     Drop$$:; Done as assignment of the value $Dropped
 1CDD   2   3B 7E 56		      cmp StackDi,Z.CurrentDO
				      UpCare
 1CE0   1+  8D 7D 08		  1   lea StackDi,$StrideV[StackDi]
 1CE3   2   C6 43 07 40		      mov V.Dtype,$Dropped
 1CE7  3,1  0F 84 FDD6		      jz Assign$$
				     ; Compound assignment.
				     ; Components of the tail are on the stack.
 1CEB   5   65: AD		     AssignDots$$:lodsw gs:[CursorSi]
 1CED   1   8B D8		     mov StemBx,ax
 1CEF   1   56			     push CursorSi
				     ; Improve performance - set StackLo NYI
 1CF0   1   8B C7		      mov ax,StackDi
 1CF2   2   2B 46 56		      sub ax,Z.CurrentDO
 1CF5   1   83 E8 10		      sub ax,2*$StrideV; At least value & a tail
 1CF8   3   E8 E427		      call DotsFsBxDsSi
				      Down; DotsFsBxDsSi allowed for value pickup by Dots$$.
 1CFB   1   83 EF 08		  1   sub StackDi,$StrideV
				      Move Vsid,V
 1CFE   1   66| 8B 0B		  1     mov ecx,V.OverExpo
 1D01   1   66| 89 0C		  1     mov Vsid.OverExpo,ecx
 1D04   2   66| 8B 43 04	  1     mov eax,V.OverMant
 1D08   1   66| 89 44 04	  1     mov Vsid.OverMant,eax
				      Down
 1D0C   1   83 EF 08		  1   sub StackDi,$StrideV
 1D0F   3p  8E 66 46		      mov fs,Z.VarScope
 1D12   1   5E			      pop CursorSi
				      BackRet
 1D13   5   C3			  1  ret


 1D14				     Interpret$$:
				      On Z.Program,LabelsBad; Tell Parser whats up.
 1D14   3   80 4E 03 20		  1          or  Bptr(Z.Program+1), high ??002D
 1D18				     Interpret1:
 1D18   1   56			      push CursorSi
 1D19   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 1D1C  3,1  74 07		      je @F
				      On Z.Cancel,BcodeInterpret; Off at InterpEnd
 1D1E   3   80 4E 04 40		  1          or  Bptr(Z.Cancel), low ??002E
 1D22   3p  8E 6E 4A		      mov gs,Z.Code
 1D25				     @@:
				     ; INTERPRET can nest so we need a block on the stack to hold each generation.
				     ; It is very like a DO block, in that it goes away when there is a SIGNAL.
				     ; And provides base for counting tails on assign.
				     ; Build DO-like block over where the parameter was.
				     ; Normally DO blocks are adjacent because DO inside DO occurs with nothing
				     ; on the stack. BcodeInterpret is different - new Bcoded routine without
				     ; new Z.Level - so complicates Z.CurrentDO maintenance.
 1D25   1   83 C7 20		      add StackDi,$StrideD-$StrideV
 1D28   1   8B 46 56		      mov ax,Z.CurrentDO
 1D2B   1   89 7E 06		      mov Z.Stack,StackDi
 1D2E   3   E8 0000 E		      call StackSafe
 1D31   2   89 43 04		      mov D.UpDO,ax
 1D34   1   89 7E 56		      mov Z.CurrentDO,StackDi
				      On D.Rec,IsInterp
 1D37   4   80 4B 07 02		  1          or  D.Rec,??002F
 1D3B   1   5E			      pop CursorSi
 1D3C   1   56			      push CursorSi
 1D3D   2   89 73 02		      mov D.Leaving,CursorSi
				     ; CursorSi not needed but left stacked for error messages.
				      move D.PcodePos,Hg.Avail; Where code will start.
 1D40   1   65: 8B 46 04	  1      mov ax,Hg.Avail
 1D44   1   89 03		  1      mov D.PcodePos,ax
 1D46   1   89 46 36		      mov Z.Cursor,ax
 1D49   1   B0 03		      mov al,$SerialInterpret
 1D4B   3   E8 0000 E		      call Serialize
				      z Z.Synch
 1D4E   1   89 AE 010D		  1           mov Z.Synch,bp
 1D52   3   E8 0000 E		      call Compiling
 1D55   1   5E			      pop si
 1D56   1   B0 00		      mov al,$SerialNone
 1D58   3   E8 0000 E		      call Serialize
 1D5B   2   65: 39 6E 0A	      cmp Hg.Original,ZeroBp
 1D5F  3,1  75 0A		      jnz @F
				     ; No execution when $Reserved.
 1D61   1   83 EF 20		      sub StackDi,$StrideD-$StrideV
 1D64   1   89 7E 56		      mov Z.CurrentDO,StackDi
 1D67   1   89 7E 06		      mov Z.Stack,StackDi
 1D6A   5   C3			      ret
				     ; If it failed to parse, that is handled at label Raise.
 1D6B   1   8B 33		     @@:mov CursorSi,D.PcodePos; Resume by executing the new code.
 1D6D   3   E9 0000 E		      jmp StartExecutionY
				     ;MASM..............................
 1D70				     InterpEnd$$:; Code made from an INTERPRET statement has completed.
				      move Hg.Avail,D.PcodePos; Reclaim code space.
 1D70   1   8B 03		  1      mov ax,D.PcodePos
 1D72   1   65: 89 46 04	  1      mov Hg.Avail,ax
 1D76   8   0F BA 76 04 06	      btr Z.Cancel,BcodeInterpret
 1D7B  3,1  0F 83 ED7F		      jnc Leave$$
				     ; Like Leave$$ but the INTERPRET was in Bcode.
 1D7F   2   8B 73 02		      mov CursorSi,D.Leaving
				      move Z.CurrentDO,D.UpDO
 1D82   2   8B 43 04		  1      mov ax,D.UpDO
 1D85   1   89 46 56		  1      mov Z.CurrentDO,ax
 1D88   1   83 EF 28		      sub StackDi,$StrideD
 1D8B   1   89 7E 06		      mov Z.Stack,StackDi
				      mv gs,cs
 1D8E   3   0E			  1   push cs
 1D8F   3p  0F A9		  1   pop gs
				      PopJunk ax
 1D91   1   58			  1    pop ax
 1D92   5   C3			      ret


				     ;------------------------------------------------------------------------------
				     ; The remaining verbs.
				     ;------------------------------------------------------------------------------
 1D93				     Options$$:
				     ; None yet.
				      Down
 1D93   1   83 EF 08		  1   sub StackDi,$StrideV
				      BackRet
 1D96   5   C3			  1  ret

 1D97				     Push$$:
 1D97   1   56			     Queue$$:push CursorSi
				     ; Length of aggregate is first word of Z.Serial.
				     ; Items have their length at both ends of the item.
 1D98   1   B0 01		      mov al,$SerialQue
 1D9A   3   E8 0000 E		      call Serialize
				     ; Establish value to be pushed.
 1D9D   3   E8 02D9		      call ToDsSiCx
 1DA0   1   57			      push StackDi
				     ; Check room.
 1DA1   1   8B 86 01AB		      mov ax,Wptr Z.Serial; Previous aggregate length.
 1DA5   1   B2 0D		      mov dl,$DescQueue
 1DA7   1   03 C1		      add ax,cx
 1DA9   1   3D 11C2		      cmp ax,sizeof Zshape.Serial-6
 1DAC  3,1  0F 87 0000 E	      ja Raise5p1
				      mv es,ss
 1DB0   3   16			  1   push ss
 1DB1   3p  07			  1   pop es
 1DB2   1   8B C1		      mov ax,cx
 1DB4   1   83 C0 04		      add ax,4; For two lengths
				     ; If Queue, existing aggregate will have to move right.
 1DB7   1   80 FB BD		      cmp bl,$pQueue
 1DBA  3,1  75 17		      jne @F
 1DBC   1   56			      push si
 1DBD   1   51			      push cx
 1DBE   1   8B B6 01AB		      mov si,Wptr Z.Serial
 1DC2   1   8B CE		      mov cx,si
 1DC4   1+  8D B4 01AC		      lea si,Zshape.Serial[si+1]; Rightmost byte
 1DC8   1   8B FE		      mov di,si
 1DCA   1   03 F8		      add di,ax
 1DCC   2   FD			      std
 1DCD   7n  F3/ 36: A4		      rep movsb [di],ss:[si]
 1DD0   2   FC			      cld
 1DD1   1   59			      pop cx
 1DD2   1   5E			      pop si
 1DD3   1   8B 96 01AB		     @@:mov dx,Wptr Z.Serial; Previous aggregate length.
 1DD7   3   01 86 01AB		      add Wptr Z.Serial,ax; New aggregate length.
				     ; Copy argument to Serial.
 1DDB   1   BF 01AD		      mov di,offset Zshape.Serial+2
 1DDE   1   80 FB BD		      cmp bl,$pQueue
 1DE1  3,1  74 02		      je @F
 1DE3   1   03 FA		      add di,dx
 1DE5				      @@:
 1DE5   5   AB			      stosw; Place first copy of length.
 1DE6   7n  F3/ A4		      rep movsb
 1DE8   5   AB			      stosw; data then second.
 1DE9   1   5F			      pop CursorDi
				      Down
 1DEA   1   83 EF 08		  1   sub StackDi,$StrideV
 1DED   3p  8E 46 44		      mov ProgEs,Z.ProgScope
 1DF0   1   5E			      pop CursorSi
				      BackRet
 1DF1   5   C3			  1  ret

				     ; Some simple verbs.
 1DF2				     Say$$:
 1DF2   1   56			      push CursorSi
 1DF3   3   E8 0283		      call ToDsSiCx
 1DF6   1   8B D6		      mov dx,si
 1DF8   1   8B 5E 14		      mov bx,Z.Stdout
 1DFB   1   B4 40		      mov ah,$DosWrite
 1DFD  30   CD 21		      int 21h; Takes ds:dx:cx to file bx
				      mv ds,cs
 1DFF   3   0E			  1   push cs
 1E00   3p  1F			  1   pop ds
 1E01   1   BA 004D		      mov dx,Yshape.CrLf
 1E04   1   B9 0002		      mov cx,2
 1E07   1   B4 40		      mov ah,$DosWrite
 1E09  30   CD 21		      int 21h
				     ; Say in Bcode just for debug.
 1E0B   2   39 6E 58		      cmp Z.ResumeP,ZeroBp
 1E0E  3,1  75 03		      jne @F
				      Down
 1E10   1   83 EF 08		  1   sub StackDi,$StrideV
 1E13   1   5E			     @@:pop CursorSi
				      BackRet
 1E14   5   C3			  1  ret

				     ;------------------------------------------------------------------------------
				     ; Conversion to Number.
				     ;------------------------------------------------------------------------------
				     ; NumDxBx makes the stack variable a number, setting carry iff it
				     ; cannot do that at 9 digits. ebx:edx left as copy of number stacked.
				     ; si and di are preserved.  ax and cx are not.
				     ; Entered at label NumDxBx.

				     ; Mantissa ended on non-blank. Check it is dot or E or e.
				     ; For this pass, dot is like a digit.
 1E15  3,1  7A 0D		     FnMantx:jpe FnChar
 1E17   1   A8 01		     test al,$Ee
 1E19  3,1  75 15		     jnz FnMantz
				     ; Pity attributes of Dot not different from some other letters.
 1E1B   1   47			      inc di
 1E1C   2   80 7C FF 2E		      cmp Bptr[si-1],'.'
 1E20  3,1  0F 84 00B8		      je FnPostDot
				     ; FnChar is place where syntax has proved to be non-number.
 1E24   1   66| 59		     FnChar:pop ecx
 1E26   1   66| 58		     pop eax
 1E28   1   5F			     pop StackDi
 1E29   3   F6 43 07 C0		     test V.Dtype,$Test
 1E2D   2   F9			     stc
				     RetSi
 1E2E   1   5E			  1   pop CursorSi
 1E2F   5   C3			  1   ret

				     ; Blank or 'E' ends mantissa. Set to rescan it.
 1E30   1   4E			     FnMantz:dec si
 1E31   3   E9 00AB		     jmp FnMant

 1E34   1   80 FC 2E		     FnPostSign:cmp ah,'.'
 1E37  3,1  0F 84 008D		     je FnNoSign
 1E3B   3   EB E7		     FnChSt:jmp FnChar

 1E3D   1   4E			     FnExpd:dec si
 1E3E   1   89 B6 00AC		     mov Z.ExpPosZi,si
 1E42   3   E9 00B9		     jmp FnB

				     ; Build up the exponent.
 1E45   1   46			     FnExp:inc si
 1E46   1   49			     dec cx
 1E47  3,1  74 F2		     jz FnChSt
 1E49   5   AC			     lodsb
 1E4A   4   2E: D7		     xlat cs:Bptr[bx]
 1E4C   1   88 86 00A5		      mov Z.SignE,al
 1E50   1   24 FC		      and al,$Group
 1E52   1   3C E4		      cmp al,$PlusMinus
 1E54  3,1  75 06		      jne @F
 1E56   1   49			      dec cx
				      JcxzQ FnChSt
 1E57   1   85 C9		  1    test cx,cx
 1E59  3,1  74 E0		  1    je FnChSt
 1E5B   1   46			      inc si
 1E5C   1   4E			     @@:dec si
 1E5D   1   89 B6 00AA		      mov Z.ExpPos,si
				     ; Scan exponent digits.
 1E61   5   AC			     @@:lodsb
				     XlatBDLS
 1E62   4   2E: D7		  1   xlat Bptr cs:[bx]
 1E64   1   A8 C0		  1   test al,0C0h
 1E66  3,1  74 D5		     jz FnExpd
 1E68  3,1  78 D1		     js FnChSt
				     LoopQ @B
 1E6A   1   49			  1    dec cx
 1E6B  3,1  75 F4		  1    jnz @B
 1E6D   1   89 B6 00AC		      mov Z.ExpPosZi,si
 1E71   3   E9 0094		      jmp FnDone

 1E74   2   66| 8B 5B 04	     Qret:mov ebx,V.Mantissa
 1E78   1   66| 8B 13		     Qretx:mov edx,V.ExpAnd
 1E7B   5   C3			     ret; Test has cleared flags.

				     ; In this version (Aug 99) we are not using the $AwayNum type, using char
				     ; types instead.
				     ; On return the flags register reflects the Dtype of the result, with also
				     ; Carry set if not number syntax. (ie Carry implies compare non-numeric.)

 1E7C				     NumDxBx:
 1E7C   3   F6 43 07 C0		      test V.Dtype,$Test
 1E80  3,1  74 F2		      jz Qret
				     ; May 2000 Still not done AwayNum so will have to check numberness each use.
 1E82				     WasChar:Off Z.Cancel,ExpRange
 1E82   3   80 66 05 FD		  1          and Bptr(Z.Cancel+1), high not ??0030
 1E86   1   56			      push CursorSi
 1E87   1   57			      push StackDi
 1E88   1   66| 50		      push eax
 1E8A   1   66| 51		      push ecx
 1E8C   3   E8 01EA		      call ToDsSiCx
				      JcxzQ FnChSt; Empty string is not a number.
 1E8F   1   85 C9		  1    test cx,cx
 1E91  3,1  74 A8		  1    je FnChSt
 1E93   1   BB 0000 E		      mov bx,Attributes; For XLAT
				     ; There just are not enough registers to make it sensible to do everything in
				     ; one pass.  Better to have a first pass that finds the digits.
				     ; si is for lods, cx counts unconsumed characters.
				     ; When jumping out of loops si/cx are out of step. dec si rescans, dec cx keeps.
				     ; First pass details are recorded in Z. fields, and in di for decimal point.
				      z Z.ExpPosZi
 1E96   1   89 AE 00AC		  1           mov Z.ExpPosZi,bp
				     ; Skip leading blanks. String all blanks is not a number.
 1E9A   5   AC			     @@:lodsb
				     XlatBDLS
 1E9B   4   2E: D7		  1   xlat Bptr cs:[bx]
 1E9D   1   A8 C0		  1   test al,0C0h
 1E9F  3,1  75 05		     jnz @F
				     LoopQ @B
 1EA1   1   49			  1    dec cx
 1EA2  3,1  75 F6		  1    jnz @B
 1EA4   3   EB 95		     jmp FnChSt
 1EA6				     @@:
				     ; Note sign. Future test will be against $AttribMinus
 1EA6   1   88 86 00A4		      mov Z.SignM,al
 1EAA   1   24 FC		      and al,$Group
 1EAC   1   3C E4		      cmp al,$PlusMinus
 1EAE  3,1  75 18		      jne FnNoSign
 1EB0   1   49			      dec cx
				      JcxzQ FnChSt
 1EB1   1   85 C9		  1    test cx,cx
 1EB3  3,1  74 86		  1    je FnChSt
				     ; Skip blanks after sign.
 1EB5   5   AC			     @@:lodsb
 1EB6   1   8A E0		     mov ah,al
				     XlatBDLS
 1EB8   4   2E: D7		  1   xlat Bptr cs:[bx]
 1EBA   1   A8 C0		  1   test al,0C0h
 1EBC  3,1  75 06		     jnz @F
				     LoopQ @B
 1EBE   1   49			  1    dec cx
 1EBF  3,1  75 F4		  1    jnz @B
 1EC1   3   E9 FF77		     FnChSt2:jmp FnChSt
 1EC4  3,1  0F 88 FF6C		     @@:js FnPostSign
 1EC8   1   4E			     FnNoSign:dec si; Here with a digit upcoming, usually.
 1EC9   1   89 B6 00A6		      mov Z.MantPos,si
				      z di; To count decimal points.
 1ECD   1   8B FD		  1           mov di,bp
 1ECF   5   AC			     @@:lodsb
				      XlatBDLS
 1ED0   4   2E: D7		  1   xlat Bptr cs:[bx]
 1ED2   1   A8 C0		  1   test al,0C0h
 1ED4  3,1  0F 84 FF58		      jz FnMantz
 1ED8  3,1  0F 88 FF39		      js FnMantx
 1EDC				     FnPostDot:LoopQ @B
 1EDC   1   49			  1    dec cx
 1EDD  3,1  75 F0		  1    jnz @B
				     ; Fall thru when digits go to the end.
 1EDF				     FnMant:; Back to here from FnMantx when 'E' upcoming, or blank.
				     ; At most one decimal point.
 1EDF   1   83 FF 01		      cmp di,1
 1EE2  3,1  77 DD		      ja FnChSt2
 1EE4   1   89 B6 00A8		      mov Z.MantPosZi,si
				     ; Mantissa better have some digits in it.  .E+99 is wrong.
 1EE8   1   2B F7		      sub si,di
 1EEA   2   3B B6 00A6		      cmp si,Z.MantPos
 1EEE  3,1  74 D1		      je FnChSt2
 1EF0   1   8B B6 00A8		      mov si,Z.MantPosZi
				     ; Similarly for exponent.
				      JcxzQ FnDone
 1EF4   1   85 C9		  1    test cx,cx
 1EF6  3,1  74 10		  1    je FnDone
 1EF8   1   A8 01		      test al,$Ee
 1EFA  3,1  0F 85 FF47		      jnz FnExp
				     ; Trailing blanks OK
 1EFE   5   AC			     FnB:lodsb
				     XlatBDLS
 1EFF   4   2E: D7		  1   xlat Bptr cs:[bx]
 1F01   1   A8 C0		  1   test al,0C0h
 1F03  3,1  75 BC		     jnz FnChSt2
				     LoopQ FnB
 1F05   1   49			  1    dec cx
 1F06  3,1  75 F6		  1    jnz FnB
 1F08				     FnDone:
				     ; Here are two checks whether the number will go in our binary format.
				     ; Mantissa to ebx, exponent to edx.
 1F08   1   66| 8B D5		      mov edx,ebp
 1F0B   1   8B 8E 00AC		      mov cx,Z.ExpPosZi
				      JcxzQ FnNoExp
 1F0F   1   85 C9		  1    test cx,cx
 1F11  3,1  74 2D		  1    je FnNoExp
 1F13   1   8B B6 00AA		      mov si,Z.ExpPos
 1F17   1   2B CE		      sub cx,si
 1F19   1   66| 8B C5		      mov eax,ebp
 1F1C   5   AC			     @@:lodsb
 1F1D   1   2C 30		      sub al,'0'
 1F1F  13+  66| 6B D2 0A	      imul edx,10
 1F23  3,1  0F 88 00C7		      js FnBigExp
 1F27   1   66| 03 D0		      add edx,eax
 1F2A   2   66| 2E: 3B 56 28	      cmp edx,Y.N1e9
 1F2F  3,1  0F 83 00BB		      jae FnBigExp
				      LoopQ @B
 1F33   1   49			  1    dec cx
 1F34  3,1  75 E6		  1    jnz @B
 1F36   2   80 BE 00A5 E4	      cmp Z.SignE,$AttribMinus
 1F3B  3,1  75 03		      jne @F
 1F3D   1   66| F7 DA		      neg edx
 1F40				      @@:
 1F40				     FnNoExp:
				     ; That has got the exponent, as written, into edx, and validated.
				     ; We shall return saying this has number syntax.
				     ; If the syntax was non-number we would have returned (with Carry) and
				     ; not reached here. So anything awkward from here on we can say "long number",
				     ; (even if it doesn't need a lot of digits) and it will be dealt with by
				     ; ArithGeneral rather than the code for binary values.
				     ; Now for mantissa to ebx.
				      z edi
 1F40   1   66| 8B FD		  1             mov edi,ebp
 1F43   1   8B B6 00A6		      mov si,Z.MantPos
 1F47   1   8B 8E 00A8		      mov cx,Z.MantPosZi
 1F4B   1   2B CE		      sub cx,si
 1F4D   1   66| 8B DD		      mov ebx,ebp
 1F50   1   66| 8B C5		      mov eax,ebp
 1F53   5   AC			     FnMloop:lodsb
 1F54   1   3C 2E		      cmp al,'.'
 1F56  3,1  75 04		      jne @F
 1F58   1   66| 47		      inc edi
 1F5A   3   EB 16		      jmp FnSkip
 1F5C				      @@:
				     ; Large mantissa best done by ArithGeneral.
 1F5C   1   2C 30		      sub al,'0'
 1F5E  13+  66| 6B DB 0A	      imul ebx,10
 1F62  3,1  72 3F		      jc FnLong
 1F64   1   66| 03 D8		      add ebx,eax
 1F67  3,1  72 3A		      jc FnLong
 1F69   1   66| 2B D7		      sub edx,edi
 1F6C   2   66| 3B 5E 63	      cmp ebx,Z.Ceiling
 1F70  3,1  73 31		      jnb FnLong
				     if 0
				     endif
 1F72				     FnSkip:LoopQ FnMloop
 1F72   1   49			  1    dec cx
 1F73  3,1  75 DE		  1    jnz FnMloop
 1F75   1   66| 3B DD		      cmp ebx,ebp
 1F78  3,1  75 03		      jne @F
 1F7A   1   66| 8B D5		      mov edx,ebp
 1F7D				      @@:
				     ; !! check edx
				     ; Exponent is held doubled, with sign of Mantissa added.
 1F7D   1   66| 03 D2		      add edx,edx
 1F80   2   80 BE 00A4 E4	      cmp Z.SignM,$AttribMinus
 1F85  3,1  75 02		      jne @F
 1F87   1   66| 42		      inc edx
 1F89				      @@:
 1F89   1   66| 3B DD		      cmp ebx,ebp
 1F8C  3,1  75 03		      jne @F
 1F8E   1   66| 8B D5		      mov edx,ebp
 1F91				      @@:
				     ; The variable on the stack is altered when binary can fit.
 1F91   1   66| 59		      pop ecx
 1F93   1   66| 58		      pop eax
 1F95   1   5F			      pop StackDi
 1F96   2   66| 89 5B 04	      mov V.Mantissa,ebx
 1F9A   1   66| 89 13		      mov V.ExpAnd,edx
 1F9D   3   F6 43 07 C0		      test V.Dtype,$Test
				      RetSi
 1FA1   1   5E			  1   pop CursorSi
 1FA2   5   C3			  1   ret
 1FA3				     FnLong:
 1FA3   1   66| 59		      pop ecx
 1FA5   1   66| 58		      pop eax
 1FA7   1   5F			      pop StackDi
				     ; Got to add zero anyway.
 1FA8   1   8B F7		      mov StackSi,StackDi
 1FAA   1   57			      push StackDi
 1FAB   4   FF 76 06		      push Z.Stack
 1FAE   1   8B 7E 06		      mov StackDi,Z.Stack
				      Up
 1FB1   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Vsi,ebx
 1FB4   1   66| 8B 1A		  1    mov ebx,Vsi.OverExpo
 1FB7   1   66| 89 1B		  1    mov V.OverExpo,ebx
 1FBA   2   66| 8B 5A 04	  1    mov ebx,Vsi.OverMant
 1FBE   2   66| 89 5B 04	  1    mov V.OverMant,ebx
 1FC2   3   E8 0000 E		      call Zero$$
				      Down
 1FC5   1   83 EF 08		  1   sub StackDi,$StrideV
 1FC8   1   B2 3F		      mov dl,$pAdd
 1FCA   3   E8 F0C3		      call ArithDl
 1FCD   1   8B F7		      mov StackSi,StackDi
 1FCF   6   8F 46 06		      pop Z.Stack
 1FD2   1   5F			      pop StackDi
				      Move V,Vsi,ebx
 1FD3   1   66| 8B 1A		  1    mov ebx,Vsi.OverExpo
 1FD6   1   66| 89 1B		  1    mov V.OverExpo,ebx
 1FD9   2   66| 8B 5A 04	  1    mov ebx,Vsi.OverMant
 1FDD   2   66| 89 5B 04	  1    mov V.OverMant,ebx
 1FE1   2   66| 8B 5B 04	      mov ebx,V.Mantissa
 1FE5   1   66| 8B 13		      mov edx,V.ExpAnd
 1FE8   3   F6 43 07 C0		      test V.Dtype,$Test
				      RetSi
 1FEC   1   5E			  1   pop CursorSi
 1FED   5   C3			  1   ret

				     ; If it looks like a number, has exponent in range, but mantissa won't fit
				     ; nine digits, then it is a long number.
				     ; But long binary numbers not implemented yet.
				     if 0
				     endif

 1FEE				     FnBigExp:On Z.Cancel,ExpRange
 1FEE   3   80 4E 05 02		  1          or  Bptr(Z.Cancel+1), high ??0031
 1FF2   3   E9 FE46		     jmp FnChSt

 1FF5				     ToWholeEbx:; Result to ebx and V.Mantissa. eax ecx edx used.
				     ; Used from arithmetic and DataType to convert to number. (Or set Carry)
 1FF5   3   E8 FE84		      call NumDxBx
 1FF8  3,1  72 7E		      jc TwFail
 1FFA  3,1  74 33		      jz TwBinary
				     ; Number in char form. Try to bring it to binary.
				     ; Got to add zero anyway.   cf FnLong
 1FFC   1   56			      push si
 1FFD   1   8B F7		      mov StackSi,StackDi
 1FFF   1   57			      push StackDi
 2000   1   8B 7E 06		      mov StackDi,Z.Stack
				      Up
 2003   1   83 C7 08		  1   add StackDi,$StrideV
				      Move V,Vsi,ebx
 2006   1   66| 8B 1A		  1    mov ebx,Vsi.OverExpo
 2009   1   66| 89 1B		  1    mov V.OverExpo,ebx
 200C   2   66| 8B 5A 04	  1    mov ebx,Vsi.OverMant
 2010   2   66| 89 5B 04	  1    mov V.OverMant,ebx
 2014   3   E8 FE65		      call NumDxBx
 2017   1   8B F7		      mov StackSi,StackDi
 2019   1   5F			      pop StackDi
				      Move V,Vsi
 201A   1   66| 8B 0A		  1     mov ecx,Vsi.OverExpo
 201D   1   66| 89 0B		  1     mov V.OverExpo,ecx
 2020   2   66| 8B 42 04	  1     mov eax,Vsi.OverMant
 2024   2   66| 89 43 04	  1     mov V.OverMant,eax
 2028   1   5E			      pop si
 2029   3   F6 43 07 C0		      Test V.Dtype,$Test
 202D  3,1  75 48		      jnz TwFailx; Unsound for 'W' test. NYI
 202F   1   66| 8B 0B		     TwBinary: mov ecx,V.ExpAnd
 2032   3   66| D1 F9		      sar ecx,1
 2035  3,1  74 27		      jz TwOK
 2037   2   66| 8B 43 04	      mov eax,V.Mantissa
 203B  3,1  78 27		      js TwNegExp
				     if Debug
 203D   1   66| 3B C5		      cmp eax,ebp
 2040  3,1  75 03		      jne @F
 2042  26   CC			      int 3
 2043   3   EB 19		      jmp TwOK
 2045				      @@:
				     endif
				     ; Make the positive exponent zero by multiplying.
 2045  13+  66| 2E: F7 66 08	     @@:mul Y.N10
 204A  3,1  72 2C		     jc TwFail
 204C   2   66| 3B 46 63	     cmp eax,Z.Ceiling
 2050  3,1  73 25		     jae TwFailx
 2052   1   66| 49		     dec ecx
 2054  3,1  75 EF		     jnz @B
 2056   3   66| 83 23 01	     TwOKzero:and V.ExpAnd,1
 205A   2   66| 89 43 04	     mov V.Mantissa,eax
 205E   2   66| 8B 5B 04	     TwOK:mov ebx,V.Mantissa
 2062   2   F8			     clc
 2063   5   C3			     ret
				     ; We might be able to avoid a negative exponent by dividing Mantissa by 10.
 2064   1   66| 8B D5		     TwNegExp:mov edx,ebp
 2067  40   66| 2E: F7 76 08	     div Y.N10
 206C   1   80 FA 00		     cmp dl,0
 206F  3,1  75 06		     jnz TwFailx
 2071   1   66| 41		      inc ecx
 2073  3,1  75 EF		      jnz TwNegExp
 2075   3   EB DF		      jmp TwOKzero
 2077   2   F9			     TwFailx:stc
 2078   5   C3			     TwFail:ret
				     ;------------------------------------------------------------------------------
				     ; ToDsSiCx sets registers to reflect the top stack item.
				     ;------------------------------------------------------------------------------
				     ; ToDsSiCx makes the stack variable a string and sets ds:si:cx to reflect it.
				     ; eax,ebx,edx,edi preserved.
				     ; high of ecx not preserved.  es not preserved.
 2079   2   8A 4B 07		     ToDsSiCx:mov cl,V.Dtype
 207C   1   F6 C1 C0		     test cl,$Test
 207F  3,1  74 18		     jz ToString
 2081  3,1  7A 09		     jpe @F
				     ; Here when it already is short string.
				     ; mov ds,Z.Zone is faster than mv ds,ss
 2083   1   83 E1 07		      and cx,7
				      Assert Vshape.String eq 0
 2086   3p  8E 5E 4C		      mov ds,Z.Zone
 2089   1   8B F7		      mov si,StackDi
 208B   5   C3			      ret
 208C				     @@:

				     if Debug
 208C   1   80 F9 C0		     cmp cl,$AwayString
 208F  3,1  75 06		     jne @F
				     endif

				     ; Here for already a long string.
 2091   6p  C5 33		      lds si,V.Fr
 2093   2   8B 4B 04		      mov cx,V.Len
 2096   5   C3			      ret

				     if Debug
 2097   5p  FF D5		     @@:Error49Bp
				     endif

 2099				     ToString:; Converting to character string.
				     ; We don't know what the numerics settings were when the arith value was made
				     ; so we have to have arranged that it is OK to assume SCIENTIFIC 9 digits.
 2099   1   66| 50		      push eax
 209B   1   66| 53		      push ebx
 209D   1   66| 52		      push edx
 209F   1   66| 8B CD		      mov ecx,ebp
				     ; Special case single digits. That will include Booleans.
				     ; This case requires exponent zero. The "sar" removes mantissa sign.
 20A2				     AfterRound:
 20A2   2   66| 8B 43 04	      mov eax,V.Mantissa
 20A6   1   66| 8B 1B		      mov ebx,V.ExpAnd
 20A9   3   66| D1 FB		      sar ebx,1
 20AC  3,1  75 2E		      jnz TsMore
 20AE   2   66| 2E: 3B 46 08	      cmp eax,Y.N10
 20B3  3,1  73 27		      jae TsMore
				     ; Here with integer less than ten.
				     ; Positives are one character answers. Result length to be in cx.
 20B5   2   C6 43 07 80		      mov V.Dtype,$NullString
 20B9   1   41			      inc cx
 20BA   2   F6 03 01		      test V.Sign,1
 20BD  3,1  75 13		      jnz @F
 20BF   1   04 30		      add al,'0'
 20C1   1   88 03		      mov V.String,al
 20C3   4   00 4B 07		     TsFrom:add V.Dtype,cl
 20C6   1   66| 5A		      pop edx
 20C8   1   66| 5B		      pop ebx
 20CA   1   66| 58		      pop eax
 20CC   3p  8E 5E 4C		      mov ds,Z.Zone
 20CF   1   8B F7		      mov si,StackDi
 20D1   5   C3			      ret
				     ; Negative one digit is two character answer.
 20D2   1   41			     @@:inc cx
 20D3   1   BB 302D		     mov bx,StringOrder('-','0')
 20D6   1   02 F8		     add bh,al
 20D8   1   89 1B		      mov Wptr(V.String),bx
 20DA   3   EB E7		      jmp TsFrom

				     ; Here if non-integer or more than one digit.
				     ; ebx is exponent value. eax is mantissa.
 20DC				     TsMore:; ecx to count how many decimal digits it takes to hold the mantissa.
 20DC   1   BE 0004		      mov si,Yshape.N10-4; ecx already zero
 20DF   1   83 C6 04		     @@:add si,4
 20E2   1   41			      inc cx
 20E3   2   66| 2E: 3B 04	      cmp eax,Dptr cs:[si]
 20E7  3,1  73 F6		      jae @B
				     ; Will floating point representation be needed?
				     ; It will if digits for the mantissa plus right zeros implied by exponent
				     ; makes too many digits.  Alternatively, it will if value less than a millionth.
				     ; For this decision we assume the number was made when digits=9.
				     ; (Although maybe get away with other cases?)
 20E9   1   66| 8B D3		      mov edx,ebx
 20EC   1   66| 03 D1		      add edx,ecx
 20EF   2   66| 2E: 3B 56 08	      cmp edx,Y.N10
 20F4  3,1  7D 64		      jge TsFloat
 20F6   1   66| 83 FA FB	      cmp edx,-5
 20FA  3,1  7C 5E		      jl TsFloat
				     ; dx between -5 and 9. Position of point relative to left of mantissa.
				     ; cx digits from mantissa.
				     ; if bx>=0 there will not be a decimal point. Length will be dx (+1 if "-")
				     ; if bx<0 length will be one for point plus max(cx,-bx+1)
 20FC   1   85 DB		      test bx,bx
 20FE  3,1  7D 0E		      jge TsNoP
				     ; Now set dx to string length.
 2100   1   8B D3		      mov dx,bx
 2102   1   F7 DA		      neg dx
 2104   1   42			      inc dx
 2105   1   3B D1		      cmp dx,cx
 2107  3,1  7D 02		      jge @F
 2109   1   8B D1		      mov dx,cx
 210B   1   8B CA		      @@:mov cx,dx
 210D   1   42			      inc dx
 210E   2   F6 03 01		     TsNoP:test V.Sign,1
 2111  3,1  74 01		      jz @F
 2113   1   42			      inc dx
 2114				      @@:
				     ; Now cx digits, dx total. (Maybe bx right '0' pad)
 2114   3   87 CA		      xchg cx,dx
 2116   1   66| 50		      push eax
 2118   3   E8 016F		      call ResultSpaceDs
 211B   3   87 CA		      xchg cx,dx
 211D   1   8B F0		      mov si,ax
 211F   1   66| 58		      pop eax
				     ; Here with V. set up and ds:si addressing target space.
 2121   1   C6 04 2D		      mov Bptr[si],'-'; May get overlaid.
 2124   1   56			      push si
 2125   1   52			      push dx
 2126   1   03 F2		      add si,dx
				     ; Fill from the right, first with bx zeros
 2128   1   85 DB		     @@:test bx,bx
 212A  3,1  7E 07		     jle @F
 212C   1   4E			     dec si
 212D   1   C6 04 30		     mov Bptr[si],'0'
 2130   1   4B			     dec bx
 2131   3   EB F5		     jmp @B
 2133				     @@:
 2133				     FromFloat:
				     ; Here bx is either 0 to mean no point or negative of position from right.
				     ; There are cx digits to go, point along the way, maybe.
				     ; si right of place for right digit.
 2133   1   3B CD		      cmp cx,ZeroBp
 2135  3,1  7F 02		      jg @F
 2137   5p  FF D5		      Error49Bp
 2139				      @@:
 2139   1   4E			     TsLoop:dec si
 213A   1   66| 8B D5		      mov edx,ebp
 213D  40   66| 2E: F7 76 08	      div Y.N10
 2142   1   80 C2 30		      add dl,'0'
 2145   1   88 14		      mov [si],dl
 2147   1   43			      inc bx
 2148  3,1  75 04		      jnz @F
 214A   1   4E			      dec si
 214B   1   C6 04 2E		      mov Bptr[si],'.'
 214E				      @@:LoopQ TsLoop
 214E   1   49			  1    dec cx
 214F  3,1  75 E8		  1    jnz TsLoop
				     ; These are results for caller.
 2151   1   59			      pop cx
 2152   1   5E			      pop si
				     ; These were caller's values.
 2153   1   66| 5A		      pop edx
 2155   1   66| 5B		      pop ebx
 2157   1   66| 58		      pop eax
				     ; Note ES was preserved.
 2159   5   C3			      ret

 215A				     TsFloat:
				     ; ecx is digits of mantissa.
				     ; ebx is signed exponent alone.
 215A   1   89 8E 00B0		      mov Z.MantSize,cx
				     ; Adjust exponent to desired point position.
 215E   1   66| 03 D9		      add ebx,ecx
 2161   1   66| 4B		      dec ebx
 2163   1   66| 50		      push eax
				     ; Separate sign of exponent. (It cannot have become zero.) ax=0 positive.
				      z ax
 2165   1   8B C5		  1           mov ax,bp
 2167   1   66| 3B DD		      cmp ebx,ebp
 216A  3,1  79 04		      jns @F
 216C   1   66| F7 DB		      neg ebx
 216F   1   40			      inc ax
 2170				      @@:
 2170   1   89 86 00AE		      mov Z.ExpSign,ax
				     ; Deduce digit places for exponent, into dx.
 2174   1   BE 0004		      mov si,Yshape.N10-4
				      z dx
 2177   1   8B D5		  1           mov dx,bp
 2179   1   83 C6 04		     @@:add si,4
 217C   1   42			      inc dx
 217D   2   66| 2E: 3B 1C	      cmp ebx,Dptr cs:[si]
 2181  3,1  72 05		      jb @F
 2183   1   83 FE 28		      cmp si,Yshape.N1e9
 2186  3,1  75 F1		      jne @B
 2188				     @@:
				     ; Setup result place.
				     ; cx mantissa digits, dx exponent digits, three for punctuation, maybe
				     ; another sign.
				     ; Except that decimal point won't happen if it would be just before 'E'.
				      LoopQ @F
 2188   1   49			  1    dec cx
 2189  3,1  75 01		  1    jnz @F
 218B   1   49			      dec cx
 218C				      @@:
 218C   1   41			      inc cx; 1=>0  rest unaltered.
 218D   1   03 CA		      add cx,dx
 218F   1   83 C1 03		      add cx,3
 2192   2   F6 03 01		      test V.Sign,1
 2195  3,1  74 01		      jz @F
 2197   1   41			      inc cx
 2198				      @@:
 2198   3   E8 00EF		      call ResultSpaceDs
 219B   1   8B F0		      mov si,ax
 219D   1   66| 58		      pop eax
 219F   1   C6 04 2D		      mov Bptr[si],'-'; May get overlaid.
 21A2   1   56			      push si
 21A3   1   51			      push cx; For result to caller.
				     ; Fill in exponent.
 21A4   1   03 F1		      add si,cx
 21A6   1   8B CA		      mov cx,dx
 21A8   3   66| 93		      xchg eax,ebx
 21AA   1   4E			     FpLoop:dec si
 21AB   1   66| 8B D5		      mov edx,ebp
 21AE  40   66| 2E: F7 76 08	      div Y.N10
 21B3   1   80 C2 30		      add dl,'0'
 21B6   1   88 14		      mov [si],dl
				      LoopQ FpLoop
 21B8   1   49			  1    dec cx
 21B9  3,1  75 EF		  1    jnz FpLoop
 21BB   1   B6 2B		      mov dh,'+'
 21BD   2   39 AE 00AE		      cmp Z.ExpSign,ZeroBp
 21C1  3,1  74 02		      je @F
 21C3   1   B6 2D		      mov dh,'-'
 21C5				      @@:
 21C5   1   B2 45		      mov dl,'E'
 21C7   1   4E			      dec si
 21C8   1   4E			      dec si
 21C9   1   89 14		      mov [si],dx
				     ; Back to fill in mantissa.
 21CB   1   8B 8E 00B0		      mov cx,Z.MantSize
				      xax ebx
 21CF   3   66| 93		  1     xchg eax,ebx
 21D1   1   8B D9		      mov bx,cx
 21D3   1   F7 DB		      neg bx
 21D5   1   43			      inc bx
 21D6   3   E9 FF5A		      jmp FromFloat
				     ; Check exponent range !!

				     ;------------------------------------------------------------------------------
				     ; Some little routines.
				     ;------------------------------------------------------------------------------
				     ; The value is the name of item bx. Load it.
 21D9   1   56			     ValueIsName:push si
 21DA   3   1E			     push ds
 21DB   1   50			     push ax; cx set to length.
 21DC   3p  8E 5E 42		      mov ds,Z.Vars
 21DF   1   8B 77 04		      mov si,Vbx.Here
 21E2   3p  8E 5E 48		      mov ds,Z.Symbols
				     ; ds:si now addresses "counted string" form of name.
 21E5   3   0F B6 0C		      movzx cx,Bptr[si]
 21E8   1   46			      inc si
 21E9   1   80 F9 07		      cmp cl,7
 21EC  3,1  77 16		      ja VINlong
 21EE   1   80 C1 80		      add cl,$NullString
				      Move V,Vsid,eax
 21F1   1   66| 8B 04		  1    mov eax,Vsid.OverExpo
 21F4   1   66| 89 03		  1    mov V.OverExpo,eax
 21F7   1   66| 8B 44 04	  1    mov eax,Vsid.OverMant
 21FB   2   66| 89 43 04	  1    mov V.OverMant,eax
 21FF   2   88 4B 07		      mov V.Dtype,cl
 2202   3   EB 03		      jmp @F
 2204   3   E8 E36D		     VINlong:call VasDsSiCx
 2207   1   58			     @@:pop ax
 2208   3p  1F			      pop ds
				      RetSi
 2209   1   5E			  1   pop CursorSi
 220A   5   C3			  1   ret

 220B				     BxConst:
				     ; We can deduce the value from bx but it would have been better to do this
				     ; at an earlier stage.
 220B   3p  8E 5E 40		      mov ds,Z.Consts
 220E   1   8B 77 04		      mov si,Vbx.Here
 2211   3p  8E 5E 48		      mov ds,Z.Symbols
				     ; ds:si now addresses "counted string" form of name.
 2214   3   0F B6 0C		      movzx cx,Bptr[si]
 2217   1   46			      inc si
 2218   1   80 F9 07		      cmp cl,7
 221B  3,1  77 16		      ja Extlong
 221D   1   80 C1 80		      add cl,$NullString
				      Move V,Vsid,eax
 2220   1   66| 8B 04		  1    mov eax,Vsid.OverExpo
 2223   1   66| 89 03		  1    mov V.OverExpo,eax
 2226   1   66| 8B 44 04	  1    mov eax,Vsid.OverMant
 222A   2   66| 89 43 04	  1    mov V.OverMant,eax
 222E   2   88 4B 07		      mov V.Dtype,cl
 2231   3   EB 03		      jmp @F
 2233   3   E8 E33E		     Extlong:call VasDsSiCx
 2236   5   C3			     @@:ret

 2237				     ResultSpace:; Sets V up as result to address CX bytes. Return also es:ax
 2237   1   83 F9 07		      cmp cx,7
 223A  3,1  77 0C		      ja @F
				     ; Setup for short string.
 223C   2   C6 43 07 80		      mov V.Dtype,$NullString
 2240   4   00 4B 07		      add V.Dtype,cl
				      mv es,ss
 2243   3   16			  1   push ss
 2244   3p  07			  1   pop es
 2245   1+  8D 03		      lea ax,V.String
 2247   5   C3			      ret
 2248   3   E8 0000 E		     @@:call AllocateCx_EsAx
 224B				     AwayEsAxCx:; This entry point also used just to set up V.
 224B   2   C6 43 07 C0		      mov V.Dtype,$AwayString
 224F   4   8C 43 02		      mov V.Sg,es
 2252   1   89 03		      mov V.Pt,ax
 2254   2   89 4B 04		      mov V.Len,cx
 2257   5   C3			      ret

 2258				     HeritageDi:; Copies as necessary to inherit from caller.
				     ; Worth the fiddle to avoid caller push.
 2258   1   5D			      pop bp
 2259   1   57			      push StackDi
 225A   1   55			      push bp
 225B   1   33 ED		      xor bp,bp
 225D   1   8B 7E 52		      mov LevelDi,Z.Level
				     ; MASM error ..............................
 2260   8   0F BA 2B 07		     HeritRecurse:bts L.Access,InheritDone
 2264  3,1  72 23		     jc HeritageRet
 2266   1   57			      push LevelDi
 2267   2   8B 7B 02		      mov LevelDi,L.UpLevel
 226A   3   E8 FFF3		      call HeritRecurse
 226D   1   5F			      pop LevelDi
				     ; Copy from higher level, known to be already filled.
 226E   1   57			      push LevelDi
 226F   1   56			      push si
 2270   2   8B 73 02		      mov LevelSi,L.UpLevel
 2273   2+  8D 72 8C		      lea si,Lsi.Digits
				      Assert (Lshape.Inherit-Lshape.Digits) mod 4 eq 0
 2276   1   51			      push cx
 2277   1   B9 0012		      mov cx,(Lshape.Inherit-Lshape.Digits)/4
 227A   2+  8D 7B 8C		      lea di,L.Digits
 227D   3   06			      push es
 227E   3p  8E 46 4C		      mov es,Z.Zone
 2281   7n  F3/ 66| 26: A5	      rep movsd [di],es:[si]
 2285   3p  07			      pop es
 2286   1   59			      pop cx
 2287   1   5E			      pop si
 2288   1   5F			      pop LevelDi
 2289   5   C3			     HeritageRet:ret

 228A   3   8C 86 0198		     ResultSpaceDs:mov Z.EsNew,es
 228E   3   E8 FFA6		     call ResultSpace
				     mv ds,es
 2291   3   06			  1   push es
 2292   3p  1F			  1   pop ds
 2293   3p  8E 86 0198		     mov es,Z.EsNew
				     ; Most times this is simple save/restore of ES but it will also work if
				     ; ES is addressing a segment that compaction moved.
 2297   5   C3			      ret

 2298 52 45 58 58 20 35 2E 30	     Version db "REXX 5.00 22 April 99"
	      30 20 32 32 20
	      41 70 72 69 6C
	      20 39 39
 22AD 44 6F 73 43 72 78 31 2E	     Configuration db "DosCrx1.0 "
	      30 20
 22B7 43 4F 4D 4D 41 4E 44 20	     COMMAND db "COMMAND "; HowInvoked
 22BF 46 55 4E 43 54 49 4F 4E	     FUNCTION db "FUNCTION "; HowInvoked
	      20
 22C8 53 55 42 52 4F 55 54 49	     SUBROUTINE db "SUBROUTINE "; HowInvoked
	      4E 45 20
				      end
Microsoft (R) Macro Assembler Version 6.11		    01/27/12 18:05:59
execute.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

AllocAppend  . . . . . . . . . . . . .	Proc
BackRet  . . . . . . . . . . . . . . .	Proc
Back . . . . . . . . . . . . . . . . .	Proc
CheckType  . . . . . . . . . . . . . .	Proc
CodeModeR  . . . . . . . . . . . . . .	Proc
DownCare . . . . . . . . . . . . . . .	Proc
Down . . . . . . . . . . . . . . . . .	Proc
EvAh . . . . . . . . . . . . . . . . .	Proc
EvRet  . . . . . . . . . . . . . . . .	Proc
JcxzQ  . . . . . . . . . . . . . . . .	Proc
LoopQ  . . . . . . . . . . . . . . . .	Proc
MkMajMin . . . . . . . . . . . . . . .	Func
Move . . . . . . . . . . . . . . . . .	Proc
Mv . . . . . . . . . . . . . . . . . .	Proc
Off  . . . . . . . . . . . . . . . . .	Proc
On . . . . . . . . . . . . . . . . . .	Proc
OpAl . . . . . . . . . . . . . . . . .	Proc
OpRet  . . . . . . . . . . . . . . . .	Proc
PopJunk  . . . . . . . . . . . . . . .	Proc
Pos  . . . . . . . . . . . . . . . . .	Func
Qry  . . . . . . . . . . . . . . . . .	Proc
Repmovsb . . . . . . . . . . . . . . .	Proc
RetSi  . . . . . . . . . . . . . . . .	Proc
Splat  . . . . . . . . . . . . . . . .	Proc
StringOrder  . . . . . . . . . . . . .	Func
TestReg  . . . . . . . . . . . . . . .	Proc
UnCodeMode . . . . . . . . . . . . . .	Proc
UpCare . . . . . . . . . . . . . . . .	Proc
Up . . . . . . . . . . . . . . . . . .	Proc
XlatBDLS . . . . . . . . . . . . . . .	Proc
dec2 . . . . . . . . . . . . . . . . .	Proc
inc2 . . . . . . . . . . . . . . . . .	Proc
la . . . . . . . . . . . . . . . . . .	Proc
move . . . . . . . . . . . . . . . . .	Proc
mv . . . . . . . . . . . . . . . . . .	Proc
top  . . . . . . . . . . . . . . . . .	Proc
xax  . . . . . . . . . . . . . . . . .	Proc
z  . . . . . . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Ashape . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Amount . . . . . . . . . . . . . . .	 0004	     Word
Dshape . . . . . . . . . . . . . . . .	 0028
  TailsAt  . . . . . . . . . . . . . .	 0000	     Word
  Subject  . . . . . . . . . . . . . .	 0000	     QWord
  CVinit . . . . . . . . . . . . . . .	 0000	     QWord
  Reps . . . . . . . . . . . . . . . .	 0000	     QWord
  To . . . . . . . . . . . . . . . . .	 0008	     QWord
  By . . . . . . . . . . . . . . . . .	 0010	     QWord
  ForCount . . . . . . . . . . . . . .	 0018	     QWord
  PcodePos . . . . . . . . . . . . . .	 0020	     Word
  Iteration  . . . . . . . . . . . . .	 0020	     Word
  Leaving  . . . . . . . . . . . . . .	 0022	     Word
  UpDO . . . . . . . . . . . . . . . .	 0024	     Word
  CV . . . . . . . . . . . . . . . . .	 0024	     Word
  Rec  . . . . . . . . . . . . . . . .	 0027	     Byte
EnvBlock . . . . . . . . . . . . . . .	 0008
  EnvNumber  . . . . . . . . . . . . .	 0000	     Word
  EnvResourceI . . . . . . . . . . . .	 0002	     Word
  EnvResourceO . . . . . . . . . . . .	 0004	     Word
  EnvResourceE . . . . . . . . . . . .	 0006	     Word
FarpX  . . . . . . . . . . . . . . . .	 0006
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
Farp . . . . . . . . . . . . . . . . .	 0004
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
Fshape . . . . . . . . . . . . . . . .	 001A
  Flags  . . . . . . . . . . . . . . .	 0000	     Word
  ToQual . . . . . . . . . . . . . . .	 0002	     Word
  Lines  . . . . . . . . . . . . . . .	 0004	     DWord
  Hand . . . . . . . . . . . . . . . .	 0008	     Word
  Other_Position . . . . . . . . . . .	 000A	     DWord
  Exten  . . . . . . . . . . . . . . .	 000E	     Byte
  TraceWidth . . . . . . . . . . . . .	 000F	     Byte
  Symbols  . . . . . . . . . . . . . .	 0010	     Word
  Code . . . . . . . . . . . . . . . .	 0012	     Word
  Vars . . . . . . . . . . . . . . . .	 0014	     Word
  Consts . . . . . . . . . . . . . . .	 0016	     Word
  ProgScope  . . . . . . . . . . . . .	 0018	     Word
Hshape . . . . . . . . . . . . . . . .	 0010
  Hdw0 . . . . . . . . . . . . . . . .	 0000	     DWord
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  Bump . . . . . . . . . . . . . . . .	 0002	     Word
  Avail  . . . . . . . . . . . . . . .	 0004	     Word
  Trigger  . . . . . . . . . . . . . .	 0006	     Word
  Link . . . . . . . . . . . . . . . .	 0008	     Word
  TreeBin  . . . . . . . . . . . . . .	 000A	     Word
  Original . . . . . . . . . . . . . .	 000A	     Word
  UpPool . . . . . . . . . . . . . . .	 000A	     Word
  Probe  . . . . . . . . . . . . . . .	 000C	     Word
  TreeProg . . . . . . . . . . . . . .	 000E	     Word
  Labels . . . . . . . . . . . . . . .	 000E	     Word
InsBlock . . . . . . . . . . . . . . .	 0015
  MajMin . . . . . . . . . . . . . . .	 0000	     Word
  Minor  . . . . . . . . . . . . . . .	 0000	     Byte
  Major  . . . . . . . . . . . . . . .	 0001	     Byte
  Value  . . . . . . . . . . . . . . .	 0002	     Word
  Named  . . . . . . . . . . . . . . .	 0004	     Word
  Position . . . . . . . . . . . . . .	 0004	     Word
  KeysList . . . . . . . . . . . . . .	 0006	     Word
  ArgNum . . . . . . . . . . . . . . .	 0008	     Byte
  Desc . . . . . . . . . . . . . . . .	 0009	     Byte
  Hex  . . . . . . . . . . . . . . . .	 000A	     Byte
  Char . . . . . . . . . . . . . . . .	 000A	     Byte
  Options  . . . . . . . . . . . . . .	 000B	     Word
  OptsHi . . . . . . . . . . . . . . .	 000D	     Word
  Digits . . . . . . . . . . . . . . .	 000F	     Word
  TokPos . . . . . . . . . . . . . . .	 0011	     Word
  TokLen . . . . . . . . . . . . . . .	 0013	     Word
Jshape . . . . . . . . . . . . . . . .	 000E
  Valued . . . . . . . . . . . . . . .	 0000	     QWord
  Pair . . . . . . . . . . . . . . . .	 0008	     DWord
  Lower  . . . . . . . . . . . . . . .	 0008	     Word
  Higher . . . . . . . . . . . . . . .	 000A	     Word
  KeyLen . . . . . . . . . . . . . . .	 000C	     Word
  Key  . . . . . . . . . . . . . . . .	 000E	     Byte
Lshape . . . . . . . . . . . . . . . .	 007C
  DigitsFuzz . . . . . . . . . . . . .	 0000	     DWord
  Digits . . . . . . . . . . . . . . .	 0000	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0002	     Word
  Form . . . . . . . . . . . . . . . .	 0004	     Byte
  StartTime  . . . . . . . . . . . . .	 0005	     QWord
  TraceLetter  . . . . . . . . . . . .	 000D	     Byte
  TraceWord  . . . . . . . . . . . . .	 000D	     Word
  Active . . . . . . . . . . . . . . .	 000F	     QWord
  Alternate  . . . . . . . . . . . . .	 0017	     QWord
  Syntax . . . . . . . . . . . . . . .	 001F	     Byte
  LostDigits . . . . . . . . . . . . .	 0020	     Byte
  NoValue  . . . . . . . . . . . . . .	 0021	     Byte
  NotReady . . . . . . . . . . . . . .	 0022	     Byte
  Error  . . . . . . . . . . . . . . .	 0023	     Byte
  Failure  . . . . . . . . . . . . . .	 0024	     Byte
  Halt . . . . . . . . . . . . . . . .	 0025	     Byte
  TrapName . . . . . . . . . . . . . .	 0026	     Word
  EventLevel . . . . . . . . . . . . .	 0034	     Word
  Condition  . . . . . . . . . . . . .	 0036	     Word
  ConditionDescription . . . . . . . .	 0038	     QWord
  ConditionExtra . . . . . . . . . . .	 0040	     QWord
  Inherit  . . . . . . . . . . . . . .	 0048	     Byte
  ClauseTime . . . . . . . . . . . . .	 0048	     QWord
  ClauseLocal  . . . . . . . . . . . .	 0050	     QWord
  PendingDescription . . . . . . . . .	 0058	     QWord
  PendingExtra . . . . . . . . . . . .	 0060	     QWord
  LevelDO  . . . . . . . . . . . . . .	 0068	     Word
  StackSave  . . . . . . . . . . . . .	 006A	     DWord
  File . . . . . . . . . . . . . . . .	 006E	     Word
  ProgScope  . . . . . . . . . . . . .	 0070	     Word
  VarScope . . . . . . . . . . . . . .	 0072	     Word
  Access . . . . . . . . . . . . . . .	 0074	     Word
  Flags  . . . . . . . . . . . . . . .	 0074	     Word
  UpLevel  . . . . . . . . . . . . . .	 0076	     Word
  Resume . . . . . . . . . . . . . . .	 0078	     Word
  Arg0 . . . . . . . . . . . . . . . .	 007A	     Word
PushShape  . . . . . . . . . . . . . .	 0010
  di_  . . . . . . . . . . . . . . . .	 0000	     Word
  si_  . . . . . . . . . . . . . . . .	 0002	     Word
  bp_  . . . . . . . . . . . . . . . .	 0004	     Word
  sp_  . . . . . . . . . . . . . . . .	 0006	     Word
  bx_  . . . . . . . . . . . . . . . .	 0008	     Word
  bl_  . . . . . . . . . . . . . . . .	 0008	     Byte
  bh_  . . . . . . . . . . . . . . . .	 0009	     Byte
  dx_  . . . . . . . . . . . . . . . .	 000A	     Word
  dl_  . . . . . . . . . . . . . . . .	 000A	     Byte
  dh_  . . . . . . . . . . . . . . . .	 000B	     Byte
  cx_  . . . . . . . . . . . . . . . .	 000C	     Word
  cl_  . . . . . . . . . . . . . . . .	 000C	     Byte
  ch_  . . . . . . . . . . . . . . . .	 000D	     Byte
  ax_  . . . . . . . . . . . . . . . .	 000E	     Word
  al_  . . . . . . . . . . . . . . . .	 000E	     Byte
  ah_  . . . . . . . . . . . . . . . .	 000F	     Byte
Sshape . . . . . . . . . . . . . . . .	 0010
  State  . . . . . . . . . . . . . . .	 0000	     Word
  Parser . . . . . . . . . . . . . . .	 0002	     Word
  ClauseWas  . . . . . . . . . . . . .	 0004	     Word
  Token  . . . . . . . . . . . . . . .	 0006	     Word
  Operation  . . . . . . . . . . . . .	 0008	     DWord
  Caller . . . . . . . . . . . . . . .	 000C	     Word
  Parms  . . . . . . . . . . . . . . .	 000E	     Word
  JumpSite . . . . . . . . . . . . . .	 0006	     Word
  SoFar  . . . . . . . . . . . . . . .	 0008	     Word
  WhatCV . . . . . . . . . . . . . . .	 0008	     Word
  SelectSite . . . . . . . . . . . . .	 0008	     Word
Vshape . . . . . . . . . . . . . . . .	 0008
  String . . . . . . . . . . . . . . .	 0000	     Byte
  Dtype  . . . . . . . . . . . . . . .	 0007	     Byte
  Sign . . . . . . . . . . . . . . . .	 0000	     Byte
  ExpAnd . . . . . . . . . . . . . . .	 0000	     DWord
  ExpoUses . . . . . . . . . . . . . .	 0000	     Byte
  ExpoSign . . . . . . . . . . . . . .	 0003	     Byte
  Mantissa . . . . . . . . . . . . . .	 0004	     DWord
  MantLow  . . . . . . . . . . . . . .	 0004	     Word
  MantHigh . . . . . . . . . . . . . .	 0006	     Word
  OverExpo . . . . . . . . . . . . . .	 0000	     DWord
  OverMant . . . . . . . . . . . . . .	 0004	     DWord
  Fr . . . . . . . . . . . . . . . . .	 0000	     DWord
  Pt . . . . . . . . . . . . . . . . .	 0000	     Word
  Sg . . . . . . . . . . . . . . . . .	 0002	     Word
  Limit  . . . . . . . . . . . . . . .	 0004	     Word
  Len  . . . . . . . . . . . . . . . .	 0004	     Word
  LabelValue . . . . . . . . . . . . .	 0000	     Word
  LabelType  . . . . . . . . . . . . .	 0006	     Word
  WhichCon . . . . . . . . . . . . . .	 0000	     Word
  PcodePos . . . . . . . . . . . . . .	 0002	     Word
  HeldOver . . . . . . . . . . . . . .	 0000	     Word
  Pair . . . . . . . . . . . . . . . .	 0000	     DWord
  Lower  . . . . . . . . . . . . . . .	 0000	     Word
  Higher . . . . . . . . . . . . . . .	 0002	     Word
  Here . . . . . . . . . . . . . . . .	 0004	     Word
Yshape . . . . . . . . . . . . . . . .	 0053
  N1 . . . . . . . . . . . . . . . . .	 0004	     DWord
  N10  . . . . . . . . . . . . . . . .	 0008	     DWord
  N100 . . . . . . . . . . . . . . . .	 000C	     DWord
  N1000  . . . . . . . . . . . . . . .	 0010	     DWord
  N1e4 . . . . . . . . . . . . . . . .	 0014	     DWord
  N1e5 . . . . . . . . . . . . . . . .	 0018	     DWord
  N1e6 . . . . . . . . . . . . . . . .	 001C	     DWord
  N1e7 . . . . . . . . . . . . . . . .	 0020	     DWord
  N1e8 . . . . . . . . . . . . . . . .	 0024	     DWord
  N1e9 . . . . . . . . . . . . . . . .	 0028	     DWord
  N1664525 . . . . . . . . . . . . . .	 002C	     DWord
  ExponHi  . . . . . . . . . . . . . .	 0030	     DWord
  ExponLo  . . . . . . . . . . . . . .	 0034	     DWord
  Cseg . . . . . . . . . . . . . . . .	 0038	     Word
  DOS  . . . . . . . . . . . . . . . .	 003A	     DWord
  DosPool  . . . . . . . . . . . . . .	 003E	     Byte
  DqCrLf . . . . . . . . . . . . . . .	 004C	     Byte
  CrLf . . . . . . . . . . . . . . . .	 004D	     Byte
  StackSave  . . . . . . . . . . . . .	 004F	     DWord
Zshape . . . . . . . . . . . . . . . .	 137C
  w  . . . . . . . . . . . . . . . . .	 0000	     Word
  SegSize  . . . . . . . . . . . . . .	 0000	     Word
  ProgramCancel  . . . . . . . . . . .	 0002	     DWord
  Program  . . . . . . . . . . . . . .	 0002	     Word
  Cancel . . . . . . . . . . . . . . .	 0004	     Word
  Stack  . . . . . . . . . . . . . . .	 0006	     Word
  ClauseLine . . . . . . . . . . . . .	 0008	     Word
  Middles  . . . . . . . . . . . . . .	 000A	     Word
  Clause . . . . . . . . . . . . . . .	 000C	     Word
  Gen  . . . . . . . . . . . . . . . .	 000E	     Word
  KWMiddle . . . . . . . . . . . . . .	 0010	     Word
  KWFound  . . . . . . . . . . . . . .	 0012	     Word
  Stdout . . . . . . . . . . . . . . .	 0014	     Word
  Stderr . . . . . . . . . . . . . . .	 0016	     Word
  SourceHandle . . . . . . . . . . . .	 0018	     Word
  HowInvoked . . . . . . . . . . . . .	 001A	     Word
  Radix  . . . . . . . . . . . . . . .	 001C	     Byte
  AxAsNum  . . . . . . . . . . . . . .	 001D	     Byte
  Tag  . . . . . . . . . . . . . . . .	 0023	     Byte
  Seed . . . . . . . . . . . . . . . .	 0028	     DWord
  ParseResetSp . . . . . . . . . . . .	 002C	     Word
  XCycleResetSp  . . . . . . . . . . .	 002E	     Word
  Dumper . . . . . . . . . . . . . . .	 0030	     Word
  Stash  . . . . . . . . . . . . . . .	 0032	     Word
  Resolved . . . . . . . . . . . . . .	 0034	     Word
  Cursor . . . . . . . . . . . . . . .	 0036	     Word
  Stream . . . . . . . . . . . . . . .	 0038	     Word
  Queue  . . . . . . . . . . . . . . .	 003A	     Word
  InsSource  . . . . . . . . . . . . .	 003C	     DWord
  SysFile  . . . . . . . . . . . . . .	 003C	     DWord
  File . . . . . . . . . . . . . . . .	 003C	     Word
  SysFiles . . . . . . . . . . . . . .	 003E	     Word
  Consts . . . . . . . . . . . . . . .	 0040	     Word
  Vars . . . . . . . . . . . . . . . .	 0042	     Word
  ProgScope  . . . . . . . . . . . . .	 0044	     Word
  VarScope . . . . . . . . . . . . . .	 0046	     Word
  Symbols  . . . . . . . . . . . . . .	 0048	     Word
  Code . . . . . . . . . . . . . . . .	 004A	     Word
  Zone . . . . . . . . . . . . . . . .	 004C	     Word
  Stem . . . . . . . . . . . . . . . .	 004E	     Word
  PoolPool . . . . . . . . . . . . . .	 0050	     Word
  Level  . . . . . . . . . . . . . . .	 0052	     Word
  Base0  . . . . . . . . . . . . . . .	 0054	     Word
  CurrentDO  . . . . . . . . . . . . .	 0056	     Word
  ResumeP  . . . . . . . . . . . . . .	 0058	     Word
  ResumeDF . . . . . . . . . . . . . .	 005A	     DWord
  ResumeD  . . . . . . . . . . . . . .	 005A	     Word
  ResumeF  . . . . . . . . . . . . . .	 005C	     Word
  ResumeS  . . . . . . . . . . . . . .	 005E	     Byte
  DigitsFuzz . . . . . . . . . . . . .	 005F	     DWord
  Digits . . . . . . . . . . . . . . .	 005F	     Word
  Fuzz . . . . . . . . . . . . . . . .	 0061	     Word
  Ceiling  . . . . . . . . . . . . . .	 0063	     DWord
  DivBreak . . . . . . . . . . . . . .	 0067	     DWord
  TwiceDigits  . . . . . . . . . . . .	 006B	     DWord
  UseGeneral . . . . . . . . . . . . .	 006F	     Word
  InsLine  . . . . . . . . . . . . . .	 0071	     Word
  InsBif . . . . . . . . . . . . . . .	 0073	     Byte
  InsOperator  . . . . . . . . . . . .	 0074	     DWord
  InsUnqual  . . . . . . . . . . . . .	 0078	     Word
  Insert . . . . . . . . . . . . . . .	 007A	      0015
  Inserts  . . . . . . . . . . . . . .	 008F	      0015
  SignM  . . . . . . . . . . . . . . .	 00A4	     Byte
  SignE  . . . . . . . . . . . . . . .	 00A5	     Byte
  MantPos  . . . . . . . . . . . . . .	 00A6	     Word
  MantPosZi  . . . . . . . . . . . . .	 00A8	     Word
  ExpPos . . . . . . . . . . . . . . .	 00AA	     Word
  ExpPosZi . . . . . . . . . . . . . .	 00AC	     Word
  ExpSign  . . . . . . . . . . . . . .	 00AE	     Word
  MantSize . . . . . . . . . . . . . .	 00B0	     Word
  OpIs . . . . . . . . . . . . . . . .	 00B2	     Byte
  Flags  . . . . . . . . . . . . . . .	 00B3	     Byte
  BifParmsHi . . . . . . . . . . . . .	 00B4	     Byte
  BifByte  . . . . . . . . . . . . . .	 00B5	     Byte
  TraceAlign . . . . . . . . . . . . .	 00B6	     DWord
  TraceSource  . . . . . . . . . . . .	 00BA	     DWord
  TraceEnds  . . . . . . . . . . . . .	 00BE	     DWord
  TraceSourceColumn  . . . . . . . . .	 00C2	     Word
  TraceEndsColumn  . . . . . . . . . .	 00C4	     Word
  DualCode . . . . . . . . . . . . . .	 00C6	     Word
  TraceOp  . . . . . . . . . . . . . .	 00C8	     Byte
  Relative . . . . . . . . . . . . . .	 00C9	     DWord
  RelativeNow  . . . . . . . . . . . .	 00CD	     DWord
  Continue . . . . . . . . . . . . . .	 00D1	     Word
  StackX . . . . . . . . . . . . . . .	 00D3	     Word
  TraceLine  . . . . . . . . . . . . .	 00D5	     Word
  InhibitTrace . . . . . . . . . . . .	 00D7	     DWord
  InhibitPauses  . . . . . . . . . . .	 00DB	     DWord
  Target . . . . . . . . . . . . . . .	 00DF	     Word
  Scanp  . . . . . . . . . . . . . . .	 00E1	     Word
  EndUsedBuffer  . . . . . . . . . . .	 00E3	     Word
  NearEnd  . . . . . . . . . . . . . .	 00E5	     Word
  CatOp  . . . . . . . . . . . . . . .	 00E7	     Byte
  RadixBadWhite  . . . . . . . . . . .	 00E8	     Byte
  BackExponent . . . . . . . . . . . .	 00E9	     Word
  LastContent  . . . . . . . . . . . .	 00EB	     Word
  CommaLine  . . . . . . . . . . . . .	 00ED	     Word
  Condition  . . . . . . . . . . . . .	 00EF	     Word
  UntilPlace . . . . . . . . . . . . .	 00F1	     Word
  StemSym  . . . . . . . . . . . . . .	 00F3	     Word
  SoFar  . . . . . . . . . . . . . . .	 00F5	     Word
  PcodePos . . . . . . . . . . . . . .	 00F7	     Word
  TraceOnly  . . . . . . . . . . . . .	 00F9	     Word
  CompareAt  . . . . . . . . . . . . .	 00FB	     Word
  StackHi  . . . . . . . . . . . . . .	 00FD	     Word
  StackLo  . . . . . . . . . . . . . .	 00FF	     Word
  OnSoft . . . . . . . . . . . . . . .	 0101	     Word
  Tail . . . . . . . . . . . . . . . .	 0103	     Word
  TokNum . . . . . . . . . . . . . . .	 0105	     Word
  TokNow . . . . . . . . . . . . . . .	 0107	     Word
  TokWas . . . . . . . . . . . . . . .	 0109	     Word
  TokData  . . . . . . . . . . . . . .	 010B	     Word
  Synch  . . . . . . . . . . . . . . .	 010D	     Word
  Lines  . . . . . . . . . . . . . . .	 010F	     Word
  MsgBegin . . . . . . . . . . . . . .	 0111	     Word
  MsgSoFar . . . . . . . . . . . . . .	 0113	     Word
  PreZi  . . . . . . . . . . . . . . .	 0115	     Word
  TargetMajMin . . . . . . . . . . . .	 0117	     Word
  TargetMinor  . . . . . . . . . . . .	 0117	     Byte
  TargetMajor  . . . . . . . . . . . .	 0118	     Byte
  EnvSeg . . . . . . . . . . . . . . .	 0119	     Word
  ForPSP . . . . . . . . . . . . . . .	 011B	     DWord
  Fcb1 . . . . . . . . . . . . . . . .	 011F	     DWord
  Fcb2 . . . . . . . . . . . . . . . .	 0123	     DWord
  AtPause  . . . . . . . . . . . . . .	 0127	     Word
  ArgsB  . . . . . . . . . . . . . . .	 0129	     Byte
  ArgsB0 . . . . . . . . . . . . . . .	 012A	     Word
  Parsee . . . . . . . . . . . . . . .	 012C	     FWord
  ParseeNum  . . . . . . . . . . . . .	 0132	     Word
  PattLenEtc . . . . . . . . . . . . .	 0134	     Word
  BreakStart . . . . . . . . . . . . .	 0136	     Word
  BreakEnd . . . . . . . . . . . . . .	 0138	     Word
  EnvNow . . . . . . . . . . . . . . .	 013A	     QWord
  CatTotal . . . . . . . . . . . . . .	 0142	     Word
  LastTarget . . . . . . . . . . . . .	 0144	     Word
  NewJshape  . . . . . . . . . . . . .	 0146	     Word
  FromDos  . . . . . . . . . . . . . .	 0148	     Word
  FromDosWas . . . . . . . . . . . . .	 014A	     Word
  FromDosZi  . . . . . . . . . . . . .	 014C	     Word
  MemoryTable  . . . . . . . . . . . .	 014E	     FWord
  MemoryTableZi  . . . . . . . . . . .	 018A	     Byte
  Left . . . . . . . . . . . . . . . .	 018A	     Word
  Right  . . . . . . . . . . . . . . .	 018C	     Word
  AllocBase  . . . . . . . . . . . . .	 018E	     DWord
  DsWas  . . . . . . . . . . . . . . .	 0192	     Word
  DsNew  . . . . . . . . . . . . . . .	 0194	     Word
  EsWas  . . . . . . . . . . . . . . .	 0196	     Word
  EsNew  . . . . . . . . . . . . . . .	 0198	     Word
  FsWas  . . . . . . . . . . . . . . .	 019A	     Word
  FsNew  . . . . . . . . . . . . . . .	 019C	     Word
  GsWas  . . . . . . . . . . . . . . .	 019E	     Word
  GsNew  . . . . . . . . . . . . . . .	 01A0	     Word
  DebugStash . . . . . . . . . . . . .	 01A2	     Word
  DebugD . . . . . . . . . . . . . . .	 01A4	     DWord
  DigitCount . . . . . . . . . . . . .	 01A8	     Word
  SerialNow  . . . . . . . . . . . . .	 01AA	     Byte
  Serial . . . . . . . . . . . . . . .	 01AB	     Byte
  CommandArg . . . . . . . . . . . . .	 1374	     QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

CancelRec  . . . . . . . . . . . . . .	 0010	   0010
  Format5  . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  AssignDO . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ForExpose  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FromIterCV . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  ForBIF . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  TokIsValue . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  ExpRange . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Description  . . . . . . . . . . . .	 0008	   0001	     0100     ?
  Compacted  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  BcodeInterpret . . . . . . . . . . .	 0006	   0001	     0040     ?
  MapOnly  . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ParseUpper . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ParseTrace . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  SourceFiles  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  BoolBefore . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  WasDropped . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ClauseRec  . . . . . . . . . . . . . .	 0010	   0010
  WasUpper . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  OffFlag  . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Condition  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  Append . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Signal . . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ClauseSet  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  CVar . . . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  Repit  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PosEq  . . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NotAssign  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  WasParse . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  InParse  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  Tailed . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  WasTailed  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PosPlus  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PosMinus . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ConditionRec . . . . . . . . . . . . .	 0008	   0005
  Enabling . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  Delayed  . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PendingNow . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  Instruction  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  CRspare  . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ErrorRec . . . . . . . . . . . . . . .	 0010	   0004
  HasShiftOn . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAloneOn . . . . . . . . . . . .	 000E	   0001	     4000     ?
  MajorField . . . . . . . . . . . . .	 0006	   0008	     3FC0     ?
  MinorField . . . . . . . . . . . . .	 0000	   0006	     003F     ?
FRec . . . . . . . . . . . . . . . . .	 0010	   0009
  Qual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Read . . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  Open . . . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  BeenRead . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  BeenWrite  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  WriteMode  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  IsSource . . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  BeenCompiled . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FFpad  . . . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
GenRec . . . . . . . . . . . . . . . .	 0010	   0005
  Dual . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  DualPending  . . . . . . . . . . . .	 000E	   0001	     4000     ?
  DualGen  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  DualOnly . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  GenSpare . . . . . . . . . . . . . .	 0000	   000C	     0FFF     ?
KeyRec . . . . . . . . . . . . . . . .	 0008	   0003
  KeyFlags . . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  EndList  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KeyLen . . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
LevelRecI  . . . . . . . . . . . . . .	 0010	   0003
  LIPad  . . . . . . . . . . . . . . .	 0002	   000E	     FFFC     ?
  Interactive  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ConditionInstruction . . . . . . . .	 0000	   0001	     0001     ?
LevelRec . . . . . . . . . . . . . . .	 0010	   0007
  Lpad . . . . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  InheritDone  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DigitsSet  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IsProcedure  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IsExternal . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IsFunction . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  Lpad2  . . . . . . . . . . . . . . .	 0000	   0003	     0007     ?
LoopsRec . . . . . . . . . . . . . . .	 0008	   0007
  LoopsPad . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  HasDot . . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  HasDots  . . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  HasTo  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  HasFor . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IsInterp . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  ByDown . . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MiddleRec  . . . . . . . . . . . . . .	 0010	   0010
  NotLabel . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  SemiAfter  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  ValueBefore  . . . . . . . . . . . .	 000D	   0001	     2000     ?
  AbutOK . . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  NoBlanks . . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  ModEquals  . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  EndClause  . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  ImplicitValue  . . . . . . . . . . .	 0008	   0001	     0100     ?
  CheckDO  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TargetSymbol . . . . . . . . . . . .	 0006	   0001	     0040     ?
  Function . . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  TakenConstant  . . . . . . . . . . .	 0004	   0001	     0010     ?
  LookLabel  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LookBin  . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DotOK  . . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  MRspare  . . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OperatorRec  . . . . . . . . . . . . .	 0008	   0006
  InTypes  . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ResultType . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  AppendNum  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  AppendRef  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DownOne  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  EndsClause . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ParmsRec . . . . . . . . . . . . . . .	 0008	   0003
  ParmsMin . . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ParmsXtr . . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  NonCheck . . . . . . . . . . . . . .	 0000	   0004	     000F     ?
ParserRec  . . . . . . . . . . . . . .	 0010	   0005
  ParserPad  . . . . . . . . . . . . .	 0004	   000C	     FFF0     ?
  DoRep  . . . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DoCV . . . . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  Forever  . . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DoDataHost . . . . . . . . . . . . .	 0000	   0001	     0001     ?
ProgramRec . . . . . . . . . . . . . .	 0010	   000B
  API_Enabled  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  Repass . . . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  LabelsBad  . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  FirstBetween . . . . . . . . . . . .	 000C	   0001	     1000     ?
  EndSource  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  BifCheck . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  RandomSeeded . . . . . . . . . . . .	 0009	   0001	     0200     ?
  NotS9  . . . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  TraceIF  . . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ShowELSE . . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PRSpare  . . . . . . . . . . . . . .	 0000	   0006	     003F     ?
RedRec . . . . . . . . . . . . . . . .	 0010	   0005
  HasShiftOff  . . . . . . . . . . . .	 000F	   0001	     8000     ?
  HasAction  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PruneCt  . . . . . . . . . . . . . .	 000C	   0002	     3000     ?
  Rtype  . . . . . . . . . . . . . . .	 000A	   0002	     0C00     ?
  Rstate . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
ShiftRec . . . . . . . . . . . . . . .	 0010	   0008
  HasShift . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  ErrorAlone . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  CatFlag  . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  HasKeys  . . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  Reference  . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  Direct . . . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  Indexb . . . . . . . . . . . . . . .	 0005	   0005	     03E0     ?
  Index  . . . . . . . . . . . . . . .	 0000	   0005	     001F     ?
TokRec . . . . . . . . . . . . . . . .	 0010	   0003
  X02  . . . . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  NdxbT  . . . . . . . . . . . . . . .	 000A	   0005	     7C00     ?
  Aim  . . . . . . . . . . . . . . . .	 0000	   000A	     03FF     ?
TokVal . . . . . . . . . . . . . . . .	 0008	   0002
  GrpNdx . . . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SubNum . . . . . . . . . . . . . . .	 0000	   0002	     0003     ?


Types:

                N a m e                  Size     Attr

Boolp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
Bool . . . . . . . . . . . . . . . . .	 0001	  Byte 
Handlep  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Handle . . . . . . . . . . . . . . . .	 0002	  Word 
Segp . . . . . . . . . . . . . . . . .	 0002	  Word 
Ulong  . . . . . . . . . . . . . . . .	 0004	  DWord 
Ushortp  . . . . . . . . . . . . . . .	 0002	  PTR Word 
Ushort . . . . . . . . . . . . . . . .	 0002	  Word 
bytep  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
charfp . . . . . . . . . . . . . . . .	 0004	  FarPTR Byte 
charp  . . . . . . . . . . . . . . . .	 0002	  PTR Byte 
char . . . . . . . . . . . . . . . . .	 0001	  Byte 
shortp . . . . . . . . . . . . . . . .	 0002	  PTR Word 
short  . . . . . . . . . . . . . . . .	 0002	  Word 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
MyGroup  . . . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . . . . .	16 Bit	 22D3	  Word	  Public  'CODE'	
FanSeg . . . . . . . . . . . . . . . .	16 Bit	 00C4	  Word	  Public  'CODE'	


Symbols:

                N a m e                 Type     Value    Attr

$0 . . . . . . . . . . . . . . . . . .	Number	 0000h	 
$10  . . . . . . . . . . . . . . . . .	Number	 0007h	 
$11  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$12  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$15  . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$16  . . . . . . . . . . . . . . . . .	Number	 0017h	 
$17  . . . . . . . . . . . . . . . . .	Number	 0019h	 
$18  . . . . . . . . . . . . . . . . .	Number	 0018h	 
$19  . . . . . . . . . . . . . . . . .	Number	 001Ah	 
$1 . . . . . . . . . . . . . . . . . .	Number	 0013h	 
$21  . . . . . . . . . . . . . . . . .	Number	 0016h	 
$23  . . . . . . . . . . . . . . . . .	Number	 001Eh	 
$28  . . . . . . . . . . . . . . . . .	Number	 0012h	 
$2 . . . . . . . . . . . . . . . . . .	Number	 0015h	 
$3 . . . . . . . . . . . . . . . . . .	Number	 0004h	 
$5 . . . . . . . . . . . . . . . . . .	Number	 0006h	 
$6 . . . . . . . . . . . . . . . . . .	Number	 0003h	 
$7 . . . . . . . . . . . . . . . . . .	Number	 000Eh	 
$8 . . . . . . . . . . . . . . . . . .	Number	 0014h	 
$9 . . . . . . . . . . . . . . . . . .	Number	 0009h	 
$?BIF  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$?CLAUSELOCAL  . . . . . . . . . . . .	Number	 007Ch	 
$?CLAUSETIME . . . . . . . . . . . . .	Number	 0074h	 
$?Discard  . . . . . . . . . . . . . .	Number	 0010h	 
$?E  . . . . . . . . . . . . . . . . .	Number	 00B4h	 
$?LINEIN_POSITION  . . . . . . . . . .	Number	 006Ch	 
$?MN . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$?MONTHS . . . . . . . . . . . . . . .	Number	 0084h	 
$?Nine . . . . . . . . . . . . . . . .	Number	 009Ch	 
$?Null . . . . . . . . . . . . . . . .	Number	 00ACh	 
$?OUTCOME  . . . . . . . . . . . . . .	Number	 0044h	 
$?Omitted  . . . . . . . . . . . . . .	Number	 0014h	 
$?RCx  . . . . . . . . . . . . . . . .	Number	 0028h	 
$?RC . . . . . . . . . . . . . . . . .	Number	 0034h	 
$?RESPONSE . . . . . . . . . . . . . .	Number	 0064h	 
$?RESULTx  . . . . . . . . . . . . . .	Number	 0020h	 
$?RESULT . . . . . . . . . . . . . . .	Number	 002Ch	 
$?RS . . . . . . . . . . . . . . . . .	Number	 0024h	 
$?SIGLx  . . . . . . . . . . . . . . .	Number	 0030h	 
$?SIGL . . . . . . . . . . . . . . . .	Number	 003Ch	 
$?STARTTIME  . . . . . . . . . . . . .	Number	 0094h	 
$?STREAMSTATE  . . . . . . . . . . . .	Number	 005Ch	 
$?STREAM . . . . . . . . . . . . . . .	Number	 0054h	 
$?SysVars  . . . . . . . . . . . . . .	Number	 0044h	 
$?S  . . . . . . . . . . . . . . . . .	Number	 00BCh	 
$?WEEKDAYS . . . . . . . . . . . . . .	Number	 008Ch	 
$?Zero . . . . . . . . . . . . . . . .	Number	 00A4h	 
$ADDRESS . . . . . . . . . . . . . . .	Number	 008Ch	 
$APPEND  . . . . . . . . . . . . . . .	Number	 0090h	 
$ARG . . . . . . . . . . . . . . . . .	Number	 0088h	 
$Abut  . . . . . . . . . . . . . . . .	Number	 004Ch	 
$And . . . . . . . . . . . . . . . . .	Number	 0018h	 
$Ashapes . . . . . . . . . . . . . . .	Number	 000Ah	 
$Assign  . . . . . . . . . . . . . . .	Number	 0054h	 
$Asterisk  . . . . . . . . . . . . . .	Number	 0011h	 
$AttribAnd . . . . . . . . . . . . . .	Number	 00D8h	 
$AttribComma . . . . . . . . . . . . .	Number	 00DCh	 
$AttribEq  . . . . . . . . . . . . . .	Number	 00EBh	 
$AttribGt  . . . . . . . . . . . . . .	Number	 00F0h	 
$AttribLine  . . . . . . . . . . . . .	Number	 00E7h	 
$AttribLt  . . . . . . . . . . . . . .	Number	 00EDh	 
$AttribMinus . . . . . . . . . . . . .	Number	 00E4h	 
$AttribOr  . . . . . . . . . . . . . .	Number	 00D5h	 
$AttribPlus  . . . . . . . . . . . . .	Number	 00E5h	 
$AttribSlash . . . . . . . . . . . . .	Number	 00D2h	 
$AttribStar  . . . . . . . . . . . . .	Number	 00D1h	 
$AwayString  . . . . . . . . . . . . .	Number	 00C0h	 
$BPcodesCeil . . . . . . . . . . . . .	Number	 005Dh	 
$BY  . . . . . . . . . . . . . . . . .	Number	 006Ch	 
$Bb  . . . . . . . . . . . . . . . . .	Number	 0004h	 
$BcodesBase  . . . . . . . . . . . . .	Number	 00B3h	 
$BifABBREV . . . . . . . . . . . . . .	Number	 0014h	 
$BifABS  . . . . . . . . . . . . . . .	Number	 002Ah	 
$BifADDRESS  . . . . . . . . . . . . .	Number	 0020h	 
$BifARG  . . . . . . . . . . . . . . .	Number	 0021h	 
$BifB2X  . . . . . . . . . . . . . . .	Number	 002Dh	 
$BifBITAND . . . . . . . . . . . . . .	Number	 0034h	 
$BifBITOR  . . . . . . . . . . . . . .	Number	 0035h	 
$BifBITXOR . . . . . . . . . . . . . .	Number	 0036h	 
$BifBase . . . . . . . . . . . . . . .	Number	 FFB9h	 
$BifC2D  . . . . . . . . . . . . . . .	Number	 0031h	 
$BifC2X  . . . . . . . . . . . . . . .	Number	 002Ch	 
$BifCENTER . . . . . . . . . . . . . .	Number	 0015h	 
$BifCENTRE . . . . . . . . . . . . . .	Number	 0016h	 
$BifCHANGESTR  . . . . . . . . . . . .	Number	 0042h	 
$BifCHARIN . . . . . . . . . . . . . .	Number	 0004h	 
$BifCHAROUT  . . . . . . . . . . . . .	Number	 0005h	 
$BifCHARS  . . . . . . . . . . . . . .	Number	 0003h	 
$BifCOMPARE  . . . . . . . . . . . . .	Number	 0017h	 
$BifCONDITION  . . . . . . . . . . . .	Number	 0022h	 
$BifCOPIES . . . . . . . . . . . . . .	Number	 0038h	 
$BifCOUNTSTR . . . . . . . . . . . . .	Number	 0041h	 
$BifD2C  . . . . . . . . . . . . . . .	Number	 0032h	 
$BifD2X  . . . . . . . . . . . . . . .	Number	 0033h	 
$BifDATATYPE . . . . . . . . . . . . .	Number	 001Fh	 
$BifDATE . . . . . . . . . . . . . . .	Number	 0000h	 
$BifDELSTR . . . . . . . . . . . . . .	Number	 0018h	 
$BifDELWORD  . . . . . . . . . . . . .	Number	 0019h	 
$BifDIGITS . . . . . . . . . . . . . .	Number	 0025h	 
$BifERRORTEXT  . . . . . . . . . . . .	Number	 000Eh	 
$BifFORMAT . . . . . . . . . . . . . .	Number	 0011h	 
$BifFORM . . . . . . . . . . . . . . .	Number	 001Eh	 
$BifFUZZ . . . . . . . . . . . . . . .	Number	 0024h	 
$BifINSERT . . . . . . . . . . . . . .	Number	 001Ch	 
$BifLASTPOS  . . . . . . . . . . . . .	Number	 001Bh	 
$BifLEFT . . . . . . . . . . . . . . .	Number	 003Dh	 
$BifLENGTH . . . . . . . . . . . . . .	Number	 0043h	 
$BifLINEIN . . . . . . . . . . . . . .	Number	 0006h	 
$BifLINEOUT  . . . . . . . . . . . . .	Number	 0007h	 
$BifLINES  . . . . . . . . . . . . . .	Number	 0002h	 
$BifMAX  . . . . . . . . . . . . . . .	Number	 0044h	 
$BifMIN  . . . . . . . . . . . . . . .	Number	 0045h	 
$BifOVERLAY  . . . . . . . . . . . . .	Number	 001Dh	 
$BifPOS  . . . . . . . . . . . . . . .	Number	 003Ch	 
$BifQUALIFY  . . . . . . . . . . . . .	Number	 000Bh	 
$BifQUEUED . . . . . . . . . . . . . .	Number	 003Fh	 
$BifRANDOM . . . . . . . . . . . . . .	Number	 0028h	 
$BifREVERSE  . . . . . . . . . . . . .	Number	 0029h	 
$BifRIGHT  . . . . . . . . . . . . . .	Number	 001Ah	 
$BifSIGN . . . . . . . . . . . . . . .	Number	 002Bh	 
$BifSOURCELINE . . . . . . . . . . . .	Number	 0026h	 
$BifSPACE  . . . . . . . . . . . . . .	Number	 000Fh	 
$BifSTREAM . . . . . . . . . . . . . .	Number	 0008h	 
$BifSTRIP  . . . . . . . . . . . . . .	Number	 0009h	 
$BifSUBSTR . . . . . . . . . . . . . .	Number	 003Eh	 
$BifSUBWORD  . . . . . . . . . . . . .	Number	 003Bh	 
$BifSYMBOL . . . . . . . . . . . . . .	Number	 0040h	 
$BifTIME . . . . . . . . . . . . . . .	Number	 0001h	 
$BifTRACE  . . . . . . . . . . . . . .	Number	 0023h	 
$BifTRANSLATE  . . . . . . . . . . . .	Number	 0010h	 
$BifTRUNC  . . . . . . . . . . . . . .	Number	 000Dh	 
$BifTag  . . . . . . . . . . . . . . .	Number	 0080h	 
$BifVALUE  . . . . . . . . . . . . . .	Number	 0037h	 
$BifVERIFY . . . . . . . . . . . . . .	Number	 000Ah	 
$BifWORDINDEX  . . . . . . . . . . . .	Number	 003Ah	 
$BifWORDLENGTH . . . . . . . . . . . .	Number	 0012h	 
$BifWORDPOS  . . . . . . . . . . . . .	Number	 0013h	 
$BifWORDS  . . . . . . . . . . . . . .	Number	 000Ch	 
$BifWORD . . . . . . . . . . . . . . .	Number	 0039h	 
$BifX2B  . . . . . . . . . . . . . . .	Number	 002Eh	 
$BifX2C  . . . . . . . . . . . . . . .	Number	 002Fh	 
$BifX2D  . . . . . . . . . . . . . . .	Number	 0030h	 
$BifXRANGE . . . . . . . . . . . . . .	Number	 0027h	 
$Bin . . . . . . . . . . . . . . . . .	Number	 0024h	 
$CALL  . . . . . . . . . . . . . . . .	Number	 0094h	 
$CONST_SYMBOL  . . . . . . . . . . . .	Number	 0040h	 
$CaseTarget  . . . . . . . . . . . . .	Number	 0006h	 
$Cat . . . . . . . . . . . . . . . . .	Number	 004Dh	 
$Colon . . . . . . . . . . . . . . . .	Number	 000Ah	 
$Comma . . . . . . . . . . . . . . . .	Number	 001Ch	 
$Constant  . . . . . . . . . . . . . .	Number	 008Ah	 
$Cr  . . . . . . . . . . . . . . . . .	Text   	 0dh
$DIGITS  . . . . . . . . . . . . . . .	Number	 00E4h	 
$DO  . . . . . . . . . . . . . . . . .	Number	 0098h	 
$DROP  . . . . . . . . . . . . . . . .	Number	 00B8h	 
$Desc59H . . . . . . . . . . . . . . .	Number	 000Bh	 
$DescArgs  . . . . . . . . . . . . . .	Number	 000Ah	 
$DescFiles . . . . . . . . . . . . . .	Number	 000Ch	 
$DescQueue . . . . . . . . . . . . . .	Number	 000Dh	 
$DescString  . . . . . . . . . . . . .	Number	 0005h	 
$Descriptions  . . . . . . . . . . . .	Number	 0037h	 
$Digit . . . . . . . . . . . . . . . .	Number	 0040h	 
$DosAllocate . . . . . . . . . . . . .	Number	 0048h	 
$DosChmod  . . . . . . . . . . . . . .	Number	 0043h	 
$DosClose  . . . . . . . . . . . . . .	Number	 003Eh	 
$DosCreate . . . . . . . . . . . . . .	Number	 003Ch	 
$DosDate . . . . . . . . . . . . . . .	Number	 002Ah	 
$DosDelete . . . . . . . . . . . . . .	Number	 0041h	 
$DosDisk . . . . . . . . . . . . . . .	Number	 0019h	 
$DosExecute  . . . . . . . . . . . . .	Number	 004Bh	 
$DosExit . . . . . . . . . . . . . . .	Number	 004Ch	 
$DosFree . . . . . . . . . . . . . . .	Number	 0049h	 
$DosGetError . . . . . . . . . . . . .	Number	 0059h	 
$DosModifyAllocated  . . . . . . . . .	Number	 004Ah	 
$DosOpen . . . . . . . . . . . . . . .	Number	 003Dh	 
$DosPSP  . . . . . . . . . . . . . . .	Number	 0062h	 
$DosPath . . . . . . . . . . . . . . .	Number	 0047h	 
$DosRead . . . . . . . . . . . . . . .	Number	 003Fh	 
$DosReturnCode . . . . . . . . . . . .	Number	 004Dh	 
$DosSeek . . . . . . . . . . . . . . .	Number	 0042h	 
$DosTime . . . . . . . . . . . . . . .	Number	 002Ch	 
$DosWrite  . . . . . . . . . . . . . .	Number	 0040h	 
$Dropped . . . . . . . . . . . . . . .	Number	 0040h	 
$ELSE  . . . . . . . . . . . . . . . .	Number	 009Ch	 
$END . . . . . . . . . . . . . . . . .	Number	 005Ch	 
$ENGINEERING . . . . . . . . . . . . .	Number	 00ECh	 
$ERROR . . . . . . . . . . . . . . . .	Number	 00CCh	 
$EXIT  . . . . . . . . . . . . . . . .	Number	 00A8h	 
$EXPOSE  . . . . . . . . . . . . . . .	Number	 00BCh	 
$Ee  . . . . . . . . . . . . . . . . .	Number	 0001h	 
$EndBuffer . . . . . . . . . . . . . .	Number	 000Ah	 
$Eof . . . . . . . . . . . . . . . . .	Text   	 1ah
$Eos . . . . . . . . . . . . . . . . .	Number	 0000h	 
$Eq  . . . . . . . . . . . . . . . . .	Number	 002Bh	 
$Exposed . . . . . . . . . . . . . . .	Number	 0050h	 
$FAILURE . . . . . . . . . . . . . . .	Number	 00C9h	 
$FOREVER . . . . . . . . . . . . . . .	Number	 0118h	 
$FORM  . . . . . . . . . . . . . . . .	Number	 00E8h	 
$FOR . . . . . . . . . . . . . . . . .	Number	 0064h	 
$FUZZ  . . . . . . . . . . . . . . . .	Number	 00E5h	 
$FileBufferSize  . . . . . . . . . . .	Number	 0400h	 
$Ge  . . . . . . . . . . . . . . . . .	Number	 002Fh	 
$Group . . . . . . . . . . . . . . . .	Number	 00FCh	 
$Gt  . . . . . . . . . . . . . . . . .	Number	 0030h	 
$HALT  . . . . . . . . . . . . . . . .	Number	 00CAh	 
$Hex . . . . . . . . . . . . . . . . .	Number	 001Ch	 
$IF  . . . . . . . . . . . . . . . . .	Number	 00D4h	 
$INPUT . . . . . . . . . . . . . . . .	Number	 00D8h	 
$INTERPRET . . . . . . . . . . . . . .	Number	 00A4h	 
$ITERATE . . . . . . . . . . . . . . .	Number	 00B5h	 
$InitStackSize . . . . . . . . . . . .	Number	 2000h	 
$Invalid . . . . . . . . . . . . . . .	Number	 0009h	 
$LEAVE . . . . . . . . . . . . . . . .	Number	 00B4h	 
$LINEIN  . . . . . . . . . . . . . . .	Number	 007Ch	 
$LOSTDIGITS  . . . . . . . . . . . . .	Number	 00C5h	 
$Label . . . . . . . . . . . . . . . .	Number	 008Bh	 
$Leeway  . . . . . . . . . . . . . . .	Number	 0003h	 
$Letter  . . . . . . . . . . . . . . .	Number	 0080h	 
$Le  . . . . . . . . . . . . . . . . .	Number	 002Eh	 
$Lf  . . . . . . . . . . . . . . . . .	Text   	 0ah
$Limit_Digits  . . . . . . . . . . . .	Number	 270Fh	 
$Limit_EnvironmentName . . . . . . . .	Number	 000Ah	 
$Limit_ExponentDigits  . . . . . . . .	Number	 0009h	 
$Limit_Insert  . . . . . . . . . . . .	Number	 0032h	 
$Limit_Literal . . . . . . . . . . . .	Number	 00FAh	 
$Limit_Major . . . . . . . . . . . . .	Number	 0036h	 
$Limit_Name  . . . . . . . . . . . . .	Number	 00FAh	 
$Limit_String  . . . . . . . . . . . .	Number	 C350h	 
$LineFeed  . . . . . . . . . . . . . .	Number	 0027h	 
$Lowercase . . . . . . . . . . . . . .	Number	 0048h	 
$Lparen  . . . . . . . . . . . . . . .	Number	 000Ch	 
$Lt  . . . . . . . . . . . . . . . . .	Number	 002Dh	 
$M090  . . . . . . . . . . . . . . . .	Number	 0010h	 
$MaxParms  . . . . . . . . . . . . . .	Number	 0064h	 
$MaxPreInsert  . . . . . . . . . . . .	Number	 00AFh	 
$Minus . . . . . . . . . . . . . . . .	Number	 0024h	 
$MsgChunk  . . . . . . . . . . . . . .	Number	 0050h	 
$MsgNum  . . . . . . . . . . . . . . .	Number	 0044h	 
$MsgRoom . . . . . . . . . . . . . . .	Number	 00C8h	 
$NAME  . . . . . . . . . . . . . . . .	Number	 00DCh	 
$NOP . . . . . . . . . . . . . . . . .	Number	 00A0h	 
$NORMAL  . . . . . . . . . . . . . . .	Number	 0114h	 
$NOTREADY  . . . . . . . . . . . . . .	Number	 00C8h	 
$NOVALUE . . . . . . . . . . . . . . .	Number	 00C6h	 
$NUMBER  . . . . . . . . . . . . . . .	Number	 0044h	 
$NUMERIC . . . . . . . . . . . . . . .	Number	 00E0h	 
$Ne  . . . . . . . . . . . . . . . . .	Number	 002Ch	 
$NoMatch . . . . . . . . . . . . . . .	Number	 00FFh	 
$NonUpable . . . . . . . . . . . . . .	Number	 0008h	 
$Not . . . . . . . . . . . . . . . . .	Number	 0020h	 
$NullString  . . . . . . . . . . . . .	Number	 0080h	 
$Num . . . . . . . . . . . . . . . . .	Number	 000Ch	 
$OFF . . . . . . . . . . . . . . . . .	Number	 011Ch	 
$OKb . . . . . . . . . . . . . . . . .	Number	 0020h	 
$OKx . . . . . . . . . . . . . . . . .	Number	 0010h	 
$ON  . . . . . . . . . . . . . . . . .	Number	 0120h	 
$OPTIONS . . . . . . . . . . . . . . .	Number	 00A5h	 
$OTHERWISE . . . . . . . . . . . . . .	Number	 00F0h	 
$OUTPUT  . . . . . . . . . . . . . . .	Number	 00F4h	 
$Omitted . . . . . . . . . . . . . . .	Number	 0088h	 
$Or  . . . . . . . . . . . . . . . . .	Number	 0015h	 
$PARSE . . . . . . . . . . . . . . . .	Number	 00F8h	 
$PROCEDURE . . . . . . . . . . . . . .	Number	 00FCh	 
$PULL  . . . . . . . . . . . . . . . .	Number	 0080h	 
$PUSH  . . . . . . . . . . . . . . . .	Number	 00A9h	 
$Pad . . . . . . . . . . . . . . . . .	Number	 0018h	 
$PcodesBase  . . . . . . . . . . . . .	Number	 0001h	 
$PcodesCeil  . . . . . . . . . . . . .	Number	 00C5h	 
$Percent . . . . . . . . . . . . . . .	Number	 0010h	 
$PjumpBase . . . . . . . . . . . . . .	Number	 0057h	 
$PjumpCeil . . . . . . . . . . . . . .	Number	 0089h	 
$PlusMinus . . . . . . . . . . . . . .	Text   	 $AttribPlus and $Group
$Plus  . . . . . . . . . . . . . . . .	Number	 0025h	 
$Power . . . . . . . . . . . . . . . .	Number	 0050h	 
$QUEUE . . . . . . . . . . . . . . . .	Number	 00AAh	 
$REPLACE . . . . . . . . . . . . . . .	Number	 0108h	 
$RETURN  . . . . . . . . . . . . . . .	Number	 00ABh	 
$Rem . . . . . . . . . . . . . . . . .	Number	 0013h	 
$ReservedLen . . . . . . . . . . . . .	Number	 0084h	 
$Reserved  . . . . . . . . . . . . . .	Byte	 0DA0	  _TEXT	
$Rparen  . . . . . . . . . . . . . . .	Number	 0038h	 
$SAY . . . . . . . . . . . . . . . . .	Number	 00ACh	 
$SCIENTIFIC  . . . . . . . . . . . . .	Number	 00EDh	 
$SELECT  . . . . . . . . . . . . . . .	Number	 0100h	 
$SIGNAL  . . . . . . . . . . . . . . .	Number	 00C0h	 
$SOURCE  . . . . . . . . . . . . . . .	Number	 007Dh	 
$STEM  . . . . . . . . . . . . . . . .	Number	 010Ch	 
$STREAM  . . . . . . . . . . . . . . .	Number	 0110h	 
$STRING  . . . . . . . . . . . . . . .	Number	 003Ch	 
$SYNTAX  . . . . . . . . . . . . . . .	Number	 00C4h	 
$Semi  . . . . . . . . . . . . . . . .	Number	 0004h	 
$Seq . . . . . . . . . . . . . . . . .	Number	 0031h	 
$SerialCompaction  . . . . . . . . . .	Number	 0002h	 
$SerialInterpret . . . . . . . . . . .	Number	 0003h	 
$SerialNone  . . . . . . . . . . . . .	Number	 0000h	 
$SerialQue . . . . . . . . . . . . . .	Number	 0001h	 
$SerialSource  . . . . . . . . . . . .	Number	 0004h	 
$Sge . . . . . . . . . . . . . . . . .	Number	 0035h	 
$Sgt . . . . . . . . . . . . . . . . .	Number	 0036h	 
$ShiftV  . . . . . . . . . . . . . . .	Number	 0003h	 
$Sigl  . . . . . . . . . . . . . . . .	Number	 0048h	 
$SizeConstsHeader  . . . . . . . . . .	Number	 0014h	 
$Slash . . . . . . . . . . . . . . . .	Number	 0012h	 
$Sle . . . . . . . . . . . . . . . . .	Number	 0034h	 
$Slt . . . . . . . . . . . . . . . . .	Number	 0033h	 
$Sne . . . . . . . . . . . . . . . . .	Number	 0032h	 
$SourceBufferSize  . . . . . . . . . .	Number	 11C8h	 
$Special . . . . . . . . . . . . . . .	Number	 00C0h	 
$Stem  . . . . . . . . . . . . . . . .	Number	 0060h	 
$Stream  . . . . . . . . . . . . . . .	Number	 0020h	 
$StrideA . . . . . . . . . . . . . . .	Number	 0006h	 
$StrideD . . . . . . . . . . . . . . .	Number	 0028h	 
$StrideF . . . . . . . . . . . . . . .	Number	 001Ah	 
$StrideH . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideJ . . . . . . . . . . . . . . .	Number	 000Eh	 
$StrideL . . . . . . . . . . . . . . .	Number	 007Ch	 
$StrideS . . . . . . . . . . . . . . .	Number	 0010h	 
$StrideV . . . . . . . . . . . . . . .	Number	 0008h	 
$Symbol  . . . . . . . . . . . . . . .	Number	 0028h	 
$SysCount  . . . . . . . . . . . . . .	Number	 000Bh	 
$THEN  . . . . . . . . . . . . . . . .	Number	 0060h	 
$TO  . . . . . . . . . . . . . . . . .	Number	 0068h	 
$TRACE . . . . . . . . . . . . . . . .	Number	 00B0h	 
$Test  . . . . . . . . . . . . . . . .	Number	 00C0h	 
$TraceAssign . . . . . . . . . . . . .	Number	 0000h	 
$TraceBY . . . . . . . . . . . . . . .	Number	 0002h	 
$TraceBack . . . . . . . . . . . . . .	Number	 001Ah	 
$TraceClause . . . . . . . . . . . . .	Number	 0004h	 
$TraceCompound . . . . . . . . . . . .	Number	 0006h	 
$TraceDot  . . . . . . . . . . . . . .	Number	 0008h	 
$TraceEndClause  . . . . . . . . . . .	Number	 001Eh	 
$TraceError  . . . . . . . . . . . . .	Number	 000Ah	 
$TraceExpr . . . . . . . . . . . . . .	Number	 000Ch	 
$TraceFailure  . . . . . . . . . . . .	Number	 000Eh	 
$TraceFunction . . . . . . . . . . . .	Number	 0010h	 
$TraceLit  . . . . . . . . . . . . . .	Number	 0016h	 
$TraceOperator . . . . . . . . . . . .	Number	 0012h	 
$TraceParse  . . . . . . . . . . . . .	Number	 001Ch	 
$TracePrefix . . . . . . . . . . . . .	Number	 0014h	 
$TraceVar  . . . . . . . . . . . . . .	Number	 0018h	 
$UNTIL . . . . . . . . . . . . . . . .	Number	 0070h	 
$UPPER . . . . . . . . . . . . . . . .	Number	 00D0h	 
$UnAccept  . . . . . . . . . . . . . .	Number	 0008h	 
$VALUE . . . . . . . . . . . . . . . .	Number	 0058h	 
$VAR_SYMBOL  . . . . . . . . . . . . .	Number	 0048h	 
$VAR . . . . . . . . . . . . . . . . .	Number	 0084h	 
$VERSION . . . . . . . . . . . . . . .	Number	 007Eh	 
$Variable  . . . . . . . . . . . . . .	Number	 0089h	 
$WHEN  . . . . . . . . . . . . . . . .	Number	 0104h	 
$WHILE . . . . . . . . . . . . . . . .	Number	 0074h	 
$WITH  . . . . . . . . . . . . . . . .	Number	 0078h	 
$White . . . . . . . . . . . . . . . .	Number	 0000h	 
$WholeGE . . . . . . . . . . . . . . .	Number	 0004h	 
$WholeGT . . . . . . . . . . . . . . .	Number	 0008h	 
$WholeNum  . . . . . . . . . . . . . .	Number	 0014h	 
$Whole . . . . . . . . . . . . . . . .	Number	 0000h	 
$Xor . . . . . . . . . . . . . . . . .	Number	 0014h	 
$Xx  . . . . . . . . . . . . . . . . .	Number	 0002h	 
$mParseEnd . . . . . . . . . . . . . .	Number	 001Ah	 
$mParseEscape  . . . . . . . . . . . .	Number	 0012h	 
$mPattern  . . . . . . . . . . . . . .	Number	 002Ah	 
$mPosEq  . . . . . . . . . . . . . . .	Number	 0032h	 
$mPosMinus . . . . . . . . . . . . . .	Number	 0042h	 
$mPosPlus  . . . . . . . . . . . . . .	Number	 003Ah	 
$mPosRest  . . . . . . . . . . . . . .	Number	 0022h	 
$mRepTail  . . . . . . . . . . . . . .	Number	 0002h	 
$mTemplateComma  . . . . . . . . . . .	Number	 004Ah	 
$mUpper  . . . . . . . . . . . . . . .	Number	 000Ah	 
$n17p1 . . . . . . . . . . . . . . . .	Number	 0002h	 
$n40p3 . . . . . . . . . . . . . . . .	Number	 0004h	 
$n40p4 . . . . . . . . . . . . . . . .	Number	 0006h	 
$n40p5 . . . . . . . . . . . . . . . .	Number	 0008h	 
$n7p3  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nArg  . . . . . . . . . . . . . . . .	Number	 0004h	 
$nDigits . . . . . . . . . . . . . . .	Number	 0000h	 
$nForm . . . . . . . . . . . . . . . .	Number	 0004h	 
$nFuzz . . . . . . . . . . . . . . . .	Number	 0002h	 
$nLineIn . . . . . . . . . . . . . . .	Number	 0006h	 
$nNormal . . . . . . . . . . . . . . .	Number	 0040h	 
$nPull . . . . . . . . . . . . . . . .	Number	 0008h	 
$nSource . . . . . . . . . . . . . . .	Number	 000Ah	 
$nStem . . . . . . . . . . . . . . . .	Number	 0000h	 
$nStream . . . . . . . . . . . . . . .	Number	 0020h	 
$nVar  . . . . . . . . . . . . . . . .	Number	 0000h	 
$nVersion  . . . . . . . . . . . . . .	Number	 000Ch	 
$nWith . . . . . . . . . . . . . . . .	Number	 0002h	 
$pAbut . . . . . . . . . . . . . . . .	Number	 0001h	 
$pAddress  . . . . . . . . . . . . . .	Number	 00A5h	 
$pAdd  . . . . . . . . . . . . . . . .	Number	 003Fh	 
$pAnd  . . . . . . . . . . . . . . . .	Number	 0035h	 
$pAssignConst  . . . . . . . . . . . .	Number	 0099h	 
$pAssignDotsP  . . . . . . . . . . . .	Number	 0007h	 
$pAssignDots . . . . . . . . . . . . .	Number	 0097h	 
$pAssignStem . . . . . . . . . . . . .	Number	 0095h	 
$pAssign . . . . . . . . . . . . . . .	Number	 0093h	 
$pBifGroup . . . . . . . . . . . . . .	Number	 00ADh	 
$pBifq . . . . . . . . . . . . . . . .	Number	 002Bh	 
$pBif  . . . . . . . . . . . . . . . .	Number	 00ABh	 
$pBool . . . . . . . . . . . . . . . .	Number	 00A1h	 
$pBy . . . . . . . . . . . . . . . . .	Number	 0011h	 
$pCallOn . . . . . . . . . . . . . . .	Number	 008Fh	 
$pCall . . . . . . . . . . . . . . . .	Number	 0055h	 
$pCat  . . . . . . . . . . . . . . . .	Number	 0003h	 
$pCeq  . . . . . . . . . . . . . . . .	Number	 007Dh	 
$pCge  . . . . . . . . . . . . . . . .	Number	 0085h	 
$pCgt  . . . . . . . . . . . . . . . .	Number	 0087h	 
$pCle  . . . . . . . . . . . . . . . .	Number	 0083h	 
$pClt  . . . . . . . . . . . . . . . .	Number	 0081h	 
$pCne  . . . . . . . . . . . . . . . .	Number	 007Fh	 
$pCommandEnv . . . . . . . . . . . . .	Number	 00A7h	 
$pCommand  . . . . . . . . . . . . . .	Number	 004Dh	 
$pControlVar . . . . . . . . . . . . .	Number	 005Bh	 
$pDivide . . . . . . . . . . . . . . .	Number	 0045h	 
$pDotControlVar  . . . . . . . . . . .	Number	 005Dh	 
$pDots . . . . . . . . . . . . . . . .	Number	 0091h	 
$pDropList . . . . . . . . . . . . . .	Number	 00B7h	 
$pDrop . . . . . . . . . . . . . . . .	Number	 009Dh	 
$pEnvName  . . . . . . . . . . . . . .	Number	 00A9h	 
$pEq . . . . . . . . . . . . . . . . .	Number	 0065h	 
$pExit . . . . . . . . . . . . . . . .	Number	 0027h	 
$pExposeList . . . . . . . . . . . . .	Number	 00B9h	 
$pExpose . . . . . . . . . . . . . . .	Number	 009Fh	 
$pFor  . . . . . . . . . . . . . . . .	Number	 0013h	 
$pGe . . . . . . . . . . . . . . . . .	Number	 006Dh	 
$pGt . . . . . . . . . . . . . . . . .	Number	 006Fh	 
$pIntDivide  . . . . . . . . . . . . .	Number	 0047h	 
$pInterpEnd  . . . . . . . . . . . . .	Number	 0089h	 
$pInterpret  . . . . . . . . . . . . .	Number	 004Fh	 
$pInvoke . . . . . . . . . . . . . . .	Number	 0053h	 
$pIterCV . . . . . . . . . . . . . . .	Number	 00A3h	 
$pIterRep  . . . . . . . . . . . . . .	Number	 0019h	 
$pIterate  . . . . . . . . . . . . . .	Number	 001Bh	 
$pJump . . . . . . . . . . . . . . . .	Number	 0063h	 
$pLeave  . . . . . . . . . . . . . . .	Number	 001Dh	 
$pLength . . . . . . . . . . . . . . .	Number	 002Dh	 
$pLe . . . . . . . . . . . . . . . . .	Number	 006Bh	 
$pLt . . . . . . . . . . . . . . . . .	Number	 0069h	 
$pMax  . . . . . . . . . . . . . . . .	Number	 002Fh	 
$pMin  . . . . . . . . . . . . . . . .	Number	 0031h	 
$pMultiply . . . . . . . . . . . . . .	Number	 0043h	 
$pNegate . . . . . . . . . . . . . . .	Number	 003Dh	 
$pNe . . . . . . . . . . . . . . . . .	Number	 0067h	 
$pNop  . . . . . . . . . . . . . . . .	Number	 0005h	 
$pNot  . . . . . . . . . . . . . . . .	Number	 0033h	 
$pNumber . . . . . . . . . . . . . . .	Number	 000Dh	 
$pNumeric  . . . . . . . . . . . . . .	Number	 0051h	 
$pOptions  . . . . . . . . . . . . . .	Number	 00C3h	 
$pOr . . . . . . . . . . . . . . . . .	Number	 0037h	 
$pParse  . . . . . . . . . . . . . . .	Number	 0009h	 
$pPositive . . . . . . . . . . . . . .	Number	 003Bh	 
$pPower  . . . . . . . . . . . . . . .	Number	 004Bh	 
$pPush . . . . . . . . . . . . . . . .	Number	 00BBh	 
$pQueue  . . . . . . . . . . . . . . .	Number	 00BDh	 
$pRaise  . . . . . . . . . . . . . . .	Number	 00AFh	 
$pRemainder  . . . . . . . . . . . . .	Number	 0049h	 
$pRepEver  . . . . . . . . . . . . . .	Number	 0059h	 
$pRep  . . . . . . . . . . . . . . . .	Number	 0057h	 
$pResult . . . . . . . . . . . . . . .	Number	 0021h	 
$pResumeParse  . . . . . . . . . . . .	Number	 000Bh	 
$pReturns  . . . . . . . . . . . . . .	Number	 0025h	 
$pReturn . . . . . . . . . . . . . . .	Number	 0023h	 
$pSay  . . . . . . . . . . . . . . . .	Number	 0029h	 
$pSeq  . . . . . . . . . . . . . . . .	Number	 0071h	 
$pSge  . . . . . . . . . . . . . . . .	Number	 0079h	 
$pSgt  . . . . . . . . . . . . . . . .	Number	 007Bh	 
$pSignalOff  . . . . . . . . . . . . .	Number	 00B1h	 
$pSignalOn . . . . . . . . . . . . . .	Number	 008Dh	 
$pSignalV  . . . . . . . . . . . . . .	Number	 00B3h	 
$pSignal . . . . . . . . . . . . . . .	Number	 008Bh	 
$pSle  . . . . . . . . . . . . . . . .	Number	 0077h	 
$pSlt  . . . . . . . . . . . . . . . .	Number	 0075h	 
$pSne  . . . . . . . . . . . . . . . .	Number	 0073h	 
$pSubtract . . . . . . . . . . . . . .	Number	 0041h	 
$pSysVar . . . . . . . . . . . . . . .	Number	 00B5h	 
$pThen . . . . . . . . . . . . . . . .	Number	 005Fh	 
$pTo . . . . . . . . . . . . . . . . .	Number	 000Fh	 
$pTraceEvent . . . . . . . . . . . . .	Number	 00C1h	 
$pTrace  . . . . . . . . . . . . . . .	Number	 00BFh	 
$pUnDo . . . . . . . . . . . . . . . .	Number	 001Fh	 
$pUnstore  . . . . . . . . . . . . . .	Number	 009Bh	 
$pUntil  . . . . . . . . . . . . . . .	Number	 0017h	 
$pWhen . . . . . . . . . . . . . . . .	Number	 0061h	 
$pWhile  . . . . . . . . . . . . . . .	Number	 0015h	 
$pXor  . . . . . . . . . . . . . . . .	Number	 0039h	 
$ret . . . . . . . . . . . . . . . . .	Number	 00C3h	 
$sAddress  . . . . . . . . . . . . . .	Number	 002Dh	 
$sDigits . . . . . . . . . . . . . . .	Number	 0027h	 
$sDropList . . . . . . . . . . . . . .	Number	 000Bh	 
$sDrop . . . . . . . . . . . . . . . .	Number	 0006h	 
$sEq . . . . . . . . . . . . . . . . .	Number	 001Bh	 
$sExit . . . . . . . . . . . . . . . .	Number	 0032h	 
$sForm . . . . . . . . . . . . . . . .	Number	 002Bh	 
$sIterate  . . . . . . . . . . . . . .	Number	 003Fh	 
$sLeave  . . . . . . . . . . . . . . .	Number	 003Eh	 
$sLength . . . . . . . . . . . . . . .	Number	 0017h	 
$sMinus  . . . . . . . . . . . . . . .	Number	 0014h	 
$sNegate . . . . . . . . . . . . . . .	Number	 0030h	 
$sNop  . . . . . . . . . . . . . . . .	Number	 002Ah	 
$sNumber . . . . . . . . . . . . . . .	Number	 0037h	 
$sPercent  . . . . . . . . . . . . . .	Number	 0000h	 
$sPositive . . . . . . . . . . . . . .	Number	 0031h	 
$sRaise  . . . . . . . . . . . . . . .	Number	 0039h	 
$sReturns  . . . . . . . . . . . . . .	Number	 0035h	 
$sSeq  . . . . . . . . . . . . . . . .	Number	 0021h	 
$sStem . . . . . . . . . . . . . . . .	Number	 0009h	 
$sWith . . . . . . . . . . . . . . . .	Number	 000Ah	 
$tBinary . . . . . . . . . . . . . . .	Number	 00FDh	 
$tChar . . . . . . . . . . . . . . . .	Number	 00FFh	 
$tLabel  . . . . . . . . . . . . . . .	Number	 00FEh	 
??0000 . . . . . . . . . . . . . . . .	Number	 0040h	 
??0001 . . . . . . . . . . . . . . . .	Number	 0001h	 
??0003 . . . . . . . . . . . . . . . .	Number	 0001h	 
??0008 . . . . . . . . . . . . . . . .	Number	 0010h	 
??0009 . . . . . . . . . . . . . . . .	Number	 0010h	 
??000A . . . . . . . . . . . . . . . .	Number	 0008h	 
??000B . . . . . . . . . . . . . . . .	Number	 0008h	 
??000C . . . . . . . . . . . . . . . .	Number	 0010h	 
??000D . . . . . . . . . . . . . . . .	Number	 0020h	 
??000E . . . . . . . . . . . . . . . .	Number	 0010h	 
??000F . . . . . . . . . . . . . . . .	Number	 0004h	 
??0010 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0011 . . . . . . . . . . . . . . . .	Number	 0001h	 
??0012 . . . . . . . . . . . . . . . .	Number	 0010h	 
??0013 . . . . . . . . . . . . . . . .	Number	 0008h	 
??0014 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0015 . . . . . . . . . . . . . . . .	Number	 1000h	 
??0016 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0017 . . . . . . . . . . . . . . . .	Number	 0004h	 
??0018 . . . . . . . . . . . . . . . .	Number	 0020h	 
??0019 . . . . . . . . . . . . . . . .	Number	 0010h	 
??001A . . . . . . . . . . . . . . . .	Number	 0008h	 
??001B . . . . . . . . . . . . . . . .	Number	 0008h	 
??001C . . . . . . . . . . . . . . . .	Number	 0010h	 
??001D . . . . . . . . . . . . . . . .	Number	 0020h	 
??001E . . . . . . . . . . . . . . . .	Number	 0010h	 
??001F . . . . . . . . . . . . . . . .	Number	 0040h	 
??0020 . . . . . . . . . . . . . . . .	Number	 0010h	 
??0021 . . . . . . . . . . . . . . . .	Number	 0040h	 
??0022 . . . . . . . . . . . . . . . .	Number	 0080h	 
??0023 . . . . . . . . . . . . . . . .	Number	 0100h	 
??0024 . . . . . . . . . . . . . . . .	Number	 0100h	 
??0025 . . . . . . . . . . . . . . . .	Number	 0100h	 
??0026 . . . . . . . . . . . . . . . .	Number	 0200h	 
??0027 . . . . . . . . . . . . . . . .	Number	 2000h	 
??0028 . . . . . . . . . . . . . . . .	Number	 0400h	 
??0029 . . . . . . . . . . . . . . . .	Number	 2000h	 
??002A . . . . . . . . . . . . . . . .	Number	 0400h	 
??002B . . . . . . . . . . . . . . . .	Number	 2000h	 
??002C . . . . . . . . . . . . . . . .	Number	 2000h	 
??002D . . . . . . . . . . . . . . . .	Number	 2000h	 
??002E . . . . . . . . . . . . . . . .	Number	 0040h	 
??002F . . . . . . . . . . . . . . . .	Number	 0002h	 
??0030 . . . . . . . . . . . . . . . .	Number	 0200h	 
??0031 . . . . . . . . . . . . . . . .	Number	 0200h	 
?BIF . . . . . . . . . . . . . . . . .	Number	 0002h	 
?CLAUSELOCAL . . . . . . . . . . . . .	Number	 000Eh	 
?CLAUSETIME  . . . . . . . . . . . . .	Number	 000Ch	 
?LINEIN_POSITION . . . . . . . . . . .	Number	 000Ah	 
?MONTHS  . . . . . . . . . . . . . . .	Number	 0010h	 
?OUTCOME . . . . . . . . . . . . . . .	Number	 0000h	 
?RESPONSE  . . . . . . . . . . . . . .	Number	 0008h	 
?STARTTIME . . . . . . . . . . . . . .	Number	 0014h	 
?STREAMSTATE . . . . . . . . . . . . .	Number	 0006h	 
?STREAM  . . . . . . . . . . . . . . .	Number	 0004h	 
?WEEKDAYS  . . . . . . . . . . . . . .	Number	 0012h	 
@8p3p17A . . . . . . . . . . . . . . .	L Near	 07F3	  _TEXT	
@CodeSize  . . . . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . . . . .	Text   	 DGROUP
ACV  . . . . . . . . . . . . . . . . .	L Near	 09B6	  _TEXT	
ARITHOP$$  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Abut$$ . . . . . . . . . . . . . . . .	L Near	 034E	  _TEXT	Public
AbutAlloc  . . . . . . . . . . . . . .	L Near	 038E	  _TEXT	
AbutOtherPop . . . . . . . . . . . . .	L Near	 03C9	  _TEXT	
AbutOther  . . . . . . . . . . . . . .	L Near	 03CA	  _TEXT	
Acc64  . . . . . . . . . . . . . . . .	L Near	 120F	  _TEXT	
Add$$  . . . . . . . . . . . . . . . .	L Near	 1164	  _TEXT	
AddPos32 . . . . . . . . . . . . . . .	L Near	 11F6	  _TEXT	
AddRegs  . . . . . . . . . . . . . . .	L Near	 1181	  _TEXT	Public
AddS9b . . . . . . . . . . . . . . . .	L Near	 11A2	  _TEXT	
AddSubEax  . . . . . . . . . . . . . .	L Near	 118F	  _TEXT	
AddSubNull . . . . . . . . . . . . . .	L Near	 1193	  _TEXT	
AddTest  . . . . . . . . . . . . . . .	L Near	 11B6	  _TEXT	
Address$$  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AfterRound . . . . . . . . . . . . . .	L Near	 20A2	  _TEXT	
AlignNoOver  . . . . . . . . . . . . .	L Near	 11A8	  _TEXT	
AllocateCx_EsAx  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
And$$  . . . . . . . . . . . . . . . .	L Near	 15AC	  _TEXT	
Arg$ . . . . . . . . . . . . . . . . .	L Near	 04E0	  _TEXT	
ArgInc . . . . . . . . . . . . . . . .	L Near	 04E7	  _TEXT	
ArithDl  . . . . . . . . . . . . . . .	L Near	 1090	  _TEXT	
ArithGeneral . . . . . . . . . . . . .	L Near	 1079	  _TEXT	
ArithLeft  . . . . . . . . . . . . . .	L Near	 108A	  _TEXT	
ArithRight . . . . . . . . . . . . . .	L Near	 1077	  _TEXT	
ArithZero  . . . . . . . . . . . . . .	L Near	 17EA	  _TEXT	
ArrayBx  . . . . . . . . . . . . . . .	Text   	 bx
ArraySi  . . . . . . . . . . . . . . .	Text   	 si
AsCall . . . . . . . . . . . . . . . .	L Near	 0C1C	  _TEXT	
AsControlVar . . . . . . . . . . . . .	L Near	 099B	  _TEXT	
AsgnToFsBx . . . . . . . . . . . . . .	L Near	 1AC7	  _TEXT	
Assert . . . . . . . . . . . . . . . .	Text   	 .erre
Assign$$ . . . . . . . . . . . . . . .	L Near	 1AC1	  _TEXT	
AssignConst$$  . . . . . . . . . . . .	L Near	 1A8D	  _TEXT	
AssignDots$$ . . . . . . . . . . . . .	L Near	 1CEB	  _TEXT	
AssignDotsP$$  . . . . . . . . . . . .	L Near	 087C	  _TEXT	
AssignExposed  . . . . . . . . . . . .	L Near	 1AE2	  _TEXT	Public
AssignLoop . . . . . . . . . . . . . .	L Near	 1CAF	  _TEXT	
AssignNullB  . . . . . . . . . . . . .	L Near	 0928	  _TEXT	
AssignNull . . . . . . . . . . . . . .	L Near	 0805	  _TEXT	
AssignRet  . . . . . . . . . . . . . .	L Near	 1AE5	  _TEXT	
AssignStem$$ . . . . . . . . . . . . .	L Near	 1C7A	  _TEXT	
AssignUpRet  . . . . . . . . . . . . .	L Near	 1CB5	  _TEXT	
AssignUp . . . . . . . . . . . . . . .	L Near	 1CD3	  _TEXT	
AssureSiPlus . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AttribAl . . . . . . . . . . . . . . .	Text   	 al
Attributes . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
AwayEsAxCx . . . . . . . . . . . . . .	L Near	 224B	  _TEXT	Public
Away . . . . . . . . . . . . . . . . .	L Near	 1C4F	  _TEXT	Public
Ax2DsSiCx  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
A  . . . . . . . . . . . . . . . . . .	Text   	 (Ashape ptr[bp+si])
B4DROP . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
B4EXPOSE . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BPcodesCeil$ . . . . . . . . . . . . .	L Near	 005C	  FanSeg	
BackToIterCV . . . . . . . . . . . . .	L Near	 0BC0	  _TEXT	
Bassigned  . . . . . . . . . . . . . .	L Near	 0988	  _TEXT	
Bassign  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bif$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifBound . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
BifGroup$$ . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bifq$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Bool$$ . . . . . . . . . . . . . . . .	L Near	 14AE	  _TEXT	
BoolBack . . . . . . . . . . . . . . .	L Near	 14BD	  _TEXT	
BoolC  . . . . . . . . . . . . . . . .	L Near	 14E2	  _TEXT	
BoolSC . . . . . . . . . . . . . . . .	L Near	 14D1	  _TEXT	
BooleryRejumps . . . . . . . . . . . .	Number	 002Dh	 Public
Boolery  . . . . . . . . . . . . . . .	L Near	 00F5	  _TEXT	Public
Bptr . . . . . . . . . . . . . . . . .	Text   	 byte ptr
BxConst  . . . . . . . . . . . . . . .	L Near	 220B	  _TEXT	
By$$ . . . . . . . . . . . . . . . . .	L Near	 0A4E	  _TEXT	
ByBin  . . . . . . . . . . . . . . . .	L Near	 0B90	  _TEXT	
ByChar . . . . . . . . . . . . . . . .	L Near	 0A6C	  _TEXT	
ByRetNeg . . . . . . . . . . . . . . .	L Near	 0A67	  _TEXT	
CD . . . . . . . . . . . . . . . . . .	Number	 0000h	 
COMMAND  . . . . . . . . . . . . . . .	Byte	 22B7	  _TEXT	
CONFIG_ARITH . . . . . . . . . . . . .	Number	 00FFh	 
CONFIG_B2C . . . . . . . . . . . . . .	Number	 00E9h	 
CONFIG_C2B . . . . . . . . . . . . . .	Number	 00E7h	 
CONFIG_MSG . . . . . . . . . . . . . .	Number	 00E5h	 
CONFIG_RAISE40$$ . . . . . . . . . . .	L Near	 187E	  _TEXT	Public
CONFIG_RAISE40 . . . . . . . . . . . .	Number	 00E1h	 
CONFIG_RAISE . . . . . . . . . . . . .	Number	 00DFh	 
CONFIG_STREAM_CHARIN . . . . . . . . .	Number	 00EDh	 
CONFIG_STREAM_CHAROUT  . . . . . . . .	Number	 00F3h	 
CONFIG_STREAM_CLOSE  . . . . . . . . .	Number	 00F1h	 
CONFIG_STREAM_COMMAND  . . . . . . . .	Number	 00F9h	 
CONFIG_STREAM_COUNT  . . . . . . . . .	Number	 00F5h	 
CONFIG_STREAM_POSITION . . . . . . . .	Number	 00EBh	 
CONFIG_STREAM_QUALIFIED  . . . . . . .	Number	 00F7h	 
CONFIG_STREAM_QUERY  . . . . . . . . .	Number	 00EFh	 
CONFIG_STREAM_STATE  . . . . . . . . .	Number	 00FBh	 
CONFIG_TIME  . . . . . . . . . . . . .	Number	 00FDh	 
CONFIG_UPPER$$ . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CONFIG_UPPER . . . . . . . . . . . . .	Number	 00E3h	 
Call$$ . . . . . . . . . . . . . . . .	L Near	 0C17	  _TEXT	
CallOn$$ . . . . . . . . . . . . . . .	L Near	 1A22	  _TEXT	
CallResult . . . . . . . . . . . . . .	L Near	 0F4D	  _TEXT	
Cat$$  . . . . . . . . . . . . . . . .	L Near	 03EA	  _TEXT	
CatAlloc . . . . . . . . . . . . . . .	L Near	 043C	  _TEXT	
CatAppend  . . . . . . . . . . . . . .	L Near	 0431	  _TEXT	
CatLong  . . . . . . . . . . . . . . .	L Near	 049C	  _TEXT	
CatMid . . . . . . . . . . . . . . . .	L Near	 0495	  _TEXT	
CatOtherPop  . . . . . . . . . . . . .	L Near	 0477	  _TEXT	
CatOther . . . . . . . . . . . . . . .	L Near	 0478	  _TEXT	
Ceq$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
Cge$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
Cgt$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
ChangeExpon  . . . . . . . . . . . . .	L Near	 1216	  _TEXT	
Check34A . . . . . . . . . . . . . . .	L Near	 1585	  _TEXT	
Check34  . . . . . . . . . . . . . . .	L Near	 156E	  _TEXT	
ClauseSourceEnd  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Cle$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
CloseBx  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Clt$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
CmpArith . . . . . . . . . . . . . . .	L Near	 1371	  _TEXT	
CmpGen2  . . . . . . . . . . . . . . .	L Near	 1350	  _TEXT	
CmpGen . . . . . . . . . . . . . . . .	L Near	 135B	  _TEXT	
Cne$$  . . . . . . . . . . . . . . . .	L Near	 1409	  _TEXT	
Command$$  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CommandEnv$$ . . . . . . . . . . . . .	L Near	 0000	  _TEXT	
Command  . . . . . . . . . . . . . . .	L Near	 0D23	  _TEXT	Public
CompareTO  . . . . . . . . . . . . . .	L Near	 0B4D	  _TEXT	Public
Compiler . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Compiling  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConTrigger . . . . . . . . . . . . . .	L Near	 0633	  _TEXT	
Configuration  . . . . . . . . . . . .	Byte	 22AD	  _TEXT	
Consist  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValueX  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ConstValue . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ControlVar$$ . . . . . . . . . . . . .	L Near	 096E	  _TEXT	
CopyInsert . . . . . . . . . . . . . .	L Near	 1990	  _TEXT	
Create4Dump  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
CursorBx . . . . . . . . . . . . . . .	Text   	 bx
CursorDi . . . . . . . . . . . . . . .	Text   	 di
CursorSi . . . . . . . . . . . . . . .	Text   	 si
D1 . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD])
DataLenCx  . . . . . . . . . . . . . .	Text   	 cx
Debug  . . . . . . . . . . . . . . . .	Number	 0001h	 
DepthBl  . . . . . . . . . . . . . . .	Text   	 bl
DepthBx  . . . . . . . . . . . . . . .	Text   	 bx
DigInsertx . . . . . . . . . . . . . .	L Near	 15E9	  _TEXT	
DigInsertz . . . . . . . . . . . . . .	L Near	 15E8	  _TEXT	
Digits$  . . . . . . . . . . . . . . .	L Near	 1602	  _TEXT	
DigitsChange . . . . . . . . . . . . .	L Near	 1627	  _TEXT	Public
DigitsSame . . . . . . . . . . . . . .	L Near	 163B	  _TEXT	
DivExact . . . . . . . . . . . . . . .	L Near	 176E	  _TEXT	
DivLoop  . . . . . . . . . . . . . . .	L Near	 1740	  _TEXT	
Divide$$ . . . . . . . . . . . . . . .	L Near	 16DD	  _TEXT	
DivideNull . . . . . . . . . . . . . .	L Near	 17F1	  _TEXT	
DosMemCheck  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
DotControlVar$$  . . . . . . . . . . .	L Near	 09C0	  _TEXT	
Dots$$ . . . . . . . . . . . . . . . .	L Near	 1BEB	  _TEXT	
DotsExposed  . . . . . . . . . . . . .	L Near	 023B	  _TEXT	Public
DotsFsBxDsSiX  . . . . . . . . . . . .	L Near	 0136	  _TEXT	Public
DotsFsBxDsSi . . . . . . . . . . . . .	L Near	 0122	  _TEXT	Public
DotsIterCV . . . . . . . . . . . . . .	L Near	 0BB5	  _TEXT	
DotsNew  . . . . . . . . . . . . . . .	L Near	 1C19	  _TEXT	
DotsReturn . . . . . . . . . . . . . .	L Near	 1C14	  _TEXT	
DownLeave  . . . . . . . . . . . . . .	L Near	 0AFB	  _TEXT	
Dptr . . . . . . . . . . . . . . . . .	Text   	 dword ptr
Drop$$ . . . . . . . . . . . . . . . .	L Near	 1CDD	  _TEXT	
DropList$$ . . . . . . . . . . . . . .	L Near	 1B0F	  _TEXT	
DropListRet  . . . . . . . . . . . . .	L Near	 1B2A	  _TEXT	
DropLoopX  . . . . . . . . . . . . . .	L Near	 1B1C	  _TEXT	
DropLoop . . . . . . . . . . . . . . .	L Near	 1B20	  _TEXT	
DualSwitch . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Dumper . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
D  . . . . . . . . . . . . . . . . . .	Text   	 (Dshape ptr[bp+di-$StrideD+$StrideV])
EasyPare . . . . . . . . . . . . . . .	L Near	 13DC	  _TEXT	
EasySign . . . . . . . . . . . . . . .	L Near	 13EC	  _TEXT	
EnvName$$  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Eq$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
Error49Bp  . . . . . . . . . . . . . .	Text   	 call bp
Exit$$ . . . . . . . . . . . . . . . .	L Near	 101B	  _TEXT	
ExitDOS  . . . . . . . . . . . . . . .	L Near	 106F	  _TEXT	Public
ExitUp . . . . . . . . . . . . . . . .	L Near	 102B	  _TEXT	
Exit . . . . . . . . . . . . . . . . .	L Near	 1063	  _TEXT	Public
Expose$$ . . . . . . . . . . . . . . .	L Near	 1B60	  _TEXT	
ExposeList$$ . . . . . . . . . . . . .	L Near	 1B8D	  _TEXT	
ExposeListRet  . . . . . . . . . . . .	L Near	 1BC4	  _TEXT	
ExposeLoopX  . . . . . . . . . . . . .	L Near	 1BB6	  _TEXT	
ExposeLoop . . . . . . . . . . . . . .	L Near	 1BBA	  _TEXT	
ExposedFs  . . . . . . . . . . . . . .	L Near	 1AFC	  _TEXT	Public
ExposedLoop  . . . . . . . . . . . . .	L Near	 01A4	  _TEXT	
External . . . . . . . . . . . . . . .	L Near	 0C64	  _TEXT	
Extlong  . . . . . . . . . . . . . . .	L Near	 2233	  _TEXT	
FUNCTION . . . . . . . . . . . . . . .	Byte	 22BF	  _TEXT	
FetchBx  . . . . . . . . . . . . . . .	L Near	 0070	  _TEXT	
FileBx . . . . . . . . . . . . . . . .	Text   	 bx
FnBigExp . . . . . . . . . . . . . . .	L Near	 1FEE	  _TEXT	
FnB  . . . . . . . . . . . . . . . . .	L Near	 1EFE	  _TEXT	
FnChSt2  . . . . . . . . . . . . . . .	L Near	 1EC1	  _TEXT	
FnChSt . . . . . . . . . . . . . . . .	L Near	 1E3B	  _TEXT	
FnChar . . . . . . . . . . . . . . . .	L Near	 1E24	  _TEXT	
FnDone . . . . . . . . . . . . . . . .	L Near	 1F08	  _TEXT	
FnExpd . . . . . . . . . . . . . . . .	L Near	 1E3D	  _TEXT	
FnExp  . . . . . . . . . . . . . . . .	L Near	 1E45	  _TEXT	
FnLong . . . . . . . . . . . . . . . .	L Near	 1FA3	  _TEXT	
FnMantx  . . . . . . . . . . . . . . .	L Near	 1E15	  _TEXT	
FnMantz  . . . . . . . . . . . . . . .	L Near	 1E30	  _TEXT	
FnMant . . . . . . . . . . . . . . . .	L Near	 1EDF	  _TEXT	
FnMloop  . . . . . . . . . . . . . . .	L Near	 1F53	  _TEXT	
FnNoExp  . . . . . . . . . . . . . . .	L Near	 1F40	  _TEXT	
FnNoSign . . . . . . . . . . . . . . .	L Near	 1EC8	  _TEXT	
FnPostDot  . . . . . . . . . . . . . .	L Near	 1EDC	  _TEXT	
FnPostSign . . . . . . . . . . . . . .	L Near	 1E34	  _TEXT	
FnSkip . . . . . . . . . . . . . . . .	L Near	 1F72	  _TEXT	
For$$  . . . . . . . . . . . . . . . .	L Near	 0A24	  _TEXT	
ForBcode . . . . . . . . . . . . . . .	Number	 0000h	 
ForBig . . . . . . . . . . . . . . . .	Number	 0000h	 
Form$  . . . . . . . . . . . . . . . .	L Near	 15BD	  _TEXT	
FormRetx . . . . . . . . . . . . . . .	L Near	 15D6	  _TEXT	
FormRet  . . . . . . . . . . . . . . .	L Near	 15D3	  _TEXT	
FoundKey . . . . . . . . . . . . . . .	L Near	 022B	  _TEXT	
FpLoop . . . . . . . . . . . . . . . .	L Near	 21AA	  _TEXT	
FromArg  . . . . . . . . . . . . . . .	L Near	 05D2	  _TEXT	
FromCmpGen . . . . . . . . . . . . . .	L Near	 13B1	  _TEXT	
FromEver . . . . . . . . . . . . . . .	L Near	 0A9E	  _TEXT	
FromFloat  . . . . . . . . . . . . . .	L Near	 2133	  _TEXT	
FromStrict . . . . . . . . . . . . . .	L Near	 1456	  _TEXT	
FromStripL . . . . . . . . . . . . . .	L Near	 1454	  _TEXT	
FromStripR . . . . . . . . . . . . . .	L Near	 1434	  _TEXT	
FromVersion  . . . . . . . . . . . . .	L Near	 05CB	  _TEXT	
FullName . . . . . . . . . . . . . . .	L Near	 0D2F	  _TEXT	
Fuzz$  . . . . . . . . . . . . . . . .	L Near	 16C0	  _TEXT	
Fuzzy  . . . . . . . . . . . . . . . .	L Near	 169A	  _TEXT	
F  . . . . . . . . . . . . . . . . . .	Text   	 (Fshape ptr[bx-$StrideF])
Ge$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
GetOut . . . . . . . . . . . . . . . .	L Near	 1984	  _TEXT	
GiveDosMem . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Gt$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
Hang . . . . . . . . . . . . . . . . .	Text   	 jmp $
HasPatternPop  . . . . . . . . . . . .	L Near	 06A3	  _TEXT	
HasPattern . . . . . . . . . . . . . .	L Near	 06A4	  _TEXT	
HavePool . . . . . . . . . . . . . . .	L Near	 0CDF	  _TEXT	
HaveSpace  . . . . . . . . . . . . . .	L Near	 0CEE	  _TEXT	
Hd . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr ds:[0])
HeritRecurse . . . . . . . . . . . . .	L Near	 2260	  _TEXT	
HeritageDi . . . . . . . . . . . . . .	L Near	 2258	  _TEXT	Public
HeritageRet  . . . . . . . . . . . . .	L Near	 2289	  _TEXT	
He . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr es:[bp])
Hf . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr fs:[bp])
Hg . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr gs:[bp])
HighDi . . . . . . . . . . . . . . . .	Text   	 di
H  . . . . . . . . . . . . . . . . . .	Text   	 (Hshape ptr[si])
IfZero . . . . . . . . . . . . . . . .	L Near	 0ACF	  _TEXT	
InSynch  . . . . . . . . . . . . . . .	L Near	 1964	  _TEXT	
InitMemory . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
InitSegDs  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
IntDivLoop . . . . . . . . . . . . . .	L Near	 17A1	  _TEXT	
IntDivide$$  . . . . . . . . . . . . .	L Near	 16DD	  _TEXT	
IntDiv . . . . . . . . . . . . . . . .	L Near	 17C7	  _TEXT	
IntRem . . . . . . . . . . . . . . . .	L Near	 17DE	  _TEXT	
InterpEnd$$  . . . . . . . . . . . . .	L Near	 1D70	  _TEXT	
Interpret$$  . . . . . . . . . . . . .	L Near	 1D14	  _TEXT	
Interpret1 . . . . . . . . . . . . . .	L Near	 1D18	  _TEXT	Public
Invoke$$ . . . . . . . . . . . . . . .	L Near	 0C0A	  _TEXT	
Is14 . . . . . . . . . . . . . . . . .	L Near	 18E9	  _TEXT	
ItNoFor  . . . . . . . . . . . . . . .	L Near	 0BB2	  _TEXT	
ItNoTo . . . . . . . . . . . . . . . .	L Near	 0BA4	  _TEXT	
IterCV$$ . . . . . . . . . . . . . . .	L Near	 0B10	  _TEXT	
IterRep$$  . . . . . . . . . . . . . .	L Near	 0BFF	  _TEXT	
Iterate$$  . . . . . . . . . . . . . .	L Near	 0C07	  _TEXT	
Jbx  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[bx])
Jdi  . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[di])
Jett . . . . . . . . . . . . . . . . .	L Near	 0EBE	  _TEXT	
Jump$$ . . . . . . . . . . . . . . . .	L Near	 1A68	  _TEXT	
J  . . . . . . . . . . . . . . . . . .	Text   	 (Jshape ptr[si])
KeyListCx  . . . . . . . . . . . . . .	Text   	 cx
KeysBase . . . . . . . . . . . . . . .	Number	 0028h	 
KeywordOffsetCx  . . . . . . . . . . .	Text   	 cx
KnownExternal  . . . . . . . . . . . .	L Near	 0EEE	  _TEXT	
LHSLenBx . . . . . . . . . . . . . . .	Text   	 bx
Lbx  . . . . . . . . . . . . . . . . .	Text   	 ss:(Lshape ptr[bx-$StrideL+$StrideV])
Le$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
Leave$$  . . . . . . . . . . . . . . .	L Near	 0AFE	  _TEXT	
Length$$ . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LengthAtBx . . . . . . . . . . . . . .	Text   	 bx
LevelDi  . . . . . . . . . . . . . . .	Text   	 di
LevelSi  . . . . . . . . . . . . . . .	Text   	 si
LineIn$  . . . . . . . . . . . . . . .	L Near	 0521	  _TEXT	
LinkBcodeX . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LinkBcode  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LoadTrigger  . . . . . . . . . . . . .	L Near	 05F5	  _TEXT	
LookFileDsBx . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LookupSi . . . . . . . . . . . . . . .	Text   	 si
Lookup . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
LowPartLenCl . . . . . . . . . . . . .	Text   	 cl
LowSi  . . . . . . . . . . . . . . . .	Text   	 si
Lsi  . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+si-$StrideL+$StrideV])
Lt$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
L  . . . . . . . . . . . . . . . . . .	Text   	 (Lshape ptr[bp+di-$StrideL+$StrideV])
MagTest  . . . . . . . . . . . . . . .	L Near	 154C	  _TEXT	
MajMinDx . . . . . . . . . . . . . . .	Text   	 dx
MajorDh  . . . . . . . . . . . . . . .	Text   	 dh
MakeMsg  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
MantPare . . . . . . . . . . . . . . .	L Near	 13D5	  _TEXT	
Max$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
MayFloat . . . . . . . . . . . . . . .	L Near	 179A	  _TEXT	
MemCheck . . . . . . . . . . . . . . .	Number	 0001h	 
Min$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
MinorDl  . . . . . . . . . . . . . . .	Text   	 dl
MinorDx  . . . . . . . . . . . . . . .	Text   	 dx
MoreSpaceEs  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
MovsCx . . . . . . . . . . . . . . . .	Text   	 cx
Multiply$$ . . . . . . . . . . . . . .	L Near	 1519	  _TEXT	
Name2File  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Ne$$ . . . . . . . . . . . . . . . . .	L Near	 1395	  _TEXT	
NegGen . . . . . . . . . . . . . . . .	L Near	 180C	  _TEXT	
Negate$$ . . . . . . . . . . . . . . .	L Near	 17FC	  _TEXT	
NewForm  . . . . . . . . . . . . . . .	L Near	 15CD	  _TEXT	
NewStemBx  . . . . . . . . . . . . . .	L Near	 01F2	  _TEXT	
NextSection  . . . . . . . . . . . . .	L Near	 05F9	  _TEXT	
NextTargetB  . . . . . . . . . . . . .	L Near	 08BE	  _TEXT	
NextTarget . . . . . . . . . . . . . .	L Near	 0758	  _TEXT	
NoArgNum . . . . . . . . . . . . . . .	L Near	 18A6	  _TEXT	
Nop$$  . . . . . . . . . . . . . . . .	L Near	 04B7	  _TEXT	
Not$$  . . . . . . . . . . . . . . . .	L Near	 15B3	  _TEXT	
Not41  . . . . . . . . . . . . . . . .	L Near	 18CE	  _TEXT	
Not7 . . . . . . . . . . . . . . . . .	L Near	 18F1	  _TEXT	
NotDropped . . . . . . . . . . . . . .	L Near	 02D1	  _TEXT	
NotExposed . . . . . . . . . . . . . .	L Near	 02A2	  _TEXT	
NotExternal  . . . . . . . . . . . . .	L Near	 0CA5	  _TEXT	
NotINT . . . . . . . . . . . . . . . .	L Near	 194A	  _TEXT	
NotLoadVariable  . . . . . . . . . . .	L Near	 008E	  _TEXT	
NotMsgNum  . . . . . . . . . . . . . .	L Near	 0318	  _TEXT	
NotPresentX  . . . . . . . . . . . . .	L Near	 028F	  _TEXT	
NotPresent . . . . . . . . . . . . . .	L Near	 028C	  _TEXT	Public
NotSigl  . . . . . . . . . . . . . . .	L Near	 034C	  _TEXT	
NotTracingX  . . . . . . . . . . . . .	L Near	 0819	  _TEXT	
NotTracing . . . . . . . . . . . . . .	L Near	 07CB	  _TEXT	
NullPattern  . . . . . . . . . . . . .	L Near	 06B6	  _TEXT	
Null . . . . . . . . . . . . . . . . .	Number	 00B7h	 
NumDxBx  . . . . . . . . . . . . . . .	L Near	 1E7C	  _TEXT	Public
Number$$ . . . . . . . . . . . . . . .	L Near	 0943	  _TEXT	
Numeric$$  . . . . . . . . . . . . . .	L Near	 15F3	  _TEXT	
Numeric$ . . . . . . . . . . . . . . .	L Near	 15FC	  _TEXT	
OnSyntaxX  . . . . . . . . . . . . . .	L Near	 19DA	  _TEXT	
OnSyntax . . . . . . . . . . . . . . .	L Near	 199C	  _TEXT	
One$$  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OneMore  . . . . . . . . . . . . . . .	L Near	 1204	  _TEXT	
One  . . . . . . . . . . . . . . . . .	Number	 00B5h	 
OpAppendCl . . . . . . . . . . . . . .	Text   	 cl
OpAppendCx . . . . . . . . . . . . . .	Text   	 cx
OpFlags  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
OpenedOK . . . . . . . . . . . . . . .	L Near	 0E39	  _TEXT	
OperandBl  . . . . . . . . . . . . . .	Text   	 bl
OperandBx  . . . . . . . . . . . . . .	Text   	 bx
Operator . . . . . . . . . . . . . . .	L Near	 0002	  _TEXT	
Options$$  . . . . . . . . . . . . . .	L Near	 1D93	  _TEXT	
Or$$ . . . . . . . . . . . . . . . . .	L Near	 15A5	  _TEXT	
Overlay  . . . . . . . . . . . . . . .	Text   	 0 dup(?)
PATHQUALIFY  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PSwitch  . . . . . . . . . . . . . . .	L Near	 0648	  _TEXT	
ParaAllocAx  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ParmsCl  . . . . . . . . . . . . . . .	Text   	 cl
ParmsCx  . . . . . . . . . . . . . . .	Text   	 cx
Parse$$  . . . . . . . . . . . . . . .	L Near	 04BD	  _TEXT	
ParseAssign  . . . . . . . . . . . . .	L Near	 0774	  _TEXT	
ParseBcode . . . . . . . . . . . . . .	L Near	 08A8	  _TEXT	
ParseB . . . . . . . . . . . . . . . .	L Near	 08BE	  _TEXT	
ParseDot . . . . . . . . . . . . . . .	Number	 00FEh	 
ParseDx  . . . . . . . . . . . . . . .	Text   	 dx
ParseEnd$  . . . . . . . . . . . . . .	L Near	 0824	  _TEXT	
ParseEscape$ . . . . . . . . . . . . .	L Near	 0842	  _TEXT	
ParseSi  . . . . . . . . . . . . . . .	Text   	 si
PartLenCx  . . . . . . . . . . . . . .	Text   	 cx
Pattern$ . . . . . . . . . . . . . . .	L Near	 0663	  _TEXT	
PatternSi  . . . . . . . . . . . . . .	Text   	 si
Pcode1 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Pcode2 . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeArg . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeGapBx . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodeOp  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
PcodesBase$  . . . . . . . . . . . . .	L Near	 0000	  FanSeg	Public
PcodesCeil$  . . . . . . . . . . . . .	L Near	 00C4	  FanSeg	
PjumpBase$ . . . . . . . . . . . . . .	L Near	 0056	  FanSeg	
PjumpCeil$ . . . . . . . . . . . . . .	L Near	 0088	  FanSeg	
PlainRet . . . . . . . . . . . . . . .	L Near	 0FBA	  _TEXT	
PosEq$ . . . . . . . . . . . . . . . .	L Near	 06C8	  _TEXT	
PosMinus$  . . . . . . . . . . . . . .	L Near	 06E5	  _TEXT	
PosNew . . . . . . . . . . . . . . . .	L Near	 070A	  _TEXT	
PosPlus$ . . . . . . . . . . . . . . .	L Near	 06F1	  _TEXT	
PosRest$ . . . . . . . . . . . . . . .	L Near	 0740	  _TEXT	
Positive$$ . . . . . . . . . . . . . .	L Near	 1829	  _TEXT	
PostAcc64  . . . . . . . . . . . . . .	L Near	 11FC	  _TEXT	
PostDotsNew  . . . . . . . . . . . . .	L Near	 1C00	  _TEXT	
PostRep  . . . . . . . . . . . . . . .	L Near	 0192	  _TEXT	
Power$$  . . . . . . . . . . . . . . .	L Near	 17F3	  _TEXT	
ProbeAboveQ  . . . . . . . . . . . . .	L Near	 01D8	  _TEXT	
ProbeBelow2Q . . . . . . . . . . . . .	L Near	 01E7	  _TEXT	
ProbeBelowQ  . . . . . . . . . . . . .	L Near	 01E5	  _TEXT	
ProbeBx  . . . . . . . . . . . . . . .	Text   	 bx
ProbeMatchQ  . . . . . . . . . . . . .	L Near	 020D	  _TEXT	
ProgEs . . . . . . . . . . . . . . . .	Text   	 es
ProgScopeInit  . . . . . . . . . . . .	L Near	 0EC4	  _TEXT	
ProgScope  . . . . . . . . . . . . . .	L Near	 00B3	  _TEXT	
Pull$  . . . . . . . . . . . . . . . .	L Near	 0523	  _TEXT	
PullSysin  . . . . . . . . . . . . . .	L Near	 0554	  _TEXT	
Pulled . . . . . . . . . . . . . . . .	L Near	 053C	  _TEXT	
Push$$ . . . . . . . . . . . . . . . .	L Near	 1D97	  _TEXT	
Qretx  . . . . . . . . . . . . . . . .	L Near	 1E78	  _TEXT	
Qret . . . . . . . . . . . . . . . . .	L Near	 1E74	  _TEXT	
Queue$$  . . . . . . . . . . . . . . .	L Near	 1D97	  _TEXT	
RHSLenDx . . . . . . . . . . . . . . .	Text   	 dx
RadixTypeDl  . . . . . . . . . . . . .	Text   	 dl
Raise$$  . . . . . . . . . . . . . . .	L Near	 1A52	  _TEXT	
Raise$ . . . . . . . . . . . . . . . .	L Near	 1A5E	  _TEXT	
Raise16p3  . . . . . . . . . . . . . .	L Near	 0CC0	  _TEXT	
Raise16  . . . . . . . . . . . . . . .	L Near	 1A16	  _TEXT	
Raise20p1  . . . . . . . . . . . . . .	L Near	 1B4F	  _TEXT	
Raise26p11 . . . . . . . . . . . . . .	L Near	 183F	  _TEXT	
Raise26p12 . . . . . . . . . . . . . .	L Near	 183E	  _TEXT	
Raise26p1  . . . . . . . . . . . . . .	L Near	 1849	  _TEXT	
Raise26p2  . . . . . . . . . . . . . .	L Near	 1848	  _TEXT	
Raise26p3  . . . . . . . . . . . . . .	L Near	 1847	  _TEXT	
Raise26p4  . . . . . . . . . . . . . .	L Near	 1846	  _TEXT	
Raise26p5  . . . . . . . . . . . . . .	L Near	 1845	  _TEXT	Public
Raise26p6  . . . . . . . . . . . . . .	L Near	 1844	  _TEXT	Public
Raise26p7  . . . . . . . . . . . . . .	L Near	 1843	  _TEXT	
Raise26p8  . . . . . . . . . . . . . .	L Near	 1842	  _TEXT	
Raise33p1  . . . . . . . . . . . . . .	L Near	 185B	  _TEXT	Public
Raise33p2  . . . . . . . . . . . . . .	L Near	 185A	  _TEXT	Public
Raise33p3  . . . . . . . . . . . . . .	L Near	 1859	  _TEXT	Public
Raise34p1  . . . . . . . . . . . . . .	L Near	 1866	  _TEXT	
Raise34p2  . . . . . . . . . . . . . .	L Near	 1865	  _TEXT	
Raise34p3  . . . . . . . . . . . . . .	L Near	 1864	  _TEXT	
Raise34p4  . . . . . . . . . . . . . .	L Near	 1863	  _TEXT	
Raise34p5  . . . . . . . . . . . . . .	L Near	 1861	  _TEXT	Public
Raise34p6  . . . . . . . . . . . . . .	L Near	 1860	  _TEXT	Public
Raise34  . . . . . . . . . . . . . . .	L Near	 1A6C	  _TEXT	
Raise40p11 . . . . . . . . . . . . . .	L Near	 186B	  _TEXT	Public
Raise40p32 . . . . . . . . . . . . . .	L Near	 186F	  _TEXT	Public
Raise40p33 . . . . . . . . . . . . . .	L Near	 1873	  _TEXT	Public
Raise40  . . . . . . . . . . . . . . .	L Near	 18AD	  _TEXT	Public
Raise41p1BLM . . . . . . . . . . . . .	L Near	 1086	  _TEXT	
Raise41p1  . . . . . . . . . . . . . .	L Near	 1854	  _TEXT	
Raise41p2BLM . . . . . . . . . . . . .	L Near	 1073	  _TEXT	
Raise41p2  . . . . . . . . . . . . . .	L Near	 1853	  _TEXT	
Raise41p3  . . . . . . . . . . . . . .	L Near	 1852	  _TEXT	
Raise41p4  . . . . . . . . . . . . . .	L Near	 1851	  _TEXT	
Raise41p5  . . . . . . . . . . . . . .	L Near	 1850	  _TEXT	
Raise41p6  . . . . . . . . . . . . . .	L Near	 184F	  _TEXT	
Raise41p7  . . . . . . . . . . . . . .	L Near	 184E	  _TEXT	
Raise49  . . . . . . . . . . . . . . .	L Near	 1877	  _TEXT	Public
Raise5p1d  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise5p1 . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Raise  . . . . . . . . . . . . . . . .	L Near	 18AF	  _TEXT	Public
RawCharAh  . . . . . . . . . . . . . .	Text   	 ah
RawCharAl  . . . . . . . . . . . . . .	Text   	 al
RawChar  . . . . . . . . . . . . . . .	Text   	 byte ptr ss:[si+bp]
Rejumps  . . . . . . . . . . . . . . .	L Near	 00C8	  _TEXT	Public
Relatives  . . . . . . . . . . . . . .	L Near	 14FA	  _TEXT	
RemIntDiv  . . . . . . . . . . . . . .	L Near	 179A	  _TEXT	
Remainder$$  . . . . . . . . . . . . .	L Near	 16DD	  _TEXT	
Rep$$  . . . . . . . . . . . . . . . .	L Near	 0A90	  _TEXT	
RepEver$$  . . . . . . . . . . . . . .	L Near	 0A87	  _TEXT	
Result$$ . . . . . . . . . . . . . . .	L Near	 0F2C	  _TEXT	
ResultSpaceDs  . . . . . . . . . . . .	L Near	 228A	  _TEXT	
ResultSpace  . . . . . . . . . . . . .	L Near	 2237	  _TEXT	Public
ResumeP$ . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ResumeParse$$  . . . . . . . . . . . .	L Near	 085A	  _TEXT	
RetEdxEbx  . . . . . . . . . . . . . .	L Near	 11AE	  _TEXT	
RetEsSi  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Return$$ . . . . . . . . . . . . . . .	L Near	 0F80	  _TEXT	
ReturnX  . . . . . . . . . . . . . . .	L Near	 0FA6	  _TEXT	
Returns$$  . . . . . . . . . . . . . .	L Near	 0F30	  _TEXT	
Round32  . . . . . . . . . . . . . . .	L Near	 11A3	  _TEXT	
RtypeAh  . . . . . . . . . . . . . . .	Text   	 ah
S1 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+$StrideS])
S2 . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si+2*$StrideS])
SUBROUTINE . . . . . . . . . . . . . .	Byte	 22C8	  _TEXT	
Say$$  . . . . . . . . . . . . . . . .	L Near	 1DF2	  _TEXT	Public
ScanSi . . . . . . . . . . . . . . . .	Text   	 si
ScannerSi  . . . . . . . . . . . . . .	Text   	 si
Scode  . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SectionCx  . . . . . . . . . . . . . .	Text   	 cx
SectionDi  . . . . . . . . . . . . . .	Text   	 di
SectionDx  . . . . . . . . . . . . . .	Text   	 dx
SectionGo  . . . . . . . . . . . . . .	L Near	 074A	  _TEXT	
SectionSi  . . . . . . . . . . . . . .	Text   	 si
Section  . . . . . . . . . . . . . . .	L Near	 0730	  _TEXT	
SegOffDi . . . . . . . . . . . . . . .	Text   	 di
Seq$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
Serialize  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetFlags . . . . . . . . . . . . . . .	L Near	 139D	  _TEXT	
SetInherit . . . . . . . . . . . . . .	L Near	 163D	  _TEXT	Public
SetStack . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetSymLenJa  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SetV . . . . . . . . . . . . . . . . .	L Near	 14C5	  _TEXT	
Sge$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
Sgt$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
ShowMsg  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Signal$$ . . . . . . . . . . . . . . .	L Near	 19D7	  _TEXT	
SignalOff$$  . . . . . . . . . . . . .	L Near	 1A41	  _TEXT	
SignalOn$$ . . . . . . . . . . . . . .	L Near	 1A26	  _TEXT	
SignalV$$  . . . . . . . . . . . . . .	L Near	 19D5	  _TEXT	
SingleNext . . . . . . . . . . . . . .	L Near	 0685	  _TEXT	
Sle$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
SlowRep  . . . . . . . . . . . . . . .	L Near	 01BE	  _TEXT	
Slt$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
Sne$$  . . . . . . . . . . . . . . . .	L Near	 1494	  _TEXT	
Solid  . . . . . . . . . . . . . . . .	Number	 0001h	 
SomeExposed  . . . . . . . . . . . . .	L Near	 1CAF	  _TEXT	
SortSpaceSS  . . . . . . . . . . . . .	Number	 0001h	 
Source$  . . . . . . . . . . . . . . .	L Near	 057F	  _TEXT	
SourceTable  . . . . . . . . . . . . .	L Near	 04D2	  _TEXT	
StackDi  . . . . . . . . . . . . . . .	Text   	 di
StackDx  . . . . . . . . . . . . . . .	Text   	 dx
StackSafe  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StackSi  . . . . . . . . . . . . . . .	Text   	 si
StartExecutionY  . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StartExecution . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
StateBx  . . . . . . . . . . . . . . .	Text   	 bx
StateDi  . . . . . . . . . . . . . . .	Text   	 di
StateSi  . . . . . . . . . . . . . . .	Text   	 si
StemAllocVbxDs . . . . . . . . . . . .	L Near	 0274	  _TEXT	
StemBx . . . . . . . . . . . . . . . .	Text   	 bx
StemEs . . . . . . . . . . . . . . . .	Text   	 es
StemLoopQ  . . . . . . . . . . . . . .	L Near	 01C2	  _TEXT	
StrictFlags  . . . . . . . . . . . . .	L Near	 149C	  _TEXT	Public
String1$$  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
String1  . . . . . . . . . . . . . . .	Number	 00BBh	 
String2  . . . . . . . . . . . . . . .	Number	 00BDh	 
StringCompare  . . . . . . . . . . . .	L Near	 1411	  _TEXT	
StringC  . . . . . . . . . . . . . . .	L Near	 1343	  _TEXT	
String . . . . . . . . . . . . . . . .	Number	 00B9h	 
StripB . . . . . . . . . . . . . . . .	L Near	 1474	  _TEXT	
StripE . . . . . . . . . . . . . . . .	L Near	 1485	  _TEXT	
SubAddEcxEax . . . . . . . . . . . . .	L Near	 12D3	  _TEXT	
SubPos . . . . . . . . . . . . . . . .	L Near	 132F	  _TEXT	
SubRegsCmp . . . . . . . . . . . . . .	L Near	 12F2	  _TEXT	
SubRegs  . . . . . . . . . . . . . . .	L Near	 12AC	  _TEXT	
SubTest  . . . . . . . . . . . . . . .	L Near	 12D9	  _TEXT	
SubZero  . . . . . . . . . . . . . . .	L Near	 133D	  _TEXT	
SubjectRestore . . . . . . . . . . . .	L Near	 085E	  _TEXT	
Subtract$$ . . . . . . . . . . . . . .	L Near	 128F	  _TEXT	
SymbolLook . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymbolsEs  . . . . . . . . . . . . . .	Text   	 es
SymbolsSafe  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
SymsZiDx . . . . . . . . . . . . . . .	Text   	 dx
SysVar$$ . . . . . . . . . . . . . . .	L Near	 02DF	  _TEXT	
S  . . . . . . . . . . . . . . . . . .	Text   	 (Sshape ptr[bp+si])
TailLenLoop  . . . . . . . . . . . . .	L Near	 0157	  _TEXT	
TailNew  . . . . . . . . . . . . . . .	L Near	 026C	  _TEXT	
TailSi . . . . . . . . . . . . . . . .	Text   	 si
TailedDropped  . . . . . . . . . . . .	L Near	 1C2B	  _TEXT	
TemplateComma$ . . . . . . . . . . . .	L Near	 050E	  _TEXT	
Terminate  . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TestExpon  . . . . . . . . . . . . . .	L Near	 1252	  _TEXT	
TheMsgBh . . . . . . . . . . . . . . .	Text   	 bh
Then$$ . . . . . . . . . . . . . . . .	L Near	 1A78	  _TEXT	Public
To$$ . . . . . . . . . . . . . . . . .	L Near	 0A37	  _TEXT	
ToArithGeneral . . . . . . . . . . . .	L Near	 1209	  _TEXT	
ToDsSiCx . . . . . . . . . . . . . . .	L Near	 2079	  _TEXT	Public
ToFindDx . . . . . . . . . . . . . . .	Text   	 dx
ToFindLenAx  . . . . . . . . . . . . .	Text   	 ax
ToString . . . . . . . . . . . . . . .	L Near	 2099	  _TEXT	
ToWholeEbxGE . . . . . . . . . . . . .	L Near	 15DC	  _TEXT	
ToWholeEbx . . . . . . . . . . . . . .	L Near	 1FF5	  _TEXT	Public
TokNowCh . . . . . . . . . . . . . . .	Text   	 ch
TokNumAh . . . . . . . . . . . . . . .	Text   	 ah
TotalCx  . . . . . . . . . . . . . . .	Text   	 cx
Trace$$  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TraceEvent$$ . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
TraceEventX  . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
Trial  . . . . . . . . . . . . . . . .	Number	 0000h	 
TriggerArg . . . . . . . . . . . . . .	L Near	 0606	  _TEXT	
TriggerWith  . . . . . . . . . . . . .	L Near	 0646	  _TEXT	
Triggers . . . . . . . . . . . . . . .	L Near	 0653	  _TEXT	
TsFloat  . . . . . . . . . . . . . . .	L Near	 215A	  _TEXT	
TsFrom . . . . . . . . . . . . . . . .	L Near	 20C3	  _TEXT	
TsLoop . . . . . . . . . . . . . . . .	L Near	 2139	  _TEXT	
TsMore . . . . . . . . . . . . . . . .	L Near	 20DC	  _TEXT	
TsNoP  . . . . . . . . . . . . . . . .	L Near	 210E	  _TEXT	
TwBinary . . . . . . . . . . . . . . .	L Near	 202F	  _TEXT	
TwFailx  . . . . . . . . . . . . . . .	L Near	 2077	  _TEXT	
TwFail . . . . . . . . . . . . . . . .	L Near	 2078	  _TEXT	
TwNegExp . . . . . . . . . . . . . . .	L Near	 2064	  _TEXT	
TwOKzero . . . . . . . . . . . . . . .	L Near	 2056	  _TEXT	
TwOK . . . . . . . . . . . . . . . . .	L Near	 205E	  _TEXT	
UnDo$$ . . . . . . . . . . . . . . . .	L Near	 0B01	  _TEXT	
Unstore$$  . . . . . . . . . . . . . .	L Near	 1ABD	  _TEXT	
Until$$  . . . . . . . . . . . . . . .	L Near	 0AD5	  _TEXT	
UpStack  . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
UpperFirstAh . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
V00  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-2*$StrideV])
V0 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di-$StrideV])
V2 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+$StrideV])
V3 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+2*$StrideV])
V4 . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di+3*$StrideV])
VINlong  . . . . . . . . . . . . . . .	L Near	 2204	  _TEXT	
ValueIsName  . . . . . . . . . . . . .	L Near	 21D9	  _TEXT	
Var$ . . . . . . . . . . . . . . . . .	L Near	 05CE	  _TEXT	
VarPoolInit  . . . . . . . . . . . . .	L Near	 0CF3	  _TEXT	
VasDsSiCx  . . . . . . . . . . . . . .	L Near	 0574	  _TEXT	Public
Vbxe . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bx])
Vbxf2  . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx+$StrideV])
Vbxf . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx])
Vbxs . . . . . . . . . . . . . . . . .	Text   	 ss:(Vshape ptr[bx])
Vbxt . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bx-$CaseTarget])
Vbx  . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[bx])
Vdid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[di])
Version$ . . . . . . . . . . . . . . .	L Near	 0567	  _TEXT	
Version  . . . . . . . . . . . . . . .	Byte	 2298	  _TEXT	
Ve . . . . . . . . . . . . . . . . . .	Text   	 es:(Vshape ptr[bp])
Vf . . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[bp])
Vsid . . . . . . . . . . . . . . . . .	Text   	 ds:(Vshape ptr[si])
Vsif . . . . . . . . . . . . . . . . .	Text   	 fs:(Vshape ptr[si])
Vsi  . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+si])
V  . . . . . . . . . . . . . . . . . .	Text   	 (Vshape ptr[bp+di])
WasChar  . . . . . . . . . . . . . . .	L Near	 1E82	  _TEXT	
WhUntRet . . . . . . . . . . . . . . .	L Near	 0AE6	  _TEXT	
When$$ . . . . . . . . . . . . . . . .	L Near	 1A78	  _TEXT	
While$$  . . . . . . . . . . . . . . .	L Near	 0AEA	  _TEXT	
WhileStemBxQ . . . . . . . . . . . . .	L Near	 01EE	  _TEXT	
With$  . . . . . . . . . . . . . . . .	L Near	 05CE	  _TEXT	
WpDoneB  . . . . . . . . . . . . . . .	L Near	 0930	  _TEXT	
WpDone . . . . . . . . . . . . . . . .	L Near	 082F	  _TEXT	
WpLastB  . . . . . . . . . . . . . . .	L Near	 090A	  _TEXT	
WpLast . . . . . . . . . . . . . . . .	L Near	 07B4	  _TEXT	
WpOneB . . . . . . . . . . . . . . . .	L Near	 08FB	  _TEXT	
WpOne  . . . . . . . . . . . . . . . .	L Near	 07A6	  _TEXT	
WpResumeB  . . . . . . . . . . . . . .	L Near	 0920	  _TEXT	
WpResume . . . . . . . . . . . . . . .	L Near	 07E7	  _TEXT	
WpWordB  . . . . . . . . . . . . . . .	L Near	 08DA	  _TEXT	
WpWord . . . . . . . . . . . . . . . .	L Near	 0787	  _TEXT	
Wptr . . . . . . . . . . . . . . . . .	Text   	 word ptr
XCycle . . . . . . . . . . . . . . . .	L Near	 005B	  _TEXT	Public
Xor$$  . . . . . . . . . . . . . . . .	L Near	 159E	  _TEXT	
Xorx . . . . . . . . . . . . . . . . .	L Near	 15A1	  _TEXT	
Ycx2 . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[2*ecx+ebp])
Ysi  . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[si])
Y  . . . . . . . . . . . . . . . . . .	Text   	 (Yshape ptr cs:[bp])
Zero$$ . . . . . . . . . . . . . . . .	L Near	 0000	  _TEXT	External
ZeroBp . . . . . . . . . . . . . . . .	Text   	 bp
ZeroDivide . . . . . . . . . . . . . .	L Near	 1794	  _TEXT	
ZeroInt  . . . . . . . . . . . . . . .	L Near	 17E3	  _TEXT	
Zero . . . . . . . . . . . . . . . . .	Number	 00B3h	 
ZoneNumerics . . . . . . . . . . . . .	L Near	 1660	  _TEXT	Public
ZoneToLevel  . . . . . . . . . . . . .	L Near	 0E24	  _TEXT	Public
Z  . . . . . . . . . . . . . . . . . .	Text   	 (Zshape ptr[bp])
_Eq$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Eq  . . . . . . . . . . . . . . . . .	Number	 00CDh	 
_Exists  . . . . . . . . . . . . . . .	Number	 00C7h	 
_Ge$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Ge  . . . . . . . . . . . . . . . . .	Number	 00D5h	 
_Gt$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Gt  . . . . . . . . . . . . . . . . .	Number	 00D7h	 
_IterCV  . . . . . . . . . . . . . . .	Number	 00C5h	 
_Jump  . . . . . . . . . . . . . . . .	Number	 00CBh	 
_Le$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Le  . . . . . . . . . . . . . . . . .	Number	 00D3h	 
_Lt$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Lt  . . . . . . . . . . . . . . . . .	Number	 00D1h	 
_Ne$$  . . . . . . . . . . . . . . . .	L Near	 14EF	  _TEXT	Public
_Ne  . . . . . . . . . . . . . . . . .	Number	 00CFh	 
_RetBc . . . . . . . . . . . . . . . .	Number	 00BFh	 
_RetB  . . . . . . . . . . . . . . . .	Number	 00C1h	 
_RetF  . . . . . . . . . . . . . . . .	Number	 00C3h	 
_Seq$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	Public
_Seq . . . . . . . . . . . . . . . . .	Number	 00D9h	 
_Sge$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	
_Sgt$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	
_Sle$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	
_Slt$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	Public
_Slt . . . . . . . . . . . . . . . . .	Number	 00DDh	 
_Sne$$ . . . . . . . . . . . . . . . .	L Near	 150C	  _TEXT	Public
_Sne . . . . . . . . . . . . . . . . .	Number	 00DBh	 
_Then  . . . . . . . . . . . . . . . .	Number	 00C9h	 
is . . . . . . . . . . . . . . . . . .	Text   	 textequ

	   0 Warnings
	   0 Errors
